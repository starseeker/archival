<!doctype linuxdoc system>
<!--
The SGML syntax in this document deviates from Linuxdoc-SGML
in the following points:

1) Due to post processing, there must only be one
<ref id="tag" name="secname">
and also one
<footnote></footnote>
per input line;

2) to keep longer code examples on one page in page based output
   (i.e. LaTeX/PDF) use:
<#if out=latex><x/needspace 8/</#if>

3) likewise, enforce a new page with:
<#if out=latex><x/newpage/</#if>

4) for references in sections (not references to sections!),
   prepend the label statement with
<#if out=latex><x/phantomsection/</#if>
.
 -->
<article>

<title>Ayam

<author>Randolf Schultz <tt>(randolf.schultz@gmail.com)</tt>

<date>20. Mar 2012

<abstract>
This is the documentation of Ayam 1.20 &ndash; a free 3D modelling environment
for the RenderMan interface.

Please note, that this document is a reference manual,
more detailed explanations of how to actually model with Ayam are
given in the tutorials.

This document has been written using the SGML-Tools (LinuxDoc) formatting
system to generate files in a variety of text formats from one source file.
There are HTML and PDF versions of this document prepared.

In addition, one can use the provided SGML-source to generate other formats.
</abstract>

<toc>

<sect>Introduction
<p>
This section contains general information about this manual and Ayam.

<sect1>About this Manual
<p>
Since this document is a reference manual, it is
probably pointless to read it from the beginning to the end
(except maybe for the next section, explaining the basics).
Instead, just look up the documentation of the things you are interested
in via the table of contents or the index. Cross references will then
guide you to other important parts of the documentation.
Again: this manual has a rather large index, please use it
(see section <ref id="index" name="Index">)!
<p>
This document is organized in the following way:
<p>
After this first section, the user interface of Ayam is introduced and
basic handling instructions for the application are given in the second
section.
In the third section all interactive modelling actions are documented.
The fourth section details all object types and object properties,
followed by documentation on all NURBS modelling tools in the fifth
section.
In the sixth section the Tcl scripting interface is explained and the
following seventh section has all information about the import and export
plugins. The eighth section is the dreaded miscellaneous section that
contains documentation not fitting elsewhere.
<p>
In this manual, the following typographic conventions are used:
<itemize>
<item>keyboard shortcuts: <tt/&lt;Ctrl+c&gt;/ (press control <em>and</em>
c key), for shortcuts like <tt/&lt;Ctrl+Shift+t&gt;/ an abbreviated
version: <tt/&lt;Ctrl+T&gt;/ will be used;
<item>names (of object types, menu entries, properties, or property elements):
<tt/"A Name"/;
<item>Tcl code examples:
<code>
set riopt(runtime) { a b }
</code>
<item>Object hierarchies:
<tscreen><verb>
+-Parent_Object(Type)
 | First_Child_Object(Type)
 | Second_Child_Object(Type)
 | [Third_Child_Object_may_be_present_or_not(Type)]
 | Empty_Level(Level)
 +-Sub_Level(Level)
 || First_Child_Object_of_Sub_Level(Type)
 |\ Last_Child_Object_of_Sub_Level(Type)
 \ Last_Child_Object(Type)
+-Next_Parent_Object(Type)
</verb></tscreen>
</itemize>

<#if out=latex><x/newpage/</#if>

<sect1>About Ayam
<p>
Ayam is a free 3D modelling environment for the RenderMan Interface,
distributed under the modified BSD licence (no advertisement clause).

<sect2>History
<p>
Ayam is in development since 1997 and was formerly known as
<tt>"The Mops"</tt>. Ayam formed the software base of the
authors PhD work. New versions of Ayam were released in
approximately half year intervals.

<sect2>Features Overview
<p>
Here is a short summary of the Ayam feature set:
<itemize>
<item>RIB (RenderMan Interface Bytestream) export and import.
<item>Support for NURBS curves, interpolating and approximating curves,
(trimmed) NURBS surfaces, interpolating surfaces, bilinear and bicubic
patches and patch meshes,
Boxes, Quadrics (Sphere, Disk, Cylinder, Cone, Hyperboloid, Paraboloid
and Torus), MetaBalls, polygonal meshes, subdivision meshes and more.
<item>All primitives may be combined with the common
CSG-operations: Intersection, Difference, and Union.
<item>NURBS modelling includes extrude, revolve, sweep, birail, skin,
and gordon operations (with caps, holes, and bevels) realized as
Tool-Objects (see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).
<item>Wavefront OBJ export and import, Rhino 3DM export and import,
AutoCAD DXF export and import, Web3D X3D export and import, Apple
Quicktime 3D Metafile (3DMF) export and import.
<item>Custom objects that may freely implement their representations
(using OpenGL and RIB) and even small GUIs to edit their type specific
parameters may be written by the user and dynamically loaded at runtime.
<item>Scripting interfaces: Tcl, JavaScript.
<item>Script objects.
<item>Miscellaneous: (automatic) instancing, arbitrary number of modelling
views, object clipboard, independent property clipboard, console,
n-level undo.
</itemize>
<p>
Since Ayam 1.12, dynamic loading of custom objects and certain plugins
are also available on the Win32 platform (they were not available
before).
<p>
Ayam is primarily aimed at the Linux, IRIX, and Win32 platforms.
On those platforms BMRT (Blue Moon Rendering Tools, a RenderMan
compliant renderer by Larry Gritz) is available.
Even though the distribution of BMRT is stopped it is still
the recommended renderer for Ayam.
Despite of this, Ayam may be used on many more platforms with any
RenderMan compliant renderer.
<p>
For platforms where BMRT is not available (e.g.~FreeBSD or NetBSD), Ayam
may be compiled with code from the Affine Toolkit with limited
functionality (see also the file INSTALL).
In this case, no parsing of slc compiled shaders will be possible.
<p>
Since Ayam 1.6 it is also possible to completely replace the BMRT shader
parsing and RIB writing code with code from the Aqsis project, thus
completely eliminating the need for BMRT. Furthermore, shader parsing
plugins are available for all major RenderMan compliant renderers allowing
a tight integration of Ayam with any of those renderers.

<sect2>Coordinate Systems and Units
<p>
Ayam uses a right-handed coordinate system as used by OpenGL
but as opposed to RenderMan (the latter is using a left-handed
coordinate system).
<p>
In the default modelling view of type <tt/"Front"/, the positive
X-axis points to the right, the positive Y-axis points upwards
and the Z-axis points outside the screen, to the user.
<p>
All coordinate values in Ayam are dimensionless. It is up to the
user to define what a value of 1.0 means: e.g.~one centimeter
or one meter.
<p>
Due to the limited precision of floating point arithmetics used in Ayam,
coordinate values should be defined in the range between -10.0 and 10.0
for most accurate results.
<p>
NURBS curves and surfaces support rational coordinate values by
allowing a fourth value (the weight) to be specified for each
control point.
In Ayam versions prior to 1.19 those weights were always multiplied
with the coordinate values (i.e.~homogenous rational coordinates)
to allow faster drawing with OpenGL/GLU, which expects rational
coordinate values to be delivered this way.
But a negative side effect of this appproach was that modification
of coordinates or weights for modelling purposes was unnecessarily
complicated.
Therefore, since Ayam 1.19, rational coordinates are now euclidean
rational, the weight is not pre-multiplied with the coordinates anymore
(this will be done internally when handing the coordinates over for
drawing or export purposes).
Scene files from older versions are converted automatically to the
new coordinate scheme when read by Ayam 1.19, but loading of scene files
written by Ayam 1.19 into older versions of Ayam requires conversion
(e.g.~by means of a script).

<sect>The Ayam GUI
<p>
This section describes the user interface of Ayam.
<p>
The user interface of Ayam is split into three types of windows:
a main window, a toolbox and an arbitrary number of view windows.
The main window displays the object hierarchy and allows to edit
object properties. The toolbox window is for easy creation of
objects and starting of modelling actions and tools. The modelling
actions are then carried out in view windows, where also the scene
is displayed.
<p>
The whole application with all open windows may be iconified (zapped) using
the shortcut <tt/&lt;Ctrl+Z&gt;/. If any of the windows iconified by zap
is de-iconified, all other windows iconified by zap will be de-iconified
as well.
<p>
<figure loc="ht">
<eps file="pics/swin.ps" height="12cm">
<img src="pics/swin.gif">
<caption>Single Window GUI Mode</caption>
</figure>
<p>
Until Ayam 1.14 all windows, main, toolbox, and views were always single
top level windows &ndash; a so called floating windows GUI mode. Since
version 1.14, a new GUI mode is available where the main window, three view
windows and the toolbox are integrated in one top level window. This mode
is called single window GUI mode, see also the image above.
The new single window GUI mode is enabled by default. All sub windows are
in panes, the space occupied by a sub window may be adjusted by dragging
the mouse at the borderlines of the panes. The number of views is not
limited to three, albeit all extra views will become extra top level windows.
<p>
The next sections document the three types of windows, main, toolbox,
and views in detail.

<sect1>Anatomy of the Main Window
<p>
The main window is split into three major areas:
<enum>
<item>an area named <tt/"Objects:"/
<item>an area labeled <tt/"Properties:"/
<item>and a text widget (the so called "Console")
</enum>
<p>
<figure loc="ht">
<eps file="pics/main.ps" height="8cm">
<img src="pics/main.gif">
<caption>The Main Window</caption>
</figure>
<p>
The relative sizes of the three areas are managed by a so called paned
geometry management. To change the relative size of the console,
move the mouse pointer to the upper border of the console until
the pointer changes and then drag the border.
The same goes for the right border of the objects section.

<sect2>Objects<label id="obj">
<p>
The default representation of the object hierarchy is a tree view.
The second available representation is a simple listbox (as known from
<tt/"The Mops"/).
The label <tt/"Objects"/ may be used to switch between the two
representations of the object hierarchy quickly (using a double click).
It is also possible to switch between both representations
using the context menu.
<p>
The two representations have very different properties regarding
speed, use of resources, and versatility. The tree is, due to the
drag and drop operations, much more versatile but also slower.
<p>
Both representations manage a so called <tt/"current level"/.
This level is the scene level that is displayed in the object listbox.
In the tree view the current level is drawn in black while all
other levels are grayed out. Selection of objects
may take place in the current level only!
<p>
After the start-up of Ayam you will notice, that there is a first
object called <tt/"Root"/ in the top level of the scene, even though the
scene seems to be empty.
See section <ref id="rootobj" name="Root Object"> for more
information regarding this special object, and what it is good for.
Note that one can not delete or copy this object.

<bf/Object Tree View:/<label id="treeview">
<p>
<figure loc="ht">
<eps file="pics/treeview.ps" height="6cm">
<img src="pics/treeview.gif">
<caption>Object Tree View</caption>
</figure>
<p>
The object tree view is quite complex and may be slow on slow machines
(of the Pentium 90 class), especially when dealing with scenes
that contain many objects. This should not be a problem nowadays.
Nevertheless, Ayam tries to keep tree update delays as low as possible,
but this works only if the scene uses the hierarchy and changes
happen in sub levels (not the root level).
<p>
In the tree view, objects may be selected using the left mouse button.
Multiple selection of objects is possible by holding down the
<tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/ key while clicking on objects.
<p>
Double clicking on objects with child objects toggles display of the
child level.
The same may be accomplished using single clicks on the well known
plus/minus symbols in front of the name of those objects.
<p>
Drag and drop operation is also possible to move objects in the
hierarchy and to initiate special actions like connecting materials
to objects. However, this last feature is documented in section
<ref id="obandprp" name="Objects, Properties, and Tags">
as it is object type specific.
<p>
<label id="treecontm">
The rightmost mouse button opens a context menu with basic tree and
clipboard operations:
<itemize>
<item><tt>"Tree/Rebuild"</tt> completely removes the tree nodes, rebuilds
the hierarchy, makes the top level current, and clears the object selection,

<item><tt>"Tree/Expand All"</tt> opens all nodes with child nodes,

<item><tt>"Tree/Collapse All"</tt> closes all nodes with child nodes,

<item><tt>"Tree/Toggle Selected"</tt> toggles display of all sub-levels
of the selected objects,

<item><tt>"Switch to Listbox"</tt> removes the tree view and replaces it
with the object listbox (see below).

<item><tt>"Deselect Object"</tt> deselects the currently selected
object(s).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="Main Menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>
<p>
Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:<label id="treesc">
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object.

<item><tt/&lt;Shift-Up&gt;/ and <tt/&lt;Shift-Down&gt;/ will not move the
selection, but rather extend it in the respective direction.
<footnote>Since 1.7.</footnote>

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Shift+Home&gt;/ and <tt/&lt;Shift+End&gt;/
extend the selection to the first or last object in the current
level respectively.
<footnote>Since 1.11.</footnote>

The root object, however, will always be omitted.

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all objects in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

<item><tt/&lt;Space&gt;/ toggles display of the child objects of the
selected object(s).

<item><tt/&lt;Shift+Space&gt;/ toggles display of all sub-levels of the
selected object(s).
<footnote>Since 1.18.</footnote>
</itemize>
<p>
If those shortcuts do not work you may need to move the keyboard
input focus away from (internal) view windows, the property GUI,
or the console using <tt/&lt;Tab&gt;/ or <tt/&lt;Shift+Tab&gt;/
first.
<p>
Another way of moving the focus (and cleaning up the application state)
is by using the <tt/&lt;Esc&gt;/ key:
In property GUIs and the console, pressing <tt/&lt;Esc&gt;/ moves the focus
away to the main window or object selection window.

Pressing <tt/&lt;Esc&gt;/ twice in a view window
will also reset the focus to the main window/object selection
window.
<footnote>Since 1.15.</footnote>
Pressing <tt/&lt;Esc&gt;/ twice in the object selection
window will additionally clear the selection (this implies
removal of the currently displayed property GUI) and change the
current level to the root level.
<p>
Thus, if you feel lost anywhere in Ayam, just press <tt/&lt;Esc&gt;/
twice or thrice.


<bf/Object Listbox:/<label id="listbox">
<p>
<figure loc="ht">
<eps file="pics/listbox.ps" height="6cm">
<img src="pics/listbox.gif">
<caption>Object Listbox</caption>
</figure>
<p>
The object listbox displays the object hierarchy of the current scene.
Using this listbox you may browse through the hierarchy of the scene
with your mouse and you may select one or more objects.
<p>
Browsing and selecting should be very intuitive:
Use a double click to enter a level (or an object with child objects),
use a single click to select objects, multiple objects may be selected using
click and drag, or holding down the <tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/
key while clicking.
Keyboard operation is also possible if the listbox has the
input focus.
<p>
A <tt/".."/ is displayed as the first element of the current level
if you are "inside" a level or another object.
A double click on the <tt/".."/ takes you to the parent level.
The buttons below the listbox may be used to change the selection or
to quickly jump through the hierarchy. They should be self explanatory.
<p>
<label id="lbcontm">
The rightmost mouse button opens a small context menu:
<itemize>
<item><tt>"Switch to Tree"</tt> removes the listbox and replaces it
with the tree view (see above).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="Main Menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>

Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:<label id="olbsc">
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object.

<item><tt/&lt;Shift-Up&gt;/ and <tt/&lt;Shift-Down&gt;/ will not move the
selection, but rather extend it in the respective direction.
<footnote>Since 1.7.</footnote>

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Shift+Home&gt;/ and <tt/&lt;Shift+End&gt;/ extend the selection
to the first or last object in the current level respectively.
<footnote>Since 1.11.</footnote>

The root object, however, will always be omitted.

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all objects in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

</itemize>
<p>
If those shortcuts do not work you may need to move the keyboard
input focus away from (internal) view windows, the property GUI,
or the console using <tt/&lt;Tab&gt;/ or <tt/&lt;Shift+Tab&gt;/
first.
<p>
Another way of moving the focus (and cleaning up the application state)
is by using the <tt/&lt;Esc&gt;/ key:
In property GUIs and the console, pressing <tt/&lt;Esc&gt;/ moves the focus
away to the main window or object selection window.

Pressing <tt/&lt;Esc&gt;/ twice in a view window
will also reset the focus to the main window/object selection
window.
<footnote>Since 1.15.</footnote>
Pressing <tt/&lt;Esc&gt;/ twice in the object selection
window will additionally clear the selection (this implies
removal of the currently displayed property GUI) and change the
current level to the root level.
<p>
Thus, if you feel lost anywhere in Ayam, just press <tt/&lt;Esc&gt;/
twice or thrice.

<sect2>Properties<label id="propgui">
<p>
<figure loc="ht">
<eps file="pics/propgui.ps" height="6cm">
<img src="pics/propgui.gif">
<caption>Properties</caption>
</figure>
<p>
The listbox right next to the object hierarchy displays the properties
of the currently selected object.
<p>
If there are multiple selected objects, the properties listbox will
display no properties at all.
<p>
Unlike the object tree/listbox, where you can select multiple entries,
only one property may be selected.
If a property is selected, the associated GUI will be shown in the
appropriate area (on the right hand side).
<p>
Also the keyboard may be used to select properties:
just press one of the <tt/&lt;0&gt;-&lt;9&gt;/ keys (most comfortably
using the numeric keypad). <tt/&lt;0&gt;/ always selects the last and
often the only object type specific property, whereas <tt/&lt;1&gt;/
selects the first property, which often contains the standard
transformations.
<footnote>Since 1.8</footnote>
<p>
All property GUIs use more or less standardized GUI elements that are
organized in list form. The lists may be scrolled if they get too long
to fit into the window.
<p>
If Ayam is in floating windows GUI mode and the elements of the current
property GUI do not fit into the screen space that is defined by the main
window size, Ayam can automatically resize the main window. This behaviour
may be controlled using the preference setting
<tt/"AutoResize"/ (see section <ref id="prefs" name="Preferences">).
<p>
If an object and a property are selected and a different object is selected,
the property GUI that has the same index as the previously selected
property in the properties listbox will be selected and shown. This is
not necessarily a property of the same type.
To avoid that or to clear the property GUI for fast browsing through the
scene you may either double click on the "Properties" label, hit the
<tt/&lt;Esc&gt;/ key three times, or use the context menu of the properties
listbox to de-select the current property.
<p>
What properties exactly will be shown, and how the GUIs look alike
depends on the selected object and the selected property.
This is documented comprehensively in section
<ref id="obandprp" name="Objects, Properties, and Tags">.
<p>
Here are some general remarks about object properties:
<p>
The various things that may be changed using a property GUI
will normally not be applied to the selected object until the
<tt/"Apply"/-button is pressed.
<p>
Holding down the <tt/"Shift"/ button while
interacting with the property GUI or pressing <tt/"Return"/
when entry widgets have the keyboard input focus will also lead
to an instant apply.
<footnote>Since 1.8.3.</footnote>
<p>
You can undo all changes to the arguments of a property that have been
made after the last <tt/"Apply"/ operation with the <tt/"Reset"/-button.
This does, however, not use the undo mechanism of Ayam.
<p>
Note also that property GUIs of custom objects may offer interactive
elements that do an instant "Apply" operation. Most GUIs of the core
objects of Ayam do not change anything until the <tt/"Apply"/-button
is used, however.
<p>
If a property GUI element has the keyboard input focus (it is then usually
displayed with a black rim around it), all the keyboard shortcuts for
the main menu and scene navigation will have no effect until the
keyboard input focus is moved away from the property GUI. You may
accomplish this easily using the <tt/&lt;Esc&gt;/ key.
<p>
A property may be copied and pasted to another object, see the
<tt/"Edit"/ menu. You can also paste property values to different types
of properties (e.g.~pasting parameters from a surface shader to the
displacement shader) using <tt/"Paste to selected"/ in the
<tt>"Special/Clipboard"</tt> sub-menu.
<p>
Pasting a property to multiple selected objects does work too.
This is a great way to apply e.g.~a parameterised surface shader to
a bigger number of material objects, without going the long way of
setting a new shader and entering parameters for it for every material
object.
<p>
Since you may not want to copy and paste whole properties all the time,
you may even mark single parameters with a double click on the
labels of the parameters. The selected parameters will then be preceded
by an exclamation mark (!) in the property GUI.
<p>
If this property is then copied, all marked parameters will be omitted.
<p>
It is also possible to copy just the selected parameters using
<tt/"Copy Marked Prop"/.
<p>
A simple example for the property clipboard:
<p>
Our task is to give a big number of material objects the same color,
but they already have different opacity settings. Copying the complete
attribute property would destroy the individually adjusted opacity values.
We can solve this by copying just the color attribute, but leave all other
attributes as they are:
<enum>
<item>Change the color of a first material object using the
<tt/"Attributes"/ property GUI. (Do not forget the <tt/"Apply"/ button!)

<item>Mark the color parameter as to be copied using a double click
on the text <tt/"Color"/; it should read <tt/"!Color"/ now.

<item>Copy just the color parameter to the property clipboard,
using <tt/"Copy Marked Prop"/ in the <tt/"Edit"/ menu or the
hot key <tt/&lt;Ctrl+I&gt;/.

<item>Select all other material objects.

<item>Paste the property using <tt/"Paste Property"/ or <tt/&lt;Ctrl+V&gt;/.

<item>All done.
</enum>
<p>
Special care must be taken when pasting incomplete properties to objects
which do not have complete properties already. Do not paste an incomplete
shader property to an object which does not already have the same shader.

<sect2>The Console<label id="cons">
<p>
<figure loc="ht">
<eps file="pics/console.ps" height="2cm">
<img src="pics/console.gif">
<caption>Console</caption>
</figure>
<p>
The third part of the main window is the console. The console is mainly
for unobtrusive text output (informative, warning, and error messages).
If something does not work as advertised, the console may be worth
a look.
<p>
The console captures the stderr and stdout channels of the
Tcl-interpreter Ayam is running in. It is also possible to
redirect all internal Tcl error messages, that would normally
cause a Tcl error dialog window to appear, to the console using
the preference setting <tt>"Misc/RedirectTcl"</tt>
(see section <ref id="prefmisc" name="Miscellaneous Preferences">).
<p>
One can of course also enter commands or even complete new Tcl procedures
into the console. However, this is a feature for an advanced
user that studied section <ref id="script" name="Scripting Interface">.
You need to explicitly click into the console to give it the input
focus and thus enable input.
<p>
An important thing to know is that the keyboard shortcuts for the
various main menu entries do not work if the console has the input
focus. Instead, other keyboard shortcuts (related to the console)
are in effect.
How do you get out of this? Simply press <tt/&lt;Shift+Tab&gt;/ or
<tt/&lt;Esc&gt;/ to move the focus away from the console and enable
the main menu shortcuts again.
<p>
Note that the <tt/&lt;Tab&gt;/ key alone does not move the focus away
from the console.
<tt/&lt;Tab&gt;/ instead completes names of files, commands (procedures),
variables, and widgets.
You may try this out by typing <tt/tip/ in the console,
then press <tt/&lt;Tab&gt;/.
The console automagically completes <tt/tip/ to <tt/tipoftheDay/
(the procedure that prints out the tip of the day, just try it).
<p>
Remember that many commands of the Ayam scripting interface work
in background: without update of object selection widget, property GUI or
redrawing of view windows. But one can enforce an immediate update of
the GUI and redrawing of all views by using <tt/&lt;Shift-Enter&gt;/
instead of <tt/&lt;Enter&gt;/ when entering commands.
<p>
Another simple demonstration of the consoles capabilities:
<itemize>
<item>Create ten box objects by clicking on the box icon ten times.
<item>Select all ten boxes.
<item>Go to the console by clicking into it.
<item>Enter the following:
<tt>forAll 0 &lcub;movOb &dollar;i 0 0; rotOb &lsqb;expr &dollar;i*10&rsqb; 0 0&rcub;</tt>
</itemize>
<p>
This example uses three procedures:
<itemize>
<item><tt/forAll/: allows to execute
a command for each of the selected objects, or for each object in the
current level if no objects are selected.
<item><tt/movOb/: moves the selected object(s).
<item><tt/rotOb/: rotates the selected object(s).
</itemize>
<p>
See section <ref id="script" name="Scripting Interface"> for a
listing of all the available commands.
<p>
Note that the example uses a side effect (the variable <tt/"i"/ that
holds the index of the currently processed object) to calculate
the amount of the movement and rotation.
<p>
For more information regarding the console, please refer to the
appropriate documentation by the original author Jeffrey Hobbs
(see the console context menu, that you may open with your right
mouse button).

<sect1>Main Menu<label id="mm">
<p>
This section discusses the main menu bar.
<p>
Note that many menu entries have keyboard shortcuts that are displayed
in each entry. But those shortcuts only work if the main window
has the keyboard input focus <em>and</em> the input focus is not in the
console or in a property GUI element (i.e.~a data entry field).
Hit <tt>&lt;Esc&gt;</tt> to set the focus to the object selection
widget and thus enable the main menu keyboard shortcuts.
<p>
One can adapt these shortcuts using the <tt>"ayamrc"</tt> file
(see section <ref id="ayamrc" name="Ayamrc File">).
<p>
Another way of navigating the menu is via the <tt/"Menu"/ or
<tt/"Alt"/ key, pressed together with the various underlined characters
in the menu entries.

<#if out=latex><x/phantomsection/</#if>

<label id="mmfile">
The <tt/"File"/ menu deals with standard file operations:
<itemize>
<item><tt/"New"/, clears the current scene (deletes all objects) and reloads
the working environment.<newline>
This operation cannot be undone!

<item><tt/"Open"/, clears the current scene and closes all views,
then loads a new scene from disk.

<p>
All objects from the file
will be read. A backup copy of the file will be made before loading
(depending on the preference setting <tt>"Main/BakOnReplace"</tt>).
See section <ref id="opensf" name="Opening Scene Files">
for a more detailed discussion.<newline>
This operation cannot be undone!
<p>
Also files supported by any of the import plugins
may be imported using this route.
<footnote>Since 1.13.</footnote>
Note that this only works if the selected file has a file name extension.
The appropriate plugin will
be loaded automatically (from the list of plugin directories in the
preferences) if needed and the import options dialog of the plugin
will be opened, with the <tt/"FileName"/ option already set.
Mind that in this case, no backup copy of the file will be made.
See also section <ref id="impex" name="Import and Export">.

<item><tt/"Insert"/, inserts the objects and views of an Ayam scene file
into the current scene.

<p>
All objects from the file will be read.
If the file to be inserted contains a Root or View objects, the new
objects will be created in the top level of the scene.
Otherwise, if just geometric objects are in the scene file (i.e.~the file
was created using <tt>"Special/Save Selected"</tt>), the new objects
will be inserted in the current level of the scene.
See section <ref id="insertsf" name="Inserting Scene Files">
for a more detailed discussion.<newline>
This operation cannot be undone!
<p>
Also files supported by any of the import plugins
may be imported using this route. See above (<tt/"Open"/).
<footnote>Since 1.13.</footnote>

<item><tt/"Save as"/, saves the current scene asking for a new file name.

<p>
All objects in the scene will be saved to the scene file, but
if the current scene was loaded from a file without root object
(and thus without view windows), root and views will be omitted
from the saved scene file as well.
See section <ref id="savesf" name="Saving Scene Files">
for a more detailed discussion.
<p>
Also files supported by any of the export plugins
may be exported using this route. Just pick a file name with the
desired extension (see above, <tt/"Open"/).
<footnote>Since 1.13.</footnote>

<item><tt/"Save"/, saves the scene. If the scene has not been saved before
(the scene file name is "unnamed") Ayam will ask for a file name first.

<p>
All objects in the scene will be saved to the scene file, but
if the current scene was loaded from a file without root object
(and thus without view windows), root and views will be omitted
from the saved scene file as well.
See section <ref id="savesf" name="Saving Scene Files">
for a more detailed discussion.

<item><tt>"Import/"</tt>, since Ayam 1.13 this sub menu is initially
empty. You need to load a plugin first to gain access to the menu entries
described here.

<item><tt>"Import/Apple 3DMF"</tt>, import a scene from the Apple
3DMF format, see section <ref id="imp3dmf" name="3DMF (Apple) Import">
for more information.

<item><tt>"Import/AutoCAD DXF"</tt>, import a scene from the AutoCAD
DXF format, see section <ref id="impdxf" name="AutoCAD DXF import">
for more information.

<item><tt>"Import/Mops"</tt>, import a scene from The Mops,
see section <ref id="impmops" name="Import of Mops Scenes">
for more information.

<item><tt>"Import/Rhino 3DM"</tt>, import a scene from the Rhino
3DM format, see section <ref id="imprhino" name="3DM (Rhino) Import">
for more information.

<item><tt>"Import/Wavefront OBJ"</tt>, import a scene from the Wavefront
OBJ format, see section <ref id="impwav" name="Wavefront OBJ Import">
for more information.

<item><tt>"Import/Web3D X3D"</tt>, import a scene from the XML
based X3D format published by the Web3D Consortium, see section
<ref id="impx3d" name="X3D (Web3D) Import">
for more information.

<item><tt>"Export/"</tt>, since Ayam 1.13 this sub menu initially
only contains the <tt>"RenderMan RIB"</tt> entry. You need to load a
plugin first to gain access to the other menu entries
described here.

<item><tt>"Export/RenderMan RIB"</tt>, exports the current scene to a RIB,
asking which camera (which view) to use.

<item><tt>"Export/Apple 3DMF"</tt>, export a scene to the Apple
3DMF format, see section <ref id="exp3dmf" name="3DMF (Apple) Export">
for more information.

<item><tt>"Export/Rhino 3DM"</tt>, export a scene to the Rhino
3DM format, see section <ref id="exprhino" name="3DM (Rhino) Export">
for more information.

<item><tt>"Export/Wavefront OBJ"</tt>, exports the current scene to a
Wavefront OBJ file, see also section
<ref id="expwav" name="Wavefront OBJ export">.

<item><tt>"Export/Web3D X3D"</tt>, export a scene to the XML
based X3D format published by the Web3D Consortium, see section
<ref id="expx3d" name="X3D (Web3D) Export">
for more information.

<item><tt/"Load Plugin"/, loads a file containing a custom object or a plugin.
Depending on the platform Ayam is running on, these are files with the
file name extension <tt/".so"/ or <tt/".dll"/.
See section <ref id="plugov" name="Plugins Overview"> for more
information regarding Ayam plugins.

<item><tt/"Save Prefs"/, save the current preference settings
to the ayamrc file after making a backup copy of this file (see section
<ref id="ayamrc" name="Ayamrc File"> for more information about this file).

<item><tt/"1."/, <tt/"2."/, <tt/"3."/, <tt/"4."/, immediately replace the
current scene with the one in the menu entry. The menu entries
are updated and rotated upon successful loading and saving of a scene
so that the first entry always contains the scene that was loaded
(or saved) last.

<item><tt/"Exit!"/, remove all temporary files, save preferences (if
the preference setting <tt>"Main/AutoSavePrefs"</tt> is turned on)
and quit the application.
</itemize>

<#if out=latex><x/newpage/</#if>

<#if out=latex><x/phantomsection/</#if>

<label id="mmedit">
The <tt/"Edit"/ menu contains object and property clipboard
operations, undo actions, and lets you open the preferences editor:
<itemize>
<item><tt/"Copy"/, copies the currently selected object(s) into the
clipboard.<newline>
This operation cannot be undone!

<item><tt/"Cut"/, moves the currently selected object(s) into the
clipboard.<newline>
This operation cannot be undone!

<item><tt/"Paste"/, copies the object(s) from the clipboard to the current
level of the scene.<newline>
This operation cannot be undone!

Note that the content of the clipboard remains intact
after this operation, this means that you can paste multiple times!
You can move objects out of the clipboard (clearing it) using the menu entry
<tt>"Special/Clipboard/Paste (Move)"</tt>.
Also note that referenced objects, when moved into the clipboard with
<tt/"Cut"/, can not be moved out of it using a simple <tt/"Paste"/, use
<tt>"Special/Clipboard/Paste (Move)"</tt> instead!
See also section <ref id="instclip" name="Instances and the Object Clipboard">.


<item><tt/"Delete"/, removes the selected object(s) from the scene.
<newline>
This operation cannot be undone!

<item><tt/"Select All"/, selects all objects in the current level
(except for the root object).

<item><tt/"Select None"/, de-selects all currently selected objects.

<item><tt/"Copy Property"/, copies the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard).
Marked parameters will be omitted!

<item><tt/"Copy Marked Prop"/, copies the currently marked parameters
of the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard).

<item><tt/"Paste Property"/, copies all property data from the property
clipboard to the currently selected object(s). The data will get pasted
to the property type saved by the last copy operation. It will not get
pasted to the currently selected property; use
<tt>"Special/Clipboard/Paste Property to selected"</tt> for that.

<item><tt/"Undo"/, perform undo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Redo"/, perform redo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Material"/, searches for the material object currently
associated with the selected object and selects it for editing.
If the selected object has no material yet, a new material
will be created: Ayam will prompt for the name of the new
material, the material object will be created, if successful,
the material will be linked to <em>all</em> currently selected objects
(even if they are already linked to other objects).

<item><tt/"Master"/, searches for the master object of the
currently selected instance object and selects it for editing,
see also section <ref id="instanceobj" name="Instance Object">.

<item><tt/"Preferences"/, opens the preferences dialog (see section
<ref id="prefs" name="Preferences"> for more information).
</itemize>

<#if out=latex><x/newpage/</#if>

<#if out=latex><x/phantomsection/</#if>

<label id="mmcreate">
The <tt/"Create"/ menu entries let you create objects. In contrast
to the object creation via the toolbox some menu entries present you
with small dialogs, where you may adjust parameters for the object
to be created.
The entry fields in those dialogs support Tcl expressions as detailed
in section <ref id="scexpdiag" name="Expression Support in Dialog Entries">.
Here are the entries of the <tt/Create/ menu:
<itemize>
<item><tt/"NURBCurve"/, create a new NURBS curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="ncurveobj" name="NCurve Object">.
This dialog also contains a <tt/"AddArgs"/ entry
field where you may specify additional command line arguments to
the <tt/"crtOb NCurve"/ command, as outlined in section
<ref id="sccrtnc" name="Creating Objects">.
<footnote>Since 1.19.</footnote>

<item><tt/"ICurve"/, create a new interpolating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="icurveobj" name="ICurve Object">.
This dialog also contains a <tt/"AddArgs"/ entry
field where you may specify additional command line arguments to
the <tt/"crtOb ICurve"/ command, as outlined in section
<ref id="sccrtic" name="Creating Objects">.
<footnote>Since 1.19.</footnote>

<item><tt/"ACurve"/, create a new approximating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="acurveobj" name="ACurve Object">.
This dialog also contains a <tt/"AddArgs"/ entry
field where you may specify additional command line arguments to
the <tt/"crtOb ACurve"/ command, as outlined in section
<ref id="sccrtac" name="Creating Objects">.
<footnote>Since 1.19.</footnote>

<item><tt/"NCircle"/, create a new NURBS circle. See
also section <ref id="ncircleobj" name="NCircle Object">.

<item><tt/"NURBPatch"/, create a new NURBS patch. A small dialog box will
pop up, where you may specify the width and height of the new patch. See
also section <ref id="npatchobj" name="NPatch Object">.
This dialog also contains a <tt/"AddArgs"/ entry
field where you may specify additional command line arguments to
the <tt/"crtOb NPatch"/ command, as outlined in section
<ref id="sccrtnp" name="Creating Objects">.
<footnote>Since 1.19.</footnote>

<item><tt/"IPatch"/, create a new interpolating patch.
<footnote>Since 1.20.</footnote>
A small dialog box will pop up, where you may specify the width and
height of the new patch. See also section
<ref id="ipatchobj" name="IPatch Object">.
This dialog also contains a <tt/"AddArgs"/ entry
field where you may specify additional command line arguments to
the <tt/"crtOb IPatch"/ command, as outlined in section
<ref id="sccrtip" name="Creating Objects">.

<item><tt/"BPatch"/, create a new bilinear patch. See
also section <ref id="bpatchobj" name="BPatch Object">.

<item><tt/"PatchMesh"/, create a new patch mesh. See
also section <ref id="patchmeshobj" name="PatchMesh Object">.

<item><tt/"Solid"/, create a new solid primitive object, for use in CSG.
<tt/"Box"/, <tt/"Sphere"/, <tt/"Disk"/, <tt/"Cone"/, <tt/"Cylinder"/,
<tt/"Torus"/, <tt/"Hyperboloid"/ or <tt/"Paraboloid"/ may be selected.

<item><tt/"Level"/, creates a new hierarchy object. <tt/"Level"/
just groups objects, <tt/"Union"/, <tt/"Intersection"/,
<tt/"Difference"/, and <tt/"Primitive"/ are CSG operations. See
also section <ref id="levelobj" name="Level Object">.

<item><tt/"Light"/, create a new light source. See
also section <ref id="lightobj" name="Light Object">.

<item><tt/"Custom Object"/, create a new custom object. If this sub-menu
is empty no custom object has been loaded yet. See
also section <ref id="customobj" name="Custom Object">.

<item><tt/"View"/, a new View window will be opened. See
also section <ref id="viewobj" name="View Object">.

<item><tt/"Instance"/, create an instance of the currently selected
object, see section <ref id="instanceobj" name="Instance Object">
for more information regarding instances.

<item><tt/"Clone"/, create a clone object, see
section <ref id="cloneobj" name="Clone Object">

<item><tt/"Mirror"/, create a Mirror object, see
section <ref id="mirrorobj" name="Mirror Object">

<item><tt/"Material"/, create a new material. A small dialog box will
pop up, where you have to specify the name of the new material. See
also section <ref id="materialobj" name="Material Object">.

<item><tt/"Camera"/, create a new camera. Camera objects may be used
to temporarily save view camera settings, see
section <ref id="cameraobj" name="Camera Object">.

<item><tt/"RiInc"/, create a new RIB-include object. Those objects
may be used to include objects into your scenes
that just exist as a piece of RIB, see
also section <ref id="riincobj" name="RiInc Object">.

<item><tt/"RiProc"/, create a new procedural object, see
also section <ref id="riprocobj" name="RiProc Object">.

<item><tt/"Script"/, create a new script object, see
also section <ref id="scriptobj" name="Script Object">.

<item><tt/"Select"/, create a new select object, see
also section <ref id="selectobj" name="Select Object">.

<item><tt/"Text"/, create a new text object, see
also section <ref id="textobj" name="Text Object">.
</itemize>

<#if out=latex><x/newpage/</#if>

<#if out=latex><x/phantomsection/</#if>

<label id="mmtools">
The <tt/"Tools"/ menu hosts modelling tools to create complex objects
or modify existing objects. Some tools open dialog windows to request
parameters.
The entry fields in those dialogs support Tcl expressions as detailed
in section <ref id="scexpdiag" name="Expression Support in Dialog Entries">.
The entries of the <tt/"Tools"/ menu are:
<itemize>
<item><tt/"Last (None)"/, this menu entry allows quick access to the
last used entry/tool in the <tt/"Tools"/ menu hierarchy.
<footnote>Since 1.13.</footnote>

The label of the entry will be changed appropriately
when a tool was started, e.g.~to <tt/"Last (Revert U)"/ after the
<tt/"Tools/Surface/Revert U"/-tool was used.
The corresponding keyboard shortcut is <tt/&lt;Ctrl+t&gt;/. To repeat
the last used tool with the same set of parameters (and without opening
the parameter dialog window again) the shortcut <tt/&lt;Ctrl+T&gt;/ can
be used instead.

<item><tt/"Create"/, <tt/"Curve"/, and
<tt/"Surface"/, are sub-menus with various NURBS based creation
and modelling tools, that are explained in depth in section
<ref id="nmtool" name="NURBS Modelling Tools">.

<item><tt/"PolyMesh"/: sub-menu for polygonal mesh related tools:
<itemize>
<item><tt/"Merge"/: merges all currently selected PolyMesh objects into
a single PolyMesh object, without checking for doubly used points,
loops, or faces. The currently selected PolyMesh objects will not
be changed by this tool. But you may let the merge-tool delete them
immediately after the merging operation, by enabling the
<tt/"RemoveMerged"/-option.
If the <tt/"OptimizeNew"/-option is enabled, the <tt/"Optimize"/-tool
(see below) will be started after the merge operation with the
newly created merged object as argument.

<item><tt/"Split"/: splits the faces from the selected PolyMesh objects
off and into a second PolyMesh object. The faces to be split off are selected
by selecting all their control points with the select points modelling
action (see also section <ref id="selac" name="Selecting Points">).
The original selected PolyMesh objects will be changed, the selected
faces will be removed. The changes to the original objects cannot be
undone. Since the split operation does not
create optimized new objects, the <tt/"Optimize"/-tool (see below) may
be started immediately after splitting using the <tt/"OptimizeNew"/-option.

<item><tt/"Optimize"/: optimizes the selected PolyMesh object(s)
by removing all multiply used (and unused) control points (if the option
<tt/"OptimizeCoords"/ is enabled) or multiply used faces (not implemented
yet). If the option <tt/"IgnoreNormals"/ is enabled, the optimize-tool will
consider points with equal coordinates but differing normals
to be equal (and optimize them).
Removing multiply used control points using the <tt/"Optimize"/-tool
may decrease the memory consumption of the control points
by a factor of about six, depending on the connectivity of the original
mesh.
</itemize>

<item><tt/"Points"/: sub-menu for tools that work on points:
<itemize>
<item><tt>"Select All Points"</tt>, selects all points of the currently
selected object(s).

<item><tt>"Invert Selection"</tt>, selects all points of the currently
selected object(s) that are not selected, and de-select all points that
are currently selected.

<item><tt>"Apply To All"</tt>, applies the transformations encoded in
the transformations property of the selected objects to all points of those
objects.
This will have the effect of resetting the transformations property
to the default values without (visibly) changing the points of the
selected objects.

<item><tt>"Apply To Selected"</tt>, applies the transformations
encoded in the transformations property of the selected objects to the
selected points.
This will reset the transformations property without (visibly)
changing the selected points. The points currently not selected
will be transformed, however!

<item><tt>"Center All Points (3D)"</tt>, moves all points of the
selected objects so that their common center (the center of gravity)
is the center of the respective objects coordinate system.
Note that, currently, this works on each of the selected objects
separately!
<item><tt>"Center All Points (2D-XY)"</tt>,
<tt>"Points/Center All Points (2D-YZ)"</tt>,
<tt>"Points/Center All Points (2D-XZ)"</tt>: work like the center
3D tool but just center in the designated plane.
</itemize>

<item><tt/"Show"/, <tt/"Hide"/ set and unset the <tt/"Hide"/
attribute of the selected object(s) thus making them invisible
or visible again.
Note that hidden objects may be excluded from RIB-Export, when
the preference setting <tt>"RIB-Export/ExcludeHidden"</tt> is
activated.

<item><tt/"Show All"/ and <tt/"Hide All"/ set and unset the <tt/"Hide"/
attribute of all objects in the scene (including the root object
and all views!) regardles of the currently selected objects (and
without changing the current selection). These operations can
not be undone using the undo system.

<item><tt/"Convert"/, starts the convert action that has been
registered for the type of the selected object(s). The exact
behaviour depends on the type of the selected object(s):
a Revolve object will e.g.~be converted to a level containing NURBS
patches that make up the surface of revolution and the caps.
This operation can not be undone, i.e.~the newly created objects
will not be removed, using the undo system.

<item><tt/"Convert (In Place)"/, starts the convert action as
outlined above, but replaces the original objects with the
new converted ones. This operation, in contrast to the simple
conversion above, can be undone.

<item><tt/"Force Notification"/, force the notification callbacks of
all selected objects (or all objects in the scene if no objects are
selected) to be called. The notification callbacks are used by objects
like e.g.~Revolve to be informed about changes of their child
objects to properly adapt to those changes.

<item><tt/"Highlight Material"/, colours all objects of the same
material in red color in the tree view. This tool expects a selected
material object or a normal object that has a material attached.
It will not work for material objects that are not registered or
have no normal objects that refer to them. It will also not work
for objects that have no material assigned. If the reference counter
of a material object is not zero, but <tt/"Highlight Material"/
reports 0 objects found, the referring objects probably reside
in the object clipboard. You can clear the color from the tree view
with the keyboard shortcut <tt/&lt;Ctrl+l&gt;/.
</itemize>

<#if out=latex><x/phantomsection/</#if>

<label id="mmcustom">
The <tt/"Custom"/ menu is initially empty. Custom objects and plugins,
may create entries here.

<#if out=latex><x/newpage/</#if>

<#if out=latex><x/phantomsection/</#if>

<label id="mmspecial">
The <tt/"Special"/ menu contains seldom used tools:
<itemize>
<item><tt/"Save Selected as"/, saves just the currently selected objects
to disk. Note that Ayam will not check, whether the objects are saved
with their materials. It is also possible to save instance objects
without their master objects. This will lead to errors while loading
such a scene later on.

<item><tt/"Save Environment"/, saves the root object and all
views to a so called environment scene file, which is read
on program startup and <tt>"File/New"</tt>.
Initially, the file requester that asks for the name
of the new environment uses the value of the preference
setting <tt>"Main/EnvFile"</tt>. Note that there will be no
check whether loading of that environment on next start up is
enabled in the preferences. Note also, that using <tt/"Save Environment"/
you can just save environment files that contain the root object
and all views. If you want to include geometric objects in your
environment or if you want to exclude the root object and just
save views you have to use <tt>"File/Save"</tt> or
<tt>"Special/Save Selected as"</tt> respectively.

<item><tt>"Clipboard/Paste (move)"</tt>, moves objects from the clipboard
back to the scene (clearing the clipboard). This is the only way to
get referenced objects out of the clipboard.

<item><tt>"Clipboard/Replace"</tt>, replaces the currently selected
object(s) with the object clipboard content, moving the replaced
objects into the clipboard. If multiple objects are selected
in non consecutive sequences, only the first consecutive sequence
or single object is replaced.

<item><tt>"Clipboard/Paste Property to selected"</tt> paste the property
from the property clipboard to the currently selected
property of the currently selected object. No type check of the
properties will take place! One may e.g.~copy the settings from a
displacement shader to a surface shader (as long as the copied arguments
of both shaders have the same names and types).

<item><tt>"Instances/Resolve all Instances"</tt>, converts all instances
of the current level (and its child objects) to normal objects.
If objects are selected, only those selected objects will be
processed.
<footnote>Since 1.14.</footnote>

<item><tt>"Instances/Automatic Instancing"</tt>, pops up a small dialog box,
where you may parameterise and start the automatic instantiation
algorithm (that automatically creates instances from
equal objects). See section <ref id="ai" name="Automatic Instancing">
for more information regarding automatic instancing.

<item><tt>"Tags/Add RiOption"</tt>, pops up a small dialog box, where you may
select and parameterise a RiOption tag to add as tag to the Root object
(see <ref id="riotag" name="RiOption Tag">). The Root object does
not have to be selected and the current selection will not be changed
by this action.

<item><tt>"Tags/Add RiAttribute"</tt>, pops up a small dialog box, where
you may select and parameterise a RiAttribute tag to add as tag to the
currently selected object(s) (see <ref id="riatag" name="RiAttribute Tag">).

<item><tt>"Tags/Edit TexCoords"</tt>, opens the texture coordinates editor.
(see also section <ref id="tctag" name="TC (Texture Coordinates) Tag">).

<item><tt>"RIB-Export/From Camera"</tt>, writes a complete RIB of
the current scene with the camera transformations taken from the
currently selected camera object. The size of the rendered image will
be taken from the RiOptions of the root object. If they are zero,
default values of 400 pixels width and 300 pixels height will be used.
The type of the projection written will be perspective.
Otherwise the RIB looks exactly the same as if exported via
main menu <tt>"File/Export/RenderMan RIB"</tt>.

<item><tt>"RIB-Export/Selected Objects"</tt>, exports only the
selected objects to a RIB. Note that instances will always be resolved,
hidden objects and objects with <tt>"NoExport"</tt> tags are treated
as on normal export operations, and light objects are simply ignored.
Note also that the created RIB, since it e.g.~lacks camera transformation
and WorldBegin/End directives, may not be rendered directly by a
RenderMan compliant renderer (unless the renderer is really forgiving
about mis-structured RIBs).
The main use of this feature is to let you create RIBs that may be easily
included in other RIBs using e.g.~the ReadArchive directive.

<item><tt>"RIB-Export/Create ShadowMap"</tt>, creates the shadow maps
from the currently selected light source.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt>"RIB-Export/Create All ShadowMaps"</tt>, creates all shadow maps
for the current scene (regardless of selection).
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Enable Scripts"/ enables all disabled script tags and
objects. Objects and tags in the object clipboard are not
affected!

<item><tt>"Select Renderer"</tt> opens a dialog where the renderer
for direct rendering from a view may be chosen.
The changes will have effect on all preference settings that control
direct rendering from a view, except whether RenderGUIs should
be used.
If the <tt>"ScanShaders"</tt> checkmark is activated, Ayam will
additionally try to load the corresponding shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">)
and rescan for compiled shaders. Note that in order for the
<tt>"ScanShaders"</tt> feature to work properly the <tt>"Main/Shaders"</tt>
and <tt>"Main/Plugins"</tt> preference settings have to be set correctly
(see also section <ref id="prefmain" name="Main Preferences">).

<item><tt>"Scan Shaders"</tt> initiates the shader parsing with the
built in shader parser or the currently loaded shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">).

<item><tt>"Reset Preferences"</tt> removes the current ayamrc file,
where the preferences are saved; after a restart of Ayam, all
preferences will be reset to factory defaults. See also
section <ref id="ayamrc" name="Ayamrc File"> for more information
about the ayamrc file.

<item><tt>"Reset Layout"</tt> resets the pane layout in single window
GUI mode so that the upper internal views get an approximately even share
of available screen space and the object selection widget and property
GUI are completely visible.

<item><tt/"Toggle Toolbox"/ closes or opens the toolbox window
(see <ref id="toolb" name="The Toolbox Window">). From version 1.3 on,
Ayam remembers the state of the toolbox in the saved preferences.
This option is not available if Ayam is in single window GUI mode.

<item><tt/"Toggle TreeView"/ toggles object tree view and object listbox.
From version 1.3 on, Ayam remembers whether the tree view or the
object listbox is open in the saved preferences
(see also section <ref id="obj" name="Objects"> for more information
about both representations).

<item><tt>"Zap Ayam"</tt> iconifies all currently open windows of Ayam.
If one of the iconified windows is de-iconified later, all other zapped
windows will be de-iconified as well.
</itemize>

<#if out=latex><x/phantomsection/</#if>

<label id="mmhelp">
The <tt/"Help"/ menu:
<itemize>
<item><tt/"Help"/, opens a web browser and displays the documentation,
the URL to display is taken from the <tt/"Docs"/ preference setting.

<item><tt/"Help on object"/, opens a web browser and displays
documentation about the currently selected type of object,
the URL to display is derived from the <tt/"Docs"/ preference setting,
this feature will not work with frame redirects
e.g.~<tt>"http://www.ayam3d.org/"</tt>; use
<tt>"http://ayam.sourceforge.net/docs/"</tt> or a <tt>"file:"</tt>-URL
as base URL in the <tt/"Docs"/ preference setting instead!

<item><tt/"Show Shortcuts"/, displays some important shortcuts for modelling
actions, you may leave this window open when doing your first
steps in modelling with Ayam.

<item><tt/"About"/, displays some version, copyright,
and trademark information.

<item><tt/"Show Tooltips"/, enables tool tips (balloon help)
for various user interface elements (including the toolbox buttons).
</itemize>

<sect1>Main Window Keyboard Shortcuts<label id="mwsc">
<p>
An important group of shortcuts is available on the function
keys:<newline>
<tt>&lt;F1&gt;</tt> has already been mentioned, it opens a
web browser and displays the URL from the <tt>"Docs"</tt>
preference setting.<newline>
<tt>&lt;F2&gt;</tt> and <tt>&lt;F3&gt;</tt> lower and raise the global
GLU sampling tolerance value respectively, allowing fast
adjustment of the NURBS drawing/shading quality.<newline>
<tt>&lt;F4&gt;</tt> toggles between display of NURBS control cage and
true curves&thinsp;/&thinsp;surface outlines.<newline>
<tt>&lt;F5&gt;</tt> rebuilds the object tree and issues a complete
notification. It is therefore helpful to update the complete
GUI after changes made to the scene using the scripting interface
in the console.<newline>
<tt>&lt;F6&gt;</tt> toggles lazy notification.
<p>
<tt>&lt;Ctrl+A&gt;</tt> is bound to the <tt>"Apply"</tt> and
<tt>&lt;Ctrl+R&gt;</tt> to the <tt>"Reset"</tt> button of the
property GUI.
<p>
The object selection can be manipulated by the cursor keys,
see also section
<ref id="treesc" name="object tree shortcuts"> and section
<ref id="olbsc" name="object list shortcuts">.
<p>
Many main menu entries have direct keyboard shortcuts, displayed
directly in the menu entries,
see also section <ref id="mm" name="main menu">.
<p>
Note that the main window keyboard shortcuts only work if the main window
has the keyboard input focus <em>and</em> the input focus is not in the
console or in a property GUI element (i.e.~a data entry field).
Hit <tt>&lt;Esc&gt;</tt> first to set the focus to the object selection
widget and thus enable the main window keyboard shortcuts.
<p>
One can adapt all these shortcuts using the <tt>"ayamrc"</tt> file
(see section <ref id="ayamrc" name="Ayamrc File">).

<sect1>Anatomy of a View<label id="viewwin">
<p>
<figure loc="ht">
<eps file="pics/view.ps" height="7cm">
<img src="pics/view.gif">
<caption>A View Window</caption>
</figure>
<p>
The view window is split into a menu bar and a
OpenGL-widget, where interaction and drawing takes place.
The title of the view window gives information about
name, current type, and the currently active modelling
action of the view.
<p>
The current modelling action, modelling mode, drawing mode and
grid size are also displayed as a set of icons on the right hand
side of the view menu bar.

<sect1>View Menu<label id="vm">
<p>
This section discusses the view menu bar.
<p>
Note that many menu entries
have keyboard shortcuts that are displayed in each entry.
But those shortcuts only work if the view window
has the keyboard input focus.
The shortcuts are adaptable using the <tt>"ayamrc"</tt> file
(see section <ref id="ayamrc" name="Ayamrc File">).
<p>
Another way of navigating the menu is via the <tt/"Menu"/ or
<tt/"Alt"/ key, pressed together with the various underlined characters
in the menu entries.

<#if out=latex><x/phantomsection/</#if>

<label id="vmview">
Here are all meny entries of the <tt/"View"/ menu:
<itemize>
<item><tt/"Quick Render"/: the scene is exported to a RIB file using the
camera settings of the current view; then the <tt/"QRender"/ command
(see the preferences) will be called. Note that the RIB export
will not use the RiOption settings for image size but the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Render"/: the scene is exported to a RIB file using the
camera settings of the current view; then the <tt/"Render"/ command
(see the preferences) will be called. Note that the RIB export
will not use the RiOption settings for image size but the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Redraw"/: forces the OpenGL-widget to be drawn, this is
particularly useful if automatic redrawing of the view has been disabled.

<item><tt/"Export RIB"/ exports the scene to a RIB. This does exactly the
same as the main menu entry <tt>"File/Export/RenderMan RIB"</tt>, except that
the current view will already be selected in the dialog box.

<item><tt/"Open PPrev"/, <tt/"Close PPrev"/: those menu entries are just
available, if the compile time option <tt/AYENABLEPPREV/ has been set.
This option is <em>not</em> set for the official Ayam binaries.
Permanent preview (PPrev) continuously writes a RIB stream to
a (fast) RenderMan renderer, a frame for each redraw operation
of the view window that was used to open the preview. This way, the
RenderMan renderer immediately displays all changes in the scene.
This is a great way to test many different camera or light settings without
the need to manually start a rendering process and close the preview window
for each different setting.
As the RIB client library usually is not able to handle multiple open
RIB streams simultaneously, RIB-Export and direct rendering from view
windows are not available until the permanent preview window is closed.

<item><tt>"Create ShadowMap"</tt>: creates the shadow maps
for the currently selected light source.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Create All ShadowMaps"/: creates all shadow maps for the
current scene (regardless of selection).
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Close"/: the View window will be removed. This entry is not
available for the internal views of Ayam in single window GUI mode.
</itemize>

<#if out=latex><x/phantomsection/</#if>

<label id="vmtype">
The <tt/"Type"/ menu entries:
<itemize>
<item><tt/"Front"/

<item><tt/"Side"/

<item><tt/"Top"/

<item><tt/"Perspective"/

<item><tt/"Trim"/
</itemize>
may be used to change the type of the view, which restrains the scope
of certain modelling actions. See sections
<ref id="viewobj" name="View Object">,
<ref id="vwsc" name="View Window Shortcuts and Actions">, and
<ref id="iac" name="Modelling Actions">
for more information.

<#if out=latex><x/phantomsection/</#if>

<label id="vmconf">
The <tt/"Configure"/ menu may be used to change preferences of the view.
Some preferences are outlined in greater detail in section
<ref id="vat" name="ViewAttrib">.
<itemize>
<item><tt/"Automatic Redraw"/, toggles whether the view should
be redrawn, whenever the scene changes. If this is disabled,
you can force a redraw using the menu entry <tt>"View/Redraw"</tt>
or the corresponding keyboard shortcut <tt/&lt;Ctrl+d&gt;/.

<item><tt/"Drawing Mode"/ determines whether the view should draw a wireframe
representation (<tt>"Drawing Mode/Draw"</tt>) or a shaded one
(<tt>"Drawing Mode/Shade"</tt>) or, new in Ayam 1.6, a representation
where the curves of the draw mode are drawn over the shaded
representation (<tt>"Drawing Mode/ShadeAndDraw"</tt>).

<item><tt/"Modelling Mode"/ allows to switch the modelling
coordinate system from world space (<tt/"Global"/) to the
space defined by the current parent object (<tt/"Local (Level)"/)
or even the space defined by the currently selected object
(<tt/"Local (Object)"/)
See also section <ref id="editlocal" name="Editing in Local Spaces">.

<item><tt/"Draw Selection only"/, if this is enabled, just the
currently selected objects (and their children) will be drawn.

<item><tt/"Draw Level only"/, if this is enabled, just the
objects of the current level (and their children) will be drawn.

<item><tt/"Draw Object CS"/, if this is enabled, small coordinate
systems (three colored lines) will be drawn at the base of each
objects coordinate system.

<item><tt/"AntiAlias Lines"/, if this is enabled, all lines will
be anti-aliased (smoothed).

<item><tt/"Draw BGImage"/, if this is enabled, the background
image will be drawn.

<item><tt/"Set BGImage"/, may be used to set the current background
image of the view, which should be a TIFF file.
You can also set this image using the view attribute <tt/BGImage/.

<item><tt/"Draw Grid"/, if this is enabled the grid will be drawn.

<item><tt/"Use Grid"/, if this is enabled the grid will be used to
constrain modelling actions to grid coordinates.

<item><tt/"Set Gridsize"/, may be used to change the size of the grid
associated with this view. Another way to change the grid size is
to use the grid icon menu on the rightmost side, see below.

<item><tt/"Half Size"/, change width and height to the half of the
current values.

<item><tt/"Double Size"/, change width and height to the double of the
current values.

<item><tt/"From Camera"/, copy camera settings from the currently
selected camera object to the view.

<item><tt/"To Camera"/, copy camera settings to the currently
selected camera object from the view.

<item><tt/"Set FOV"/, lets you specify a field of view value
for the view, and adapts the zoom accordingly. This is just
working for perspective views, of course.

<item><tt/"Zoom to Object"/, adapt the camera settings, so that
the currently selected objects are centered in the view.

<item><tt/"Align to Object"/, align the view to the coordinate
system of the currently selected object or to the parent
object of the current level if no object is currently selected.

</itemize>

Apart from the text based menus documented above, there are also some icon
based menus in the view window menu bar:
<p>
The <tt/"Modelling mode"/ icon menu may be used to quickly change the current
modelling mode (global or local, see also section
<ref id="editlocal" name="Editing in Local Spaces">). Apart from a
different icon, the local modes will display a L or O in the lower
right corner of the icon.
The icon, additionally, conveys whether objects or points will currently
modified by a modelling action (for points, a red dot will be present
in the upper right corner of the icon).
Furthermore, the type of the view will be displayed in the upper left
corner of the icon as letter F, S, T, or P for front, side, top, or
perspective views, respectively. Views of type trim get no designating
letter in the icon.
See also the image below:
<p>
<figure loc="ht">
<eps file="pics/mmmenu.ps" height="4cm">
<img src="pics/mmmenu.gif">
<caption>Modelling Mode Icon Menu</caption>
</figure>
<p>
The <tt/"Drawing mode"/ icon menu may be used to quickly change the current
drawing mode, drawing, shading, or drawing and shading.
See also the image below:
<p>
<figure loc="ht">
<eps file="pics/dmmenu.ps" height="4cm">
<img src="pics/dmmenu.gif">
<caption>Drawing Mode Icon Menu</caption>
</figure>
<p>
The <tt/"Grid"/ icon menu may be used to quickly change the current grid
size:
<p>
On the right hand side in the view menu bar there is a little icon
that displays the current grid size. You may click on the icon to
display a menu with predefined grid size values.
Choosing one of the values 0.1, 0.25, 0.5, or 1.0 will set the
grid size of the view to the chosen value and will additionally
enable drawing of the grid and snapping to the grid.
The entry <tt/"X"/ allows to set a custom grid value.
The last entry will set the grid size to 0.0 and disable drawing of
and snapping to the grid.
If a grid size other than 0.1, 0.25, 0.5, or 1.0 is in effect for the view,
a generic icon (with a X instead of a number) will be displayed in the
icon menu.
See also the image below:
<p>
<figure loc="ht">
<eps file="pics/grmenu.ps" height="5.5cm">
<img src="pics/grmenu.gif">
<caption>Grid Icon Menu</caption>
</figure>

<sect1>View Window Shortcuts and Actions<label id="vwsc">
<p>
Important keyboard commands of a view window (aside from the view
menu shortcuts) are discussed in this section.
<p>
Note that the view keyboard shortcuts only work if the view window
has the keyboard input focus.
<p>
One can adapt these shortcuts using the <tt>"ayamrc"</tt> file
(see section <ref id="ayamrc" name="Ayamrc File">).
<p>
Keyboard shortcuts directly modifying the camera, that is associated
with the view window, are:
<itemize>
<item><tt/&lt;Left&gt;/, <tt/&lt;Up&gt;/, <tt/&lt;Right&gt;/,
<tt/&lt;Down&gt;/ rotate viewer around origin.

<item><tt/&lt;Shift+Left&gt;/, <tt/&lt;Shift+Up&gt;/, <tt/&lt;Shift+Right&gt;/,
<tt/&lt;Shift+Down&gt;/ pan the view.

<item><tt/&lt;+&gt;/, <tt/&lt;-&gt;/, or <tt/&lt;Add&gt;/, <tt/&lt;Sub&gt;/ (on the numeric keypad) zoom the view.

<item><tt/&lt;Ctrl+5&gt;/ (on the numeric keypad!) resets the views
camera (From and To) to the view type dependend default values.

<item><tt/&lt;.&gt;/ pans the view to the mark.
</itemize>

Interactive actions modifying the camera, that is associated with the
view window, are:
<itemize>
<item>Using <tt/&lt;v&gt;/ you may move the view with your mouse.

<item>Using <tt/&lt;V&gt;/ you move the camera in the direction it is
looking. Note that this affects both, from and to setting of the
virtual camera. Furthermore, this movement will have no visible effect in
parallel views.

<item><tt/&lt;R&gt;/ (note the case!) starts rotating the virtual
camera around the point it is looking to.

<item>Rotating the view is also possible in any
modelling mode, by holding down the <tt/&lt;Alt&gt;/-key.

<item><tt/&lt;o&gt;/ starts zooming the view. Moving the mouse up
zooms in and moving the mouse down zooms out.

<item>Zooming the view into a rectangular region
defined through a mouse drag is also possible in any
modelling mode, by holding down the <tt/&lt;Shift&gt;/-key.
<footnote>Since 1.7.</footnote>
</itemize>
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Pan View|<tt/&lt;v&gt;/|
<#if out=latex><x>inlinegfx pics/movevac.png 0.7cm </x></#if>
<#if out=html><img src="pics/movevac.gif"></#if>
@<hline>
Zoom View|<tt/&lt;V&gt;/|
<#if out=latex><x>inlinegfx pics/zoomvac.png 0.7cm </x></#if>
<#if out=html><img src="pics/zoomvac.gif"></#if>
@<hline>
Rotate View|<tt/&lt;R&gt;/|
<#if out=latex><x>inlinegfx pics/rotatevac.png 0.7cm </x></#if>
<#if out=html><img src="pics/rotatevac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>View Actions Overview</caption>
</table>
<p>
You may also pan/move the view by dragging with the rightmost mouse
button and zoom the view with the middle mouse button without affecting
any other active view or modelling action.
<p>
If you have a wheel mouse and it is configured to send
Mouse4 and Mouse5 button events, Ayam will zoom the view
when you turn the wheel.
<p>
<tt/&lt;PgUp&gt;/ and <tt/&lt;PgDown&gt;/ allow to cycle through the view
types.
<footnote>Since 1.15.</footnote>
<p>
<tt/&lt;Ctrl+PgUp&gt;/ and <tt/&lt;Ctrl+PgDown&gt;/
cycle through the drawing modes.
<footnote>Since 1.16.</footnote>
<p>
Using the menu entry <tt/"Zoom to Object"/ or the corresponding
shortcut <tt/&lt;Ctrl+o&gt;/ (<tt/&lt;O&gt;/ for internal views)
one can change the views camera settings so that the selected
objects will be displayed centered in the view window. This is handy
to search for objects or if the user is simply lost in space.
<p>
Using the menu entry <tt/"Align to Object"/ or the shortcut
<tt/&lt;Ctrl+a&gt;/ (<tt/&lt;L&gt;/ for internal views)
one can change the views camera settings so that it is aligned
to the coordinate system of the currently selected object.
This is handy for modelling in local coordinate systems
(e.g.~when editing the control points of some planar curve defined in the
XY-plane that has been rotated around the Y-axis).
See also section <ref id="editlocal" name="Editing in Local Spaces">.
<p>
It is also possible to move through the scene hierarchy and
change the selection directly in view windows:
<footnote>Since 1.18.</footnote>

<itemize>
<item><tt/&lt;Ctrl+4&gt;/, <tt/&lt;Ctrl+6&gt;/ (on the numeric keypad!)
move up and down in the hierarchy respectively, also selecting the parent
or first child.

<item><tt/&lt;Ctrl+2&gt;/, <tt/&lt;Ctrl+8&gt;/ (on the numeric keypad!)
select the next or previous object.

<item><tt/&lt;Ctrl+Shift+2&gt;/, <tt/&lt;Ctrl+Shift+8&gt;/
(on the numeric keypad!)
extend the current selection to include the next or previous object.
</itemize>

<sect1>Selecting Objects within a View<label id="objsel">
<p>
This section describes techniques that you can use for selecting
one or more objects within a view window with the mouse.
<p>
When the view windows action is <tt/"Pick"/ you can pick (select) objects
that appear within this view with the mouse.
You can invoke this action by pressing <tt/&lt;P&gt;/
or make this action the default action using the preference
setting <tt>"Modelling/DefaultAction"</tt>. If picking is the
default action, it will be automatically enabled when any other
action is broken using <tt/&lt;Esc&gt;/.

<sect2>Selecting Individual Objects<label id="oneobjsel">
<p>
Selecting objects within a view is a straightforward operation that uses
standard methods. You will use the following two selection operations most
frequently:

<itemize>
<item>To select a single object within a view, move the cursor to the object
and click mouse button 1 (the leftmost one).
Once you select an object, any objects previously
selected are unselected automatically.

<item>To select an additional object, move the cursor to the object and
<tt/&lt;Control&gt;/+Click (again with the leftmost mouse button).
Previously selected objects remain selected, and
the newly picked object is added to the selection. Notice that the picked item
must belong to the same level as the previously selected objects. An
alternative method for selecting multiple objects is to drag a rectangle
around them. For more information see
<ref id="mulobjsel" name="Drag-selecting Multiple Objects">
</itemize>

<sect2>Drag-selecting Multiple Objects<label id="mulobjsel">
<p>
You can select multiple objects using the <tt/&lt;Control&gt;/+Click method
described in section <ref id="oneobjsel" name="Selecting Individual Objects">.
An additional method for selecting multiple objects is to drag a rectangle
around those objects. However only objects that belong to the current level
can be picked within a drag-selection. If you want to select multiple objects
that belong to another level you must change the current level by either
selecting it in the tree/listbox or by picking one object from that level
on a view.
<p>
The procedure for drag-selecting multiple objects also uses a standard method:

<enum>
<item>Imagine a rectangle that encloses only the objects you want to select.

<item>Click at one corner of the rectangle and, while continuing to press the
mouse button, drag until you have enclosed all the objects.

<item>Release the mouse button. All the valid objects inside or crossing the
rectangle are selected and any objects previously selected are unselected
automatically.
</enum>

<p>
Note that if you press <tt/&lt;Control&gt;/ during the drag-selection, objects
that are enclosed by the rectangle will be added to the current selection
instead of replacing it.

<sect2>Ambiguous Picking<label id="ambobjsel">
<p>
In some cases Ayam is unable to differentiate between the objects you have
selected and other nearby or related objects. This ambiguity can arise as
follows:

<itemize>
<item>Imagine a small square surrounding the cursor. When you click an object,
any other valid objects that fall inside this square are also considered to
be possible selections. For example, if you select an item that is positioned
very close to another one, Ayam may consider both items to be possible
selections.

<item>If your model is three-dimensional (which is likely to happen),
imagine a line that is perpendicular to the screen and that passes through
the cursor and into the model. When you pick an object, any objects that
intersect this line are considered to be possible candidates for selection.
</itemize>

<p>
<figure loc="ht">
<eps file="pics/ampick.ps" height="3cm">
<img src="pics/ampick.gif">
<caption>List of Ambiguous Candidates</caption>
</figure>
<p>
If the selection is ambiguous Ayam displays a window that contains a list of
the possible candidates for selection. When you click a name in the list,
the corresponding object is highlighted. Click <tt/"Ok"/ when you have
determined which object to select or <tt/"Cancel"/ to close the list and keep
the previous selection unchanged.<newline>
It is also possible to use a double click in the list of selection
candidates to select an object and immediately close the dialog.
<footnote>Since 1.11.</footnote>
<p>
Notes:
<itemize>
<item>While the list of ambiguous candidates is opened you can not pick other
objects within the views.

<item>It is possible to use the <tt/"Zoom to Object"/ action (shortcut
<tt/&lt;O&gt;/) while the ambiguous select listbox is open to get
a better view of the temporarily selected object.

<item>The tolerance used to determine whether an object should be picked
or not can be adjusted (see <tt/"PickTolerance"/ in
<ref id="hidprefs" name="Hidden Preference Settings">).
</itemize>

<sect1>The Toolbox Window<label id="toolb">
<p>
<figure loc="ht">
<eps file="pics/tools.ps" height="8cm">
<img src="pics/tools.gif">
<caption>The Toolbox</caption>
</figure>
<p>
The toolbox window displays some buttons that start interactive
modelling actions, modelling tools, or create objects.
You can open and close it using the main menu entry
<tt>"Special/Toggle Toolbox"</tt>.
<p>
Note that in contrast to the keyboard shortcuts of the
view windows, the buttons in the toolbox may switch to the modelling
actions for all open views. This is the case if Ayam is in single window
GUI mode <em>and</em> AutoFocus is enabled or if Ayam is in multi window
GUI mode. For more information about
the actions see section <ref id="iac" name="Modelling Actions">.
<p>
When creating objects, holding down
the <tt>&lt;Ctrl&gt;</tt> key while pressing the corresponding toolbox
button will keep the objects selected.
This is especially useful for objects that would move the currently
selected objects to themselves as children (Level, Revolve, Skin etc.).
<p>
Several other tool buttons also change their behaviour with modifier
keys, check the tooltips.
<p>
The toolbox window may be configured by the user using the
hidden preference setting <tt/"toolBoxList"/ in the ayamrc file.
Using this setting you may select from certain groups of buttons
and change the order in which they appear in the toolbox window.
See section <ref id="hidprefs" name="Hidden Preference Settings"> for
more information.
<p>
The toolbox is also open for extension by scripts, see section
<ref id="scextoolbox" name="Script Examples (Toolbox Buttons)"> for
examples.
<p>
You may also resize the window to change from the vertical standard
layout to a horizontal one, optimizing the use of precious screen
space. After resizing, the toolbox will re-layout the buttons,
warning you if the space is too small for all buttons to display.
If the window is too big for the desired layout and the hidden
preference setting <tt>"ToolBoxShrink"</tt> is switched on, the
toolbox will shrink wrap the window to match the space occupied by
the buttons.
Furthermore, using the hidden preference setting <tt>"ToolBoxTrans"</tt>
the toolbox window can be made transient.
It will then (depending on the window manager or its configuration)
get a different or no decoration, no icon, and will always be iconified
when the main window gets iconified.

<sect1>Preferences<label id="prefs">
<p>
<figure loc="ht">
<eps file="pics/prefs.ps" height="8cm">
<img src="pics/prefs.gif">
<caption>Preferences Dialog</caption>
</figure>
<p>
The preferences dialog may be opened using the main menu entry
<tt>"Edit/Preferences"</tt> or the shortcut <tt/&lt;Ctrl+p&gt;/.
<p>
Use
<itemize>
<item><tt/"Ok"/ to close the preference editor and
apply all changes,

<item><tt/"Apply"/ to apply the changes, but leave the editor open,

<item><tt/"Revert"/ to reset to the settings that have been loaded on
program startup (these are not the factory defaults, to get back to
the factory defaults, restart Ayam with the command line option
<tt/"-failsafe"/ or use the main menu entry
<tt>"Special/Reset Preferences"</tt>),

<item><tt/"Cancel"/ to close the dialog without applying any changes.
All changes done after the last press of <tt/"Apply"/ will be lost.
</itemize>

Note that while the preference editor is open, AutoFocus is temporarily
turned off and changes to the <tt/"AutoFocus"/ preference setting will
only be realized after the editor is closed.
<p>
The preferences are divided into five sections as follows.

<sect2>Main Preferences<label id="prefmain">
<p>
The <tt/"Main"/ section contains the most important application setup
related preference settings.
<p>
Note that unused settings will not be shown, e.g.~on the
Win32 platform, the <tt/"TwmCompat"/ setting will be hidden.
<footnote>Since 1.14.</footnote>
<itemize>
<item><tt/"Shaders"/ contains a number of paths (separated by a colon
<tt/":"/ on Unix and by a semicolon <tt/";"/ on Win32) where Ayam looks
for compiled shaders (e.g.~files with the extension <tt/".slc"/ that
have been compiled with slc from BMRT). Using the <tt/"Add"/ button,
you may easily add another path, simply press the button and select a
file from the directory you want to add. Note that currently the
filename of a compiled shader may contain just two <tt/"."/ at maximum.
The environment variable SHADERS will be adapted to match the contents
of this preference setting, so that renderers started by Ayam see
exactly the same shaders as Ayam through the <tt/"Shaders"/ preference
setting.

<p>
Note that this option does of course not affect any renderers that are
started outside the Ayam context.

<item><tt/"Scan for Shaders!"/ initiates a rebuild of the internal
shader database. All shaders in the directories specified by
the <tt/"Shaders"/ preference setting will be scanned and entered in
that database.
Watch the console for error messages that may appear while scanning.
See also section <ref id="parseshd" name="Shader Parsing"> for more
information on scanning shaders.
</itemize>

The next sub-section contains GUI (user interface) related
settings.<label id="prefgui">
<itemize>
<item><tt/"Locale"/, sets a language for the balloon help texts,
the default value menu shows all currently available locales.

<p>
The value will have no effect until Ayam is restarted!

<item><tt/"SingleWindow"/ toggles, whether Ayam should create just
one main window with internal views and toolbox or use the old
floating windows style GUI. The new single window GUI mode is enabled
by default.

<item><tt/"AutoResize"/ toggles, whether the main window
should be resized horizontally according to the property GUI whenever
a new GUI is displayed.

<p>
This option is not available in the single window GUI mode.

<item><tt/"AutoFocus"/ controls whether Ayam should automatically
move the focus to a view or the main window, when the mouse pointer
enters it. However, depending on your operating system, window manager,
or their settings, this may only work correctly, when a window
of Ayam already has the focus. On some operating systems or window
managers AutoFocus might not work at all. Furthermore, note that moving
the focus to a window might also raise it.

<p>
In single window GUI mode, AutoFocus additionally manages the input
focus of the internal views, tree view, property GUI, and console.

<p>
While the preference editor is open, AutoFocus is temporarily
turned off and changes to the <tt/"AutoFocus"/ preference setting will
only be realized after the preferences editor is closed.

<item><tt/"TwmCompat"/ changes, how Ayam tells the window manager
new geometries of windows. This option has to be toggled if Ayam
fails to correctly remember the geometry of the main window between
two invocations or if the main window jumps downward when properties
are selected.

<p>
This option is not available on the Win32 platform and on MacOSX Aqua.

<item><tt/"AutoSavePrefs"/, if this is switched on, Ayam will write
the preferences settings to the ayamrc file when the program quits.

<item><tt/"BakOnReplace"/, if this is switched on, Ayam will make
a backup copy of each scene file it loads via the main menu entry
<tt>"File/Open"</tt> or via the most recently used list.
The backup file will be placed right next to the loaded file
and get an additional file name extension according to the hidden
preference setting <tt/"BackupExt"/.

<item><tt/"AddExtensions"/, this option may be used to let Ayam
automatically add file name extensions to saved files (if they
do not have already a proper extension).

<item><tt/"EnvFile"/; This file typically contains some view
objects to create a standard 2-, 3-, or 4-view working environment
and is automatically loaded upon startup of Ayam (if the hidden
preference option <tt/"LoadEnv"/ is switched on) and upon clearing
the scene using <tt>"File/New"</tt> (if the hidden preference option
<tt/"NewLoadsEnv"/ is switched on).
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"Scripts"/ is a list of Tcl script files that will
be executed on startup. The scripts do <em>not</em>
have to be specified with full path and filename.
<footnote>Since 1.16.</footnote>
Furthermore, the scripts and plugins directories (as specified using the
<tt/"Plugins"/ option below) are automatically searched, and the tcl
file name extension is automatically added, so that a setting
of <tt/"colfocus;loadayslx"/
would load the colfocus script from the scripts directory and the
ayslx shader parsing plugin from the plugins directory.
If non absolute paths are used they are relative
to the current directory of Ayam on application startup (which is typically
the directory where the Ayam executable resides).
Multiple entries have to be separated by a colon (<tt/":"/) on Unix and by
a semicolon (<tt/";"/) on Win32.
If unsure about the correct syntax, just use the <tt/"Add"/ button.

<item><tt/"Plugins"/ is a list of directories that contain custom
objects or plugins. Those directories will e.g.~be searched for
custom objects when unknown object types are encountered while reading
Ayam scene files. If a matching custom object is found, it will be
automatically loaded into Ayam, so that scene loading may proceed without
an error. If non absolute paths are used they are relative
to the directory where the Ayam executable resides.
Thus, the default value "plugins" leads to Ayam searching for plugins
in the directory "plugins" located in the directory, where the Ayam
executable resides:
<tscreen><verb>
.../ayam/bin/Ayam.exe
.../ayam/bin/plugins/
.../ayam/bin/plugins/ayslx.dll
</verb></tscreen>
Multiple entries have to be separated by a colon (<tt/":"/) on Unix and
by a semicolon (<tt/";"/) on Win32.
If unsure about the correct syntax, just use the <tt/"Add"/ button.

<item><tt/"Docs"/ is an URL that points to the documentation in
HTML format.

<item><tt/"TmpDir"/ is the directory, where temporary RIB files are
created, e.g.~when rendering directly from view windows.
</itemize>

The preference settings <tt/"ListTypes"/, <tt/"MarkHidden"/,
<tt/"LoadEnv"/, and <tt/"NewLoadsEnv"/ are hidden preference
settings since Ayam 1.14, see section
<ref id="hidprefs" name="Hidden Preference Settings">.


<sect2>Modelling Preferences<label id="prefmodel"><label id="prefmodeling">
<p>
The next section of the preferences, <tt/"Modelling"/,
contains modelling related settings:
<itemize>
<item><tt/"PickEpsilon"/ is used by the single point editing actions
(see section <ref id="editac" name="Editing Points">)
to determine which point of an object has been selected.
A smaller <tt/"PickEpsilon"/ means more exact picking.
The value of <tt/"PickEpsilon"/ should be positive and is expressed
in terms of object coordinates, however, also the view zoom factor modifies
the effective <tt/"PickEpsilon"/ value in a way that for zoomed-in views
a smaller value will be used (and vice versa).

<p>
In older versions of Ayam (prior to 1.8), a value of 0.0 was
allowed and default. This is no longer the case, the new default
value is 0.05.

<item><tt/"LazyNotify"/ determines whether notification shall
occur on all mouse movements or just on release of the mouse button,
for the interactive modelling actions.
This option may also be toggled easily using the keyboard shortcut
<tt>&lt;F6&gt;</tt>.

<p>
Notification is the mechanism used to inform objects that rely
on certain child objects (e.g.~the Revolve tool object) about
changes of their child objects, so that the parent can adapt
to the child objects automagically
(see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).

<item><tt/"CompleteNotify"/ determines when notification of all objects
depending on references of changed objects takes place:
<itemize>
<item><tt/"Never"/, for manual control of complete notification
(manual complete notification can be carried out using the main
menu entry <tt>"Tools/Force Notification"</tt>) or using the
keyboard shortcut <tt>&lt;F5&gt;</tt>;
<item><tt/"Always"/, a complete notification is done whenever the
normal notification is carried out;
<item><tt/"Lazy"/, the complete notification runs
only after a modelling action finished (when the mouse button is
released).
</itemize>
Note that complete notify also updates objects that implicitly depend on
updated objects via instances.

<item><tt/"EditSnaps"/ determines, whether points
should be snapped to the grid when a grid is defined and
in use for the single point modelling actions.

<item><tt/"Snap3D"/ controls whether points that are snapped to
grid coordinates (in single point editing actions and when grids are active)
should be influenced in all three dimensions, or just the two dimensions
determined by the type of the view.

<item><tt/"FlashPoints"/ controls flashing of editable points in
the single point modelling actions when they would be modified by
a click and drag action.
Note that a change of this preference option only takes effect for
the next invocation of the single point editing modelling action.

<item><tt/"GlobalMark"/ toggles whether each view should manage its
own mark (off, default), or whether there should be just one global
mark (on). Note that enabling this preference setting will not
immediately lead to a global mark set in all windows, one rather
needs to set a new mark that will then become global.

<item><tt/"DefaultAction"/ determines the modelling action
that will be active after a press of the <tt/&lt;Esc&gt;/ key
in a view window.

<item><tt/"UndoLevels"/ determines the number of modelling steps
that should be saved in the undo buffer. Useful values range
from 2 to 50 (depending on how much memory you like to spend).
If you set <tt/"UndoLevels"/ to -1, the undo system will be disabled
completely.
For more information, see also the section
<ref id="undos" name="The Undo System">.
</itemize>

<sect2>Drawing Preferences<label id="prefdraw"><label id="prefdrawing">
<p>
The preferences in the <tt/"Drawing"/ section let you specify
how objects are being drawn:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a NURBS curve
or NURBS patch using GLU.
Smaller tolerance settings lead to higher quality. Useful values
range from 1 to 100.
This setting has no effect for objects that override it
using a local tolerance setting different from 0.

<p>
Using the keyboard shortcuts <tt>&lt;F2&gt;</tt> and <tt>&lt;F3&gt;</tt>
the GLU tolerance may also be set easily.

<item><tt/"NPDisplayMode"/ sets the display mode for NURBS patches.
Either the control hull (or control polygon) is drawn (ControlHull), or
just the outlines of the polygons created by the tesselation
(OutlinePoly), or just the outlines of the patch (OutlinePatch).

<p>
Note that this setting does not affect shaded patches.

<p>
Note also, that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<p>
Toggling between drawing of hulls and outlines may also be
done easily using the keyboard shortcut <tt>&lt;F4&gt;</tt>.

<item><tt/"NCDisplayMode"/ sets the display mode for NURBS curves,
The control hull (control polygon) or the curve or a
combination of both may be displayed.

<p>
Note that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<p>
Toggling between drawing of hulls and curves may also be
done easily using the keyboard shortcut <tt>&lt;F4&gt;</tt>.


<item><tt/"UseMatColor"/ determines, whether the shaded representation
uses the color defined by the material of an object for
rendering.

<item><tt/"Background"/, <tt/"Object"/, <tt/"Selection"/, <tt/"Grid"/,
<tt/"Tag"/, <tt/"Shade"/, and <tt/"Light"/ let you set colors that
will be used when drawing or shading.
</itemize>

<sect2>RIB-Export Preferences<label id="prefrib"><label id="prefrib-export">
<p>
The <tt/"RIB-Export"/ section of the preferences contains settings that
affect how RIBs are created.
<itemize>
<item><tt/"RIBFile"/ allows to set the file Ayam is exporting
RenderMan Interface Bytestreams (RIBs) to. Note that some
filenames have special meaning:
<p>
If you set <tt/"RIBFile"/ to <tt/"Scene"/ (this is the default)
the RIB file name will be derived from the name of
the currently loaded scene with the last extension replaced by
<tt/".rib"/. If you set <tt/"RIBFile"/ to <tt/"Scenefile"/, the leading
path will be stripped from the scene name additionally.
Use <tt/"Scenefile"/, if you render with shadow maps.
This way the scene will use relative paths to
load the shadow maps and you may move
the RIBs around more easily.
<p>
<tt/"Ask"/ is another special setting, that allows
to select a different filename each time you export a RIB file.
A file selection dialog will pop up, after the selection of the
view to export.
The same effect may be achieved by leaving <tt/"RIBFile"/ totally
empty.
<p>
If you set <tt/"RIBFile"/ to <tt/"rendrib"/,
libribout.a does not create a RIB file at all, but immediately pipes the
resulting byte stream into rendrib (the BMRT renderer) for rendering.
The same goes for <tt/"rgl"/.
Moreover, filenames that start with a pipe symbol <tt/"|"/ will
cause the program after the pipe symbol to be started by libribout
and the written RIB to be piped into. This works e.g.~with
Photorealistic RenderMan, try it out with <tt/"|render"/.
In the latter cases of direct rendering, you will probably want to set
up the RIB to render to the display (read leave the <tt/"Image"/
preference setting empty.
However, when you use these options of direct rendering, be warned, that
for the time of the rendering Ayam will be frozen (it will neither
respond to mouseclicks nor will it update any windows), until the
rendering is finished and the display window of the renderer is closed.

<item><tt/"Image"/ specifies the image file that will be created,
when you render the exported RIB file.
You may set it to <tt/"RIB"/, this will create image
files that are named as the exported RIB file (with the last
file extension replaced by <tt/".tif"/). Again, setting
it to <tt/"Ask"/ will cause a dialog box to appear,
each time you export to a RIB file.
<p>
Note that in contrast to the <tt/"RIBFile"/ option leaving the field
totally empty is not equal to entering <tt/"Ask"/ but generates
RIB files that will be set up to render to the display.

<item><tt/"ResInstances"/, if this is enabled all instance
objects are resolved (temporarily) before being written to the RIB file.

<item><tt/"CheckLights"/, if this is enabled Ayam will
check the current scene for lights before RIB export. If no lights or
no lights that are actually switched on are to be found in
the scene, a distant headlight will be added to the scene
automatically for RIB export.

<item><tt/"DefaultMat"/ determines a default material setting
that should be written in the top level of the RIB, so that it
is in effect for all objects, that are not connected to a material
object. Many RenderMan compliant renderers will not render the
objects at all, if no material is defined.
The default <tt/"matte"/, writes just a simple
<tt>RiSurface "matte"</tt> (without parameters) to the RIB.
The setting <tt/"default"/ looks for a material object named
<tt/"default"/ and writes it's complete shaders and attributes,
if it does not find such a material it falls back to <tt/"matte"/.
The setting <tt/"none"/ does not write any default material setting.

<item><tt/"RIStandard"/ determines whether Ayam
should omit all non standard RenderMan interface options and
attributes on RIB export.

<item><tt/"WriteIdent"/ determines, whether Ayam should
write special RiAttributes
(<tt>RiAttribute "identifier" &lsqb;"name"&rsqb;</tt>)
with the names of the objects to the RIB to aid in RIB file debugging.

<item><tt/"ShadowMaps"/ determines, whether shadow maps should
be used, when writing light sources. It is not sufficient
to switch this on to render using shadow maps, light sources
that shall use shadow maps have to be parameterised
as well, see section <ref id="shadowmaps" name="Using ShadowMaps">.
If <tt/"ShadowMaps"/ is set to <tt/"Automatic"/, the
exported RIBs will automatically render and use all shadow maps;
if it is set to <tt/"Manual"/, the shadow maps will be rendered on
user request only (e.g.~using the view menu entry:
<tt>"View/Create All ShadowMaps"</tt>). <tt/"Manual"/ should be used,
when rendering directly from view windows with shadow maps.

<item><tt/"ExcludeHidden"/ causes hidden objects not to be
exported to RIB files.

<item><tt/"RenderMode"/ allows to switch between two different methods
of forcing a renderer to render to the screen (via a RiDisplay statement
in the exported RIB, necessary for e.g.~PRMan and RDC;
or via a command line argument, e.g.~<tt>-d</tt> for rendrib from BMRT).

<item><tt/"QRender"/ determines the command that should be executed,
upon quick rendering a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"QRenderUI"/, enables the Rendering GUI for quick rendering,
see discussion of <tt/"RenderUI"/ below.

<item><tt/"QRenderPT"/, progress template for quick rendering,
see discussion of <tt/"RenderPT"/ below.

<item><tt/"Render"/ determines the command that should be executed,
upon normal rendering of a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"RenderUI"/ enables the renderer user interface (Rendering GUI),
which consists of a simple progress bar, a label that displays the
estimated or elapsed rendering time, a checkbutton to control
ringing the bell when the rendering is finished,
and a cancel button. This GUI is displayed
when a renderer is invoked directly from a view window
using the <tt/"Render"/ view menu entry (or the equivalent keyboard shortcut).
Proper work of this GUI depends on the existence of
two external programs: <tt/"cat"/ and <tt/"kill"/ (those programs
should be available on every Unix platform). If you do not have
those programs in your path, do not enable the RenderUI option.
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"RenderPT"/ is a string that contains a progress output
template used by Ayam to determine the current percentage of completion
of the rendering for display in the Rendering GUI. The special symbol <tt/"%d"/
denotes the position of the percentage number in the output of the renderer.
For rendrib from BMRT2.6 this should be set to <tt/"R90000 %d"/ and
the special command line option <tt/"-Progress"/ should be used.
For rendrib from BMRT2.5 it should be set to <tt/"Done computing %d"/
and no special option has to be given to the renderer.
If the output of the renderer contains variable strings before
the progress number, a second variant of parsing the output using
regular expressions is available since Ayam 1.6. In this case, the
progress template should be a complete regexp command for Tcl
that parses the string contained in the variable named <tt/"string"/
and puts the parsed progress number into a variable named <tt/"progress"/.
Here is an example that works with Pixie-1.2.1, which outputs
strings like <tt/"fish.rib (222):  - 10.00 percent"/:
<tscreen><verb>
regexp -- {^.* - (\[0-9\]+)} string dummy percent
</verb></tscreen>

<item><tt/"SMRender"/, renderer to use for the rendering of shadow maps
(e.g.~view menu entry <tt>"View/Create All ShadowMaps"</tt>),
see also section <ref id="shadowmaps" name="Using ShadowMaps">.
<tt>%s</tt> denotes the name of the RIB file.

<item><tt/"SMRenderUI"/, enables the Rendering GUI for the rendering
of shadow maps, see discussion of <tt/"RenderUI"/ above.

<item><tt/"SMRenderPT"/, progress template for the rendering
of shadow maps, see discussion of <tt/"RenderPT"/ above.

<item><tt/"SMFileFormat"/, designates the file format of the shadow maps,
use <tt/"zfile"/ for RenderMan and <tt/"shadow"/ for Gelato.

<item><tt/"SMFileType"/, type of shadow maps to be created, currently
available types are <tt/"z"/ &ndash; normal shadow maps (for RenderMan
renderers and Gelato), <tt/"avgz"/ &ndash; Woo shadow maps (for Gelato only!),
and <tt/"volz"/ &ndash; volume shadow maps (for Gelato only!).

<item><tt/"SMChangeShaders"/, toggles, whether Ayam should automatically
prepend a "shader" to light shader names for lights that use shadow maps
upon RIB export. Not changing the shader names is necessary for Gelato.

<item><tt/"PPRender"/ is the name of the renderer to use for the
permanent preview feature (see also section <ref id="vm" name="View Menu">).
This setting is just available, if the compile
time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
</itemize>

Note that you can set many renderer related preferences at once using the
select renderer tool via the main menu <tt>"Special/Select Renderer"</tt>
(see also section <ref id="mmspecial" name="Special Menu">). In fact,
using <tt>"Special/Select Renderer"</tt> first, then fine tuning your
renderer setup using the preferences editor is the suggested way to
switch Ayam to a certain RenderMan renderer.

<sect2>Miscellaneous Preferences<label id="prefmisc">
<p>
The (<tt/"Misc"/) section of the preferences contains the dreaded
miscellaneous settings.

The first sub-section deals with error message handling:
<itemize>
<item><tt/"RedirectTcl"/ controls whether error messages
stemming from Tcl/Tk should be redirected to the console,
rather than be handled by Tcls sometimes annoying error
handling dialog box. However, this dialog box with the built in
stack trace can also become very handy, while writing and debugging
Tcl scripts.

<item><tt/"Logging"/ determines, whether error messages should
be written to the file specified by <tt/"LogFile"/.
If this is enabled, you should clear the log manually from time
to time, as Ayam will always append to <tt/"LogFile"/.

<item><tt/"LogFile"/; see above.

<item><tt/"ErrorLevel"/, this option controls how many messages
should be written to the Ayam console. Available
values are: <tt/"Silence"/ no output,
<tt/"Errors"/ only error messages,
<tt/"Warnings"/, only error and warning messages,
and finally <tt/"All"/ (default), all messages, even informative,
should be written to the console.

</itemize>

The last sub-section contains miscellaneous user interface
related preferences:
<itemize>
<item><tt/"SaveAddsMRU"/; if this is switched on, saving to a file
will add that file to the most recently used files list in the
main menu for quick access.

<item><tt/"TclPrecision"/; this is the precision Tcl handles floating
point numbers with. You may want to decrease this number to about 5
if any numbers in the entry fields are represented in an exact, but also
too lengthy and hard to read fashion, like 0.4999999 instead of 0.5.
Note that you may lose model precision in doing so. The default value used
by Tcl is 12 and results in no loss of precision. The default value
used by Ayam is 6 and should result in a good balance between precision
and readability.

<item><tt/"SavePrefsGeom"/ controls when the geometry of the preferences
editor should be remembered by Ayam, <tt/"Never"/: the window is always
opened in standard size, centered on the screen; <tt/"WhileRunning"/:
the window width and position will be remembered as long as Ayam is
running; <tt/"Always"/: the window width and position will be remembered
in the saved preferences, thus, also surviving a restart of Ayam.
Note that the height of the preferences window will always be adapted
to the currently open preferences section, no matter how <tt/"SavePrefsGeom"/
is set.

<item><tt/"SMethod"/; is the sampling method used by the NURBS to PolyMesh
(tesselation) facility (based on GLU V1.3+). Five methods are available:
<enum>
<item><tt/"DomainDistance"/ (the default) simply tesselates the NURBS
into equally
sized pieces with regard to parametric space; <tt/"SParamU"/ and
<tt/"SParamV"/ control the number of sampling points in U and V direction
respectively per unit length.
This leads to different numbers of samples for knot vectors
of different length in parameter space.
<item>The tesselation method <tt/"PathLength"/ ensures that no edge of a
polygon generated by the tesselation is longer than the value specified
by <tt/"SParamU"/ and the tesselation method
<item><tt/"ParametricError"/
ensures that the distance between the tesselated surface and the original
surface is no point bigger than the value specified by <tt/"SParamU"/.
<item><tt/"NormalizedDomainDistance"/
ensures that the tesselation creates the same number of sample
points (as given via <tt/"SParamU"/ and <tt/"SParamV"/) for any
knot vector and
<item><tt/"AdaptiveDomainDistance"/ additionally adds
sample points dependend on the number of control points (width or
height of the patch) to provide a better adaptation to complex patches.
</enum>
The tesselation methods,<tt/"NormalizedDomainDistance"/
and <tt/"AdaptiveDomainDistance"/ are available since Ayam 1.9
to overcome the limitations of the <tt/"DomainDistance"/ method.

<p>
Note that <tt/"SParamU"/ is expressed in object space units for the
<tt/"PathLength"/ and <tt/"ParametricError"/ tesselation methods.

<item><tt/"SParamU"/; is a parameter for the sampling method above.
The default value for the sampling method <tt/"DomainDistance"/ is 10. Higher
values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"PathLength"/ is 30.
Smaller values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"ParametricError"/ is 0.5.
Smaller values lead to better quality and more tesselated polygons.

<item><tt/"SParamV"/; is just available for the tesselation modes
<tt/"DomainDistance"/, <tt/"NormalizedDomainDistance"/, and
<tt/"AdaptiveDomainDistance"/.
</itemize>

<sect>Modelling Actions<label id="iac">
<p>
Before invoking any modelling action you should select one or more
objects using the object hierarchy in the main window, the pick action,
or selection manipulating keyboard shortcuts.
<p>
Every action can be started with a key press (a shortcut) when
the keyboard focus is in a view window or by clicking on the associated
button in the toolbox window.
Using a keyboard shortcut starts that action in the current view only,
the other views are not affected. In multi window GUI mode, starting an
action from the toolbox window will cause the action to be started in all
view windows that are currently open simultaneously. In single window GUI
mode, the action will be started in the current internal view only
(unless <tt/"AutoFocus"/ is enabled).
<p>
It is perfectly ok to start and work with many different actions at
the same time in different views: you can have e.g.~a view, where you move
objects, a second where you rotate objects and a third, where you pick
objects. The layout, drawing style, and grids may also differ between
the different views. Together with the feature, that you may change
the selection while actions are active and even pan and zoom views
(using the rightmost and middle mouse buttons respectively) while
actions are active and without breaking them, this is the key to
unsurpassed flexibility in modelling using Ayam.
<p>
To break an action, the <tt/&lt;Esc&gt;/ key may be used.
<p>
The default action for all views, which is also in effect after
use of the <tt/&lt;Esc&gt;/ key, is <tt/"None"/ or <tt/"Pick"/
(depending on the preference setting <tt>"Modelling/DefaultAction"</tt>).
See section
<ref id="objsel" name="Selecting Objects within a View">
for more information about picking objects.
<p>
Note that the modelling actions are not available in perspective views.
<p>
If an action is in effect for a view, the views title will be changed
appropriately.
<p>
A modelling action is performed by clicking into the view with the
leftmost mouse button to mark a point in space or to pick a vertex
and then by dragging the mouse.
<p>
You may undo/redo the effects of a modelling action using <tt/&lt;Ctrl+z&gt;/
and <tt/&lt;Ctrl+y&gt;/ (see section
<ref id="undos" name="The Undo System"> for more information).
<p>
Grids are available to restrict the modelling actions to certain
points and help in exact modelling.
<p>
Also note that you may use the middle and rightmost mouse button
to zoom and move the view while modelling actions are active.
<p>
For actions that modify the camera of a view please see section
<ref id="vwsc" name="View Window Shortcuts and Actions">.

<#if out=latex><x/newpage/</#if>

<sect1>Modelling Actions Overview
<p>
This section gives an overview over the various modelling actions.
Note that a more complete collection of shortcuts is available as separate
reference card document in the Ayam distribution.
<p>
<table loc="ht">
<tabular ca="|c|c|c||c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/|<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
<em>Transform:</em>|||||@<hline>
Move|<tt/&lt;m&gt;/|
<#if out=latex><x>inlinegfx pics/moveac.png 0.7cm </x></#if>
<#if out=html><img src="pics/moveac.gif"></#if>|
Rotate|<tt/&lt;r&gt;/|
<#if out=latex><x>inlinegfx pics/rotateac.png 0.7cm </x></#if>
<#if out=html><img src="pics/rotateac.gif"></#if>
@<hline>
Move X|<tt/&lt;mx&gt;/|
<#if out=latex><x>inlinegfx pics/movexac.png 0.7cm </x></#if>
<#if out=html><img src="pics/movexac.gif"></#if>|
Rotate About|<tt/&lt;ra&gt;/|
<#if out=latex><x>inlinegfx pics/rotateaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/rotateaac.gif"></#if>
@<hline>
Move Y|<tt/&lt;my&gt;/|
<#if out=latex><x>inlinegfx pics/moveyac.png 0.7cm </x></#if>
<#if out=html><img src="pics/moveyac.gif"></#if>|
Set Mark|<tt/&lt;a&gt;/|
<#if out=latex><x>inlinegfx pics/markac.png 0.7cm </x></#if>
<#if out=html><img src="pics/markac.gif"></#if>
@<hline>
Move Z|<tt/&lt;mz&gt;/|
<#if out=latex><x>inlinegfx pics/movezac.png 0.7cm </x></#if>
<#if out=html><img src="pics/movezac.gif"></#if>
|||@<hline><hline>
Scale 3D|<tt/&lt;S&gt;/|
<#if out=latex><x>inlinegfx pics/scale3dac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale3dac.gif"></#if>|
Scale 3D About|<tt/&lt;Sa&gt;/|
<#if out=latex><x>inlinegfx pics/scale3daac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale3daac.gif"></#if>
@<hline>
Scale 2D|<tt/&lt;s&gt;/|
<#if out=latex><x>inlinegfx pics/scale2dac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale2dac.gif"></#if>|
Scale 2D About|<tt/&lt;sa&gt;/|
<#if out=latex><x>inlinegfx pics/scale2daac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale2daac.gif"></#if>
@<hline>
Scale 1D X|<tt/&lt;sx&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dxac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dxac.gif"></#if>|
Scale 1D X About|<tt/&lt;sxa&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dxaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dxaac.gif"></#if>
@<hline>
Scale 1D Y|<tt/&lt;sy&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dyac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dyac.gif"></#if>|
Scale 1D Y About|<tt/&lt;sya&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dyaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dyaac.gif"></#if>
@<hline>
Scale 1D Z|<tt/&lt;sz&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dzac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dzac.gif"></#if>|
Scale 1D Z About|<tt/&lt;sza&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dzaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dzaac.gif"></#if>
@<hline>
Stretch 2D|<tt/&lt;T&gt;/|
<#if out=latex><x>inlinegfx pics/stretchac.png 0.7cm </x></#if>
<#if out=html><img src="pics/stretchac.gif"></#if>|
Stretch 2D About|<tt/&lt;Ta&gt;/|
<#if out=latex><x>inlinegfx pics/stretchaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/stretchaac.gif"></#if>
@<hline><hline>
<em>Edit:</em>|||||@<hline>
Edit|<tt/&lt;e&gt;/|
<#if out=latex><x>inlinegfx pics/editac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editac.gif"></#if>|
Tag Points|<tt/&lt;t&gt;/|
<#if out=latex><x>inlinegfx pics/tagac.png 0.7cm </x></#if>
<#if out=html><img src="pics/tagac.gif"></#if>
@<hline>
Edit Weights|<tt/&lt;w&gt;/|
<#if out=latex><x>inlinegfx pics/editwac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editwac.gif"></#if>|
Insert Points|<tt/&lt;i&gt;/|
<#if out=latex><x>inlinegfx pics/insertac.png 0.7cm </x></#if>
<#if out=html><img src="pics/insertac.gif"></#if>
@<hline>
Edit Numeric|<tt/&lt;E&gt;/|
<#if out=latex><x>inlinegfx pics/editdac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editdac.gif"></#if>|
Delete Points|<tt/&lt;d&gt;/|
<#if out=latex><x>inlinegfx pics/deleteac.png 0.7cm </x></#if>
<#if out=html><img src="pics/deleteac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Modelling Actions Overview</caption>
</table>

<#if out=latex><x/newpage/</#if>

<sect1>Transforming Objects or Selected Points
<p>
Many modelling actions either work on objects transformation attributes
or coordinates of selected points. Before Ayam 1.18 this was controlled
implicitly by the point selection: if points were selected, they would
be transformed instead of the object.
<p>
There are now two keyboard shortcuts (<tt/&lt;o&gt;/ and <tt/&lt;p&gt;/)
that let the user control this behaviour directly per view:
<footnote>Since 1.18.</footnote>
<tt/&lt;o&gt;/ switches to object transformations and <tt/&lt;p&gt;/ to
point transformations.
These shortcuts can be used anytime, even in the middle of any other
actions. If points are to be modified, a little red point will appear
in the modelling mode icon in the view menu as shown in the image
below:
<p>
<figure loc="ht">
<eps file="pics/trpnt.ps" height="4cm">
<img src="pics/trpnt.gif">
<caption>View Transforming Objects (left) and Points (right)</caption>
</figure>
<p>
See also the section
<ref id="apnttcl" name="Automatic Point Actions">
for a script, that, partially, brings back the old implicit behaviour.

<sect1>Moving Objects or Selected Points
<p>
Using the modelling action <tt/"Move"/ (shortcut: <tt/&lt;m&gt;/)
you may move selected objects or the selected (tagged) points
of the selected objects.
<p>
Note that the objects/points will be moved in the XY-plane for
Front-views, the ZY-plane for Side-views, and the XZ-plane
for Top-views only, no matter how the view is rotated.
<p>
The move action may be restricted to a certain
axis, by pressing <tt/&lt;x&gt;/, <tt/&lt;y&gt;/, or <tt/&lt;z&gt;/
right after the <tt/&lt;m&gt;/.
<footnote>Since 1.17.</footnote>
<p>
For an overview of the move actions see also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Move|<tt/&lt;m&gt;/|
<#if out=latex><x>inlinegfx pics/moveac.png 0.7cm </x></#if>
<#if out=html><img src="pics/moveac.gif"></#if>
@<hline>
Move X|<tt/&lt;mx&gt;/|
<#if out=latex><x>inlinegfx pics/movexac.png 0.7cm </x></#if>
<#if out=html><img src="pics/movexac.gif"></#if>
@<hline>
Move Y|<tt/&lt;my&gt;/|
<#if out=latex><x>inlinegfx pics/moveyac.png 0.7cm </x></#if>
<#if out=html><img src="pics/moveyac.gif"></#if>
@<hline>
Move Z|<tt/&lt;mz&gt;/|
<#if out=latex><x>inlinegfx pics/movezac.png 0.7cm </x></#if>
<#if out=html><img src="pics/movezac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Move Actions Overview</caption>
</table>

<sect1>Rotating Objects or Selected Points<label id="rotac">
<p>
Using the modelling action <tt/"Rotate"/ (shortcut: <tt/&lt;r&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects.
<p>
The axis of rotation is always parallel to the Z-axis in Front-views, the
Y-axis in Top-views, and the X-axis in Side-views of the local
object coordinate system. The orientation of the object coordinate system
may change in respect to the world coordinate system if a sequence of
rotate modelling actions is applied.
<p>
Note that if multiple objects are selected, each object is rotated
around the center of its own local coordinate system.
Only the Rotate_X, Rotate_Y, or Rotate_Z property of the selected
objects will be changed by this action.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Rotate|<tt/&lt;r&gt;/|
<#if out=latex><x>inlinegfx pics/rotateac.png 0.7cm </x></#if>
<#if out=html><img src="pics/rotateac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Rotate Action</caption>
</table>

<sect1>Rotating Objects or Selected Points About a Point<label id="rotaac">
<p>
Using the rotate about modelling action one may interactively rotate
objects or the selected (tagged) points of the selected objects about
a specific point in space.
<p>
To start the rotate about action, invoke the normal rotate action,
then press <tt/&lt;a&gt;/.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Rotate About|<tt/&lt;ra&gt;/|
<#if out=latex><x>inlinegfx pics/rotateaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/rotateaac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Rotate About Action</caption>
</table>
<p>
To rotate about a different point, one needs to restart the
intermediate set mark action (simply press <tt/&lt;a&gt;/ again).
<p>
After setting the mark, the action works the same way as
the Rotate action, except that it rotates the selected object(s)
or points about the mark.
This, consequently, also works with multiple selected objects.
Note that this action does not only change the Rotate_X,
Rotate_Y, or Rotate_Z
properties of the selected objects, but also the Translate_X,
Translate_Y, or Translate_Z properties.
<p>
To avoid degenerated coordinates due to roundoff errors
it is highly suggested to use grids with this action.
<p>
See also the section
<ref id="aactcl" name="Automatic About Center Actions">
for a script, that modifies the rotate action to rotate
about the current selections center automatically.

<sect1>Scaling Objects or Selected Points<label id="scalac">
<p>
There are several different actions available to interactively scale
objects or the selected (tagged) points of the selected objects:
<p>
The modelling action <tt/"Scale 3D"/ (shortcut: <tt/&lt;S&gt;/, note the
big S!) scales all three axes of the selected objects or
the selected (tagged) points of the selected objects
by the same factor.
<p>
The modelling action <tt/"Scale 2D"/ (shortcut: <tt/&lt;s&gt;/)
scales just two axes of the selected objects or
the selected (tagged) points of the selected objects. Those axes are
XY in a Front-view, ZY in a Side-view, and XZ in a Top-view.
<p>
It is also possible to restrict the scaling of objects or selected
points to just one axis.
For that one needs to press <tt/&lt;x&gt;/, <tt/&lt;y&gt;/, or
<tt/&lt;z&gt;/ right after <tt/&lt;s&gt;/ (e.g.~<tt/&lt;sx&gt;/ for
scale 1D about x).
<p>
Since Ayam 1.17, direct access to the 1D scale modelling actions
<tt/"Scale X"/ (old shortcut: <tt/&lt;x&gt;/),
<tt/"Scale Y"/ (old shortcut: <tt/&lt;y&gt;/), and
<tt/"Scale Z"/ (old shortcut: <tt/&lt;z&gt;/) is no longer available.
<p>
The modelling action <tt/"Stretch 2D"/ (shortcut: <tt/&lt;T&gt;/)
works much like <tt/"Scale 2D"/ but the scale factor for each
axis may be different. Never start this action by a click
near one of the axes to be changed, as this will cause
very big scale factors for the other axis. Try it first with
a centered box by starting from one of the box corners,
then try it once starting on the X-axis.
<p>
For an overview of the scale actions see also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Scale 3D|<tt/&lt;S&gt;/|
<#if out=latex><x>inlinegfx pics/scale3dac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale3dac.gif"></#if>
@<hline>
Scale 2D|<tt/&lt;s&gt;/|
<#if out=latex><x>inlinegfx pics/scale2dac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale2dac.gif"></#if>
@<hline>
Scale 1D X|<tt/&lt;sx&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dxac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dxac.gif"></#if>
@<hline>
Scale 1D Y|<tt/&lt;sy&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dyac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dyac.gif"></#if>
@<hline>
Scale 1D Z|<tt/&lt;sz&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dzac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dzac.gif"></#if>
@<hline>
Stretch 2D|<tt/&lt;T&gt;/|
<#if out=latex><x>inlinegfx pics/stretchac.png 0.7cm </x></#if>
<#if out=html><img src="pics/stretchac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Scaling Actions Overview</caption>
</table>

<sect1>Scaling Objects or Selected Points About a Point<label id="scalaac">
<p>
Using the scale about modelling actions one may interactively scale
objects or the selected (tagged) points
of the selected objects about a specific point in space.
<p>
To start a scale about action, invoke the normal scale action,
then press <tt/&lt;a&gt;/ (e.g.~<tt/&lt;sa&gt;/ for scale 2D about,
<tt/&lt;sya&gt;/ for scale 1D Y about).
For an overview of the scale about actions see also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Scale 3D About|<tt/&lt;Sa&gt;/|
<#if out=latex><x>inlinegfx pics/scale3daac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale3daac.gif"></#if>
@<hline>
Scale 2D About|<tt/&lt;sa&gt;/|
<#if out=latex><x>inlinegfx pics/scale2daac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale2daac.gif"></#if>
@<hline>
Scale 1D X About|<tt/&lt;sxa&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dxaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dxaac.gif"></#if>
@<hline>
Scale 1D Y About|<tt/&lt;sya&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dyaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dyaac.gif"></#if>
@<hline>
Scale 1D Z About|<tt/&lt;sza&gt;/|
<#if out=latex><x>inlinegfx pics/scale1dzaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/scale1dzaac.gif"></#if>
@<hline>
Stretch 2D About|<tt/&lt;Ta&gt;/|
<#if out=latex><x>inlinegfx pics/stretchaac.png 0.7cm </x></#if>
<#if out=html><img src="pics/stretchaac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Scaling About Actions Overview</caption>
</table>
<p>
To scale about a different point, one needs to restart the
intermediate set mark action (simply press <tt/&lt;a&gt;/ again).
<p>
After setting the mark, the action works the same way as
the scale action, except that it scales the selected object(s)
or points about the mark.
This, consequently, also works with multiple selected objects.
Note that this action does not only change the Scale_X, Scale_Y,
or Scale_Z
properties of the selected objects, but also the Translate_X,
Translate_Y, or Translate_Z
properties.
<p>
Also note, that the three dimensional scaling about the mark
occurs in all three dimensions, however, in the interactive
set mark action one is only able to specify two dimensional
coordinates using a mouse click (the third coordinate is always
set to zero). To specify a true three dimensional mark one
can use the corresponding view object attributes or select
a point and set the mark to it (shortcut <tt/&lt;C&gt;/).
<p>
To avoid degenerated coordinates due to roundoff errors
it is highly suggested to use grids with this action.
<p>
See also the section
<ref id="aactcl" name="Automatic About Center Actions">
for a script, that modifies the scale actions to scale
about the current selections center automatically.

<sect1>Setting the Mark<label id="markac">
<p>
<figure loc="ht">
<eps file="pics/mark.ps" height="6.5cm">
<img src="pics/mark.gif">
<caption>Front View With Mark Set At 1,-1,0</caption>
</figure>
<p>
This action may be invoked to mark a point in space for perusal
of other modelling actions that e.g.~rotate or scale about a point.
<p>
The keyboard shortcut to invoke the set mark action is <tt/&lt;a&gt;/.
This action is also active as intermediate action for e.g.~rotate
about, where the keyboard shortcuts <tt/&lt;r&gt;/
and then <tt/&lt;a&gt;/ would be used in a sequence and after
setting the mark, the rotate about action would take over.
<p>
See also the table below.
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Set Mark|<tt/&lt;a&gt;/|
<#if out=latex><x>inlinegfx pics/markac.png 0.7cm </x></#if>
<#if out=html><img src="pics/markac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Set Mark Action</caption>
</table>
<p>
A single click with the mouse sets the mark. If grids are active in
the view, the mark will be snapped to the nearest grid coordinates.
Additionally, when this action is active, the following keyboard
shortcuts are available:
<itemize>
<item><tt/&lt;Return&gt;/ accept the current mark (useful, if one
first rotates about a point then decides to also scale about
the same point: <tt/&lt;ra&gt;/, drag mouse, <tt/&lt;sa&gt;/,
<tt/&lt;Return&gt;/, drag mouse &hellip;),
<item><tt/&lt;c&gt;/ set the mark to the center of gravity of all
currently selected objects coordinate systems,
<item><tt/&lt;C&gt;/ set the mark to the center of gravity of all
currently selected points.
<item><tt/&lt;b&gt;/ set the mark to the center of the bounding
box of all currently selected points.
The image below demonstrates the difference between the
center of the bounding box and the center of gravity.
</itemize>
The marked point will be shown as a little red cross in the view window
(see also the image below).
<p>
<figure loc="ht">
<eps file="pics/bbxvscog.ps" height="4cm">
<img src="pics/bbxvscog.gif">
<caption>Bounding Box Center Mark (left) and Center of Gravity Mark (right)</caption>
</figure>
<p>
The mark may also directly be set using the corresponding view object
property (see also section <ref id="vat" name="ViewAttrib Property">).
<p>
Another way of setting the mark is via the <tt/"FindU"/ special action
for curves
(see also section <ref id="finduac" name="Finding Points on Curves">)
or the <tt/"FindUV"/ special action
for surfaces
(see also section <ref id="finduvac" name="Finding Points on Surfaces">)
.
<p>
Also note, that, using a mouse click, one is only able to specify two
dimensional mark coordinates (the third coordinate is always
set to zero).
<p>
The mark can also be used to remember an important point in space
and get back to it later using the pan to mark action
(keyboard shortcut <tt/&lt;.&gt;/).
<p>
Finally, remember that certain operations like e.g.~changing the view
type will clear the mark.


<sect1>Selecting/Tagging Points<label id="selac">
<p>
The modelling action <tt/"Select Points"/ (shortcut: <tt/&lt;t&gt;/;
for <bf>t</bf>&thinsp;ag points) may be applied to objects that support
single point editing or read only points.
<p>
To select or de-select a point it can directly be clicked upon
or a rectangular region can be dragged with the mouse around the
points in question.
<p>
Only points within a certain distance from the mouse pointer
click position will be considered picked (see preference option
<tt>"Modelling/PickEpsilon"</tt>).
Points that would be picked will flash in a different color when
the mouse pointer moves over them (this is also controlled by the
preference option <tt>"Modelling/FlashPoints"</tt>).
<p>
Selected points will be drawn in dark red when the select points
modelling action or a modelling action that would modify the selected
points is active (see the following image).
<p>
<figure loc="ht">
<eps file="pics/selpnts.ps" height="4cm">
<img src="pics/selpnts.gif">
<caption>Object With Selected Points (red)</caption>
</figure>
<p>
The selected editable points may be modified subsequently using the
modelling actions Move, Rotate, and Scale as discussed above when the
view is switched to point transformations using the shortcut <tt/&lt;p&gt;/.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Tag Points|<tt/&lt;t&gt;/|
<#if out=latex><x>inlinegfx pics/tagac.png 0.7cm </x></#if>
<#if out=html><img src="pics/tagac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Tag Action</caption>
</table>
<p>
After the pick (the selection of a point), the picked point
will be added to the list of selected points for the selected object.
If the selected point is already in that list it will be removed from
the list instead, the picked point will be deselected.
<p>
All points can be selected easily using the keyboard shortcut <tt/&lt;A&gt;/.
<p>
The list of selected points will not be deleted from the object until
an explicit deselection is performed using the keyboard shortcut
<tt/&lt;N&gt;/ or if certain modelling tools are used.
<p>
The point selection can also be inverted using the keyboard shortcut
<tt/&lt;I&gt;/.
<p>
All three shortcuts above can be used anytime without interfering
with any other active modelling actions.
<p>
Note that the list of selected points is not copied, if the object
is copied using the clipboard. The selection is also not saved to
Ayam scene files. But selected points survive undo/redo.
<footnote>Since 1.16.</footnote>
<p>
Furthermore, the selection action iself is not an operation
recorded in the undo buffer, thus cannot directly be undone.
<p>
The point selection also does not interfere with single point modelling
actions:
It is perfectly legal to select some points, move them using
the move action, then switch to single point editing, edit
some other or even one of the selected points, switch back
to the selection action, add other points to the selection or delete
some points from the selection, switch to rotate, rotate the selected
points and so on.
<p>
One may also add a bigger number of points to the selection using a
click and drag operation. All points that are inside the rectangular
region defined by the click and drag will be added to the selection.
In fact, this approach is the only way to safely add points to the
selection that occlude each other. Clicking always only adds/removes
single points.
<p>
Holding down the <tt/&lt;Ctrl&gt;/-key while
dragging the mouse removes all selected points within the rectangular
region defined by the drag from the selection.
<footnote>Since 1.16.1.</footnote>
<p>
The exact behaviour of picking multiple points of a NURBS curve or surface
depends on the attribute <tt/"CreateMP"/:<newline>
If <tt/"CreateMP"/ is enabled, picking a multiple point will always
select all points that make up the multiple point.<newline>
If <tt/"CreateMP"/ is disabled, picking a multiple point will only
select the first of the points that make up the multiple point
(but one can use drag select to select all points nevertheless).

<sect1>Editing Points<label id="editac">
<p>
To edit the points of an object three actions (<tt/"Edit"/,
<tt/"Edit Weights"/, and <tt/"Numeric Point Edit"/) are available.
All those actions may be applied to objects that support single point
editing only.
Such objects usually draw their selectable points using small white
rectangular handles when a modelling action is active (see also the
image below).
<p>
<figure loc="ht">
<eps file="pics/handles.ps" height="5cm">
<img src="pics/handles.gif">
<caption>Objects With Read Only (left) and With Editable Points (right)</caption>
</figure>
<p>
In contrast to e.g.~the move action, all point edit actions require the
handle of the point to be picked directly.
Only points within a certain distance from the mouse pointer click
position will be considered picked (see preference option
<tt>"Modelling/PickEpsilon"</tt>).
Points that would be picked will flash in a different color when
the mouse pointer moves over them (this is also controlled by the
preference option <tt>"Modelling/FlashPoints"</tt>).
<p>
For an overview of the point edit actions see also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Edit|<tt/&lt;e&gt;/|
<#if out=latex><x>inlinegfx pics/editac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editac.gif"></#if>
@<hline>
Edit Weights|<tt/&lt;w&gt;/|
<#if out=latex><x>inlinegfx pics/editwac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editwac.gif"></#if>
@<hline>
Numeric Edit|<tt/&lt;E&gt;/|
<#if out=latex><x>inlinegfx pics/editdac.png 0.7cm </x></#if>
<#if out=html><img src="pics/editdac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Edit Actions Overview</caption>
</table>

<itemize>
<item>The modelling action <tt/"Edit"/ (shortcut: <tt/&lt;e&gt;/)
works much like the move action, but it moves single points instead of
objects. Since Ayam 1.18 it is possible
to edit points of multiple selected objects (in former versions
only points from the first selected object were considered).
<p>
If a multiple point is edited, this action modifies all single
points that make up the multiple point, i.e.~you can not move
single points apart from a multiple point using the point
edit action. Temporarily disable the <tt/"CreateMP"/ property or
explode the multiple point to do that.
<p>
If the preference option <tt>"Modelling/EditSnaps"</tt> is enabled,
the picked point will be moved to the nearest grid coordinates first,
otherwise the grid just controls the displacement for the edit
action. The snapping can occur in 2D or 3D depending on the preference
option <tt>"Modelling/Snap3D"</tt>.
Moreover, while snapping a point, the mouse pointer will warp to
the new position of the point (so that the user does not lose
track of it). Warping the mouse pointer currently does not work on
MacOSX Aqua.

<item>The modelling action <tt/"Edit Weights"/ (shortcut: <tt/&lt;w&gt;/)
changes the w coordinate of a single point by dragging the mouse left
or right. The weights may be reset for all points
using the shortcut: <tt/&lt;W&gt;/. Furthermore, it is
not possible to edit the weights of multiple selected objects, only
the first selected object is considered.
<p>
If a NURBS curve has multiple points, this action modifies all
single points that make up the multiple point.

<item>The modelling action <tt/"Numeric Point Edit"/ (shortcut:
<tt/&lt;E&gt;/)
starts an intermediate point selection action and upon a click
with the mouse opens a small window where you may change the
coordinates of the selected editable point(s) by entering
new coordinate values on the keyboard (see image below).
<p>
<figure loc="ht">
<eps file="pics/numpnted.ps" height="4.5cm">
<img src="pics/numpnted.gif">
<caption>Numeric Point Edit Dialog</caption>
</figure>
<p>
Nothing will be changed unless the <tt/"Return"/ key is pressed
in a coordinate entry field or the <tt/"Apply"/ button is used.
In contrast to the normal point selection action, clicking on new
points, while the edit point dialog is open, deselects the old point(s),
selects the new point and loads its coordinate values into the
entry fields. In case of multiple selected objects, the deselection
is only performed on the object with a new selection.
<p>
Note that the w coordinate setting will be ignored for selected points
that do not have weight information (are not rational).
<p>
Using the small menu on top of the coordinate window one can
determine whether editing takes place in local/object space or
global/world space.
<p>
This modelling action may affect multiple points of multiple selected
objects.
<footnote>Since 1.18.</footnote>
<p>
Snapping points of different objects together is now possible too:
Just select two objects, start numeric point editing (press <tt/&lt;E&gt;/),
pick a point on the first object (where a point of the second object
should be snapped to), the point edit window opens, now drag select
the point of the second object (do <em/not/ use a single click for
selection as this would also load new coordinates) and press apply.
<p>
The numeric point editing action also supports read only
points, their coordinates may be retrieved, but applying any values
will have no effect.
<footnote>Since 1.18.</footnote>
<p>
Single coordinate entry fields may be empty to
prevent a change of the corresponding coordinate value.
<footnote>Since 1.20.</footnote>
<p>
If a multiple point is edited, this action modifies all single
points that make up the multiple point, i.e.~you can not move
single points apart from a multiple point using the numeric point
edit action. Temporarily disable the <tt/"CreateMP"/ property or
explode the multiple point to do that.
<p>
Notice that the numeric point editing dialog may stay
open all the time.
<footnote>Since 1.4.</footnote>
<p>
Furthermore, it is not necessary that the original
object stays selected while working with the numeric point edit dialog,
you may select other objects to e.g.~infer new point coordinates from
their properties and apply them to the original object.
Furthermore notice that the coordinate values displayed in the numeric
point editing window will not update when the point is modified by
another modelling action. Simply click on the point again in a view
where the numeric point editing action is active, to update the coordinate
values in the numeric point editing dialog.
<p>
Even though the dialog may display point coordinates in degraded
accuracy (due to floating point to string conversion)
the original point data is unchanged and its accuracy is not affected
as long as the new data is not applied.
See also the discussion of the <tt/"TclPrecision"/ preference option in
section <ref id="prefmisc" name="Miscellaneous Preferences">).
</itemize>

<sect1>Snapping Points to the Grid<label id="snapac">
<p>
<figure loc="ht">
<eps file="pics/snapgrpnt.ps" height="5cm">
<img src="pics/snapgrpnt.gif">
<caption>Snapping Points to the Grid</caption>
</figure>
<p>
There are two actions available for snapping points to the current
grid of a view.
<footnote>Since 1.11.</footnote>
<p>
The actions are initiated using the shortcuts <tt/&lt;g&gt;/
and <tt/&lt;G&gt;/. If an object has selected (tagged)
editable points, only those points will be snapped to the grid,
otherwise all editable points of the object will be snapped to the grid
(see also the image above).
If <tt/&lt;g&gt;/ is used, the snapping only occurs in
the modelling plane associated with the view (i.e.~in 2D).
To snap all three coordinate values to the grid use <tt/&lt;G&gt;/.
Note that the snapping also occurs, if the view has the preference
option <tt/"Use Grid"/ turned off.
This action can be used without affecting other active actions.

<sect1>Snapping Points to the Mark<label id="snapmac">
<p>
<figure loc="ht">
<eps file="pics/snapmrkpnt.ps" height="3cm">
<img src="pics/snapmrkpnt.gif">
<caption>Snapping Points to the Mark</caption>
</figure>
<p>
The snap points to mark action moves all selected points to
the current mark.
<footnote>Since 1.18.</footnote>
<p>
This action is initiated using the shortcut <tt/&lt;M&gt;/.
All selected editable points of the selected objects are snapped to
the current mark coordinates (see section
<ref id="markac" name="Setting the Mark">
for more information about the mark) immediately.
This action can be used without affecting other active actions.
See also the image above.

<sect1>Snapping Objects to the Mark<label id="snapomac">
<p>
The snap objects to mark action moves all selected objects to
the current mark.
<footnote>Since 1.18.</footnote>
<p>
This action is initiated using the shortcut <tt/&lt;K&gt;/.
All selected objects are snapped to the current
mark coordinates (see section
<ref id="markac" name="Setting the Mark">
for more information about the mark) immediately, providing
an easy way to move objects over long distances or to just put
an object "here".
This action can be used without affecting other active actions.

<sect1>Inserting or Deleting Points<label id="insdelac">
<p>
The modelling action <tt/"Insert Point"/ (shortcut: <tt/&lt;i&gt;/)
may be applied to NURBS, interpolating, and approximating curves
(objects of type NCurve, ICurve, and ACurve) only.
A new control point will be inserted in the curve right
after the picked point. The new point will be inserted in the
middle between the selected point and the next point, changing
the shape of the curve. It is also possible to insert control
points into certain types of NURBS curves without changing
their shape using knot insertion; see also the insert knot tool section
<ref id="insknt" name="Insert Knot Tool">.
<p>
The modelling action <tt/"Delete Point"/ (shortcut: <tt/&lt;d&gt;/)
may be applied to NURBS, interpolating, and approximating curves
(objects of type NCurve, ICurve, and ACurve) only.
The selected control point will be deleted from the curve.
Deleting points from a curve with knot type <tt/"Custom"/
may currently lead to an incorrect knot sequence, please
check and correct the new sequence manually.
See also the table below.
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Insert Points|<tt/&lt;i&gt;/|
<#if out=latex><x>inlinegfx pics/insertac.png 0.7cm </x></#if>
<#if out=html><img src="pics/insertac.gif"></#if>
@<hline>
Delete Points|<tt/&lt;d&gt;/|
<#if out=latex><x>inlinegfx pics/deleteac.png 0.7cm </x></#if>
<#if out=html><img src="pics/deleteac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Insert/Delete Points Actions</caption>
</table>

<sect1>Manipulating the Multiplicity of Points<label id="multac">
<p>
<figure loc="ht">
<eps file="pics/edmult.ps" height="7cm">
<img src="pics/edmult.gif">
<caption>Successively Increasing the Multiplicity of Selected Points</caption>
</figure>
<p>
To manipulate the multiplicity of selected NURBS curve control
points there are two modelling actions available.
<footnote>Since 1.20.</footnote>
<p>
The actions are initiated using the shortcuts <tt>&lt;*&gt;</tt>
(to increase the multiplicity) and <tt>&lt;/&gt;</tt>
(to decrease the multiplicity).

Increasing the multiplicity of a control point can be used to
easily construct sharp corners and linear curve segments
(see also the image above).

The multiplicity of the selected control points will only be
raised to the order of the curve and, conversely, never be
decreased below 1. Trying to increase/decrease beyond those
limits will not result in any error.

The selected points stay selected, so that the actions can be
applied multiple times.

Both actions can be invoked anytime without breaking other
actions.

<sect1>Finding Points on Curves<label id="finduac">
<p>
The modelling action <tt/"FindU"/ (shortcut: <tt/&lt;u&gt;/)
may be applied to NURBS curves (objects of type NCurve or
objects that provide NCurve objects) only.
This action may be used to get the corresponding parametric
value u from a point on a curve. For every picked point
the appropriate value for u is calculated, stored
in the global variable u, and additionally written to the console.
The mark is set to the position of the picked point (see section
<ref id="markac" name="Setting the Mark">
for more information about the mark).
Remember to exactly pick a point on the curve or nearby, otherwise
the calculation may fail.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Find U|<tt/&lt;u&gt;/|
<#if out=latex><x>inlinegfx pics/finduac.png 0.7cm </x></#if>
<#if out=html><img src="pics/finduac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Find Point on Curve Action</caption>
</table>

<sect1>Finding Points on Surfaces<label id="finduvac">
<p>
The modelling action <tt/"FindUV"/ (shortcut: <tt/&lt;U&gt;/)
may be applied to NURBS surfaces (objects of type NPatch or
objects that provide NPatch objects) only.
This action may be used to get the corresponding parametric
values u and v from a point on a surface. For every picked point
the appropriate values for u and v are calculated, stored
in the global variables u and v, and additionally written to the console.
The mark is set to the position of the picked point (see section
<ref id="markac" name="Setting the Mark">
for more information about the mark).
Remember to exactly pick a point on the surface or nearby, otherwise
the calculation may fail. As the icon suggests, this action works best
in the shaded drawing mode.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|c|"><hline>
<bf/Name/|<bf/Shortcut/|<bf/Icon/@<hline>
Find UV|<tt/&lt;U&gt;/|
<#if out=latex><x>inlinegfx pics/finduvac.png 0.7cm </x></#if>
<#if out=html><img src="pics/finduvac.gif"></#if>
<#if out=latex>@<hline></#if>
</tabular>
<caption>Find Point on Surface Action</caption>
</table>

<sect1>Interactively Splitting Curves<label id="splitncac">
<p>
The modelling action <tt/"Split Curve"/ (shortcut <tt/&lt;c&gt;/)
may be applied to NURBS curves (objects of type NCurve) only.
Using this action you may split a NURBS curve into two new curves
at a point on the curve that may be specified by picking a point
on the curve.
Remember to exactly pick a point on the curve or nearby otherwise
the calculation of the parametric value for the split will fail.
The selected curve will be changed by this action, and
a new curve will be created. It is currently not possible to undo
the changes of a split!

<#if out=latex><x/newpage/</#if>

<sect1>Editing in Local Spaces<label id="editlocal">
<p>
Normally, all editing takes place in world space and the input
plane of all modelling actions is constrained to the world
XY-, ZY-, or XZ-plane (depending on the type of view used).
<p>
However, if a view is <em>aligned</em> and switched to <em>local</em>,
one can also edit in local object space. This means one can e.g.~edit a
planar parameter curve of a skin object where both objects
(curve and skin) are rotated and scaled arbitrarily
and make sure that the parameter curve remains planar all the time.
<p>
In other words, this means that the input plane of an aligned local view
will match the XY-, ZY-, or XZ-plane of the local object space,
depending on the type of the view (<tt/"Front"/, <tt/"Side"/, or <tt/"Top"/).
Editing and other modelling actions take place in that plane.
<p>
Furthermore, grids will also act as if defined in local object space.
Note that in contrast to their normal behaviour, grids can also be scaled
differently in X-window and Y-window coordinates in aligned local views
(if the local object space is deformed this way).
<p>
How to make a view local and align it?
<p>
All you need to do is to first select an object and then press
<tt/&lt;l&gt;/ <em>twice</em> to make the view object-local (one can
also use <tt/&lt;Ctrl+l&gt;/ in external views).
In Ayam versions prior to 1.18 one also needed to manually align
the view using <tt/&lt;L&gt;/ (or <tt/&lt;Ctrl+a&gt;/ in external
views). Since Ayam 1.18, the view is automatically aligned to the
selected object or current level when cycling through the global/local
modes. Manually aligning a view may still be necessary, if the camera
of the view is e.g.~changed by a view action (however, realigning is also
always possible by cycling the modelling mode three times).
But let us get back to our local view.
<p>
To illustrate local views a little bit further, see the following example
images:
<p>
<figure loc="ht">
<eps file="pics/local-1.ps" height="5cm">
<img src="pics/local-1.gif">
<caption>Global Front View with Rotated Sweep</caption>
</figure>
<p>
A Sweep object with a circular B-Spline curve as cross section (rotated
about the y axis by 90 degrees) and a straight standard curve as trajectory.
The Sweep itself is rotated about the z axis by 30 degrees. The view is a
front view, the cross section and trajectory are both selected.
Note how inadequate the grid spacing would be to edit the trajectory curve
(it is e.g.~near impossible to edit the curve and keep
it straight). 
<p>
&raquo;&thinsp;Press <tt/&lt;l&gt;/.
<p>
<figure loc="ht">
<eps file="pics/local-2.ps" height="5cm">
<img src="pics/local-2.gif">
<caption>Local (Level) Aligned View</caption>
</figure>
<p>
The view has been switched to level-local using a single press of the
<tt/&lt;l&gt;/ key (see the modelling mode icon, it is displaying a
L in the lower right corner. The view is now aligned to the 30 degree
rotated space of the Sweep object (note the Root object coordinate
system, it is tilted). The grid is also rotated (with respect to the
root coordinate system) but now much more useful for editing the
trajectory, in fact it is perfectly aligned to the trajectory.
<p>
&raquo;&thinsp;Press <tt/&lt;l&gt;/ again.
<p>
<figure loc="ht">
<eps file="pics/local-3.ps" height="5cm">
<img src="pics/local-3.gif">
<caption>Local (Object) Aligned View</caption>
</figure>
<p>
Now the view is object-local and aligned to the first of the selected
objects (the cross section curve), note again the modelling mode icon,
it is now displaying a O in the lower right corner. As the selected
cross section curve was rotated by 90 degrees around the y axis, the
front view now again displays a circle. Note again the orientation
of the Root object coordinate system. One can safely edit the cross
section curve, it will stay planar.

Note, that object-local aligned views only align to the first of multiple
selected objects; if all selected objects have the same transformation
attributes, everything is fine, but if not, some objects will be misaligned.

Also remember: when a view is level-local, changing the current level
does not automatically realign the view. If the view is object-local,
changing the object selection will also possibly lead to a misaligned
view. To realign the view after changing the current level or object
selection simply press <tt/&lt;L&gt;/. Note that aligning the view changes
the aim point of the view camera to the origin of the respective local
coordinate system which might not be appropriate for modelling purposes;
so, after a selection change, one may want to also zoom the view to the
newly selected object: <tt/&lt;LO&gt;/.

<sect>Objects, Properties, and Tags<label id="obandprp">
<p>
This section informs you about the different object types of Ayam and
about the property GUIs that appear in the properties section of the
main window if a single object and a property have been selected.
<p>
Documentation on the standard properties (Transformations, Attributes,
Material, Shader, and Tags) can be found in
section <ref id="stdprop" name="Standard Properties">.
<p>
Furthermore, this section contains information about all tag types,
see section <ref id="tags" name="Tags">.
<p>
In the next sections general object capabilities will be briefly
documented in tables like this:
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Object Type|No/Object Type+/*|Yes/No|N/A&thinsp;/&thinsp;Children&thinsp;/&thinsp;Object Type+/*|Yes/No*
<#if out=latex>@<hline></#if>
</tabular>
<caption>Object Capabilities Template</caption>
</table>

The capabilities are:
<itemize>
<item><bf/Type/: the type name as displayed in the object tree view
and understood by the <tt/"crtOb"/ scripting interface command;
<item><bf/Parent of/: the object is a parent object (can have child
objects of the designated type),
+ &ndash; multiple child objects may be present (one or many),
* &ndash; multiple child objects must be present (many),
note that the type of the child object(s) does not need to match directly,
the child(s) must rather provide an object of the appropriate type
(see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">);
<item><bf/Material/: the object can be associated with a material;
<item><bf>Converts to/Provides</bf>: type of converted/provided objects
(Children means, the provided objects of the children are delivered upstream),
+ &ndash; multiple objects may be provided (one or many),
* &ndash; multiple objects will be provided (many);
<item><bf/Point Edit/: the object has editable points,
* &ndash; read only points are supported.
</itemize>

<#if out=latex><x/newpage/</#if>

Example:
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Revolve|NCurve|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Object Capabilities Example</caption>
</table>

Explanation:
<itemize>
<item><bf/Type/: the Revolve object has the type name <tt/"Revolve"/,
i.e.~it can be created from scripts using the command <tt/"crtOb Revolve"/;
<item><bf/Parent of/: the Revolve object has one NCurve (or NCurve providing
object) as child;
<item><bf/Material/: the Revolve object can be associated with a material;
<item><bf>Converts to/Provides</bf>: the Revolve object converts to (and
provides) one or multiple NPatch objects;
<item><bf/Point Edit/: the Revolve object has no editable points, it does
not support single point modelling actions; however, read only points are
supported (the control points of the underlying NPatch object can be read
and selected).
</itemize>

<#if out=latex><x/newpage/</#if>

<sect1>Object Types Overview
<p>
This section provides an overview on the object types available in
Ayam (since there are so many).
The object types are grouped by application in the following sections.

<sect2>Scene Organization
<p>
These objects help to organize the scene apart from
geometric objects:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Root|View+|No|N/A|No@<hline>
View|NPatch|No|N/A|Yes@<hline>
Camera|No|No|N/A|Yes@<hline>
Light|No|No|N/A|Yes@<hline>
Material|No|N/A|N/A|No@<hline>
Level|Any+|Yes|N/A&thinsp;/&thinsp;Children+|No@<hline>
Clone|Any+|No|Children+|No*@<hline>
Mirror|Any+|No|Children+|No*@<hline>
Instance|No|No|Master|No*@<hline>
Select|Any+|No|N/A&thinsp;/&thinsp;Children+|No@<hline>
RiInc|No|No|N/A|No@<hline>
RiProc|No|No|N/A|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Scene Organization</caption>
</table>

<sect2>CSG/Solid Primitives
<p>
These objects serve as geometric primitives in CSG hierarchies:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Box|No|Yes|NPatch*|No*@<hline>
Sphere|No|Yes|NPatch+|No*@<hline>
Disk|No|Yes|NPatch|No*@<hline>
Cone|No|Yes|NPatch+|No*@<hline>
Cylinder|No|Yes|NPatch+|No*@<hline>
Torus|No|Yes|NPatch+|No*@<hline>
Paraboloid|No|Yes|NPatch+|No*@<hline>
Hyperboloid|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>CSG/Solid Primitives</caption>
</table>

<sect2>Freeform Curves
<p>
These objects are mainly used as child objects for the surface
generating tool objects:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCurve|No|No|N/A|Yes@<hline>
ICurve|No|No|NCurve|Yes@<hline>
ACurve|No|No|NCurve|Yes@<hline>
NCircle|No|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Freeform Curves</caption>
</table>

<sect2>Freeform Surfaces
<p>
These objects enable direct manipulation of freeform surfaces:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NPatch|NCurve+/Level+|Yes|PolyMesh|Yes@<hline>
IPatch|No|Yes|NPatch|Yes@<hline>
BPatch|No|Yes|NPatch|Yes@<hline>
PatchMesh|No|Yes|NPatch|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Freeform Surfaces</caption>
</table>

<sect2>Curve Tool Objects
<p>
These objects modify existing curves or create new curves:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNC|NCurve+|No|NCurve|No*@<hline>
ExtrNC|NPatch|No|NCurve|No*@<hline>
OffsetNC|NCurve|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Curve Tool Objects</caption>
</table>

<#if out=latex><x/newpage/</#if>

<sect2>Surface Tool Objects
<p>
These objects create freeform surfaces from curves or other surfaces:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Revolve|NCurve|Yes|NPatch+|No*@<hline>
Extrude|NCurve+|Yes|NPatch+|No*@<hline>
Swing|NCurve*|Yes|NPatch+|No*@<hline>
Sweep|NCurve*|Yes|NPatch+|No*@<hline>
Birail1|NCurve*|Yes|NPatch+|No*@<hline>
Birail2|NCurve*|Yes|NPatch+|No*@<hline>
Skin|NCurve*|Yes|NPatch+|No*@<hline>
Gordon|NCurve*/Level|Yes|NPatch+|No*@<hline>
Bevel|NCurve+|Yes|NPatch|No*@<hline>
Cap|NCurve+|Yes|NPatch|No*@<hline>
Text|No|Yes|NPatch+|No*@<hline>
Trim|NPatch/NCurve+/Level+|Yes|NPatch|No*@<hline>
ConcatNP|NPatch*/NCurve*|Yes|NPatch|No*@<hline>
ExtrNP|NPatch|Yes|NPatch|No*@<hline>
OffsetNP|NPatch|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Surface Tool Objects</caption>
</table>

<sect2>Polygonal and Subdivision Objects
<p>
These objects complement the Ayam feature set and allow
objects modelled in the polygonal or subdivision modelling
paradigms to be included in Ayam scenes:
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PolyMesh|No|Yes|SDMesh|Yes@<hline>
SDMesh|No|Yes|PolyMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Polygonal and Subdivision Objects</caption>
</table>

<sect2>Scripts and Plugins
<p>
These objects create/modify arbitrary other objects from scripts
or define new object types via the custom object plugin mechanism.
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Script|Any+|No|Any|No*@<hline>
MetaObj|MetaComp+|Yes|PolyMesh|No@<hline>
MetaComp|No|No|N/A|No@<hline>
SDNPatch|No|Yes|PolyMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Scripts and Plugins</caption>
</table>

<#if out=latex><x/newpage/</#if>

<sect1>Root Object<label id="rootobj">
<p>
There is always exactly one Root object in the scene.
This object is something special in that it can not be deleted
or copied.
The Root object holds rendering options global to the scene like RiOptions,
atmosphere and imager shaders. Furthermore, all currently open
view windows are represented as child objects of the Root object.
<p>
If you hide the Root object, the little red/green/blue coordinate system
will not be drawn in any view.
<p>
The Root object also aids in per-scene window geometry management
using SaveMainGeom and SavePaneLayout tags (see also section
<ref id="tags" name="Tags">.
<p>
The global scene rendering options are documented in the following sections.

<sect2>RiOptions Property<label id="rio"><label id="rioptionsprop">
<p>
The RiOptions property carries RenderMan Interface options.
Both, standard and BMRT specific options may be set using this
property. For the sake of brevity only a short description of
the available options will be given here.
Please refer to the documentation of the RenderMan Interface
and the documentation of BMRT for more detailed information about the
options.
<p>
The RiOptions property consists of the following elements:
<itemize>
<item><tt/"Width"/, <tt/"Height"/, if greater than zero this value
will be used for the image size instead of the corresponding
dimension of the view window, but only for real RIB export operations,
not for the QuickRender and not for the Render actions in view windows.
QuickRender and Render actions will always use the dimensions of the
view window instead.

<item><tt/"StdDisplay"/, if this is enabled, a standard display
statement will be written to the RIB, which looks like this:

<tscreen><verb>Display "unnamed.tif" "file" "rgba"</verb></tscreen>

If you disable this option, be sure to add atleast one
RiDisplay tag to the root object (see also section
<ref id="ridtag" name="RiDisplay Tag">), otherwise your RIB will
not contain a RiDisplay statement. This option has no effect on
RIBs created by the QuickRender and Render actions in view windows.

<item><tt/"Variance"/, maximum allowed variance of two pixel values.
The default 0.0 causes no setting in the RIB. If the variance is > 0.0
no pixel samples setting will be written to the RIB. Various
sources discourage the use of variance based sampling, because
e.g.~the number of samples actually taken (and therefore the rendering
time) might not easily be predicted anymore.

<item><tt/"Samples_X"/, <tt/"Samples_Y"/ number of samples taken per
pixel.

<item><tt/"FilterFunc"/, function used to filter final pixel values.

<item><tt/"FilterWidth"/, <tt/"FilterHeight"/ size of the pixel filter.

<item><tt/"ExpGain"/, Exposure

<item><tt/"ExpGamma"/, Exposure Gamma

<item><tt/"RGBA_ONE"/, <tt/"RGBA_MIN"/, <tt/"RGBA_MAX"/,
<tt/"RGBA_Dither"/, specify quantisation and dithering

<item><tt/"MinSamples"/, <tt/"MaxSamples"/, minimum and maximum number
of samples per pixel (for variance based sampling).

<item><tt/"MaxRayLevel"/, maximum number of recursive rays.

<item><tt/"ShadowBias"/, minimum distance that one object has to
be in order to shadow another object.

<item><tt/"PRManSpec"/, toggles behaviour of BMRT's specular() function
between PRMan compatible (default) and RI standard compatible.

<item><tt/"RadSteps"/, number of radiosity steps, the default 0 leads
to no radiosity calculations to be performed.

<item><tt/"PatchSamples"/, minimum number of samples per patch to
calculate the radiosity form factors for this patch.

<item><tt/"Textures"/, <tt/"Shaders"/, <tt/"Archives"/ and <tt/"Procedurals"/
are search paths for the renderer.

<item><tt/"TextureMem"/ and <tt/"GeomMem"/ determine how much
memory rendrib (from BMRT) should use at maximum to cache textures and
tesselated geometry.
</itemize>

<sect2>Imager, Atmosphere Property<label id="imager">
<p>
The Imager and Atmosphere properties let you define shaders for the
Root object, please refer to section
<ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Imager shaders are executed once for every rendered pixel,
they may e.g.~be used to set a specific background color.
<p>
Atmosphere shaders are volume shaders that
may be used to implement global atmospheric
optical effects like fog.

<sect2>RIB Export
<p>
The Root object appears in RIB output in different places as collection
of RenderMan Interface options and imager as well as atmosphere shaders.
<p>
The exact RIB statements used depend on the configuration of the
object and the preference setting <tt>"RIB-Export/RIStandard"</tt>.
<p>
The Root object is the only object to support RiOptions, RiHider, and
RiDisplay tags (see also section
<ref id="tags" name="Tags">.

<#if out=latex><x/newpage/</#if>

<sect1>View Object<label id="viewobj">
<p>
Every view window (see also section
<ref id="viewwin" name="Anatomy of a View">)
has a corresponding view object as a child object of the root object.
You can change camera settings, the type of the view,
and other things related to the view using the properties of the view object.
Note that deleting the object that represents a view, will not
close the view window. You will just lose a way to configure it.
Please, do not mess with the objects in other ways (e.g.~copy them),
you are asking for trouble otherwise!
<p>
Each view is associated with a virtual camera.
The type of the view determines the Up-vector of that camera.
If the type is "Top" the Up-vector corresponds to the world
Z-axis, else the world Y-axis.
The type of the view, additionally, determines the so called input plane
of the view. Interactive modelling actions in a view are limited to that
input plane (unless the view is switched to local modelling;
see also section
<ref id="editlocal" name="Editing in Local Spaces">).
<footnote>Since 1.4.</footnote>
<p>
The standard input planes are as following: Front &ndash; XY-plane,
Side &ndash; ZY-plane, Top &ndash; XZ-plane, Trim &ndash; XY-plane.
<p>
In perspective views no interactive modelling actions are possible,
but you may position the camera, pick objects, and select points.
<p>
Views of type <tt/"Trim"/ are very special. They are used to edit
trim curves of NPatch objects only. They display <em>only</em>
those trim curves as normal NURBS curves when the current level is
inside a NPatch.
The extensions of the patch in parameter-space are drawn as a rectangle.
The trim curves should completely lie inside this rectangle.
Note that picking of objects currently does not work in views of type
<tt/"Trim"/.
<p>
View objects act in special ways, when certain objects are dropped
onto them in the tree view:
<p>
When a camera object is dropped onto a view object using drag and drop
in the tree view the camera settings of the camera object will be copied
to the views camera.
<p>
When a light object of type <tt/"Spot"/ is dropped onto a view object
using drag and drop in the tree view the views camera will be changed,
so that the user looks along the light to see what objects of the scene
are lit by the light object (this works best with perspective views
that have equal width and height).
<p>
It is also possible, to directly drag objects from the
tree view to a view window: for geometric objects, the view then
performs a zoom to object operation, for cameras and light sources
the views camera will be changed as if the object was dropped
onto a view object in the tree view (see the above description).
<footnote>Since 1.8.</footnote>
<p>
The following table briefly lists some capabilities of the View object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
View|NPatch|No|N/A|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>View Object Capabilities</caption>
</table>
<p>
The next sections detail the properties of the view object.

<sect2>Camera Property<label id="camp"><label id="cameraprop">
<p>
This section describes all elements of the <tt/"Camera"/ property:
<itemize>
<item><tt/"From"/ is the point where the camera (that is attached
to the view) is situated.
<item><tt/"To"/ is the point the camera is looking to.
<item><tt/"Up"/ is the up vector of the camera.
<item><tt/"Near"/ defines the near clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Near should always be positive for perspective views, and
smaller than far.
<item><tt/"Far"/ defines the far clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Far should always be bigger than near.
<item><tt/"Roll"/ defines an angle by which the camera is rotated
around the axis that is defined by the points from and to.
<item><tt/"Zoom"/ is a zoom factor.
</itemize>

Note that the up vector is not checked for erroneous values
(e.g.~pointing in the direction of from-to) when applying the changes
of the <tt/"Camera"/ property.

<sect2>ViewAttrib Property<label id="vat"><label id="viewattribprop">
<p>
This section describes the elements of the <tt/"ViewAttrib"/ property:
<itemize>
<item><tt/"Type"/ specifies the type of the view. Front, Side, Top (all
parallel), Perspective and Trim (again parallel) may be selected.
<item><tt/"Width"/ and <tt/"Height"/ control the size of the view
window. It is currently not possible to resize internal views
with these elements.
<item><tt/"Redraw"/ toggles automatic redrawing of the view.
If this is disabled, no drawing takes place in the view until an
explicit redraw is requested (using the view menu, or the shortcut
<tt>&lt;Ctrl+d&gt;</tt>).
<item><tt/"DrawingMode"/ allows to specify the drawing mode of
the view: <tt/"Draw"/ draws a wireframe, <tt/"Shade"/ draws lighted
surfaces. Note that the lighting is in no way an exact (or even similar)
representation of the light information as specified with Light objects
in the scene.
Instead, a single light source, located at the camera origin
(a headlight), will be used
<tt/"ShadeAndDraw"/ combines surfaces and wireframes.

<item><tt/"DrawSel"/ toggles drawing of selected objects. If this is
enabled, only the current selected objects will be drawn.
<item><tt/"DrawLevel"/ toggles drawing of the objects of the current
level only. If this is enabled, only the objects of the current
level will be drawn.
<item><tt/"Grid"/ is the grid size, 0.0 means no grid.
<item><tt/"DrawGrid"/ toggles drawing of the current grid.
<item><tt/"UseGrid"/ toggles, whether the current grid should be
used by the interactive modelling actions.
<item><tt/"ModellingMode"/ enables editing in local object spaces.
See also section <ref id="editlocal" name="Editing in Local Spaces">.

<item><tt/"DrawBG"/ controls whether the background image should
be drawn.
<item><tt/"BGImage"/ is the name of a TIFF file, that will
be used as texture for the background image. Ayam will read
this image once when you apply the changes to the
<tt/"ViewAttrib"/ property
but reread
the image file if the notification callback of the view object
is invoked (e.g.~using the main menu entry
<tt>"Tools/Force Notification"</tt>).

<item><tt/"Mark"/ is the marked point (in world coordinates) for
the rotate and scale about modelling actions.

<item><tt/"SetMark"/ controls whether the data from the <tt/"Mark"/
entries above should be used as new mark coordinates.

<item><tt/"EnableUndo"/ is switched on by default and allows to
disable undo for view actions, e.g.~panning or zooming a view,
these actions then also do not change the scene changed state.
</itemize>

<sect1>Camera Object<label id="cameraobj">
<p>
Camera objects are used to temporarily save camera settings
of views.
Therefore, they has just have two properties
explained above, see sections <ref id="camp" name="Camera"> and
<ref id="attrs" name="Attributes Property">.
<p>
When a view object is dropped onto a camera object using drag and drop
in the tree view, the camera settings from the view will be copied
to the camera object.
<p>
The following table briefly lists some capabilities of the Camera object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Camera|No|No|N/A|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Camera Object Capabilities</caption>
</table>

<sect2>RIB Export
<p>
Camera objects never appear in RIB output.

<#if out=latex><x/newpage/</#if>

<sect1>Light Object<label id="lightobj">
<p>
Light objects let you bring light into your scenes.
<p>
The behaviour of a light source object depends heavily on the type
of the light source.
There are currently four different light types available in Ayam:
<tt/"Custom"/, <tt/"Point"/, <tt/"Distant"/ and <tt/"Spot"/.
<p>
Custom Lights:<label id="cul">
<p>
Light sources of type <tt/"Custom"/ use the attached light shader.
<p>
Note that Ayam is trying to guess from the names of the light shader
arguments to draw the light.
The names <tt/"from"/ and <tt/"to"/ denote location and destination
of the light source. Those names should not be used for other things
in the light shaders.
<p>
Point-, Distant-, and Spotlights:<label id="pdsl">
<p>
These (standard) light sources have well defined parameters that
will be displayed in the <tt/"LightAttr"/ property.
Please refer to the RenderMan documentation for more information
about the standard light sources (see section
<ref id="secref" name="references">).
<p>
In contrast to the light sources as defined in the RenderMan
interface, Ayam light sources are always global by default. This
means, regardless of the place of a light source in the scene
hierarchy, it will always light all other objects (unless the
<tt/"IsLocal"/ attribute is used).
<p>
Note that you can not preview the effect of a light source in
shaded Ayam views, currently. However it is possible to estimate
the effect of a spot light source by simply dropping it into
a perspective view window, the view will then show you the objects
lit by the spot.
<p>
The following table briefly lists some capabilities of the Light object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Light|Yes|No|N/A|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Light Object Capabilities</caption>
</table>

<sect2>LightAttr Property<label id="lip"><label id="lightattrprop">
<p>
Depending on the type of the light source, the light attribute
property contains different parameters. Parameters that
are not displayed will not be used on RIB export, consequently.
<p>
Using <tt/"Type"/ you can change the type of the light source.
When you change the type of a light source, the property GUI will
be adapted to show only the options available for the new light
source type, but only after you used the <tt/"Apply"/-button.
<p>
<tt/"IsOn"/ allows you to switch the light off or on. The default
value is on.
<p>
<tt/"IsLocal"/ controls whether the light source should light
just local objects (objects, that are defined in the same level
in the scene hierarchy as the light source object or below it) or
all objects in the scene.
The default is off, all objects in the scene are lit.
The <tt/"IsLocal"/ attribute is ignored for lights that are
defined in the root level of the scene. Mind also that shadow maps
will always contain shadows from all objects in the scene,
regardless of the <tt/"IsLocal"/ attribute of the light source.
<p>
Using the light attribute <tt/"Shadows"/ you may determine
whether the light source should cast shadows.
The default is off, no shadows. Note that this option will not
magically enable shadows on renderers that create shadows by
shadow maps. It will merely be interpreted by raytracing
renderers like BMRT.
<p>
The attribute <tt/"Samples"/ determines the number of times to sample
an area light source, independent of pixel samples, the default value
is 1. This attribute is available for custom lights only.
<p>
<tt/"UseSM"/ determines, whether shadow maps should be created
and used for this light source. The resolution of the
shadow map may be determined by the attribute <tt/"SMRes"/. If
<tt/"SMRes"/ is 0, a default of 256 by 256 pixels will be used.
These options are for renderers that do not support raytraced
shadows like PRMan or Aqsis only.
<p>
For lights of type <tt/"Distant"/ the <tt/"Scale"/ attributes
of the <tt/"Transformations"/ property of the light
object may be used to scale the camera transformation
used for the creation of the corresponding shadow map.
Values of 1 for <tt/"Scale_X"/ and <tt/"Scale_Y"/ create
a shadow map that is sized 1 by 1 units in world space.
<p>
All other parameters that may appear in the <tt/"LightAttr"/
property are the standard parameters for the standard RenderMan
light sources: distant, point, and spot:
<itemize>
<item><tt/"From"/ and <tt/"To"/ denote position and target of the light
source as point in space. You may edit both points using standard
point editing actions (see also section
<ref id="iac" name="interactive actions">).
<item><tt/"Color"/ is the color of the light emitted by the light source.
<item><tt/"Intensity"/ is the intensity of the light emitted by the
light source. Note that the standard point and spot lights have
a quadratic falloff (with distance), that requires the intensity
to be set to quite high values in order to achieve some
illumination effect (e.g.~around 30 for the standard distance of
<tt/"From"/ and <tt/"To"/ of a spot light).
<item><tt/"ConeAngle"/ is the angle of the beam of a spot light.
<item><tt/"ConeDAngle"/ (cone delta angle) is the angle that determines a
falloff area at the edge of the beam of a spot light.
<item><tt/"BeamDistrib"/ (beam distribution) determines, how the light
falls off in the beam of the spot light. Larger values result in narrower
lit areas.
</itemize>

In order to ease the parameterisation of spot lights, you may drop the
light source object onto a view object or into a view window
(preferably one with a perspective viewing transformation and with equal
width and height) to see what objects of the scene are actually lit
by the light object.

<sect2>Using ShadowMaps<label id="shadowmaps">
<p>
Using shadow maps requires the global preference setting
<tt>"RIB-Export/ShadowMaps"</tt> to be switched on.
Furthermore, for each light source for which a shadow map should be
created, the attributes <tt/"IsOn"/ and <tt/"UseSM"/ have to be
switched on.
<p>
<bf>Automatic Creation of ShadowMaps</bf>
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Automatic"</tt>,
Ayam will create a special version of the RIB on export, that creates
all shadow maps automatically upon rendering. This is done by rendering
depth images from the position of every light source that casts shadows.
Special light source shaders later pick up these depth images
and calculate shadows.
This approach implies, that the scene is rendered multiple times.
To reduce the size of the RIB, the objects to be rendered
are written to a second RIB file named <tt>"&lt;scene&gt;.obj.rib"</tt>.
This file is read from the main RIB several times via
<tt>"ReadArchive"</tt>. The RIB contains multiple frames which may
also be rendered separately if the frame number is known.
To help you picking the right frame number for the image
(e.g.~to re-render just the final image, when only a material setting was
changed, and no shadow casting lights were moved and no shadow casting
geometry was changed),
a comment with the frame number of the last frame (the image) will be
written as last statement to the RIB.
<p>
Because multiple files (RIBs and shadow maps) are used, it is suggested
to change the preference setting <tt>"RIB-Export/RIBFile"</tt> to
<tt>"Scenefile"</tt>. This will strip the leading absolute path component
from the filenames so that you may move the exported scene from one
system to another more easily.
<p>
Do not render directly from a view window to the display when the
<tt/"ShadowMaps"/ <tt/"RIB-Export"/ preference option is set to
<tt>"Automatic"</tt>.
Your renderer may not write image files when the command line option
to render directly to the display (-d for rendrib, or -fb for Aqsis) is
in use. Consequently, this may also inhibit writing of the shadow maps,
so that the resulting image will look wrong, or the renderer will render
the shadow map to the display and simply stop.
<p>
<bf>Manual Creation of ShadowMaps</bf>
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Manual"</tt>,
the exported scene will not render the shadow maps but rather
expects them to be present already. You can create them manually
(hence the name <tt>"Manual"</tt>) using the view menu entries
<tt>"View/Create ShadowMap"</tt>, <tt>"View/Create All ShadowMaps"</tt>
or the main menu entries
<tt>"Special/RIB-Export/Create ShadowMap"</tt>,
<tt>"Special/RIB-Export/Create All ShadowMaps"</tt>.
The manual approach has the advantage, that the shadow maps will not
be re-created each time you render the scene.
<p>
<bf>ShadowMap Types</bf>
<p>
Ayam supports three different methods for the creation of shadow maps
for certain types of light sources: point, distant, and spot:
<p>
The point method is used with
lights of type <tt>"Point"</tt> and custom lights that have a light
shader argument named "from".
Six shadow maps pointing in all possible axis aligned
directions and named <tt>"&lt;rib&gt;.point&lt;num&gt;_&lt;dir&gt;.shd"</tt>
(where <tt>"&lt;rib&gt;"</tt> is the name of the RIB,
<tt>"&lt;num&gt;"</tt> is the number of the light source that makes
use of shadow maps and <tt>"&lt;dir&gt;"</tt> is one of
<tt/"x+"/, <tt/"x-"/, <tt/"y+"/, <tt/"y-"/, <tt/"z+"/, or <tt/"z-"/)
will be created.
<p>
The distant method is used with lights of type <tt>"Distant"</tt>
and custom lights that have a light
shader argument named "from" and a light
shader argument named "to".
One shadow map is created and named
<tt>"&lt;rib&gt;.dist&lt;num&gt;.shd"</tt>.
By default, the size of the shadow map is 1 by 1 units in world space,
but this may be adapted using the scale transformation attributes of
the light object.
<p>
The spot method is used with lights of type <tt>"Spot"</tt>
and custom lights that have a light
shader argument named "from", a light
shader argument named "to", and a light shader argument named "coneangle".
One shadow map is created and named
<tt>"&lt;rib&gt;.spot&lt;num&gt;.shd"</tt>.
The spot method uses the cone angle (and additionally the delta cone
angle, if present) argument to determine the size of the shadow map
in world space.
<p>
If a light object of type <tt>"Spot"</tt>, <tt>"Distant"</tt> or
<tt>"Point"</tt> is used, Ayam automatically changes the name of the
exported light shader to <tt>"shadowspot"</tt>, <tt>"shadowdistant"</tt>,
and <tt>"shadowpoint"</tt> respectively. Additionally, the shader
will be parameterised to use the created shadow maps.
If the light source is of type <tt>"Custom"</tt>, no automatic renaming
and adjusting of the shader takes place. This means, you have
to make sure that the shader really uses the shadow maps, by
selecting the right shader and parameterising it accordingly.
See the discussion above for the names of the shadow map files.
Those file names, most probably, will have to be entered as parameter
to the light shader.
<p>
For example, you will not get any shadows if you use a light source of
type <tt/"Custom"/ with the normal <tt/"distantlight"/ shader attached,
even though Ayam is able to create the necessary shadow maps. The
normal <tt/"distantlight"/ shader just makes no use of the shadow maps.
You have to manually switch to a shader that
makes use of the shadow maps (<tt/"shadowdistant"/ in this case) to get
shadows.
<p>
<bf>ShadowMap Mini Tutorial</bf>
<p>
Here is a short example for a scene using a shadow map:
<enum>
<item>Go to the preferences (section <tt/"RIB-Export"/) and set
<tt/"ShadowMaps"/ to <tt>"Automatic"</tt>.
<item>Create two boxes.
<item>Open the <tt/"Transformations"/ property of the second box.
<item>Translate it by X: 0.0, Y: -1.0, Z: 0.0.
<item>Scale it by X: 4.0, Y:1.0, Z:4.0.
<item>Create a light source.
<item>Open the <tt/"LightAttr"/ property.
<item>Change the type to <tt/"Spot"/. Press <tt/"Apply"/.
<item>Now change the parameters of the spot light to <tt/"IsOn"/: Yes,
<tt/"Intensity"/: 18.0,
<tt/"UseSM"/: Yes, <tt/"ConeAngle"/: 45.0, <tt/"BeamDistrib"/: 3.0,
<tt/"From"/: -2, 2, 2, <tt/"To"/: 1, 0, -1;
leave all other parameters at their default values.
<item>Create a new view and make it perspective (Menu:
<tt>"Type/Perspective"</tt>).
<item>Export a RIB from that perspective view (Menu:
<tt>"View/Export RIB"</tt>).
<item>Render the RIB with a RenderMan compliant renderer, that uses
shadow maps, e.g.~Photorealistic RenderMan (prman) or Aqsis.
</enum>

This scene is distributed with Ayam as an example scene named
<tt>"shadowmaps.ay"</tt>.
<p>
Note that for Aqsis you should add a RiHider hidden,depthfilter,s,midpoint
tag to your root object if shadow maps are in use. Other renderers might
require additional tweaking using shadow bias RiOption tags.
Please consult the documentation of your renderer on how to achieve
the best results using shadow maps.

<sect2>Using AreaLights<label id="alob">
<p>
The common idealized standard light sources <tt/"Point"/, <tt/"Distant"/
and <tt/"Spot"/ have no own geometric extension in space.
This means, shadows resulting from such light sources will have sharp
borders which does not look too natural.
Good looking soft shadows may be generated using area lights.
<p>
Area lights may be created by simply placing a single object as child
object of a <tt/"Custom"/ light object that has the <tt>"arealight"</tt>
shader attached:
<tscreen><verb>
+-AreaLight(Light)
 \ AreaLightGeometry(Sphere)
</verb></tscreen>
This child object determines the geometry, place, <em>and</em> extension
of the light source.
According to L. Gritz, Spheres and Cylinders work best as area light
geometry for BMRT, because of special sampling code.
<p>
An example:
<itemize>
<item>Create a custom light object.
<item>Assign the arealight light shader to it.
<item>Create a sphere.
<item>Drag and drop the sphere onto the Light object so that it becomes
a child of the light object.
<item>Transform the sphere object to your hearts content; the position
and size of the object determines the position and size of the light
source.
</itemize>

There is an example scene named <tt>"arealight.ay"</tt> distributed with
Ayam.

<#if out=latex><x/newpage/</#if>

<sect1>Material Object<label id="materialobj">
<p>
Material objects are used to attach RiAttributes and shaders to
geometric objects.
<p>
When geometric objects are dropped onto a material object using
drag and drop in the tree view they will be connected to this
material object.
<p>
While geometric objects are connected to a material object this material
object may not be deleted.
<p>
The following table briefly lists some capabilities of the Material object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Material|No|N/A|N/A|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Material Object Capabilities</caption>
</table>

<sect2>RiAttributes Property<label id="riattrs"><label id="riattributesprop">
<p>
Using this property standard and BMRT specific attributes may be set.
Please refer to the documentation of the RenderMan interface
and the documentation of BMRT for more detailed information about the
RenderMan specific attributes.

<itemize>
<item><tt/"Color"/, the color of the object. If you set one of the
entries to a negative value (e.g.~-1), the color will not be set at all
for this object.
<item><tt/"Opacity"/, the opacity of the object, the default
255 255 255 means the object is totally opaque. If you set one of the
entries to a negative value (e.g.~-1), the opacity will not be set at all
for this object.
<item><tt/"ShadingRate"/, determines how often shaders are evaluated for
a sample.
<item><tt/"Interpolation"/, determines how return values computed
by the shaders are interpolated across a geometric primitive.
<item><tt/"Sides"/, determines how many sides of the surface of a
geometric primitive should be shaded.
<item><tt/"BoundCoord"/, sets the coordinate system in which the
displacement bound is expressed.
<item><tt/"BoundVal"/, displacement bound value.
<item><tt/"TrueDisp"/, toggles true displacements on or off. Default off.
<item><tt/"CastShadows"/, determines how the object casts shadows:
the default <tt/"Os"/ means the object casts shadows according to it's
opacity; <tt/"None"/ object does not cast any shadows; <tt/"Opaque"/
the object is completely opaque and casts shadows; <tt/"Shade"/
the object has a complex opacity pattern determined by it's surface
shader, that is used in shadow calculations.
<item><tt/"Camera"/, <tt/"Reflection"/, and <tt/"Shadow"/ toggle
visibility attributes.
</itemize>

<sect2>Surface, Displacement, Interior, Exterior Property<label id="matshader">
<p>
These properties let you define shaders for the material object, please
refer to section <ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Surface shaders may be used to procedurally encode lighting models and
textures. Displacement shaders may procedurally deform the object while
rendering. Interior and Exterior shaders are so called volume shaders
that may be used to capture special optical effects, encoding how light
is affected while passing through an object.

<sect2>MaterialAttr Property<label id="matattr"><label id="materialattrprop">
<p>
The MaterialAttr property contains attributes related to the
management of material objects:
<itemize>
<item><tt/"Materialname"/ denotes the name of the material. Note
that material names have to be unique in a scene. If two
materials with the same name exist, only the first material
created with this name is "registered" and thus may be connected
to geometric objects.
<item><tt/"Refcount"/ shows how many geometric objects are connected to
(are of) this material. Note that connected or referring geometric objects
not necessarily have to live in the scene, they may as well temporarily
reside in the object clipboard.
<item><tt/"Registered"/ displays whether this material may be
connected to geometric objects, see the discussion about material names above.
</itemize>

<sect2>RIB Export
<p>
Material objects only appear in RIB output if connected to a
geometric object (e.g.~a Box).
<p>
The exact RIB statements used depend on the configuration of the
material and the preference setting <tt>"RIB-Export/RIStandard"</tt>.
<p>
If all elements of the MaterialAttr property are left on their default
values, only color and opacity will be written to the RIB:
<tscreen><tt>
RiColor(...);<newline>
RiOpacity(...);
</tt></tscreen>
After the elements of the MaterialAttr property, the surface, displacement,
interior, and exterior shaders (if attached to the material) will
be exported, all shader parameters will be properly declared:
<tscreen><tt>
RiDeclare("Ka", "float");<newline>
...<newline>
RiSurface("Ka", 0.9, ...);<newline>
...
</tt></tscreen>
After the material description custom RiAttributes and texture
coordinates from tags will be exported.
<p>
No attempt is being made to re-order or sort objects in a level according
to their attached materials, they will rather be exported in the order of
their appearance in the level and thus each object with a material
will also be prepended by a full material specification as described
above.

<#if out=latex><x/newpage/</#if>

<sect1>Level Object<label id="levelobj">
<p>
Level objects may be used to build object hierarchies and perform CSG
operations.
<p>
Ayam does not offer a layer concept, but by grouping objects using
levels and the hide/show tools, layer functionality may be emulated
to a certain extent.
<p>
Organizing the scene and working in levels also increases the speed
of object tree updates, as only the current level and its sub-levels
are subject to a tree update if something in the object hierarchy changes.
<p>
Note that child objects of a level inherit the levels transformations,
material, attributes, and shaders. Inheritance of e.g.~transformations
means:<newline>
If you have a NURBS patch in a level that is translated to (10,0,0),
the origin of the local coordinate system of the NURBS patch
will be situated at (10,0,0). If you decide to move the patch by a
value of 5 in X direction by setting a corresponding value in the
Transformations property of the patch object, the local coordinate
system of the patch will be placed at (15,0,0) in world coordinates,
i.e.~the control point (1,0,0) will be at (16,0,0).
<p>
Note also that since Ayam 1.12, Level objects provide their child
objects to their parent objects as a list. This means the following
hierarchy is now valid:
<tscreen><verb>
+-Skin
 +-Level
  | NCurve
  | NCurve
  | ICurve
  \ NCurve
</verb></tscreen>
All NURBS curves and objects that may be converted to NURBS curves
(in this example: the ICurve) will be provided to the Skin by the
Level object. Transformation attributes of the Level will be added
to the provided objects. Objects that do not provide the wanted
type will be silently ignored.
<p>
The following table briefly lists some capabilities of the Level object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Level|Any+|Yes|N/A&thinsp;/&thinsp;Children+|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Level Object Capabilities</caption>
</table>

<sect2>LevelAttr Property<label id="lep"><label id="levelattrprop">
<p>
Levels do not have many object type specific properties, you may just
modify the type of the level using the attribute <tt/"Type"/.
<p>
Levels of type <tt/"Level"/ just group objects and inherit attributes.
<p>
Levels of type <tt/"Union"/, <tt/"Intersection"/, and <tt/"Difference"/
are used to build CSG hierarchies. Additionally, they inherit attributes.
Note that Ayam is currently not able to correctly display the results
of CSG operations, all objects are always drawn completely, even though
a CSG operation would cut parts away.
<p>
However, since Ayam 1.8 there is a plugin available that is able to
preview the results of CSG operations, see also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">.
<p>
The object hierarchy to cut away a part of a box using a sphere
looks like this:
<tscreen><verb>
+-Level_of_Type_Difference(Level)
 | Box
 \ Sphere
</verb></tscreen>
More than two objects may be arguments of a CSG operation:
<tscreen><verb>
+-Level_of_Type_Difference(Level)
 | Box
 | Sphere
 \ Sphere
</verb></tscreen>
In this example, the two spheres would cut away parts of the box.
<p>
New solid primitives may be created with levels of type <tt/"Primitive"/.
<tscreen><verb>
+-Level_of_Type_Difference(Level)
 +-Level_of_Type_Primitive(Level)
 | | Sphere_blue
 | \ Disk_red
 \ Box_grey
</verb></tscreen>
In this example an open sphere with <tt/"ThetaMax"/ 180.0 (a hemisphere)
is manually capped by a disk object. The two objects need to be placed
into a level of type <tt/"Primitive"/ because each object alone is an
open surface and therefore not a valid CSG primitive. Both objects that
form the new primitive use a different material. In addition, a grey box
cuts away a part from the multi colored hemisphere.
The above CSG hierarchy is available as example scene file
<tt/"multicolcsg.ay"/.
<p>
See also this image:
<p>
<figure loc="ht">
<eps file="pics/multicolcsg.ps" height="4cm">
<img src="pics/multicolcsg.gif">
<caption>Multicolor CSG Example</caption>
</figure>
<p>
Note that Ayam is not able to check, whether your new primitive obeys
the rule of total closeness. For instance, if the disk in the above
example would not totally cap the sphere (this happens if the disk
<tt/"ThetaMax"/ is not 360.0 or if it is not placed exactly at the
sphere) Ayam would not complain upon RIB export.
The rendered image would expose serious errors, however.
<p>
Furthermore, it is not necessary to enclose normal child objects
(e.g.~quadrics with the <tt/"Closed"/ attribute set to on) of
CSG levels in primitive levels for RIB export. This is done by Ayam
automatically where needed.

<sect2>RIB Export
<p>
The exact representation of a Level in RIB output depends on
its type.
<p>
Normal Level objects appear in RIB output as Transformation
hierarchies:
<tscreen><tt>
RiTransformBegin();<newline>
 RiTranslate(&hellip;);<newline>
 RiRotate(&hellip;);<newline>
 RiScale(&hellip;);<newline>
<newline>
 &laquo;Children RIB output&raquo;<newline>
<newline>
RiTransformEnd();
</tt></tscreen>

<p>
Level objects of type Union, Difference, or Intersection will
additionally contain a call to SolidBegin, and each child will
be properly declared as primitive, e.g.:
<tscreen><tt>
RiTransformBegin();<newline>
 &laquo;Level Transformations&raquo;<newline>
 RiSolidBegin(RI_DIFFERENCE);<newline>
<newline>
 RiSolidBegin(RI_PRIMITIVE);<newline>
 &laquo;Child &num;1 RIB output&raquo;<newline>
 RiSolidEnd();<newline>
<newline>
 RiSolidBegin(RI_PRIMITIVE);<newline>
 &laquo;Child &num;2 RIB output&raquo;<newline>
 RiSolidEnd();<newline>
<newline>
 RiSolidEnd();<newline>
RiTransformEnd();
</tt></tscreen>

<#if out=latex><x/newpage/</#if>

<sect1>Clone Object<label id="cloneobj">
<p>
<figure loc="ht">
<eps file="pics/clone.ps" height="5cm">
<img src="pics/clone.gif">
<caption>Clone Object (blue) with Trajectory Curve (white)</caption>
</figure>
<p>
The Clone object allows to easily create and control an arbitrary
number of instances of a single object, hereafter called the cloned
object.
The instances can be transformed (each by a certain amount expressed
as difference between two instances) or placed on a trajectory curve
(see also the image above).
<p>
If a second object is present as child of the Clone object it is treated
as trajectory (or path) curve automatically.
The process of placing the clones on the trajectory is very similar
to the sweeping operation
(see also section <ref id="sweepobj" name="Sweep Object">).
<p>
Thus, the default object hierarchy of a Clone object looks like this:
<tscreen><verb>
+-Clone
 | Cloned-Object
 \ [Trajectory(NCurve)]
</verb></tscreen>
If you use a trajectory curve to place the clones, you may want
to hide the cloned object and also add a <tt/"NoExport"/ tag to it.
Otherwise the original object will appear twice, on the trajectory and
on its normal, untransformed, position. Note that the transformation
attributes of the cloned object will be completely overwritten when
placing the clones on the trajectory curve. If the cloned object has
distinct scale or rotation attributes it should be put inside a level
object like this:
<tscreen><verb>
+-Clone
 +-Level
 |\ Cloned-Object with non-standard Scale/Rotation
 \ Trajectory(NCurve)
</verb></tscreen>
<p>
It is not possible to create clones from objects that may not
be master objects of instance objects, e.g.~it is not possible
to clone light objects or material objects. However, (since Ayam 1.7)
it is possible to use instances as parameter objects.
<p>
If an instance object is used as cloned object on a trajectory
it can be placed in a level and the <tt/"NoExport"/ tag can
be added to the level object (as adding tags to Instance objects is
more involved), see the following hierarchy for an example:
<#if out=latex><x/needspace 6/</#if>
<tscreen><verb>
+-Clone
 +-Level with NoExport tag
 |\ Instance
 \ Trajectory(NCurve)
</verb></tscreen>
<p>
Since Ayam 1.20 the mirror facility of the Clone object is realized
through the new Mirror object (see also
section <ref id="mirrorobj" name="Mirror Object">).
The mirror facility was integrated into the Clone object before.
<p>
The following table briefly lists some capabilities of the Clone object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Clone|Any+|No|Children+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Clone Object Capabilities</caption>
</table>
<p>
The following attributes further control the cloning process:

<sect2>CloneAttr Property<label id="cloneattr"><label id="cloneattrprop">
<p>
<itemize>
<item><tt/"NumClones"/ is the number of clones to create.
<item><tt/"Rotate"/ is only used, if a trajectory curve is present.
If it is enabled all clones will be aligned according to the normal of
the trajectory curve. Otherwise the rotation attributes will not be
touched when placing the clone on the trajectory.

<item><tt/"Translate_X"/, <tt/"Translate_Y"/, <tt/"Translate_Z"/,
<tt/"Rotate_X"/, <tt/"Rotate_Y"/, <tt/"Rotate_Z"/,
<tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/,
those attributes control the transformation of the instances created by
the Clone object. These attributes specify difference values
between two instances: the clone <tt/"n+1"/ is offset by <tt/"Translate_X"/,
<tt/"Translate_Y"/, and <tt/"Translate_Z"/ from the previous clone <tt/"n"/.
It is also rotated by <tt/"Rotate_X"/, <tt/"Rotate_Y"/, and <tt/"Rotate_Z"/
and scaled by <tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/ in relation
to the previous clone.

<p>
Note however, that the transformation attributes
do not affect the first clone.

<p>
The transformation attributes are also in effect if a trajectory
curve is present, they will be applied after moving of the
instance to the trajectory and rotating it.
<footnote>Since 1.13.</footnote>

</itemize>
The following table summarizes which transformation attributes are used
in the respective clone modes.

<table loc="ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/Mode/|<bf/Use Child Transform/|<bf/Use CloneAttrib Transform/|<bf/Use Clone Transform/@<hline>
Clone|No|Yes|Yes@<hline>
Trajectory|Yes|Yes|Yes@<hline>
Mirror|Yes|N/A|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>Clone Parameterisation Examples</caption>
</table>

<sect2>Conversion Support
<p>
The Clone object may be converted to ordinary objects using the
main menu entry <tt>"Tools/Convert"</tt>.
<p>
Upon conversion a Level object will be created, that contains the original
object <em>and</em> the clones.

<sect2>RIB Export
<p>
Clone objects appear in RIB output as a number of real
objects, each with different transformation attributes.
<p>
As the original objects will also appear in the RIB output,
it is suggested to add a <tt/"NoExport"/ tag to the original
if the Clone is in trajectory mode.

<#if out=latex><x/newpage/</#if>

<sect1>Mirror Object<label id="mirrorobj">
<p>
<figure loc="ht">
<eps file="pics/mirror.ps" height="4cm">
<img src="pics/mirror.gif">
<caption>Mirrored Object (blue) From Curve (white)</caption>
</figure>
<p>
The Mirror object allows to easily create and control an arbitrary
number of mirrored instances of a number of objects.
<footnote>Since 1.20.</footnote>
<p>
The original object(s)
<em>and</em> their mirrored counterparts will be
provided by the Mirror object to the respective parent object (normally,
tool objects do not provide their unmodified children).
Additionally, the order of the mirrored objects will be reversed so that
it is possible to use a single Mirror object (with one or multiple NURBS
curves as children) as parameter object of e.g.~a Skin object:
<tscreen><verb>
+-Skin
 +-Mirror
  \ NCurve
+-Skin
 +-Mirror
  | NCurve_1(NCurve)
  | NCurve_2(NCurve)
  \ NCurve_3(NCurve)
</verb></tscreen>
The first Skin object in the above example can only work, because also
the unmodified NCurve is provided by the Mirror object. The second Skin
object can only work properly, because the order of the provided objects
is reversed, so that it gets to see the curves in the following sequence:
<tt/"NCurve_1"/, <tt/"NCurve_2"/, <tt/"NCurve_3"/, <tt/"Mirrored_NCurve_3"/,
<tt/"Mirrored_NCurve_2"/, <tt/"Mirrored_NCurve_1"/.
<p>
The following table briefly lists some capabilities of the Mirror object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Mirror|Any+|No|Children+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Mirror Object Capabilities</caption>
</table>
<p>
The following attributes further control the mirror process:

<sect2>MirrorAttr Property<label id="mirrorattr"><label id="mirrorattrprop">
<p>
<itemize>
<item><tt/"Plane"/ allows to select the plane about which the mirroring
should occur (YZ-, XZ-, or XY-plane).
</itemize>

<sect2>Conversion Support
<p>
The Mirror object may be converted to ordinary objects using the
main menu entry <tt>"Tools/Convert"</tt>.
<p>
Upon conversion a Level object will be created, that contains the original
objects and the mirrored counterparts (the latter in reverse order).

<sect2>RIB Export
<p>
Mirror objects appear in RIB output as a number of real
objects, each with different transformation attributes.

<#if out=latex><x/newpage/</#if>

<sect1>Instance Object<label id="instanceobj">
<p>
Instance objects help to save memory consumption in scenes with many
similar or repeating objects or transport geometric data across the
scene hierarchy.
<p>
The term instance is unfortunately misleading (and can be very confusing
if you are accustomed to the terminology of object oriented programming),
but it is the term that seems to be used and understood by most
computer graphic artists. A better term would be link, as an instance
object has the same basic properties as a link in a Unix file system.
A link is just a pointer to an original file, the same goes for
an instance object: it is just a pointer to an original object (here
also called master object).
A link can be placed anywhere on the file system,
an instance object can be placed anywhere in the scene hierarchy, and
additionally, it can be transformed.
<p>
Normally, the sole purpose of instance objects is to save space,
in memory and on the disk. But in the tool object context, instances
also serve as a means to transport geometric data across the scene
hierarchy to make tool objects depend on each other (see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).
Note that in the tool object context, instance objects are the only
objects, that are subject to a second round of provision.
<p>
The amount of saved space can be very high, depending heavily on the
actual scene and at what levels in the hierarchy instances are used.
If there are no similar objects in the scene, however, one can hardly
utilise instancing. Similar means "the same except for
the transformation property" in this context.
<p>
Some simple rules for instancing:

<itemize>
<item>No instances may be created of objects of the following types:
Root, View, Instance, Material, Light. Do not try to fool
Ayam and create instances of levels that contain aforementioned
types of objects, things will go awry!
<item>It is allowed, however, to put some instances
into a level object and create instances of this level
(this is sometimes called hierarchical instancing).
<item>But one may not put instances of a level into the very same
level or one of its children (this would be recursive instancing,
which is not supported by Ayam).
<item>The original/master object may not be deleted from the scene
as long as there are instances of that object in the scene or in the
object clipboard.
</itemize>

If deleting of an object fails, and the error message
complains about the reference counter not being zero, then
the last rule was about to be violated. Clean the clipboard using
the menu <tt>"Special/Clipboard/Paste (Move)"</tt> and delete
or resolve all references first.
<p>
Ayam can also create instances for complete scenes automatically
(see section <ref id="ai" name="Automatic Instancing">).
<p>
To easily find the master object of an instance, just select the
instance, then use the main menu entry: <tt>"Edit/Master"</tt>.
<!--
To find out, where in the scene instances of a master object
exist, select the master object and use the main menu entry
<tt>"Edit/Master"</tt>.
-->
<p>
The following table briefly lists some capabilities of the Instance object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Instance|No|No|Master|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Instance Object Capabilities</caption>
</table>

<sect2>Instances without Transformations (References)<label id="referencing">
<p>
Instance objects support the <tt>"RP"</tt> tag type
in a special way:
if the <tt>"Transformations"</tt> property is removed using a
<tt>"RP"</tt> tag, the instance does not provide objects with
an own set of transformation attributes (to ease hierarchy building
with e.g.~<tt>"ExtrNC"</tt>/<tt>"ExtrNP"</tt> objects, where only
pointers to already existing objects are required and where it is
expected, that the instance reflects the master exactly, including
its transformation attributes).
<footnote>Since 1.16.</footnote>
<p>
The extract curve/surface tools automatically add such a tag to the
instances they create.
<p>
To create such a tag manually, select the Instance object and enter
into the Ayam console:
<code>
addTag RP Transformations
</code>
.
<p>
This special case of an instance is sometimes also called reference.

<sect2>Instances and the Object Clipboard<label id="instclip">
<p>
It is not possible to copy a master object and some instances
of it, so that the new instances point to the newly created master.
All copies of instance objects always point to the same original
master object.
<p>
For example, when the following two objects are copied and pasted back to the
scene
<tscreen><verb>
--NCurve   <-----
                 |
--Instance  -----
</verb></tscreen>
the following scene hierarchy results:
<tscreen><verb>
--NCurve   <-------
                 | |
--Instance  -----  |
                   | !
--NCurve           |
                   |
--Instance  -------
</verb></tscreen>
The new instance still points to the original master and <em>not</em>
to the copy of the master.
<p>
It is possible to move masters and instances through the scene hierarchy
using drag and drop in the tree view or using the clipboard with
<tt>"Edit/Cut"</tt> and then <tt>"Special/Clipboard/Paste (Move)"</tt>.

<sect2>Conversion Support
<p>
An Instance object may be converted to an ordinary object using the
main menu entry <tt>"Tools/Convert"</tt>.
This process is also called resolving the instance.
<p>
To resolve all instance objects in a scene
to normal objects, one can also use the main menu entry:
<tt>"Special/Instances/Resolve all Instances"</tt>.

<sect2>RIB Export
<p>
The RIB export of instances does <em>not</em> use the RiInstance facility
of the RenderMan interface, but rather the more flexible ReadArchive
mechanism.
<p>
This means, every master object in the scene will be written
in a separate archive (RIB file) on disk, and every instance will
cause that archive file to be read when rendering the RIB file.
You can change this behaviour using the RIB export preference setting
<tt/"ResInstances"/: If <tt/"ResInstances"/ is enabled, all instances
will be resolved temporarily to normal objects before being exported
to RIB. The resulting RIB file will then be self contained.

<#if out=latex><x/newpage/</#if>

<sect1>Select Object<label id="selectobj">
<p>
The Select object may be used in hierarchies
of tool objects to select one object from a list of provided objects.
<footnote>Since 1.14.</footnote>
Also multiple objects and ranges (even decreasing
ranges that lead to reversed orders) may be selected.
<footnote>Since 1.16.</footnote>
<p>
In the following example hierarchy, a single patch from multiple provided
patches of the Sweep object (the swept surface, a bevel, or a cap)
could be selected by the Select object and delivered upstream to
the ExtrNC object.
<tscreen><verb>
+-Sweep
+-Revolve
 +-ExtrNC
  +-Select
   \ Instance_of_Sweep(Instance)
</verb></tscreen>
Note that this example just serves illustrative purpose; the hierarchy
presented is not exactly useful, as the ExtrNC object has a selector
facility built in. Consequently, the Select object should be used in
scenarios, where a selector facility does not exist or is hard to
implement, as e.g.~in Script object scripts.
<p>
The following table briefly lists some capabilities of the Select object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Select|Any+|No|N/A&thinsp;/&thinsp;Children+|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Select Object Capabilities</caption>
</table>

<sect2>SelectAttrib Property<label id="selectp"><label id="selectattribprop">
<p>
<itemize>
<item><tt/"Indices"/ designates the object(s) to select. The index values
are zero based. Multiple indices must be separated by <tt/","/, ranges
can be specified like this <tt/"1-4"/, reversed ranges are allowed
(<tt/"4-1"/) and will create an object list of reversed order. The special
index <tt/"end"/ (or abbreviated <tt/"e"/) designates the last of all
the provided objects.
An index may appear multiple times, leading to multiple copies of the
selected object to be delivered upstream.
The index space spans over all provided objects of the desired type
from all child objects. This means one can mix provided objects from
multiple child objects of the Select object. Syntactically incorrect
ranges and indices are silently ignored.
<p>
Examples:
 <itemize>
  <item><tt/"0,2"/ &ndash; delivers the first and third provided objects
upstream;
  <item><tt/"end-0"/ &ndash; delivers all provided objects in reversed order
upstream;
  <item><tt/"0,0,0"/ &ndash; delivers three copies of the first provided
object upstream;
  <item><tt/"0,4-end,1"/ &ndash; delivers the first, the fifth (if there are
so many) up to the last, and the second object upstream.
 </itemize>
</itemize>

<sect2>RIB Export
<p>
Select objects never appear in RIB output.

<#if out=latex><x/newpage/</#if>

<sect1>RiInc Object<label id="riincobj">
<p>
RiInc objects may be used to include objects or whole scene parts into your
scenes that, for some reason, are just available as a piece of RIB.
<p>
The following table briefly lists some capabilities of the RiInc object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
RiInc|No|No|N/A|No<#if out=latex>@<hline></#if>
</tabular>
<caption>RiInc Object Capabilities</caption>
</table>
<p>
The following attributes control the inclusion process:

<sect2>RiIncAttr Property<label id="riincp"><label id="riincattrprop">
<p>
<itemize>
<item>Using <tt/"File"/ you specify the filename of the RIB to be included.
<item><tt/"Width"/, <tt/"Height"/, and <tt/"Length"/ specify
the size of a box, that will be drawn as a geometric representation of
the RIB.
</itemize>

<sect1>RiProc Object<label id="riprocobj">
<p>
RiProc objects may be used to include procedural objects or external
archives into your scenes.
<p>
The following table briefly lists some capabilities of the RiProc object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
RiProc|No|No|N/A|No<#if out=latex>@<hline></#if>
</tabular>
<caption>RiProc Object Capabilities</caption>
</table>
<p>
The following attributes control the RiProc object:

<sect2>RiProcAttr Property<label id="riprocp"><label id="riprocattrprop">
<p>
<itemize>
<item><tt/"Type"/ defines the type of the procedural object which is
one of <tt/"DelayedReadArchive"/, <tt/"RunProgram"/, or
<tt/"DynamicLoad"/.
<item>Using <tt/"File"/ you specify the filename of the RIB archive,
program, or dynamic shared object (depending on the type of the
procedural object).
<item>Using <tt/"Data"/ additional arguments may be supplied to
procedural objects of type <tt/"RunProgram"/ and <tt/"DynamicLoad"/.
<item><tt/"MinX"/, <tt/"MaxX"/, <tt/"MinY"/, <tt/"MaxY"/, <tt/"MinZ"/,
and <tt/"MaxZ"/ specify the size of the bounding box of the objects that
the procedural will create or the archive contains.
</itemize>

<#if out=latex><x/newpage/</#if>

<sect1>Box Object<label id="boxobj">
<p>
A solid box, centered at the origin of the object coordinate system.
<p>
The following table briefly lists some capabilities of the Box object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Box|No|Yes|NPatch*|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Box Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a box:

<sect2>BoxAttrib Property<label id="bxp"><label id="boxattribprop">
<p>
<itemize>
<item><tt/"Width"/ is the width of the box (size of the box in
direction of the X axis of the objects coordinate system).
<item><tt/"Length"/ is the length of the box (size of the box in
direction of the Z axis of the objects coordinate system).
<item><tt/"Height"/ is the height of the box (size of the box in
direction of the Y axis of the objects coordinate system).
</itemize>

<sect2>Conversion Support
<p>
A box object may be converted to three NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.
<footnote>Since 1.8.2.</footnote>

<sect2>RIB Export
<p>
The box object will always be exported as six bilinear patches.

<#if out=latex><x/newpage/</#if>

<sect1>Sphere Object<label id="sphereobj">
<p>
A sphere, centered at the origin of the object coordinate system.
<p>
The following table briefly lists some capabilities of the Sphere object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Sphere|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Sphere Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a sphere:

<sect2>SphereAttr Property<label id="spattr"><label id="sphereattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the sphere
may be used in CSG operations safely.
<item><tt/"Radius"/ is the radius of the sphere, default is 1.
<item><tt/"ZMin"/ is the lower limit of the sphere on the Z axis,
default is -1.
<item><tt/"ZMax"/ is the upper limit of the sphere on the Z axis,
default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the sphere in degrees, default
is 360.
</itemize>

<sect2>Conversion Support
<p>
A sphere object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the sphere.
<footnote>Since 1.8.2.</footnote>
<p>
If the sphere is closed, an enclosing Level object will be
created and the caps follow the sphere in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.

<sect2>RIB Export
<p>
The sphere object appears in RIB output as simple
<tscreen><tt>
RiSphere(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"ZMin"/, <tt/"ZMax"/, or
<tt/"ThetaMax"/ have other than the default values,
as complex CSG hierarchy of at most two spheres, two cylinders, and
eight disks.

<#if out=latex><x/newpage/</#if>

<sect1>Disk Object<label id="diskobj">
<p>
A disk in the XY plane, centered at the origin of the object coordinate system.
<p>
The following table briefly lists some capabilities of the Disk object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Disk|No|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Disk Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a disk:

<sect2>DiskAttr Property<label id="dkp"><label id="diskattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the disk, default is 1.
<item><tt/"ZMin"/ displaces the disk along the Z axis, default is 0.
<item><tt/"ThetaMax"/ is the sweeping angle of the disk in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A disk object may be converted to a NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the disk.
<footnote>Since 1.8.2.</footnote>

<sect2>RIB Export
<p>
The disk object will always be exported as simple disk:
<tscreen><tt>
RiDisk(...);
</tt></tscreen>

<#if out=latex><x/newpage/</#if>

<sect1>Cone Object<label id="coneobj">
<p>
A cone, centered at the origin of the object coordinate system,
with the base in the XY plane.
<p>
The following table briefly lists some capabilities of the Cone object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cone|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Cone Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a cone:

<sect2>ConeAttr Property<label id="cnp"><label id="coneattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the cone
may be used in CSG operations safely.
<item><tt/"Radius"/ is the radius of the cone at the base, default is 1.
<item><tt/"Height"/ is the height of the cone, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cone in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A cone object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cone.
<footnote>Since 1.8.2.</footnote>
<p>
If the cone is closed, an enclosing Level object will be
created and the caps follow the cone in the following order:
disk-shaped cap at the base, cap at theta 0,
cap at thetamax.

<sect2>RIB Export
<p>
The cone object appears in RIB output as simple
<tscreen><tt>
RiCone(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"ThetaMax"/ has a different than
the default value, as complex CSG hierarchy of at most one cone, one disk, and
two polygons.

<#if out=latex><x/newpage/</#if>

<sect1>Cylinder Object<label id="cylinderobj">
<p>
A cylinder, centered at the origin of the object coordinate system.
<p>
The following table briefly lists some capabilities of the Cylinder object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cylinder|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Cylinder Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a cylinder:

<sect2>CylinderAttr Property<label id="cyp"><label id="cylinderattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the cylinder
may be used in CSG operations safely.
<item><tt/"Radius"/ is the radius of the cylinder, default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cylinder in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A cylinder object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cylinder.
<footnote>Since 1.8.2.</footnote>
<p>
If the cylinder is closed, an enclosing Level object will be
created and the caps follow the cylinder in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.

<sect2>RIB Export
<p>
The cylinder object appears in RIB output as simple
<tscreen><tt>
RiCylinder(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"ThetaMax"/ has a different than
the default value, as complex CSG hierarchy of at most one cylinder, two disks,
and two polygons.

<#if out=latex><x/newpage/</#if>

<sect1>Torus Object<label id="torusobj">
<p>
A torus, centered at the origin of the object coordinate system.
A torus is a donut like shape, that results from sweeping
a small circle (that has been displaced along X sufficiently)
around the Z axis.
<p>
The following table briefly lists some capabilities of the Torus object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Torus|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Torus Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a torus:

<sect2>TorusAttr Property<label id="top"><label id="torusattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the torus
may be used in CSG operations safely.
<item><tt/"MajorRad"/ is the radius of the torus, measured
from the Z axis to the center of the swept smaller circle, default is 0.75.
<item><tt/"MinorRad"/ is the radius of the swept circle, default is 0.25.
<item><tt/"PhiMin"/ determines an angle to limit the swept circle,
default is 0.
<item><tt/"PhiMax"/ determines an angle to limit the swept circle,
default is 360.
<item><tt/"ThetaMax"/ is the sweeping angle of the torus in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A torus object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the torus.
<footnote>Since 1.8.2.</footnote>
<p>
If the torus is closed, an enclosing Level object will be
created and the caps follow the torus in the following order:
disk-shaped cap at theta 0, disk-shaped cap at thetamax, ring-shaped
cap at phimin 0, ring-shaped cap at phimax.

<sect2>RIB Export
<p>
The torus object appears in RIB output as simple
<tscreen><tt>
RiTorus(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"PhiMin"/, <tt/"PhiMax"/, or
<tt/"ThetaMax"/ have different than the default values, as complex
CSG hierarchy of at most one one torus, two disks, and two hyperboloids.

<#if out=latex><x/newpage/</#if>

<sect1>Paraboloid Object<label id="paraboloidobj">
<p>
A paraboloid, centered at the origin of the object coordinate system.
<p>
The following table briefly lists some capabilities of the Paraboloid object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Paraboloid|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Paraboloid Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a paraboloid:

<sect2>ParaboloidAttr Property<label id="pap"><label id="paraboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the paraboloid
may be used in CSG operations safely.
<item><tt/"RMax"/ is the radius of the paraboloid at a Z of <tt/"ZMax"/,
the base of the paraboloid surface, default is 1.
<item><tt/"ZMin"/ limits the paraboloid surface on the Z axis,
must be positive, default is 0.
<item><tt/"ZMax"/ limits the paraboloid surface on the Z axis and
determines the Z location of the base, must be positive, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the paraboloid in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A paraboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the paraboloid.
<footnote>Since 1.8.2.</footnote>
<p>
If the paraboloid is closed, an enclosing Level object will be
created and the caps follow the paraboloid in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.

<sect2>RIB Export
<p>
The paraboloid object appears in RIB output as simple
<tscreen><tt>
RiParaboloid(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"ZMin"/, <tt/"ZMax"/ or
<tt/"ThetaMax"/ have different than the default values, as complex
CSG hierarchy of at most one paraboloid, two disks, and two bicubic patches.

<#if out=latex><x/newpage/</#if>

<sect1>Hyperboloid Object<label id="hyperboloidobj">
<p>
A hyperboloid, centered at the origin of the object coordinate system.
The shape of the hyperboloid will be created by sweeping a line specified
by two points in space around the Z axis. Thus, disk, cylinder, and cone are
special cases of the hyperboloid.
<p>
The following table briefly lists some capabilities of the Hyperboloid object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Hyperboloid|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Hyperboloid Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a hyperboloid:

<sect2>HyperboloidAttr Property<label id="hyp"><label id="hyperboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<newline>
Only when this option is enabled, the hyperboloid
may be used in CSG operations safely.
<item><tt/"P1_X"/, <tt/"P1_Y"/ and <tt/"P1_Z"/, define point one,
default is (0, 1, -0.5).
<item><tt/"P2_X"/, <tt/"P2_Y"/ and <tt/"P2_Z"/, define point two,
default is (1, 0, 0.5).
<item><tt/"ThetaMax"/ is the sweeping angle of the hyperboloid in degrees,
default is 360.
</itemize>

<sect2>Conversion Support
<p>
A hyperboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the hyperboloid.
<footnote>Since 1.8.2.</footnote>
<p>
If the hyperboloid is closed, an enclosing Level object will be
created and the caps follow the hyperboloid in the following order:
disk-shaped cap at P1, disk-shaped cap at P2, non-planar cap at theta 0,
non-planar cap at thetamax.

<sect2>RIB Export
<p>
The hyperboloid object appears in RIB output as simple
<tscreen><tt>
RiHyperboloid(...);
</tt></tscreen>
or, if <tt/"Closed"/ is enabled and <tt/"ThetaMax"/ has a different than
the default value, as complex CSG hierarchy of at most one hyperboloid,
two disks, and two bilinear patches.
<p>
Note that due to a bug in BMRT that is still present in V2.3.6
the <tt/"Closed"/ option does not work properly when
<tt/"ThetaMax"/ has a different than the default value and the
hyperboloid has no displacement shader. In fact, using a displacement
shader with a km (amount of displacement) of 0.0 is a work-around
for this bug (found by T. E. Burge).

<#if out=latex><x/newpage/</#if>

<sect1>NCurve (NURBS Curve) Object<label id="ncurveobj">
<p>
<figure loc="ht">
<eps file="pics/ncurve.ps" height="5cm">
<img src="pics/ncurve.gif">
<caption>A simple NURBS Curve</caption>
</figure>
<p>
The NCurve object is the most used basic object for NURBS modelling
in Ayam because NURBS curves are used to build more complex smoothly
shaped surfaces using operations like extrude, revolve, sweep or skin.
NURBS curves can be open or closed and used to emulate Bezier and
B-Spline curves easily. In addition, for easier modelling, they
support multiple points, as explained in section
<ref id="ncurvemp" name="Multiple Points">.
<p>
The following table briefly lists some capabilities of the NCurve object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCurve|No|No|N/A|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>NCurve Object Capabilities</caption>
</table>
<p>
The next section details the NCurve object property.

<sect2>NCurveAttr Property<label id="ncattr"><label id="ncurveattrprop">
<p>
The first section of the NCurveAttr property contains curve specific
settings:<p>
<itemize>
<item><tt/"Type"/: This attribute replaces the <tt/"Closed"/
attribute since Ayam 1.9.

<p>
The type <tt/"Open"/ is for the standard open NURBS curve.

<p>
If the type is <tt/"Closed"/, the first and last control point of
the curve will be made identical. This will close the curve but
without any guaranteed continuity.
Such a closed curve will e.g.~be created by the NURBS circle tool.
It is important to know, that identical start/end control points
alone can not guarantee that the curve is closed if the knot vector
is not clamped. If in doubt, use the clamp tool or a knot vector
of type <tt/"NURB"/, <tt/"Chordal"/, or <tt/"Centripetal"/.

<p>
If the type is <tt/"Periodic"/, the last p control points of the curve
will be made identical to the first p where p is the degree of the
curve (read order-1). This will close the curve with guaranteed continuity.
Note that for a cubic spline (order 4) you will need atleast 6 control
points to make it periodic. It is important to know, that the multiple control
points alone can not guarantee that the curve is closed if the knot vector
has no periodic extensions. If in doubt, switch the curve to
knot type <tt/"B-Spline"/, <tt/"Chordal"/, or <tt/"Centripetal"/.

<p>
You may also want to enable the creation of multiple points using the
<tt/"CreateMP"/ attribute (see below) for closed and periodic curves so that
single point editing actions modify all multiple control points.

<item><tt/"Length"/ is the number of control points of the curve.

<item><tt/"Order"/ is the order of the curve.
<item><tt/"Knot-Type"/: Using <tt/"Knot-Type"/ you may select from
<tt/"NURB"/, <tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Custom"/, <tt/"Chordal"/,
and <tt/"Centripetal"/ knot types.

<p>
The knot type <tt/"NURB"/ will generate uniformly distributed knot values
ranging from 0.0 to 1.0, where the multiplicity of the knots at the
ends will be of order of the curve (the knot vector will be clamped).
This guarantees that the curve will touch the control points at the ends
of the curve.
An example <tt/"NURB"/ knot vector for a curve of length 5 and order 4
would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.5 1.0 1.0 1.0 1.0 }</tt>.

<p>
The knot type <tt/"Bezier"/ will generate just 0.0 and 1.0 values. Note that
the order of the curve has to be equal to the length of the curve if
<tt/"Bezier"/ knots are generated. Otherwise, the generated knot sequence is
illegal. The resulting curve looks and behaves exactly like a real
Bezier curve, interpolating the control points at the ends and so on.
An example <tt/"Bezier"/ knot vector for a curve of length 5 and order 5
would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 }</tt>.

<p>
The knot type <tt/"B-Spline"/ will generate uniformly distributed knot values
(without any multiple knots). The resulting curve looks and behaves like a
B-Spline curve. It is <em>not</em> interpolating the control end points.
An example <tt/"B-Spline"/ knot vector for a curve of length 5 and order 4
would be:

<p>
<tt>{ 0.0 0.125 0.25 0.375 0.5 0.625 0.75 0.875 1.0 }</tt>.

<p>
The knot types <tt/"Chordal"/ and <tt/"Centripetal"/ will generate knot
values whose distribution reflect the distances of the control points.
This only works, if there are free knots in the knot vector,
i.e.~knots that are not subject to clamping or periodic extensions
(the default NURBS curve with 4 control points and order 4 has
<em>none</em>).
For open curves, the generated knot vector will be clamped, for periodic
curves, proper periodic extensions will be created.
Those knot types are mainly useful for curves with unevenly distributed
control points that will be sampled uniformly (in parametric space) later
on and where it is expected, that the uniform sampling in parameter space
results in evenly distributed sample points in coordinate space, e.g.~if
the curves are used as Sweep, Birail, or Clone trajectory, or surfaces
are created from them that use implicit texture coordinates or a uniform
tesselation strategy.
The <tt/"Chordal"/ and <tt/"Centripetal"/ knots will ensure a more uniform
distribution of the sample points on the curve in such cases (see also the
example image below).
An example <tt/"Chordal"/ knot vector for an open curve of length 5 and
order 4 would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.388889 1.0 1.0 1.0 1.0 }</tt>.

The image below illustrates the use of two curves with uniform (NURB) vs.
chordal knot vectors as Sweep trajectories.
The upper Sweep with the uniform knot vector has much more unevenly
distributed/sized sections and exhibits more severe self intersection
problems.
Please note that the shapes of the curves differ slightly.

<figure loc="ht">
<eps file="pics/chordalex.ps" height="6cm">
<img src="pics/chordalex.gif">
<caption>Sweeps Created From Curves With Uniform (upper) And
Chordal (lower) Knot Vectors</caption>
</figure>

<item><tt/"Knots"/ allows to enter own custom knot sequences.
Note that <tt/"Knots"/ are not in use if <tt/"Knot-Type"/ (above)
is of type <tt/"NURB"/, <tt/"B-Spline"/, <tt/"Bezier"/, <tt/"Chordal"/,
or <tt/"Centripetal"/. Note also, that the content of this parameter
will be overwritten, if the knot type is switched to any of the
aforementioned types.

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this curve. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.

<item><tt/"IsRat"/ informs you, whether the curve
is rational (uses weight values different from 1.0).
<footnote>Since 1.9.</footnote>
</itemize>

The GLU-parameters control the appearance of the curve when
curve/surface display is enabled.
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a curve.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ determines how the curve should
be drawn. The control hull (control polygon) or the curve or a
combination of both may be displayed. The setting <tt/"Global"/
means, that the global preference setting
<tt>"Drawing/NCDisplayMode"</tt> should be used.

</itemize>

When changing more than one of the above values the changes will be
applied in the order of the values in the property. The
sum of the changed values should describe a valid NURBS curve.
It is perfectly legal to change the length of the curve,
it's order, and switch to a custom knot vector (be sure to actually
enter a valid new knot vector) at once. Ayam will check your changes
and fall back to certain default values if e.g.~your knot sequence is wrong.
Check the console for any messages after pressing the <tt/"Apply"/ button!
<p>
When the curve type is changed using the NCurveAttr property
Ayam may also have to change the position of some control points
as follows:
<itemize>
<item>When the type is changed from open to closed, the last control
point is moved to be identical to the first one. In addition, if the
current knot type of the curve is <tt/"B-Spline"/, it will be reset to
knot type <tt/"NURB"/.
<item>When the type is changed from open or closed to periodic, the last
p control points will be moved to be identical to the first p, where
p is the degree of the curve (order-1). For a cubic curve (order 4),
consequently, the last three control points will be moved. In addition,
if the current knot type of the curve is <tt/"NURB"/ or <tt/"Bezier"/
it will be changed to <tt/"B-Spline"/ automatically.
</itemize>
When changing the order of a periodic curve (and not
touching the length) Ayam will automatically add or remove control
points to/from the curve so that the shape of the curve remains
largely intact and the periodic extensions plausible.
<footnote>Since 1.18.</footnote>

<sect2>Multiple Points<label id="ncurvemp">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A NURBS Curve with Multiple Points (big handles)</caption>
</figure>
<p>
The NURBS curves of Ayam support so called multiple points.
A multiple point is made of a number of different control points
that have the same coordinates.
Modelling actions will always modify all the control points that
make up a multiple point.
Multiple points will be drawn with a bigger handle than normal points
(see image above).
They may e.g.~be used to create closed curves. Note that the control
points that make up a multiple point do not have to be consecutive
(in the control point vector of the NURBS curve).
Multiple points may be created using the collapse tool,
and split up again using the explode tool (see sections
<ref id="collt" name="Collapse Tool"> and
<ref id="explt" name="Explode Tool"> for more information regarding
those tools).
Note that even though you might have exploded some multiple points
Ayam will re-create them automatically on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
property if they still have identical coordinate values.
In other words, you should immediately edit the control
points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again!
You may also totally inhibit creation of multiple points for a
NURBS curve using the attribute <tt/"CreateMP"/.

<sect2>RIB Export
<p>
NCurve objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>ICurve (Interpolating Curve) Object<label id="icurveobj">
<p>
The ICurve object creates a global interpolating NURBS curve from n
3D non-rational ordered data points.
The curve may be closed, the order of the curve may be configured,
the parameterisation may be adapted, and end derivatives may be specified.
The open versions create n+2 NURBS control points, and the closed ones n+3.
<p>
<figure loc="!ht">
<eps file="pics/icurves.ps" height="7cm">
<img src="pics/icurves.gif">
<caption>Different ICurves resulting from identical data point configurations
(Upper Left: Open, Order 3; Upper Right: Open, Order 4; Lower Left: Closed, Order 3; Lower Right: Closed, Order 4)</caption>
</figure>
<p>
The image above shows some interpolating curves, the left ones
are of order 3 (quadratic curves), the right ones are of order 4 (cubic
curves), the upper open, and the lower closed ones. The interpolation
fidelity for the closed curves was tuned by adjusting the <tt/"SDLen"/
and <tt/"EDLen"/ parameters (all set to 0.2), see also the discussion
of the parameters below.
<p>
In all parameterisation modes, knot averaging will be used
to determine the knot vector of the interpolating curve.
<p>
Note that the axis of symmetry for closed interpolating curves
crosses the first data point (in contrast to open interpolating
or closed approximating curves, where it crosses between the last
and first data point).
For example, the closed interpolating curves in the above example
image are indeed both symmetric, but the axis of symmetry is crossing
the first and third data point and is, thus, rotated by 45 degrees.
<p>
This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g.~revolve, sweep, extrude, and skin) are
able to work with an ICurve object instead of an object
of type NCurve.
<p>
The following table briefly lists some capabilities of the ICurve object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ICurve|No|No|NCurve|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>ICurve Object Capabilities</caption>
</table>
<p>
The following parameters control the interpolation process:

<sect2>ICurveAttr Property<label id="icp"><label id="icurveattrprop">
<p>
<itemize>
<item>The <tt/"Type"/ parameter controls whether the interpolated
curve should be open or closed.

<item><tt/"Length"/ is the number of data points to interpolate.

<item>The next parameter <tt/"Order"/ determines the desired order of the
interpolating curve. If the specified order is bigger than the number of
control points used by the interpolating NURBS curve, then the order is
silently changed to match the number of control points.

<item>The parameter <tt/"ParamType"/ switches the parameterisation
between <tt/"Chordal"/ (default), <tt/"Centripetal"/, and <tt/"Uniform"/.
The centripetal method generates a better parameterisation than
the default (chordal) if the input data contains sharp turns.
The uniform method is available since Ayam 1.20 and generates
worse parameterisations (that lead to wiggles and overshooting)
in the general case but it might help in some edge cases.

<item><tt/"Derivatives"/ allows to choose between automatic and
manual derivatives.


If automatic derivatives are switched on, the direction of the derivatives
will be determined from the first, second, second to last, and last
data points for open curves and from the second and second to last data
points for closed curves. In addition, the respective derivative
vector will be scaled by <tt/"SDLen"/ and <tt/"EDLen"/.

If manual dervivatives are is switched on, two more
editable points appear in the single point editing modes. Those
additional points directly control the derivatives in the
endpoints of the interpolating curve. The parameters <tt/"SDLen"/ and
<tt/"EDLen"/ do not influence those derivatives.

<item>The parameters <tt/"SDLen"/ and <tt/"EDLen"/ are used to control
the length of the first and last derivative (if automatically
generated from the data points, i.e.~when <tt/"Derivatives"/ above is
switched to automatic).

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

The parameters <tt/"Mode"/, <tt/"Closed"/, and <tt/"IParam"/ are gone
since Ayam 1.16. <tt/"Closed"/ was replaced by <tt/"Type"/, <tt/"IParam"/
by <tt/"SDLen"/ and <tt/"EDLen"/, and the <tt/"Mode"/ is now determined
automatically from the desired order.

<sect2>Conversion Support
<p>
The interpolating curve may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ICurve objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>ACurve (Approximating Curve) Object<label id="acurveobj">
<p>
<figure loc="!ht">
<eps file="pics/acurves.ps" height="7cm">
<img src="pics/acurves.gif">
<caption>Different ACurves (Upper Left: ALength 3, Order 3; Upper Right: ALength 4, Order 4; Lower Left: ALength 4, Order 4; Lower Right: ALength 6, Order 3)</caption>
</figure>
<p>
The ACurve object creates an approximating NURBS curve with m control
points from n 3D non-rational ordered data points (see image above).
<footnote>Since 1.15.</footnote>
<p>
The number of data points must be higher than or equal to the number of
control points used. The approximation algorithm used is of the least
squares variety. If the number of control points approaches the number
of data points, undesired wiggles in the output curve may occur.
<p>
This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g.~revolve, sweep, extrude, and skin) are
able to work with an ACurve object instead of an object
of type NCurve.
<p>
The following table briefly lists some capabilities of the ACurve object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ACurve|No|No|NCurve|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>ACurve Object Capabilities</caption>
</table>
<p>
The following parameters control the approximation process:

<sect2>ACurveAttr Property<label id="acp"><label id="acurveattrprop">
<p>
<itemize>
<item>Using <tt/"Length"/ you determine the number of data points to
approximate.

<item>Using <tt/"ALength"/ you determine the number of (distinct)
control points to use for the approximating NURBS curve.
The total number of distinct control points must be smaller than or equal
to the number of data points.

<item>The curve can be closed with the parameter <tt/"Closed"/.
For closed approximations, the total number of control points will
be <tt/"ALength + Order - 1"/.
The following table illustrates this relationship.

<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Length/|<bf/ALength/|<bf/Order/|<bf/Closed/|<bf/Output Length/@<hline>
10|5|3|No|5@<hline>
10|5|3|Yes|8@<hline>
10|4|4|Yes|8@<hline>
5|4|3|No|4@<hline>
5|4|3|Yes|7<#if out=latex>@<hline></#if>
</tabular>
<caption>ACurve Parameterisation Examples</caption>
</table>
<p>

<item>For symmetric data point configurations, the approximating curve
is not necessarily symmetric. With the parameter <tt/"Symmetric"/
a symmetric result can be enforced (see image below), albeit at the
cost of about double runtime and a slightly worse parameterisation.
<p>
<figure loc="!ht">
<eps file="pics/acurve-sym.ps" height="4cm">
<img src="pics/acurve-sym.gif">
<caption>Left: asymmetric ACurve, Right: symmetric ACurve</caption>
</figure>

<item>The parameter <tt/"Order"/ specifies the desired order
of the approximating NURBS curve. Currently, only orders higher than
2 are supported.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect2>Conversion Support
<p>
The approximating curve may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ACurve objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>NCircle (NURBS Circle) Object<label id="ncircleobj">
<p>
<figure loc="ht">
<eps file="pics/ncircles.ps" height="5cm">
<img src="pics/ncircles.gif">
<caption>Different NCircle Objects (l: default, m: TMax 180, r: Radius 0.5, TMax 200)</caption>
</figure>
<p>
The NCircle object creates a circular NURBS curve or a circular arc in
the XY plane centered at the origin with designated radius and start/end
angles (see image above).
<footnote>Since 1.12.</footnote>
<p>
In order to revert the created NURBS curve
the start/end angles may be used, e.g.~<tt/"TMin"/ 0.0,
<tt/"TMax"/ -360.0 for a reverse full circle.
<footnote>Since 1.15.</footnote>
<p>
The following table briefly lists some capabilities of the NCircle object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCircle|No|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>NCircle Object Capabilities</caption>
</table>
<p>
The following section describes the parameters of the circle or
arc.

<sect2>NCircleAttr Property<label id="ncircleattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the circle.

<item><tt/"TMin"/ (ThetaMin) controls the starting angle of the circle
or arc to be created. Negative values are allowed.

<item><tt/"TMax"/ (ThetaMax) controls the end angle of the circle
or arc to be created. Negative values are allowed.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect2>Conversion Support
<p>
The circular curve/arc may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
NCircle objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>ConcatNC (Concatenate NURBS Curves) Object<label id="concatncobj">
<p>
<figure loc="ht">
<eps file="pics/concatnc.ps" height="5cm">
<img src="pics/concatnc.gif">
<caption>ConcatNC Object (blue) from a Linear Curve and 3 Instances (white)</caption>
</figure>
<p>
The ConcatNC object concatenates all child objects (which should be
NURBS curves or provide NURBS curves) to a single NURBS curve. Since
the ConcatNC object also provides a NURBS curve, it is possible to
use it as child object for another ConcatNC object (with possibly
different parameters) or as a parameter object for a tool object that
works with NURBS curves such as Revolve or Extrude.
<p>
The concatenation process works as follows:
<enum>
<item>The orders of all parameter curves will be elevated to the maximum
order of all the parameter curves (see also section
<ref id="elevt" name="elevate tool"> for more information on elevation)
and all curves will be clamped (see also section
<ref id="clat" name="clamp tool"> for more information on clamping).
<item>If the parameter <tt/"FillGaps"/ is enabled, fillet curves will be
created for every gap between the parameter curves of the ConcatNC object.
If <tt/"Closed"/ and <tt/"FillGaps"/ are enabled, an additional fillet
is created to close the curve.
<item>Now the control points of all parameter curves and fillets are simply
copied into a new big control point vector, without checking for double
points. This means that for parameter curves that touch at their
respective ends, atleast double control points in the new concatenated
curve will result.
<item>If <tt/"Closed"/ is enabled, the curve will be closed.
</enum>
<p>
The knot sequence of the new concatenated curve will be of type
<tt/"NURBS"/ or a custom knot vector will be computed (depending
on the setting of <tt/"Knot-Type"/).
If <tt/"Knot-Type"/ is <tt/"NURBS"/, the shape of the concatenated curve
will differ from the parameter curves if any of the parameter curves has
a custom knot vector with non equidistant knots. If <tt/"Knot-Type"/ is
<tt/"Custom"/, the shape of the parameter curves will be preserved.
<p>
Attributes like display mode and tolerance for the new concatenated curve
are simply taken from the first parameter curve.

<#if out=latex><x/newpage/</#if>

The following table briefly lists some capabilities of the ConcatNC object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNC|NCurve+|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>ConcatNC Object Capabilities</caption>
</table>
<p>
The following parameters further control the concatenation process:

<sect2>ConcatNCAttr Property<label id="concatncp"><label id="concatncattrprop">
<p>
<itemize>
<item>Using <tt/"Closed"/ a closed concatenated curve may be created,
even if the parameter curves do not touch.
If also <tt/"FillGaps"/ (see below) is enabled, an additional fillet will
be created for the last and the first child curve to close
the concatenated curve. If <tt/"FillGaps"/ is not enabled,
the concatenated curve will be closed with the same algorithm
that is also used by the close curve tool (possibly changing
its shape).

<item>If <tt/"Revert"/ is enabled, the orientation of the concatenated
curve will be reversed.

<item><tt/"FillGaps"/ creates fillet curves for all gaps between
the parameter curves of the ConcatNC object. No fillet will be created
if the end points of two parameter curves match.

<p>
The fillet curves will initially be created from four control
points. The outer fillet control points are the parameter curve end points
and the inner fillet control points will be positioned on the tangent
of the respective parameter curve end point (see also the discussion
of <tt/"FTLength"/ below). Thus, the transitions between parameter
curve and fillet should be atleast G1 continuous.
Degree elevation will be used to raise the degree of the fillet to
that of the concatenated curve; this may introduce additional
control points in the fillet but its shape does not change and the
transition continuity is also not affected.

If the order of the resulting concatenated curve is 2, only simple
fillets, connecting the parameter curves by straight lines, will
be generated.

<item><tt/"FTLength"/ determines the distance of the inner fillet
control points from their respective end points. This value can
be adapted for smaller&thinsp;/&thinsp;larger gaps between parameter
curves.

<item><tt/"Knot-Type"/ sets the knot type of the concatenated curve:
<itemize>
<item>If <tt/"Knot-Type"/ is <tt/"NURB"/ a simple knot vector
with equidistant knots is generated, which leads to a concatenated curve
that does not exactly preserve the shapes of the original curves.
Furthermore, all transitions between parameter curves are always smoothed
out.

<item>If <tt/"Knot-Type"/ is <tt/"Custom"/, the knot vector is composed from
the knot vectors of the original curves, and thus, their
shapes may be preserved completely. This also applies to potential
discontinuities in transitions.

<p>
However, this comes at the price of internal knots with high multiplicity.
Note that such a curve is <em>not</em> differentiable in all places anymore.
</itemize>
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect2>Conversion Support
<p>
The concatenated curve may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ConcatNC objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>ExtrNC (Extract NURBS Curve) Object<label id="extrncobj">
<p>
<figure loc="ht">
<eps file="pics/extrnc.ps" height="5cm">
<img src="pics/extrnc.gif">
<caption>Extracted Curves (white) from Arbitrarily Shaped Surface (blue)</caption>
</figure>
<p>
The ExtrNC object extracts a NURBS curve from a NURBS patch object,
for use as parameter object for other tool objects, like
e.g.~Revolve (see image above).
It also works with NURBS patch providing objects, so that
the following example hierarchy is valid:
<tscreen><verb>
--NPatch
+-Skin
 +-ExtrNC
 |\ Instance_of_NPatch(Instance)
 \ NCurve
</verb></tscreen>
Depending on the parameters of the ExtrNC object, the Skin object
above will have one boundary in common with a boundary or an iso-curve
of the NPatch object.
Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNC object. Therefore, the main menu entry
<tt>"Tools/Create/ExtrNC"</tt>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNC object.
<p>
As the geometry of the extracted curve is completely defined by
the master surface, ExtrNC objects do not support own transformation
attributes.
<footnote>Since 1.19.</footnote>
<p>
Note that the extraction of any curves currently completely ignores
potentially present trimming information of the NPatch object.
<p>
The following table briefly lists some capabilities of the ExtrNC object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ExtrNC|NPatch|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>ExtrNC Object Capabilities</caption>
</table>
<p>
The extraction process is controlled by the following attributes:

<sect2>ExtrNCAttr Property<label id="extrncp"><label id="extrncattrprop">
<p>
<itemize>
<item><tt/"Side"/ controls which curve should be extracted from the
surface.
Available values are:
<itemize>
<item><tt/"U0"/, <tt/"Un"/: extract upper or lower
boundary curve (along width);
<item><tt/"V0"/, <tt/"Vn"/: extract left or right
boundary curve (along height);
<item> <tt/"U"/, <tt/"V"/
extract curve along width and height respectively at specified parametric
value (see below).
<footnote>Since 1.8.1.</footnote>
<item><tt/"Boundary"/: extract the complete boundary curve of the patch.
<footnote>Since 1.13.</footnote>
<item><tt/"Middle_U"/, <tt/"Middle_V"/: create a curve from the patch
data that is the "middle axis" (simply the medium of all control points
of a patch in the designated dimension).
<footnote>Since 1.15.</footnote><newline>
This option is useful to re-engineer swept surfaces, delivered
as simple patches.
</itemize>
Note that if <tt/"Side"/ is <tt/"U0"/, <tt/"Un"/, <tt/"V0"/, or <tt/"Vn"/
the extraction process just copies the respective boundary control points,
which only works for clamped knot vectors. To extract a boundary from
a surface with e.g.~a B-Spline knot vector, one should <em/not/ use <tt/"U0"/
but <tt/"U"/ with <tt/"Parameter"/ set to 0.0 and <tt/"Relative"/ enabled
as <tt/"U"/ uses a different, more expensive, extraction process (which
involves knot insertion).

<item><tt/"Parameter"/ controls the parametric value in U or V
direction in the parameter space of the NURBS patch object where the
curve should be extracted. This parameter is only used when <tt/"Side"/
is <tt/"U"/ or <tt/"V"/. The valid range of parameter values depends
on the knot vectors of the NURBS patch.

<item><tt/"Relative"/ controls whether the parametric value should
be interpreted in a relative way. If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector, regardless of the
actual knot values, and the valid range for <tt/"Parameter"/ is
then consequently 0.0-1.0.
<footnote>Since 1.15.</footnote>

<item><tt/"Revert"/ immediately reverts the extracted curve.

<item><tt/"CreatePVN"/ controls creation of a PV tag that contains
the normals (derived from the surface control points) on the surface.
This PV tag can then be used to control a 3D offset curve.

<item><tt/"PatchNum"/ allows to select a patch from a list of
patches delivered e.g.~by a beveled Extrude object as child
of the ExtrNC object.
This way it is possible to extract a curve from a bevel or cap
surface of e.g.~said Extrude object.
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the extracted NURBS curve.
</itemize>
<p>
See section <ref id="ncattr" name="NCurveAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Conversion Support
<p>
The extracted curve may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ExtrNC objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>OffsetNC (Offset NURBS Curves) Object<label id="offsetncobj">
<p>
<figure loc="ht">
<eps file="pics/offnc.ps" height="5cm">
<img src="pics/offnc.gif">
<caption>Offset Curves (white) from NURBS Curves (blue) with Offset 0.2, -0.2, and 0.3</caption>
</figure>
<p>
The OffsetNC object creates offset curves from planar NURBS curves using
four different algorithms.
<footnote>Since 1.14.</footnote><newline>
The offset curve will always match the original curve in type, length, order,
and knots. See also the image above.
<p>
The available offset algorithms are:

<bf/<tt/Point//<newline>
offsets each control point along the normal derived from the surrounding
control points; the offset curve created by this algorithm may come too
near the original curve at sharp convex features whose exact forms are
not preserved well either,

<bf/<tt/Section//<newline>
this algorithm offsets all control polygon sections in the direction of their
normal and places new control points at intersection points of the lines
defined by the offset sections; this algorithm is better in avoiding self
intersections of the offset curve but the offset curve may be too far away
from the original curve at sharp convex or concave features
(regions of high curvature),

<bf/<tt/Hybrid//<newline>
this algorithm offsets the curve two times using the Point and Section
algorithms and then mixes the results so that the bad
features of the two algorithms cancel out each other,
<footnote>Since 1.19.</footnote>

<bf/<tt/3DPVN//<newline>
Since Ayam 1.18 there is a fourth offsetting algorithm available, that
creates true three dimensional offsets from non planar curves using
a primitive variable tag that contains normal information for the curve
(vertex normals). Such tags can be created manually or automatically
e.g.~when extracting curves from surfaces using the <tt/"ExtrNC"/ object.
<p>
As the geometry of the offset curve is completely defined by
the master curve, OffsetNC objects do not support own transformation
attributes.
<footnote>Since 1.19.</footnote>
<p>
The <tt/"Bevel3D"/ offset algorithm has been removed since Ayam 1.19.
<p>
The following table briefly lists some capabilities of the OffsetNC object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
OffsetNC|NCurve|No|NCurve|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>OffsetNC Object Capabilities</caption>
</table>
<p>
The following parameters further control the offsetting process:

<sect2>OffsetNCAttr Property<label id="offsetncp"><label id="offsetncattrprop">
<p>
<itemize>
<item>The first parameter <tt/"Mode"/ determines, which algorithm
to use for the offsetting process.

<item>Using <tt/"Revert"/ you may revert the direction of the
offset curve.

<item><tt/"Offset"/ determines the distance between original curve and
offset curve. Negative values are allowed.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect2>Conversion Support
<p>
The offset curve may be converted to an ordinary NURBS curve using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
OffsetNC objects never directly appear in RIB output (only indirectly as trim
curve).

<#if out=latex><x/newpage/</#if>

<sect1>NPatch (NURBS Patch) Object<label id="npatchobj">
<p>
<figure loc="ht">
<eps file="pics/npatch.ps" height="5cm">
<img src="pics/npatch.gif">
<caption>NURBS patch: surface (blue) from control polygon (white)</caption>
</figure>
<p>
The NPatch object allows to model NURBS surfaces in a direct way, e.g.~by
modifying control points (see also the image above). Note that using
NPatch objects should be seen as last resort, only to be used when the
flexibility of all the NURBS surface creating tool objects is not high
enough to achieve a certain shape.
<p>
Like NCurve objects, NPatch objects mark their last control point with
a small arrow. Note that the arrow points in the V direction (height).
<p>
NPatch objects also support the concept of multiple points, see section
<ref id="ncurvemp" name="Multiple Points">
for more information regarding this.
<footnote>Since 1.10.</footnote>
<p>
The following table briefly lists some capabilities of the NPatch object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NPatch|NCurve+/Level+|Yes|PolyMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>NPatch Object Capabilities</caption>
</table>

<sect2>NPatchAttr Property<label id="npattr"><label id="npatchattrprop">
<p>
The first section of the NPatchAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
Similar to the <tt/"Length"/ parameter of the NCurve object, changes to
<tt/"Width"/ or <tt/"Height"/ add or remove internal control points
(i.e.~to double the resolution of a 4 by 4 NURBS patch in U direction,
change the <tt/"Width"/ from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).

<item><tt/"Order_U"/ and <tt/"Order_V"/ set the orders of the patch.

<item><tt/"Knot-Type_U"//<tt/"Knot-Type_V"/ and
<tt/"Knots_U"//<tt/"Knots_V"/: For a discussion of the
<tt/"Knot-Type"/ and <tt/"Knots"/ parameters,
please see section <ref id="ncattr" name="NCurveAttr">.

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this surface. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.
<footnote>Since 1.10.</footnote>

<item><tt/"IsRat"/ informs you, whether the patch
is rational (uses weight values different from 1.0).
<footnote>Since 1.9.</footnote>
</itemize>

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn (<tt/"ControlHull"/), or just the outlines of the polygons
created by the tesselation (<tt/"OutlinePolygon"/), or just the
outlines of the patch (<tt/"OutlinePatch"/). The default setting
(<tt/"Global"/) means, that the value of the global preference setting
<tt>"Drawing/NPDisplayMode"</tt> should be used instead.
</itemize>

<sect2>Trim Curves<label id="trim">
<p>
Trim curves may be used to cut out certain parts of a NURBS patch.
They are simple 2D NURBS curves defined in the parametric space
of the associated NURBS patch. Trim curves have to be defined as child
objects of the NURBS patch object they belong to. In contrast to other
child objects, however, they do not inherit the transformation attributes
of the parent object. Trim curve editing should take place in views
of type <tt>Trim</tt>, that draw the boundaries of the parametric
space of the corresponding NURBS patch as rectangle, but otherwise
act as normal <tt>Front</tt> views.
<p>
Note that the direction of the trim curve determines which part of
the NURBS patch should be cut out. You can use the <tt/Revert/ tool
(<tt>Tools/NURBCurve</tt> menu) to easily change the direction
of a trim curve.
<p>
Some special restrictions apply to trim curves:
<itemize>
<item>All trim curves should entirely lie in the (u,v) parameter
space of the NURBS patch (remember the rectangle in the <tt>Trim</tt> view).
Note that this restriction does not apply to the control points,
but the curves! It is ok to have control points outside the
rectangle if the defined curve is inside the rectangle.

<item>The last point of a trim curve must be identical
to the first point.

<item>Trim loops (multiple trim curves that form loops) are possible too;
the last point of each curve in the loop must be identical to the first
point of the next curve in the loop and the first point of the first curve
of a loop must be identical to the last point of the last curve of that
loop.

<item>To mark a set of curves to be a loop, they must be placed in a level
object. The order of the curves in this level is the order of the loop.
The transformation attributes of this level object are fully ignored for
trimming.

<item>Drawing trimmed NURBS patches with certain implementations of
OpenGL may require a special trim curve (a rectangular piecewise linear
curve that encloses the whole NURBS patch) to be present. Such a curve
may be generated with the <tt/TrimRect/ tool. You can find this tool in
the <tt>"Tools/Create"</tt> menu. This curve is needed if you want to cut
out a hole with a single trim curve. This curve is generally not needed
if you want to render the patch with BMRT but it should not hurt if it
is present.

<item>If there are nested trim curves, their direction must alternate.

<item>Trim curves may not intersect each other or themself.
</itemize>
Note that Ayam is not checking whether your trim curves
follow these rules.
<p>
Warning: Certain OpenGL implementations may be easily crashed
drawing trimmed NURBS patches with trims that do not follow the
aforementioned rules. When in doubt or while heavy modelling,
switch to wireframe drawing and switch off shading temporarily
and you will be on the safe side.
<p>
NURBS curve providing objects are also supported as trim curves.
<footnote>Since 1.5.</footnote>

<sect2>Conversion Support
<p>
A NPatch object may be converted to a PolyMesh object using the
main menu entry <tt>"Tools/Convert"</tt>.
<p>
This process is also called tesselation and thus, the tesselation
parameters from TP tags will be used in the conversion process (if present)
(see also section <ref id="tptag" name="TP Tag">).

<sect2>RIB Export
<p>
NPatch objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
PV tags are supported and also trim curves may appear.

<#if out=latex><x/newpage/</#if>

<sect1>IPatch (Interpolating Patch) Object<label id="ipatchobj">
<p>
<figure loc="ht">
<eps file="pics/ipatch.ps" height="5cm">
<img src="pics/ipatch.gif">
<caption>Interpolating surface (blue) from data points (white)</caption>
</figure>
<p>
A IPatch forms a surface defined by interpolating a regular grid
of three dimensional and non rational data points (see also the
image above).
<p>
The following table briefly lists some capabilities of the IPatch object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
IPatch|No|Yes|NPatch|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>IPatch Object Capabilities</caption>
</table>

<sect2>IPatchAttr Property<label id=ipattr><label id="ipatchattrprop">
<p>
The IPatchAttr property contains the following elements:
<itemize>
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
Similar to the <tt/"Length"/ parameter of the NCurve object, changes to
<tt/"Width"/ or <tt/"Height"/ add or remove internal control points
(i.e.~to double the resolution of a 4 by 4 interpolating patch in U direction,
change the <tt/"Width"/ from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).

<item><tt/"Order_U"/ and <tt/"Order_V"/ set the desired interpolation
orders of the patch. If any of these values is set to 2, no explicit
interpolation will take place in this dimension (the surface will
implicitly interpolate the data points due to the low order).

<item><tt/"Close_U"/ and <tt/"Close_V"/ allow to create closed
surfaces in the respective dimension.

<item><tt/"Knot-Type_U"/ and <tt/"Knot-Type_V"/ switches the parameterisation
between <tt/"Chordal"/ (default), <tt/"Centripetal"/, and <tt/"Uniform"/.
The centripetal method generates a better parameterisation than
the default (chordal) if the input data contains sharp turns.
The uniform method generates worse parameterisations (that lead to
wiggles and overshooting)
in the general case but it might help in some edge cases.

<item><tt/"Deriv_U"/ and <tt/"Deriv_V"/ toggle whether

<itemize>
<item><tt/"None"/: no end derivatives,

<item><tt/"Automatic"/: automatically created (from data points)
derivatives, scaled by the additional parameters
<tt/"SDLen_U"/, <tt/"EDLen_U"/, <tt/"SDLen_V"/, and<tt/"EDLen_V"/,

<item><tt/"Manual"/: completely manually controlled end derivatives
(appearing as additional control points in point editing, if enabled)
</itemize>
should be used in the interpolation.
</itemize>

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn (<tt/"ControlHull"/), or just the outlines of the polygons
created by the tesselation (<tt/"OutlinePolygon"/), or just the
outlines of the patch (<tt/"OutlinePatch"/). The default setting
(<tt/"Global"/) means, that the value of the global preference setting
<tt>"Drawing/NPDisplayMode"</tt> should be used instead.
</itemize>
<itemize>
<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the created NURBS patch.
</itemize>

<sect2>Conversion Support
<p>
The interpolated surface may be converted to an ordinary NURBS patch
using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
IPatch objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
PV tags are currently not supported.

<#if out=latex><x/newpage/</#if>

<sect1>BPatch (Bilinear Patch) Object<label id="bpatchobj">
<p>
<figure loc="ht">
<eps file="pics/bpatch.ps" height="5cm">
<img src="pics/bpatch.gif">
<caption>Bilinear Patch</caption>
</figure>
<p>
A BPatch is a simple bilinear patch defined by four control
points. BPatch objects are e.g.~used internally to build box objects,
see also <ref id="boxobj" name="Box Object">.
<p>
The following table briefly lists some capabilities of the BPatch object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
BPatch|No|Yes|NPatch|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>BPatch Object Capabilities</caption>
</table>

<sect2>BPatchAttr Property<label id=bpattr><label id="bpatchattrprop">
<p>
The BPatchAttr property allows to directly control the
four points defining the geometry of the patch:<p>
<itemize>
<item><tt/"P1_X"/, <tt/"P1_Y"/, <tt/"P1_Z"/, first point.
<item><tt/"P2_X"/, <tt/"P2_Y"/, <tt/"P2_Z"/, second point.
<item><tt/"P3_X"/, <tt/"P3_Y"/, <tt/"P3_Z"/, third point.
<item><tt/"P4_X"/, <tt/"P4_Y"/, <tt/"P4_Z"/, fourth point.
</itemize>

<sect2>Conversion Support
<p>
The bilinear patch may be converted to an ordinary NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
BPatch objects will be exported as bilinear patch primitives:
<tscreen>
<tt>RiPatch(RI_BILINEAR, ...);</tt>
</tscreen>
PV tags are supported.

<#if out=latex><x/newpage/</#if>

<sect1>PatchMesh Object<label id="patchmeshobj">
<p>
<figure loc="ht">
<eps file="pics/pamesh.ps" height="5.5cm">
<img src="pics/pamesh.gif">
<caption>Bicubic (left) and Bilinear (right) PatchMesh Surfaces (blue) from their Respective Control Polygons (white)</caption>
</figure>
<p>
The PatchMesh object may be used to model with bilinear and
bicubic patch meshes.
<p>
Like NCurve objects, PatchMesh objects mark their last control point with
a small arrow. Note that the arrow points in the V direction (height).
<p>
The following table briefly lists some capabilities of the PatchMesh object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PatchMesh|No|Yes|NPatch|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>PatchMesh Object Capabilities</caption>
</table>

<sect2>PatchMeshAttr Property<label id="pmattr"><label id="patchmeshattrprop">
<p>
The first section of the PatchMeshAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Type"/ may be set to <tt/"Bilinear"/ or <tt/"Bicubic"/.
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
<item><tt/"Close_U"/ and <tt/"Close_V"/ determine, whether the patch
mesh should be closed in U and V direction respectively.
<item><tt/"BType_U"/ and <tt/"BType_V"/ control the basis type
for bicubic patches. You may choose between the basis types:
<tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Catmull-Rom"/,
<tt/"Hermite"/, and <tt/"Custom"/.
In the latter case (<tt/"Custom"/), additional parameters may be set.
Those are <tt/"Step_U"//<tt/"Step_V"/ (the stepsize of the basis) and
<tt/"Basis_U"//<tt/"Basis_V"/ the basis itself
(please see the RenderMan Companion for a discussion of basis types).
</itemize>
The parameters <tt/"BType_U"/ and <tt/"BType_V"/ and consequently
<tt/"Step_U"//<tt/"Step_V"/ and <tt/"Basis_U"//<tt/"Basis_V"/ are
only available to bicubic patch meshes.

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<tt>"Drawing/DisplayMode"</tt> should be used.
</itemize>

<sect2>Conversion Support
<p>
The patch mesh may be converted to an ordinary NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>.
However, this does not work for all possible types of patch meshes
(e.g.~patch meshes with the basis types Catmull-Rom, Hermite, or
Custom can not be converted, currently).
An internal NURBS patch representation is also in use when drawing
the patch mesh (if the <tt/"DisplayMode"/ is not <tt/"ControlHull"/)
and when shading the patch mesh.
Consequently, there is currently no shaded representation of patch meshes
of basis type Catmull-Rom, Hermite or Custom.

<sect2>RIB Export
<p>
PatchMesh objects will be exported as patch mesh primitives:
<tscreen>
<tt>RiPatchMesh(...);</tt>
</tscreen>
PV tags are supported.

<#if out=latex><x/newpage/</#if>

<sect1>PolyMesh Object<label id="polymeshobj">
<p>
The PolyMesh object may be used to include objects that
have been modeled using the polygonal modelling paradigm
in Ayam scenes.
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g.~curves.
<p>
The PolyMesh object is equivalent to the general points polygons
primitive of the RenderMan interface. This means, each PolyMesh
object may contain multiple general (convex or concave) polygons,
which in turn may consist of an outer loop and an arbitrary number
of inner loops that describe holes in the polygon. The loops use a point
indexing scheme to efficiently reuse coordinate values.
This general approach requires a so called tesselation to be carried
out, in order for the PolyMesh object to be shaded.
For the tesselation, Ayam uses routines of the GLU library.
<p>
Ayam is able to automatically create face normals for PolyMeshes.
They will be calculated while tesselating the PolyMesh and be
perpendicular to the plane determined by the first three vertices
of the outer loop of a polygon.
Furthermore, Ayam supports vertex normals (normals stored for every
control point).
<p>
Note that storing a bunch of triangles each in its own PolyMesh
object will lead to a real waste of memory. You may use the
merge tool (main menu <tt>"Tools/PolyMesh/Merge"</tt>) to merge
many PolyMesh objects into a single PolyMesh object.
<p>
The following table briefly lists some capabilities of the PolyMesh object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PolyMesh|No|Yes|SDMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>PolyMesh Object Capabilities</caption>
</table>

<sect2>PolyMeshAttr Property<label id="pomattr"><label id="polymeshattrprop">
<p>
The PolyMeshAttr GUI just displays some information about the
PolyMesh object:
<itemize>
<item><tt/"NPolys"/ the number of polygons.
<item><tt/"NControls"/ the total number of control points
defined.
<item><tt/"HasNormals"/ is 1 if the object uses vertex normals,
else it is 0.
</itemize>

<sect2>Conversion Support
<p>
PolyMesh objects may be converted to SDMesh
objects using the main menu entry <tt>"Tools/Convert"</tt>.
<footnote>Since 1.11.</footnote>

Note that no verification of the usability of the
mesh as base mesh for a subdivision surface is carried out.
Usually, such meshes have to be manifold and may not contain
T-junctions.

<sect2>RIB Export
<p>
PolyMesh objects will be exported as RiPointsGeneralPolygons primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.~a RiGeneralPolygon).
<p>
PV tags are supported.

<#if out=latex><x/newpage/</#if>

<sect1>SDMesh Object<label id="sdmeshobj">
<p>
<figure loc="ht">
<eps file="pics/sdmesh.ps" height="6cm">
<img src="pics/sdmesh.gif">
<caption>SDMesh object with original polygonal mesh (blue)</caption>
</figure>
<p>
The SDMesh object may be used to include objects that
have been modeled using the subdivision modelling paradigm
in Ayam scenes (see also the image above).
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g.~curves.
<p>
The SDMesh object is equivalent to the Subdivision Mesh
primitive of the RenderMan interface. This means, each SDMesh
object may contain multiple faces with arbitrary number
of vertices that form a polygonal mesh. This polygonal mesh is
then successively refined using a subdivision scheme and, depending
on the number of refinement (or subdivision) steps, results in
a more or less smooth surface. There are several different
subdivision schemes, but the scheme currently supported
by most RenderMan compliant renderers is named "Catmull-Clark".
<p>
Tags may be specified for faces, edges, or vertices
to control the subdivision process (e.g.~to create sharp corners or edges
in the resulting surface). All tags known from the RenderMan interface
(hole, crease, corner, and interpolateboundary) are supported by Ayam,
but they may currently not be changed by the user.
<p>
Unless the <tt/"subdiv"/ plugin (available since Ayam 1.19) is loaded,
Ayam is not able to do the subdivision and show the resulting smooth
surface. All that is shown in wireframe and shaded views is the original
polygonal mesh.
<p>
The following table briefly lists some capabilities of the SDMesh object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
SDMesh|No|Yes|PolyMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>SDMesh Object Capabilities</caption>
</table>

<sect2>SDMeshAttr Property<label id="sdmattr"><label id="sdmeshattrprop">
<p>
The SDMeshAttr GUI just displays some information about the
SDMesh object:
<itemize>
<item><tt/"Scheme"/, is the subdivision scheme, currently available
schemes are Catmull-Clark and Loop.
<footnote>Since 1.11.</footnote>
<item><tt/"Level"/ is the number of subdivision steps that should
be carried out when subdividing the mesh for preview. This subdivision
needs the <tt/"subdiv"/ plugin.
<item><tt/"DrawSub"/ allows to switch between the control polygon
and the subdivided polygon outlines when drawing the mesh.
<item><tt/"NFaces"/, the number of faces.
<item><tt/"NControls"/, the total number of control points
defined.
</itemize>

<sect2>Conversion Support
<p>
SDMesh objects may be converted to PolyMesh objects.
<footnote>Since 1.11.</footnote>

Note however that only the original, unrefined, control
polygon (i.e.~the base mesh) will be converted unless the <tt/"Level"/
attribute is not zero <em>and</em> the <tt/"subdiv"/ plugin is loaded.

<sect2>RIB Export
<p>
SDMesh objects will be exported as subdivision mesh primitives:
<tscreen>
<tt>RiSubdivisionMesh(...);</tt>
</tscreen>
PV tags are supported.

<#if out=latex><x/newpage/</#if>

<sect1>Revolve Object<label id="revolveobj">
<p>
<figure loc="ht">
<eps file="pics/revolve.ps" height="5cm">
<img src="pics/revolve.gif">
<caption>Revolve Object (left: Curve, right: Surface of Revolution)</caption>
</figure>
<p>
The Revolve object forms a surface of revolution from a NURBS curve.
<p>
The Revolve object has the generating NURBS curve as child object
and watches its changes and adapts to it automagically.
<p>
The axis of revolution is always the Y axis.
The parameter curve should be defined in the XY plane.
If not, it will be squashed down to this plane before revolving it.
<p>
The following table briefly lists some capabilities of the Revolve object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Revolve|NCurve|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Revolve Object Capabilities</caption>
</table>

<sect2>RevolveAttr Property<label id="rep"><label id="revolveattrprop">
<p>
The parameter <tt/"ThetaMax"/ specifies the
sweeping angle of the revolution just like for an ordinary
RenderMan quadric primitive.
<p>
The Revolve object also supports a B-Spline mode
that may be enabled by setting the parameter <tt/"Sections"/
to a value higher than 0.
<footnote>Since 1.8.</footnote>
In this mode, a circular B-Spline is
used as basis for the surface of revolution instead of the
standard NURBS circle. Depending on the number of sections
chosen, the surface of revolution does not exactly interpolate
the parameter curve, but the surface may be edited more easily
after a possible conversion to an ordinary NURBS patch object,
because the control points will not be rational if the revolved
curve is also not rational.<newline>
Note that also the B-Spline mode can realize arbitrary
<tt/"ThetaMax"/ values.
<footnote>Since 1.18.</footnote>
<p>
In addition to the number of sections, in B-Spline mode it is
possible to control the order of the surface of revolution
using the parameter <tt/"Order"/. If <tt/"Order"/ is 0,
a standard value of 3 will be used.
<p>
The revolve object can automatically generate caps,
which are trimmed NURBS patches. Using the parameters
<tt/"UpperCap"/, <tt/"LowerCap"/, <tt/"StartCap"/, and <tt/"EndCap"/,
you determine whether such caps should be
generated, default is off (no caps).
<p>
If the side caps of a surface of revolution of an open
curve are not created correctly, GLU complains about
"intersecting or misoriented trim curves",
try to revert the revolved curve.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Conversion Support
<p>
The surface of revolution and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If caps are present, an enclosing Level object will be created
and the caps follow the surface of revolution in the following
order: upper, lower, start, end.
<p>
The Revolve object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Revolve objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps are present, those follow as trimmed NURBS patch primitives
in the following order: upper, lower, start, end.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Extrude Object<label id="extrudeobj">
<p>
<figure loc="ht">
<eps file="pics/extrude.ps" height="4cm">
<img src="pics/extrude.gif">
<caption>Extrude Object (left: Curve, middle: normal Extrusion,
right: Extrusion with Caps)</caption>
</figure>
<p>
The extrude object forms an extrusion from a number of planar NURBS curves.
<p>
The first curve determines the outline and the other curves determine
holes in the extrusion object. Holes may be used by objects that form
e.g.~letters.
<p>
The object has the generating NURBS curves as child objects,
watches them and adapts to them automagically.
<p>
Consequently, the object hierarchy of an Extrude object may look like this:
<tscreen><verb>
+-Extrude
 | Outline(NCurve)
 | [Hole_1(NCurve)
 | ...
 \ Hole_n(NCurve)]
</verb></tscreen>
<p>
The extrude object can generate caps, if the generating
curves are closed. Cap generation may fail, if the outer
curve has weights and the curve itself leaves the convex
hull of the control polygon. Be careful when using curves
with weights!
<p>
The sharp corners between caps and extrusion may be beveled.
<p>
The axis of the extrusion is always the Z axis.
The parameter curves should be defined in the XY plane.
If not, they will be squashed down to this plane.
See section
<ref id="toxyt" name="To XY Tool"> for information on
how to easily achieve curves in the XY plane.
<p>
The dimensions and orders of the extruded surface(s) will be taken from the
respective parameter curves as follows: width and order in U direction
will be 2, height and order in V direction are taken from the parameter
curve.
<p>
The following table briefly lists some capabilities of the Extrude object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Extrude|NCurve+|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Extrude Object Capabilities</caption>
</table>

<sect2>ExtrudeAttr Property<label id="extrattr"><label id="extrudeattrprop">
<p>
The parameter <tt/"Height"/ determines how
big in Z direction the extrusion should be. Note that
the height of the bevels will not be taken into account here,
if the extrusion height is 1.0 and beveling (upper and lower) is
switched on with radius 0.1 the resulting object extends 1.2 units in
Z direction.
<p>
The extrude object can automatically generate caps,
that are trimmed NURBS patches. Using <tt/"StartCap"/ and
<tt/"EndCap"/ you determine whether such caps should be generated,
default is off (no caps). Note that this feature does only work
properly, if the generating NURBS curves are closed and not self
intersecting, this is because the generating curves themselves are
used as trim curves for the caps. Warning, Ayam will not check whether
the parameter curves conform to these criteria. Ayam, however,
automatically detects the correct orientation of the curves (and
reverts them if necessary).
<p>
Since Ayam 1.10 the bevel parameters of the extrude object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, and <tt/"BevelRadius"/ are no
longer available. They were replaced with new dynamic tag creating
bevel property GUI sections that are accessible through the new
command entries <tt/"Add Start Bevel!"/ and <tt/"Add End Bevel!"/
respectively. If one of those entries is used, a corresponding
bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Using Holes and Bevels<label id="handb">
<p>
All curves forming holes in the extruded object must be defined inside
(geometrically) the first curve (the outline curve). Additionally,
they may not intersect each other or themself and one can not have hole
curves inside hole curves. If there are bevels and caps, allow extra
spacing between the curves (for the bevels).
Ayam will not check whether the parameter curves conform to these criteria.
<p>
With the direction of the curve one decides the direction of the
bevel as well (should it round outwards or inwards?).
If the bevels of the holes look wrong try to revert the generating
curves of the holes.
Note that beveling does not work well with open curves. One should always
use closed curves for beveling.
Beveling may lead to self intersecting trim curves in sharp corners of an
extrusion. Decrease the bevel radius or round the corners of the extruded
curve (using insertion of additional control points) if cap generation
fails due to self intersecting bevels.
<p>
Another special issue shall be noted: If there are holes, the
corresponding bevels will be scaled with the hole curve object
transformation values. Thus, to achieve equally sized bevels for outline
and holes, possible scale transformations should be carried out on the
hole curve control points, rather than on the hole curve object
transformation attributes.

<sect2>Conversion Support
<p>
The extruded surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the extruded surface in the following
order: end bevel, end cap, start bevel, start cap.
<p>
The Extrude object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Extrude objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Swing Object<label id="swingobj">
<p>
<figure loc="ht">
<eps file="pics/swing.ps" height="5cm">
<img src="pics/swing.gif">
<caption>Swing Object (left: Curves, right: Resulting Swung Surface)</caption>
</figure>
<p>
The Swing object forms a surface that results from rotating a NURBS curve
(cross section or profile) around an axis while
scaling it according to a second NURBS curve (trajectory or path).
<footnote>Since 1.14.</footnote><newline>
This process is sometimes also called <em>rotational sweep</em>.
<p>
The swing object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory.
<p>
The object hierarchy of a Swing object, thus, looks like this:
<tscreen><verb>
+-Swing
 | Cross_Section(NCurve)
 \ Trajectory(NCurve)
</verb></tscreen>
<p>
The swing operation will occur around the Y-axis.
<p>
The base plane for the swing operation is the YZ-plane. The cross section
curve should be defined in this plane and the trajectory should start here.
<p>
The dimensions and orders of the swung surface will be taken from the
respective parameter curves as follows: width and order in U direction
from the trajectory, height and order in V direction from the cross
section.
<p>
The following table briefly lists some capabilities of the Swing object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Swing|NCurve*|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Swing Object Capabilities</caption>
</table>

<sect2>SwingAttr Property<label id="swingattrprop">
<p>
The attributes <tt/"UpperCap"/, <tt/"LowerCap"/, <tt/"StartCap"/, and
<tt/"EndCap"/ may be used to automatically create cap surfaces, that
close the Swing on the respective ends.
Note that this works properly only if the corresponding parameter
curve is closed and planar.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the Swing, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect2>Conversion Support
<p>
The swung surface and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If caps are present, an enclosing Level object will be created
and the caps follow the swung surface in the following
order: upper, lower, start, end.
<p>
The Swing object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Swing objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps are present, those follow as trimmed NURBS patch primitives
in the following order: upper, lower, start, end.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Sweep Object<label id="sweepobj">
<p>
<figure loc="ht">
<eps file="pics/sweep.ps" height="6cm">
<img src="pics/sweep.gif">
<caption>Sweep Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Sweep object forms a surface that results from moving a NURBS curve
(cross section or profile) along a second NURBS curve (trajectory or path).
The cross section may be scaled while sweeping using a third curve, the
scaling function. Swept surfaces may be closed in the direction of the
trajectory and, since Ayam 1.10, they may even be periodic.
<p>
The Sweep object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory,
and the third curve represents the scaling function.
<p>
The object hierarchy of a Sweep object, thus, looks like this:
<tscreen><verb>
+-Sweep
 | Cross_Section(NCurve)
 | Trajectory(NCurve)
 \ [Scaling_Function(NCurve)]
</verb></tscreen>
<p>
Note that the <tt/"Translate"/ attributes of the cross section curve
will be fully ignored. All other transformation attributes
(of cross section and trajectory) will be used to determine
place, orientation, and size of the Sweep object.
<p>
The cross section curve has to be defined in the YZ-plane of the
Sweep objects coordinate system but it also has to be defined in the
XY-plane of its own coordinate system. This means that a simple circular
curve as e.g.~created with the toolbox has to be rotated by 90 degrees
around the Y-axis using its transformation attributes to follow these
rules. Later editing of this curve has to be done in a Side view (or
in an aligned local Front view, if the Sweep object itself is transformed
somehow).
<p>
The scaling function is sampled for each section and the Y-component
of the coordinates of the current curve point will be used as
scale factor that is applied to the cross section in Y-direction.
<p>
If any sample point of the scaling function has a Z-component different
from zero, the Z-component will be used to independently scale the
cross section in X-direction, otherwise the Y-component will be used
to also scale the cross section in X-direction.
<footnote>Since 1.13.</footnote>
<p>
This implies, that e.g.~a scaling function that does nothing should be
a linear curve from (0,1,1) to (1,1,1).
Scale components that are less than or equal to zero will be silently ignored.
<p>
<figure loc="ht">
<eps file="pics/ssweep.ps" height="5cm">
<img src="pics/ssweep.gif">
<caption>Sweep Object (blue) with Scaling Function (white)</caption>
</figure>
<p>
Here is a short example for the creation of a sweep:
<enum>
<item>Create a circular B-Spline curve using the toolbox. (This will be our
cross section.)
<item>Rotate the curve by 90 degrees around the Y-axis. (Use the
<tt/"Transformations"/ property for that.)
<item>Create a simple NURBS curve using the toolbox. (This will be our
trajectory.)
<item>Select both curves. (Select the first curve, hold down
the <tt/"Shift"/ key and select the other curve.)
<item>Create the Sweep object using the toolbox.
<item>Now you may enter the Sweep object and modify
e.g.~the second curve, the trajectory. (Press <tt/&lt;e&gt;/,
then drag some control points around.)
<item>To modify the cross section you would need to switch to a
view of type <tt/"Side"/. (Use the views <tt/"Type"/ menu or
the <tt/&lt;PgDwn&gt;/ keyboard shortcut while the view has the input focus.)
</enum>

Section <ref id="scexsweep" name="Easy Sweep"> has an example
script that automates creation and parameterisation of
a suitable cross section curve.
<p>
The following table briefly lists some capabilities of the Sweep object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Sweep|NCurve*|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Sweep Object Capabilities</caption>
</table>

<sect2>SweepAttr Property<label id="swp"><label id="sweepattrprop">
<p>
The <tt/"Type"/ attribute controls whether the
swept surface should be open, closed, or periodic in the direction
of the trajectory curve.
<footnote>Since 1.10.</footnote>
<p>
If <tt/"Interpolation"/ is enabled, an additional interpolation
will be run on the swept surface in U direction so that all section
curves will be interpolated by the swept surface. Instead of a
NURBS knot vector, the swept surface will then get a
Chordal knot vector (calculated by knot averaging) and the
swept surface will follow the trajectory more closely.
See the image below for an example.
<p>
<figure loc="ht">
<eps file="pics/sweepinterp.ps" height="5cm">
<img src="pics/sweepinterp.gif">
<caption>Sweep Along a Quarter Circle without (left) and with (right) Interpolation Enabled</caption>
</figure>
<p>
The third parameter, <tt/"Sections"/, determines how many
sections (in U direction) should be used, when generating the
sweep NURBS patch. The sweep NURBS patch has sections+1 control
points in U direction for open and closed sweep types whereas
sections+order control points will be created for periodic sweep types.
<newline>
Also zero is a valid setting for the <tt/"Sections"/
parameter and used as default value.
<footnote>Since 1.13.</footnote>
If <tt/"Sections"/ is zero the number of sections is directly derived
from the length of the trajectory curve plus one (except for trajectory
curves of length 2, where it is 1). See the table below for examples.
<newline>
Consequently, if <tt/"Sections"/ is zero, for a standard NURBS curve of
length 4, the number of sections used is 5 and the width of the created
NURBS patch is 6, for a curve with just 2 control points, the number of
sections used is 1 and the width of the resulting patch is 2.<newline>
Moreover, if <tt/"Sections"/ is zero, the order of the sweep in U direction
is taken from the trajectory curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
If <tt/"Rotate"/ is enabled, the cross sections will be
rotated so that they are always perpendicular to the trajectory,
this enabled by default.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
Sweep on both ends.
Note that this works properly only if the cross section
curve is closed and planar (defined in the XY plane).
<p>
Also bevels are available for sweeps.
<footnote>Since 1.10.</footnote>
They are accessible through the command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a corresponding bevel parameter tag is created and more options will be
made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the sweep, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.
<p>
The following table shows some example parameter configurations for
the Sweep object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Trajectory Length/|<bf/Trajectory Order/|<bf/Sweep Length/|<bf/Sweep Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4<#if out=latex>@<hline></#if>
</tabular>
<caption>Sweep Parameterisation Examples</caption>
</table>

<sect2>Conversion Support
<p>
The swept surface, the bevels and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the swept surface in the following
order: start bevel, start cap, end bevel, end cap.
<p>
The Sweep object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Sweep objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: start bevel, start cap,
end bevel, end cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Birail1 Object<label id="birail1obj">
<p>
<figure loc="ht">
<eps file="pics/birail1.ps" height="5cm">
<img src="pics/birail1.gif">
<caption>Birail1 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail1 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves.
The object hierarchy of a Birail1 object, thus, looks like this:
<tscreen><verb>
+-Birail1
 | Cross_Section(NCurve)
 | Rail1(NCurve)
 \ Rail2(NCurve)
</verb></tscreen>
<p>
When the cross section touches the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curve will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curve and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail1vc.ps" height="5cm">
<img src="pics/birail1vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail1 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail1 object. Mind the direction of the rail curves (R1 and R2)
with regard to the cross section curve (CS) and the fact that the
cross section curve touches the starting points of the rail curves.
<p>
Note that the cross section curve does not have to be two dimensional, and,
in contrast to the normal Sweep object, it also does not have to be
defined in a special plane. Also note that the precision with which the
resulting surface will interpolate the rail curves depends on the
number of sections chosen.
<p>
The Birail1 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
The following table briefly lists some capabilities of the Birail1 object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Birail1|NCurve*|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Birail1 Object Capabilities</caption>
</table>
<p>
The following parameters further control the birailing process:

<sect2>Birail1Attr Property<label id="birail1p"><label id="birail1attrprop">
<p>
Similar to the <tt/"Sweep"/, the <tt/"Type"/ attribute controls whether the
swept surface should be open, closed, or periodic in the direction
of the birail curves.
<p>
The parameter <tt/"Sections"/ determines how many
sections (in U direction) should be used, when generating the
birailed NURBS patch. The birailed NURBS patch always has sections+1 control
points in U direction.
<newline>
Also zero is a valid setting for
the <tt/"Sections"/ parameter and used as default value.
<footnote>Since 1.13.</footnote>
<newline>
If <tt/"Sections"/ is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.
<newline>
Moreover, if <tt/"Sections"/ is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g.~defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a corresponding bevel parameter tag is created and more options will be
made available in the property GUI to adjust the bevel parameters or
remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the birail, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<#if out=latex><x/newpage/</#if>

The following table shows some example parameter configurations for
the birail object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Rail1 Length/|<bf/Rail1 Order/|<bf/Birail1 Length/|<bf/Birail1 Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4<#if out=latex>@<hline></#if>
</tabular>
<caption>Birail1 Parameterisation Examples</caption>
</table>

<sect2>Conversion Support
<p>
The birailed surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the birailed surface in the following
order: end bevel, end cap, start bevel, start cap.
<p>
The Birail1 object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Birail1 objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Birail2 Object<label id="birail2obj">
<p>
<figure loc="ht">
<eps file="pics/birail2.ps" height="5cm">
<img src="pics/birail2.gif">
<caption>Birail2 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail2 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves, while morphing it
into a second cross section (or profile) curve. The morphing process
may be controlled by a fifth parameter curve.
The object hierarchy of a Birail2 object, thus, looks like this:
<tscreen><verb>
+-Birail2
 | Cross_Section1(NCurve)
 | Rail1(NCurve)
 | Rail2(NCurve)
 | Cross_Section2(NCurve)
 \ [Interpolation_Control(NCurve)]
</verb></tscreen>
<p>
When the cross sections touch the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curves will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curves and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail2vc.ps" height="5cm">
<img src="pics/birail2vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail2 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail2 object. Mind the direction of the rail curves (R1 and R2)
with regard to the two cross section curves (CS1 and CS2) and the
fact, that all curves touch at their respective end points.
<p>
Note that the cross section curves do not have to be two dimensional, and,
in contrast to the normal Sweep object, they also do not have to be
defined in a special plane. Furthermore, they do not have to be compatible
in terms of length, order, and knots. Incompatible curves will be made
compatible before birailing automatically; the height of the resulting
surface, however, is not easily predictable anymore in this case.
Also note that the precision with which the resulting surface will
interpolate the rail curves depends on the number of sections chosen.
<p>
If a fifth curve is present as parameter object, this curve will
control the morphing (interpolation) process. The y coordinate
of this curve at a specific point, which should have a value between
0 and 1, determines the ratio of control of the first cross section
(0) and the second cross section (1) over the interpolated curve.
Thus, a straight line running from point (0,0) to (1,1) will be equivalent
to the standard linear interpolation that would be carried out if no
interpolation control curve were present. Note, however, that the
interpolation control curve has no influence on the first and last
copy of the respective cross section curve, unless the <tt/"InterpolCtrl"/
option is used.
<footnote>Since 1.10.</footnote>
<p>
The Birail2 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
The following table briefly lists some capabilities of the Birail2 object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Birail2|NCurve*|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Birail2 Object Capabilities</caption>
</table>
<p>
The following parameters control the birailing process:

<sect2>Birail2Attr Property<label id="birail2p"><label id="birail2attrprop">
<p>
The parameter <tt/"Sections"/ determines how many sections (in U direction)
should be used, when generating the birailed NURBS patch. The birailed
NURBS patch always has sections+1 control points in U direction.
<newline>
Also zero is a valid setting for
the <tt/"Sections"/ parameter and used as default value.
<footnote>Since 1.13.</footnote>
<newline>
If <tt/"Sections"/ is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.
<newline>
Moreover, if <tt/"Sections"/ is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
The parameter <tt/"InterpolCtrl"/ allows the interpolation controlling
curve full influence on the birailed surface.
If <tt/"InterpolCtrl"/ is disabled, the first and last border of the
resulting surface will always exactly match the parameter curves (CS1 and
CS2 respectively), regardless of the interpolation control curve.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g.~defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a corresponding bevel parameter tag is created and more options will be
made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the birail, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.
<p>
The following table shows some example parameter configurations for
the birail object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Rail1 Length/|<bf/Rail1 Order/|<bf/Birail2 Length/|<bf/Birail2 Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4<#if out=latex>@<hline></#if>
</tabular>
<caption>Birail2 Parameterisation Examples</caption>
</table>

<sect2>Conversion Support
<p>
The birailed surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the birailed surface in the following
order: end bevel, end cap, start bevel, start cap.
<p>
The Birail2 object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Birail2 objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Skin Object<label id="skinobj">
<p>
<figure loc="ht">
<eps file="pics/skin.ps" height="6cm">
<img src="pics/skin.gif">
<caption>Skin Object (left: Curves, right: Resulting Skinned Surface)</caption>
</figure>
<p>
The skin object forms a surface defined by a set of cross section curves,
where the first and last curve will always be interpolated by the surface
(this process is sometimes also called <em>lofting</em>). When only two
parameter curves are used the skin forms a so called <em>ruled surface</em>.
<p>
The complete template for the Skin object hierarchy, consequently,
looks like this:
<tscreen><verb>
+-Skin
 | C_1(NCurve)
 | C_2(NCurve)
 | [...
 \ C_n(NCurve)]
</verb></tscreen>
<p>
Note that in contrast to the build from curves tool,
the curves may be of arbitrary length and order. One may e.g.~easily
use a parameter curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points.
If the curves are of different length or order, they will all be
converted internally until they are compatible. Be warned, that
this process may consume a considerable amount of time
because all unclamped curves have to be converted to
clamped ones; then, for every curve with low order degree elevation
has to be done; then a uniform knot vector has to be found; then all
curves have to be refined using this new knot vector; interpolation
adds another dimension of complexity. If you experience
lags when editing the child curves of a skin object try to switch
to lazy notification.
Since Ayam 1.9, a skin object will also use all the curves of a
tool object, that provides multiple curves, e.g.~a clone object
in mirror mode.
<p>
The direction of the parameter curves will be parallel to the v
dimension (height) of the skinned surface. The number of the parameter
curves will define the u dimension (width) of the skinned surface.
<p>
Also note that the resulting patch may be quite complex, even though
the curves are not, if the orders or knot vectors of the curves do not
match.
For example, a skinned patch from two curves of length 4 but one with
order 4 and the other with order 2 will result in a patch with
a width of 2 and a height of 10.
<p>
The skin object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
<p>
The following table briefly lists some capabilities of the Skin object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Skin|NCurve*|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Skin Object Capabilities</caption>
</table>
<p>
The following parameters control the skinning process:

<sect2>SkinAttr Property<label id="skp"><label id="skinattrprop">
<p>
The first parameter <tt/"Interpolation"/ controls
whether the inner curves should also be interpolated by the
skinning surface.
<p>
The second parameter <tt/"Order_U"/ determines the order
of the resulting surface in U direction (the order in V direction is
determined by the curves). The order may not be higher than the
number of curves used. If the specified value is higher than the number
of curves, the order of the generated surface will be silently
set to the number of curves.
If <tt/"Order_U"/ is 0, a default value of 4 will be used.
<p>
Using the next parameter <tt/"Knot-Type_U"/, you can adapt the
type of the knot vector that should be used in the U direction of the
skinned surface. Note that this setting will have no effect if
interpolation is switched on because then a chord length parameterisation
will be used. If the knot type is Bezier and the specified
order (see above) does not exactly match the number of skinned curves,
then the order will be silently adapted to the number of skinned curves.
New in Ayam 1.7 is support for the knot type Custom, which creates
a chord length parameterisation, even if interpolation is not enabled.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be used
to automatically create cap surfaces to close the skinned surface
on both ends.
Note that this works only if the respective curves are closed and
planar (e.g.~defined in the XY plane).
Furthermore, if the skin is not interpolating the respective parameter
curves (this may be the case if the <tt/"Knot-Type_U"/ parameter is set
to <tt/"B-Spline"/) the cap(s) will not be created in the right place.
The cap(s) will always be created in the position of the first (last)
parameter curve.
<p>
Since Ayam 1.10 bevels are available for skins.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a corresponding bevel parameter tag is created and more options will be
made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the skin, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect2>Conversion Support
<p>
The skinned surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the skinned surface in the following
order: end bevel, end cap, start bevel, start cap.
<p>
The Skin object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Skin objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Gordon Object<label id="gordonobj">
<p>
<figure loc="ht">
<eps file="pics/gordon-hood.ps" height="6cm">
<img src="pics/gordon-hood.gif">
<caption>Gordon Object (left: Curves, right: Resulting Gordon
Surface)</caption>
</figure>
<p>
The Gordon object forms a surface defined by two sets of intersecting
curves (a network of curves), where all curves will always be interpolated
by the surface (see image above). The image below shows the simplest
configuration of such a network, consisting of four parameter curves.
Note the arrangement and the direction of the curves.
Also note that this configuration is in fact equivalent to a Coons patch.
<p>
<figure loc="ht">
<eps file="pics/sgordon.ps" height="6cm">
<img src="pics/sgordon.gif">
<caption>Gordon Surface with Parameter Curves (white)</caption>
</figure>
<p>
The curves may be of arbitrary length and order. One may e.g.~use
a curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points for the U parametric dimension. Note, however,
that in the general case only non-rational curves can be used
as parameter curves for a Gordon surface.
If the parameter curves are rational, the weight information
of the curves will simply be ignored.
However, since Ayam 1.13 there is a special case allowed: if
exactly four parameter curves are present, their weight
information will be used properly. Mind that for a correct
surface interpolation the curves weights have to match in the
respective end points.
<p>
The Gordon object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
Separation of the two sets of curves has to be done using an
empty level object. The first set of curves determines the u
direction and the second set of curves the V direction of the
Gordon surface. For the example surface in the image above, the
child objects of the Gordon object would have to look like this
in the Ayam object tree view:
<tscreen><verb>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 \ V2(NCurve)
</verb></tscreen>
<p>
The creation of a Gordon surface is computationally
expensive. It involves (interpolated) skinning of the two sets of
parameter curves, finding the intersection points of the two sets
of parameter curves, interpolating the matrix of intersection points,
making the three resulting surfaces compatible, and finally combining
the three surfaces into the resulting Gordon surface. If there are lags
while editing the parameter curves of a Gordon surface, consider
switching to lazy notification.
<p>
In order to ease the computationally intensive intersection
detection for Ayam one may specify a third argument (separated
from the two sets of parameter curves by a second empty level object).
This third argument should be a NURBS patch object that describes
all intersection points (by its control points).
If present, this intersection patch always takes precedence over the
intersection points calculated internally.
One may want to add a <tt>"NoExport"</tt> tag to this patch, to prevent
it from appearing in RIB output.
<p>
The object hierarchy of a Gordon object using such a patch may look
like this:
<tscreen><verb>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | Level
 \ Intersections(NPatch)
</verb></tscreen>
<p>
The complete template for the Gordon object hierarchy, consequently,
is as follows:
<tscreen><verb>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | [...
 | Un(NCurve)]
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | [...
 | Vn(NCurve)]
 | [Level
 \ Intersections(NPatch)]
</verb></tscreen>
<p>
The Gordon object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
The following table briefly lists some capabilities of the Gordon object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Gordon|NCurve*/Level|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Gordon Object Capabilities</caption>
</table>
<p>
The following parameters of the Gordon object further control
the creation of the Gordon surface:

<sect2>GordonAttr Property<label id="gop"><label id="gordonattrprop">
<p>
If the parameter <tt/"WatchCurves"/ is switched on, Ayam will
check for all four outer parameter curves, whether they touch in their
endpoints. If not, the endpoints will be corrected. Note that this
works only properly with clamped curves and objects that directly
contain editable control points (i.e.~it works with NCurve and ICurve
objects, but not with Instance or ConcatNC objects). If Ayam can
determine which curve was modified last, the other curve that should
meet at the endpoint in question will be modified by <tt/"WatchCurves"/.
If Ayam finds no information on modifications, the U curves take
precedence (i.e.~the V curves will be modified).
<p>
The parameters <tt/"Order_U"/ and <tt/"Order_V"/ determine the
desired order of the resulting surface in U and V direction.
However, depending on the number and configuration of curves used
in the U or V direction, it may not be possible to create a Gordon
surface of the desired order.
If <tt/"Order_U"/ or <tt/"Order_V"/ are 0, a default value
of 4 will be used.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the Gordon surface, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect2>Conversion Support
<p>
The Gordon surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
Gordon objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Bevel Object<label id="bevelobj">
<p>
<figure loc="!ht">
<eps file="pics/bevel.ps" height="5cm">
<img src="pics/bevel.gif">
<caption>Bevel Object (left: Curve, right: Resulting Bevelled Surface)</caption>
</figure>
<p>
The bevel object forms a bevelled surface from a single planar parameter
curve. The bevel cross section shape may be defined by a second curve.
Consequently, the template for the object hierarchy of a Bevel object
looks like this:
<tscreen><verb>
+-Bevel
 | NCurve
 \ [NCurve]
</verb></tscreen>
<p>
Bevels are also available as properties of different tool objects
(e.g.~Extrude or Sweep). In fact, Bevel objects use the same creation
algorithm as bevel properties but offer increased flexibility in terms of
e.g.~material settings. Surfaces created from bevel properties always
share the material settings of the tool object. In contrast, Bevel
objects may have their own material settings. Bevel objects are
available in Ayam since version 1.10.
<p>
Note that the parameter curve of a Bevel object should be closed and
planar to achieve best results;
see section
<ref id="toxyt" name="To XY Tool"> for information on
how to easily achieve this. If the curve is closed or periodic,
the appropriate curve type should be set in the curve object,
otherwise the bevelled surface may expose defects.
<p>
Since Ayam 1.19 the bevel object supports a second parameter curve
that defines the bevels cross section shape. It should run from
0,0 to 1,1. If present, the type parameter is ignored (with one
notable exception) as the shape of the bevel is defined by the second curve.
If the type is <tt/"RoundCapped"/ or <tt/"LinearCapped"/ the bevel
will be extended to a cap.
Note that even if the curve should end at 1,1, this is not mandatory
and allows for bevels of differing width and height to be created.
<p>
The Bevel object watches the child object and adapts to it automatically
via the notification mechanism.
<p>
The following table briefly lists some capabilities of the Bevel object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Bevel|NCurve+|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Bevel Object Capabilities</caption>
</table>
<p>
The following parameters of the Bevel object further control
the creation of the bevelled surface:

<sect2>BevelAttr Property<label id="bevelp"><label id="bevelattrprop">
<p>
<itemize>
<item><tt/"BevelType"/ lets you choose between different shapes of bevels:
 <itemize>
 <item><tt/"Round"/ a quarter circle,

 <item><tt/"Linear"/ a straight bevel,

 <item><tt/"Ridge"/ a more complex ridged surface,

 <item><tt/"RoundCapped"/ a quarter circle followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point,

 <item><tt/"LinearCapped"/ a straight bevel followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point.
 </itemize>

Note that the bevel types <tt/"RoundCapped"/ and <tt/"LinearCapped"/
lead to degenerated NURBS surfaces. If applied shaders or textures
look wrong, consider creation of real cap surfaces instead.

<item><tt/"BevelRadius"/ controls the size of the bevelled surface when seen
from the top of the parameter curve. Note that the size of the bevel is
expressed in units defined by the object coordinate system of the
controlling object. Scale values of the controlling object affect the
bevel size.

<item><tt/"BevelRevert"/ allows to revert the sense of the bevelled surface,
should it round inwards or outwards? The sense may also be controlled
using the direction of the parameter curve and, additionally, the sense
in a different dimension may also be affected by using negative values
for the bevel radius.
</itemize>
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"BevelAttr"/ property.
<p>
To help in the exact configuration of the bevel, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect2>Conversion Support
<p>
The bevelled surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
Bevel objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Cap Object<label id="capobj">
<p>
<figure loc="!ht">
<eps file="pics/cap.ps" height="6cm">
<img src="pics/cap.gif">
<caption>Cap Object (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
The cap object forms a surface that fills a closed planar NURBS curve.
If multiple curves are present as child objects, the curves following
the first curve define holes in the cap surface similar to the
parameter curves of an extruded surface (see also section
<ref id="handb" name="Using Holes and Bevels">).
<p>
<figure loc="!ht">
<eps file="pics/gordoncap.ps" height="5cm">
<img src="pics/gordoncap.gif">
<caption>Cap from Non-Planar Curve (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
Since Ayam 1.13 the cap object also supports the so called Gordon mode.
Here, only a single parameter curve may be present but, in contrast
to the standard mode of operation (Trim), in the Gordon mode the parameter
curve may be non-planar. Internally the cap object will split the
parameter curve into four sections and build a Gordon surface from
the four sections (see the image above for an example).
<p>
Consequently, the template for the object hierarchy of a Cap object
looks like this:
<tscreen><verb>
+-Cap
 | Outline(NCurve)
 | [Hole1(NCurve)]
 +-[Hole2(Level)
  | Part1(NCurve)
  \ Part2(NCurve)]
</verb></tscreen>
<p>
Note that, in Trim mode, the curves have to be planar and defined in
the XY plane; see section
<ref id="toxyt" name="To XY Tool"> for information on
how to easily achieve this.
Furthermore, cap generation may fail, if the control points of the
first curve have weights and the curve leaves the convex hull of the
control polygon. Be careful when using weights!
<p>
The Cap object watches the child objects and adapts to them automatically
via the notification mechanism.
<p>
The following table briefly lists some capabilities of the Cap object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cap|NCurve+|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Cap Object Capabilities</caption>
</table>
<p>
The following parameters control the cap creation process:

<sect2>CapAttr Property<label id="capp"><label id="capattrprop">
<p>
The attribute <tt/"Type"/ determines whether a trimmed NURBS surface
should be created (type <tt/"Trim"/), or an untrimmed Gordon surface
(type <tt/"Gordon"/), see also the general discussion about the cap
object above.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"CapAttr"/ property.
<p>
To help in the exact configuration of the cap, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect2>Conversion Support
<p>
The cap surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
Cap objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>ConcatNP (Concatenate NURBS Patches) Object<label id="concatnpobj">
<p>
<figure loc="ht">
<eps file="pics/concatnp.ps" height="5cm">
<img src="pics/concatnp.gif">
<caption>ConcatNP Object (white) From Two NURBS Patches (blue)</caption>
</figure>
<p>
The ConcatNP object concatenates all child objects, which should be NURBS
patches or provide NURBS patches to a single NURBS patch (see also the
image above).
<footnote>Since 1.16.</footnote>

The concatenation simply splits all surfaces into curves, makes
the curves compatible, and joins them to the concatenated surface.

Also NURBS curves or objects that provide NURBS curves can be used
as parameter objects.
<footnote>Since 1.20.</footnote>

Since the ConcatNP object also
provides a NURBS patch, it is possible to use it as child object for
another ConcatNP object (with possibly different parameters).

Attributes like display mode and tolerance for the new concatenated patch
are simply taken from the first parameter patch. Eventually present
trim curves will currently <em>not</em> be honored properly.

The following table briefly lists some capabilities of the ConcatNP object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNP|NPatch*/NCurve*|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>ConcatNP Object Capabilities</caption>
</table>
<p>
The following parameters further control the concatenation process:

<sect2>ConcatNPAttr Property<label id="concatnpp"><label id="concatnpattrprop">
<p>
<itemize>
<item>Using <tt/"Type"/, open, closed, or periodic concatenated patches may
be created.
If a closed surface is to be created and also <tt/"FillGaps"/ (see below) is
enabled, an additional fillet will be created for the last and the first
child surface to close the concatenated surface.

<item><tt/"Order"/ is the desired order of the concatenated surface
(in U direction), the default value (0) leads to a cubic surface.
If the desired order is 1, the respective order from the first
of the parameter surfaces is taken.
If the desired order is higher than the number of curves (i.e.~the
total number of control points of all surfaces in their desired
directions plus the number of eventually present parameter curves),
it will be lowered to the number of curves silently.

<item><tt/"FillGaps"/ creates fillet surfaces for all gaps between
the parameter surfaces of the ConcatNP object. No fillet will be created
if the end curves of two parameter surfaces match or if parameter
curves are present between the parameter surfaces in question.

<p>
Similar to the fillets for concatenated curves, the fillet surface
will be constructed from four control points (in U direction).
However, the tangent vectors will not be calculated directly, but
instead derived from the respective control points.

<item><tt/"FTLength"/ determines the distance of the inner fillet
control points from their respective end points. This value can
be adapted for smaller&thinsp;/&thinsp;larger gaps between parameter
surfaces. If this parameter is negative, the distance between the
two surfaces in the end points will be multiplied in so that a
more pleasing fillet shape results in configurations where the
distances vary a lot (see also the image below).
<p>
<figure loc="ht">
<eps file="pics/concatnpfillets.ps" height="5cm">
<img src="pics/concatnpfillets.gif">
<caption>Concatenated Surfaces (blue) with Fillets (left: FTLength 0.3, right: FTLength -0.3</caption>
</figure>

<item>If <tt/"Revert"/ is enabled, the orientation of the concatenated
surface will be reversed (in U direction).

<item>The <tt/"Knot-Type"/ parameter allows to choose a knot vector for
the concatenated surface in U direction. Similar to the
ConcatNC object, only <tt/"Custom"/ knots allow to preserve the shapes
of the parameter surfaces completely but this comes at the price of multiple
internal knots (see also <ref id="concatncp" name="ConcatNCAttr Property">).
In addition, for <tt/"Custom"/ knots, all parameter surfaces will be
elevated to a common maximum order or atleast be clamped in the
respective direction prior to the splitting to curves but after
the fillet creation.

<item>The <tt/"UVSelect"/ option is a string that can be used to
control the splitting direction for each parameter surface
individually. Valid characters in this string are <tt/"u"/, <tt/"U"/,
<tt/"v"/, and <tt/"V"/.
The uppercase variants lead to a reverted surface.
To connect two surfaces that share the same orientation "over a corner"
one would e.g.~need to set <tt/"UVSelect"/ to <tt/"uV"/
(see also the image below).
The default, an empty string, is equivalent to <tt/"u"/ for all
patches. Also incomplete strings lead to <tt/"u"/ for all remaining
patches. There is no need to specify a value for fillets, those
will always be created in a way that they can be split along the
U direction.
<p>
<figure loc="ht">
<eps file="pics/concatnpuv.ps" height="5cm">
<img src="pics/concatnpuv.gif">
<caption>Concatenating two Surfaces with UVSelect == "uV"</caption>
</figure>
</itemize>
<itemize>
<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the created NURBS patch.
</itemize>

<sect2>Conversion Support
<p>
The concatenated surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ConcatNP objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>ExtrNP (Extract NURBS Patch) Object<label id="extrnpobj">
<p>
<figure loc="ht">
<eps file="pics/extrnp.ps" height="5cm">
<img src="pics/extrnp.gif">
<caption>Extracted Surface (white) from Arbitrarily Shaped Surface (blue)</caption>
</figure>
<p>
The ExtrNP object extracts a NURBS patch from
another NURBS patch object, for use as parameter object for other tool
objects (see image above).
<footnote>Since 1.14.</footnote>
<p>
It also works with NURBS patch providing objects, so that the following
example hierarchy is valid:
<!-- <#if out=latex><x/needspace 5/</#if> -->
<tscreen><verb>
--NPatch
+-ExtrNP
 \ Instance_of_NPatch(Instance)
</verb></tscreen>
Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNP object. Therefore, the main menu entry
<tt>"Tools/Create/ExtrNP"</tt>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNP object.
<p>
As the geometry of the extracted surface is completely defined by
the master surface, ExtrNP objects do not support own transformation
attributes.
<footnote>Since 1.19.</footnote>
<p>
Also note that eventually present trim curves will <em>not</em> be honored
properly.
<p>
The following table briefly lists some capabilities of the ExtrNP object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ExtrNP|NPatch|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>ExtrNP Object Capabilities</caption>
</table>
<p>
The extraction process is controlled by the following attributes:

<sect2>ExtrNPAttr Property<label id="extrnpp"><label id="extrnpattrprop">
<p>
<itemize>
<item><tt/"UMin"/, <tt/"UMax"/, <tt/"VMin"/, and <tt/"VMax"/ are
parametric values that control which part of the original surface
is to be extracted. The valid range of parameter values depends
on the knot vectors of the original surface.

<item><tt/"Relative"/ controls whether the parametric values should
be interpreted in a relative way.
<footnote>Since 1.15.</footnote>
If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector, regardless of the
actual knot values, and the valid range for the parametric values is
then consequently 0.0-1.0.

<item><tt/"PatchNum"/ allows to select a patch from a list of
patches delivered e.g.~by a beveled extrude object as child
of the ExtrNP object.
This way it is possible to extract a patch from a bevel or cap
surface of e.g.~a Revolve object.

<item>See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the extracted NURBS surface.
</itemize>

<sect2>Conversion Support
<p>
The extracted surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
ExtrNP objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>OffsetNP (Offset NURBS Surfaces) Object<label id="offsetnpobj">
<p>
<figure loc="ht">
<eps file="pics/offnp.ps" height="5cm">
<img src="pics/offnp.gif">
<caption>Offset Surface (white) from NURBS Surface (blue) with Offset 0.2</caption>
</figure>
<p>
The OffsetNP object creates offset surfaces from
NURBS surfaces using a simple algorithm.
<footnote>Since 1.17.</footnote>
The offsetting also works for closed and periodic surfaces in any
possible combinations in the two dimensions.
<footnote>Since 1.19.</footnote>
However, note that degenerate and rational surfaces are still not supported.
<p>
The offset surface will always match the original surface in width/height,
orders, and knots. See also the image above.
Trim curves are copied verbatim from the parameter surface to the
offset surface.
<p>
As the geometry of the offset surface is completely defined by
the master surface, OffsetNP objects do not support own transformation
attributes.
<footnote>Since 1.19.</footnote>
<p>
The following table briefly lists some capabilities of the OffsetNP object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
OffsetNP|NPatch|Yes|NPatch|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>OffsetNP Object Capabilities</caption>
</table>
<p>
The following parameters further control the offsetting process:

<sect2>OffsetNPAttr Property<label id="offsetnpp"><label id="offsetnpattrprop">
<p>
<itemize>
<item><tt/"Offset"/ determines the distance between original surface and
offset surface. Negative values are allowed.

<item>See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
</itemize>
<itemize>
<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the created NURBS surface.
</itemize>

<sect2>Conversion Support
<p>
The offset surface may be converted to an ordinary NURBS patch using the
main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
OffsetNP objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>

PV tags are supported.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Text Object<label id="textobj">
<p>
<figure loc="!ht">
<eps file="pics/text-ayam.ps" height="4cm">
<img src="pics/text-ayam.gif">
<caption>Text Object set in Verdana</caption>
</figure>
<p>
Text objects may be used to easily create objects that form letters or
even whole words in very high quality. For that, they parse TrueType font
description files, extract the Bezier curves from the font description,
sort the curves, connect them properly and finally extrude them.
As with the Extrude objects, caps and bevels may be created automatically.
<p>
Parsing of TrueType font descriptions is quite tricky. For the sake
of brevity and ease of the implementation, Ayam does not support elaborate
TrueType features like kerning tables, that e.g.~control distances between
certain letters (You are not going to typeset a book with Ayam anyway,
aren't you?). Therefore you might experience wrong letter distances
from time to time. If this happens, just create a Text object for each
letter, and arrange the objects as you like.
<p>
You may convert the current Text object to ordinary NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Text object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Text|No|Yes|NPatch+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Text Object Capabilities</caption>
</table>
<p>
The following attributes control the creation of the text objects.

<sect2>TextAttr Property<label id="textattr"><label id="textattrprop">
<p>
<itemize>
<item>Using <tt/"FontName"/ you specify a TrueType font description file.
Those files usually have the file name extension <tt/".ttf"/.
Only real TrueType font files, containing Bezier curve font descriptions,
are supported. There are also rastered, bitmap containing TrueType
font description files, those will not work.

<item>Using <tt/"String"/ you specify the letters to be created.
This entry (and the corresponding data structures) are Unicode clean.
This means you can put any Unicode letters into this entry. You should
of course make sure, that the specified letters are included in the
selected font file.

<item><tt/"Height"/ controls the height of the extruded object.

<item><tt/"Revert"/ reverts the sense of inside-outside detection
mechanism for the cap generation. Depending on the actual font description
file (or even letter) you may need to toggle this to get caps.

<item><tt/"UpperCap"/, <tt/"LowerCap"/, work like for the Extrude object
(see section <ref id="extrattr" name="ExtrudeAttr Property"> for a more
exhaustive description of those parameters).

<item><tt/"Add Start Bevel!"/, <tt/"Add End Bevel!"/:
Since Ayam 1.10 the bevel parameters of the text object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, <tt/"BevelRadius"/, and
<tt/"RevertBevels"/ are no longer available. They were replaced with
new dynamic tag creating bevel property GUI sections that are accessible
through the new command entries <tt/"Add Start Bevel!"/ and
<tt/"Add End Bevel!"/
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
Just one note: for some fonts, the bevel radius has to be set to really
small values (about 0.0008) to get proper bevels and caps. This is
because of sharp corners in some letters that lead to self overlapping
borders of the bevel surfaces with high values for the bevel radius.
</itemize>

See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Conversion Support
<p>
The extruded surfaces, the bevels, and the caps,
may be converted to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
If bevels or caps are present, an enclosing Level object will be created
and the caps follow the extruded surfaced in the following
order: end bevel, end cap, start bevel, start cap.
<p>
The Text object provides a list of NURBS patch objects in the
same order as created upon conversion.

<sect2>RIB Export
<p>
Text objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.
<p>
PV tags are supported but all NURBS patch primitives will get
the same set of tags.
<footnote>Since 1.20.</footnote>

<#if out=latex><x/newpage/</#if>

<sect1>Trim Object<label id="trimobj">
<p>
The Trim object may be used in hierarchies
of tool objects to trim NURBS patch providing objects otherwise
unavailable to trimming like e.g.~a Revolve object.
<footnote>Since 1.16.</footnote>
The first child of the Trim object is the NURBS patch providing object
and the second object is the trim curve (defined in the parametric
space of the NURBS surface). More curves and loops may follow.
All curves must obey the rules for trimming as outlined in section
<ref id="trim" name="Trim Curves">.
The surface may already be trimmed and there may be multiple provided
patches, however only one of them will be trimmed by the Trim object.
<p>
The object hierarchy of a Trim object, thus, looks like this:
<tscreen><verb>
+-Trim
 | Surface(Revolve)
 | Trim_1(NCurve)
 +-[Trim_2(Level)
 | | NCurve
 | \ NCurve
 | ...
 \ Trim_n(ICurve)]
</verb></tscreen>
<p>
The following table briefly lists some capabilities of the Trim object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Trim|NPatch/NCurve+/Level+|Yes|NPatch|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Trim Object Capabilities</caption>
</table>
<p>
The following parameters further control the trimming process:

<sect2>TrimAttrib Property<label id="trimp"><label id="trimattribprop">
<p>
<itemize>
<item><tt/"PatchNum"/ allows to select a patch, should the NURBS
patch providing object deliver a list. This way, a bevel of an
extrusion might be trimmed.
</itemize>

<sect2>Conversion Support
<p>
The trimmed surface may be converted to an ordinary NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
Trim objects will be exported as NURBS patch primitives:
<tscreen>
<tt>RiNuPatch(...);</tt>
</tscreen>
PV tags are currently not supported.

<#if out=latex><x/newpage/</#if>

<sect1>Script Object<label id="scriptobj">
<p>
Script objects are the most flexible object type of Ayam.
They may be used to create new objects, modify existing objects,
or realise mechanisms like constraints using small scripts
that are embedded in the Script objects themselves.
<p>
Those small embedded scripts may employ functionality from Tcl and
the Tcl scripting interface of Ayam
(see also section <ref id="script" name="Scripting Interface">).
<p>
Script objects may also use arbitrary, plugin provided,
scripting languages, like e.g.~JavaScript, provided by the
<tt/"jsinterp"/ plugin (see also:
<ref id="jsinterp" name="JavaScript Scripting Interface">).
<footnote>Since 1.18.</footnote>

<sect2>Safe Interpreter<label id="safeinterp">
<p>
In Ayam versions prior to 1.16 Script object scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
Script objects scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state. Direct access
to Tk is also completely blocked, but Script objects still can have their
own property GUIs (refer to the examples below).
<p>
In particular, the following Tcl commands are <em>not</em> available in the
safe interpreter:
cd, encoding, exec, exit, fconfigure, file, glob, load, open, pwd, socket,
source, unload; auto_exec_ok, auto_import, auto_load, auto_load_index,
auto_qualify, unknown (the missing unknown and autoloading facilities
lead to further unavailability of commands normally available via
autoloading, like e.g.~parray, history).
The puts command is available in a limited fashion: only access to
the stdout and stderr channels is allowed.
Ayam scripting interface commands that directly manipulate the user
interface are also not available (uS, rV etc.). Please refer to the
documentation of the scripting interface commands about their availability
in the safe interpreter
(see section
<ref id="sccomm" name="Index of Procedures and Commands">).
<p>
In addition, access to global variables like env, ay, ayprefs
is not allowed. In fact, the safe interpreter has a completely
separate set of variables. Transfer of data between both interpreters
must be arranged manually from the Ayam interpreter (e.g.~scripts that
run in the Ayam console).
<p>
With the help of scripts, that run in the Ayam interpreter, more commands
may be transfered to or made available in the safe interpreter.
But this may, of course, open security holes again.
<p>
You can also still re-enable full access from script objects to the
complete scripting interface by recompiling Ayam.
If you do so, for security reasons, if scene files containing script
objects are loaded, Ayam will raise a warning dialog, offering to
temporarily disable all script objects that will be read. The script
objects will be disabled using the <tt/"Active"/ script object property
and may be enabled after careful inspection of the script code manually
or using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>Script Object Usage
<p>
The script of a script object will be run each time the script is
modified and each time the notification callback of the script object
is called (e.g.~because one of the children of the script object changed).
As long as the script of a script object is executed, Ayam will
not process any events except for checking whether the script emergency
hotkey <tt/&lt;Ctrl+Shift+c&gt;/, that may also be used to
escape from infinite loops in the Ayam console, is pressed.
Calling commands and procedures that lead to the processing of
events or that are slow because they manipulate or update the
GUI of Ayam should be avoided. In particular, the following
procedures and commands should <em>not</em> be used: uS, uCR, uCL,
selOb, plb_update, undo!
<p>
Script objects may also create their own property
GUIs for e.g.~script parameters.
<footnote>Since 1.8.2.</footnote>
This may be accomplished by adding
tags of type <tt>"NP"</tt> with the name of the new property as
value to the script object. The script itself is responsible for data
management and property GUI creation.
<p>
The parameters set via a such a property GUI may be
comfortably saved with scene files by just adding the following
comment as first line to the script:
<footnote>Since 1.9.</footnote>
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
where arrayname designates the name of the global Tcl array
the property GUI elements operate with.
Note that with the introduction of individual parameters in Ayam
1.15 not all members of the arrays will be saved. Only members
from the <tt>"SP"</tt> list (see below) will be considered, which gives
script object developers fine grained control over what actually goes
to the Ayam scene file.
<p>
There is also a tag type to remove properties
(<tt>"RP"</tt>).
<footnote>Since 1.12.</footnote>
Using this tag, one can e.g.~hide the actual script
code and block users from unintentionally changing it.
<p>
Script objects can have individual sets of parameters,
so that multiple copies of a script object can be used (without individual
parameters all copies would share the same parameter values).
<footnote>Since 1.15.</footnote>
For this, the new variable <tt>"SP"</tt> in the script data array
contains a list of parameter names in that array that are individual
(not shared by all copies of the script object).
<p>
Starting with Ayam 1.16, the environment for running script objects scripts
has been refined to allow more complex scripts (that traverse the scene or
use the clipboard) to be written:
When a script is running, the current level is the child level of the
respective script object. Furthermore, the object clipboard is saved
for running the script and re-established after the script finished.
<p>
Script objects may also use arbitrary, plugin provided,
scripting languages.
<footnote>Since 1.18.</footnote>
To switch to a different language, the first line
of the script must be a comment (in the syntax of the other language)
with the word <tt>"use:"</tt> followed by the language name, as
provided by the corresponding plugin, e.g.~for JavaScript the first line
should look like this:
<code>
/* Ayam, use: JavaScript */
</code>
The special comments for saving of array items and language switching
can be used in conjunction like this:
<code>
/* Ayam, use: JavaScript, save array: MyArr */
</code>
<p>
The binary and source distributions of Ayam contain several example
scripts for script objects in the <tt>"ayam/bin/scripts"</tt> and
<tt>"ayam/src/scripts"</tt> directories, respectively. In addition,
there are example scene files using script objects in the
<tt>"ayam/scn/scripts"</tt> directory.
<p>
The following table briefly lists some capabilities of the Script object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Script|Any+|No|Any+|No*<#if out=latex>@<hline></#if>
</tabular>
<caption>Script Object Capabilities</caption>
</table>
<p>
The next section discusses the available script object types and
additional controlling parameters.

<sect2>ScriptAttr Property<label id="scriptattr"><label id="scriptattrprop">
<p>
<itemize>
<item>If <tt/"Active"/ is disabled, the script will not be run.

<item><tt/"Type"/ is the type of the script object.
Three types of script objects are currently available:
 <itemize>
 <item><tt/"Run"/, the script will be run and no special action will
take place.

 <item><tt/"Create"/, the script will be run and will create and
parameterise new objects. After running the script, the newly
created object(s) will automatically be moved into the internal data
structure of the script object. The script object will look like
and act as an object of the type that the script created.
If the script creates e.g.~a NCurve object, the script object may
be used as parameter object of a tool object that needs a NCurve,
e.g.~a Sweep:
<tscreen><verb>
+-Sweep
 | Cross_Section(Script)
 \ Path(NCurve)
</verb></tscreen>
If the newly created object has to be selected by the script code
for further parameterisation purposes, the selection should be done
using the scripting interface command <tt/"sL"/ (which performs
a hidden selection in the safe interpreter context).
Consequently, the most simple example script for a script object
of type <tt/"Create"/ looks like this:
<code>
crtOb NCurve
</code>
Or, with further parameterisation
<code>
crtOb NCurve
sL
setProperty NCurveAttr(Order) 2
</code>

 <item><tt/"Modify"/, if the script object has child objects,
these child objects will be temporarily moved into the internal data
structure of the script object. A copy of all child objects will be
created as new children of the script object. A selection of the
new child objects will be established, then the script will be run.
Usually, the script modifies one of the selected objects (moves control
points, adds tags, or does something similar). Afterwards, the two sets
of objects will be exchanged, the modified objects will be moved to
the internal data structure of the script object while
the unmodified original child objects will again be child objects of the
script object. The modified objects will be provided upstream to
potential parents.
If certain actions in the script shall be restricted to
one of the child objects of the script object, the
<tt/"withOb"/ command may be used to accomplish this easily.
The script object will look like and act as an object of the type
of the first child object of the script object.
If the script object has e.g.~a NCurve object as first child, the
script object may be used as parameter object of a tool object that
needs a NCurve, e.g.~a Sweep:
<#if out=latex><x/needspace 6/</#if>
<tscreen><verb>
+-Sweep
 +-Cross_Section(Script)
 |\ NCurve
 \ Path(NCurve)
</verb></tscreen>
A simple example script for a script object of type <tt/"Modify"/ that
needs a single NURBS curve as child object may look
like this:
<code>
revertC
</code>
Note: In order to make this work for objects providing NURBS curves
(interpolating curves or instances of NURBS curves) the code has to
look like this:
<code>
convOb -inplace; revertC
</code>
</itemize>

<item><tt/"Script"/ is the script code. The corresponding widget
is a standard Tcl text widget that allows to directly edit the code.
It is also possible to edit the code in an external editor and
copy it to the script object using the operating system clipboard
and the <tt/"Paste (Replace)"/ context menu entry of the text widget.
If the first line of the script is a comment like
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
then the global Tcl array <tt>&lt;arrayname&gt;</tt> will be saved with
the script object to Ayam scene files.
The array must contain an entry <tt/"SP"/ that lists all individual
parameters of the script object. Note that only parameters from this
list will be saved to Ayam scene files.
Note also, that <tt/"SP"/ must <em/never/ contain <tt/"SP"/. All copies
of a script object must share the same set of individual vs. shared
parameters. If objects need to store differing/individual amounts of
parameter data, lists can be used as individual parameters.
</itemize>

<sect2>Script Object Examples<label id="scriptobjex">
<p>
This section illustrates the development of a script object for parametric
lines, otherwise unavailable in Ayam.
<p>
We start with a simple version, that first creates a NURBS curve object with
two control points and then places the control points each at +/- half the
desired line length on the x axis. Just copy the following code to the
Script property of a script object of type <tt/"Create"/, and activate it.
<code>
set length 1
crtOb NCurve -length 2
sL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</code>
<p>
<figure loc="ht">
<eps file="pics/scriptex1.ps" height="4cm">
<img src="pics/scriptex1.gif">
<caption>Simple Script for Parametric Line Primitive</caption>
</figure>
<p>
This code works, but if lines of a different length than 1 are needed,
the user must edit the script which is not very convenient and error
prone.
A complete, easy to use, and safe GUI for the length parameter
can be added by changing the script code
(<tt>&quot;&num; &circ;&circ;&circ;&quot;</tt> lines designate changed
or added code):
<#if out=latex><x/needspace 18/</#if>
<code>
# Ayam, save array: LineAttrData
if { ![info exists ::LineAttrData] } {
    array set ::LineAttrData {
	Length 1
	SP {Length}
    }
}
if { ![info exists ::LineAttrGUI] } {
    set w [addPropertyGUI LineAttr]
    addParam $w LineAttrData Length
}
set length $::LineAttrData(Length)
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
crtOb NCurve -length 2
sL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</code>
and by adding a <tt>"NP"</tt> (new property) tag to the script object
with the value <tt>"LineAttr"</tt>, resulting in a new clickable
graphical user interface as can be seen in the following image:
<p>
<figure loc="ht">
<eps file="pics/scriptex2.ps" height="4cm">
<img src="pics/scriptex2.gif">
<caption>Parametric Line Primitive with Parameter GUI</caption>
</figure>
<p>
The GUI setup code creates a Tcl array essential to manage the
data of an Ayam object property (LineAttrData). Then, the LineAttr
property GUI is created and a GUI element is added to the GUI using
<tt>"addParam"</tt>.
Note that the <tt>"addPropertyGUI"</tt> command expects for a property
named <tt>"SomePropertyName"</tt> a corresponding property data array
named <tt>"SomePropertyNameData"</tt> to exist.
The GUI setup code should just run once, therefore it checks for the
presence of the variable LineAttrGUI (which is set on the first run of
<tt>"addPropertyGUI"</tt>) first.
See also section
<ref id="ayproparr" name="Global Property Management and Data Arrays">
for more information about property GUIs and the Ayam scripting interface.
<p>
Finally, to enable saving of the parameter value in the new property
<tt>"LineAttr"</tt> to scene files, a comment must be prepended to the
script (<tt>"Ayam, save array: LineAttrData"</tt>), and to enable
multiple and individually parameterised copies of this
script object, a <tt/"SP"/ entry needs to be added to the
<tt>"LineAttrData"</tt> array as well.
<p>
The complete script is also available as example script file
<tt>"scripts/crtlinegui.tcl"</tt> in the Ayam distribution.
<p>
In addition, a second example demonstrates the scene traversal and
hierarchy building capabilities available to script objects since
Ayam 1.16.

Create a script object, and add two children to it, a box and a
NURBS curve (order 2, knot type: chordal works best). Then add the following
script to the script object:
<code>
# this script needs object type "Modify" and two children:
# a box/sphere and a curve
withOb 1 {estlenNC len}
cutOb
crtOb Clone
goDown -1
pasmovOb
goUp
sL
getProp
set CloneAttrData(NumClones) [expr round($len)]
setProp
</code>
This little script first determines the length of the curve,
then it creates a Clone object and moves the children of the Script
object to it (via the object clipboard). Finally, the Clone object
is parameterised, so that the trajectory is completely filled (assuming
that each copy of the first child needs 1 length unit on the trajectory)
with objects.
One may now modify the curve using interactive modelling actions,
change its length, and the trajectory is always completely filled.
See example image below (compare the Clone configurations from
the two different trajectory curves):
<p>
<figure loc="ht">
<eps file="pics/scriptex3.ps" height="5cm">
<img src="pics/scriptex3.gif">
<caption>Hierarchy Building Script Object Example</caption>
</figure>

<#if out=latex><x/newpage/</#if>

<sect1>Custom Objects<label id="customobj">
<p>
Custom objects are plugins that extend the Ayam capabilities by
defining totally new types of e.g.~geometric objects. This may
be done easily, because the Ayam core is written in a modelling
paradigm independent way.
<p>
A simple example of a custom object is the CSphere, which implements
a simple sphere and has a new property named <tt/"CSphereAttr"/.
This property contains all parameters of a simple RenderMan Interface
quadric sphere. A more complex example would be the MetaObj custom
object. It is possible, but not planned for now, to integrate
the T-Spline modelling paradigm into Ayam this way.
<p>
Since a custom object has total control over properties and representations,
you should refer to the documentation of the respective custom object for
more information regarding its properties.
<p>
One custom object is already distributed with Ayam. This Metaball
custom object is documented in the next section:

<#if out=latex><x/newpage/</#if>

<sect1>Metaball Object<label id="metaobjobj"><label id="metacompobj">
<p>
<figure loc="ht">
<eps file="pics/meta.ps" height="5cm">
<img src="pics/meta.gif">
<caption>A Metaball Object from Six Meta Components</caption>
</figure>
<p>
A metaball object is a custom object (see also section
<ref id="customobj" name="Custom Object">).
It allows you to model with implicit surfaces in realtime.
<p>
To start modelling you should first create a <tt>"MetaObj"</tt> object
using the menu entry
<tt>"Create/Custom Object/MetaObj"</tt> (if this menu entry is not
available, you have to load the <tt>"metaobj"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<tt>"Create/Custom Object/MetaObj"</tt> creates a so called meta world with a
single meta component (a sphere) in it. The meta world is represented
by a <tt>"MetaObj"</tt> object and the component by a <tt>"MetaComp"</tt>
object which is a child of the <tt>"MetaObj"</tt> object.
<p>
The complete template for the MetaObj object hierarchy, consequently,
looks like this:
<tscreen><verb>
+-MetaWorld(MetaObj)
 | C1(MetaComp)
 | [...
 \ Cn(MetaComp)]
</verb></tscreen>
<p>
The following table briefly lists some capabilities of the MetaObj and
MetaComp objects.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
MetaObj|MetaComp+|Yes|PolyMesh|No@<hline>
MetaComp|No|No|N/A|No<#if out=latex>@<hline></#if>
</tabular>
<caption>MetaObj/MetaComp Object Capabilities</caption>
</table>
<p>
Meta components live only in a meta world, therefore it makes no sense
to create <tt>"MetaComp"</tt> objects in other places except as a
child of a <tt>"MetaObj"</tt> object. Type, parameters, and
transformation attributes of the meta components define the function
of an implicit surface. The <tt>"MetaObj"</tt> object, that represents
the meta world, evaluates this function on a regular three-dimensional
grid and creates a polygonal representation for a specific function
value (the so called threshold value).
<p>
This process may be further parameterised using the <tt/"MetaObjAttr"/
property:

<sect2>MetaObjAttr Property<label id="moattr"><label id="metaobjattrprop">
<p>
<itemize>
<item>With the parameter <tt/"NumSamples"/ you specify the resolution of the
three-dimensional regular grid, on which the implicit function is
evaluated, in each dimension.
A higher number of samples results in better quality but more polygons
are created and more CPU power and memory are needed. For modelling
you should set this to a lower value of about 40. For final rendering
you may increase this to about 160.

<item><tt/"IsoLevel"/, defines the threshold value for that a polygonal
representation of the implicit function should be created. Normally, you
should not need to change this value.

<item>To show the actual bounds of the meta world, you may enable
the <tt>"ShowWorld"</tt> parameter.
</itemize>

New in Ayam 1.5 is an adaptive calculation mode of the implicit
surface. It may be switched on using the new attribute
<tt>"Adaptive"</tt>. In the adaptive calculation mode, Ayam tries
to vary the resolution of the resulting polygonal mesh according to
the features of the implicit surface in order
to capture fine details, even though a coarse grid is used.
This is not done using a successively refined grid but by a
refinement of the triangles created by the original algorithm
(see also XXXX).
You may control the adaptation process using three parameters:
<tt>"Flatness"</tt>, <tt>"Epsilon"</tt>, and <tt>"StepSize"</tt>.
If <tt>"Adaptive"</tt> is set to <tt>"automatic"</tt>, Ayam will
not use the adaptive calculation while a modelling action is in
progress. This mode has been introduced, because the adaptive mode
may consume a considerable amount of CPU resources.
<p>
While modelling with meta balls you may add other <tt/"MetaComp"/ objects
to the <tt/"MetaObj"/ object and parameterise them.
A <tt/"MetaComp"/ object has the following properties.

<sect2>MetaCompAttr Property<label id="mcattr"><label id="metacompattrprop">
<p>
<itemize>
<item><tt/"Formula"/ specifies the type of the meta component.
The following types are available: Metaball, Torus, Cube, Heart, and
Custom. The latter gives you the possibility to use your own formulas.

<item>With the parameter <tt/"Negative"/ you define a component with a
negative effect on the implicit function value.
Negative components are not visible on their own but they are useful
for modelling holes. Just try it.
</itemize>

The other parameter are specific to the type of the component:

<sect2>Metaball<label id="mbcp">
<p>
<itemize>
<item><tt/"Radius"/ sets the radius of the metaball
<item><tt/"EnergyCoeffA"/, <tt/"EnergyCoeffB"/, and <tt/"EnergyCoeffC"/
are some parameters for the metaball formula.
Usually you can leave those parameters at their default values.
If you change them, be careful.
</itemize>

<sect2>Torus<label id="mtcp">
<p>
<itemize>
<item><tt/"Ri"/ the inner radius of the torus
<item><tt/"Ro"/ the outer radius if the torus
<item><tt/"Rotate"/ rotates the torus about 90 degree
</itemize>

<sect2>Cube<label id="mucp">
<p>
<itemize>
<item><tt/"EdgeX"/, <tt/"EdgeY"/, and <tt/"EdgeZ"/, let you define the
sharpness of the edges of the cube
</itemize>

<sect2>Custom<label id="cucp">
<p>
<itemize>
<item><tt/"Expression"/ is a piece of Tcl script, that represents your
own custom formula for a meta component. The expression may call any
Tcl commands to calculate a field value from the current grid position,
which is given in the global variables <tt>"x"</tt>, <tt>"y"</tt>, and
<tt>"z"</tt>.
The expression has to return the field value in the global variable
<tt>"f"</tt>.
Here is an example for a custom expression:
<code>
set f [expr {pow($x,4)+pow($y,4)+pow($z,4)}]
</code>
Note that those expressions are called many times
and since they are programmed in Tcl, this can be quite slow.
You should use any tricks (like the curly braces
in the expr-statement above) to speed up the expression.
</itemize>

<sect2>Conversion Support
<p>
Metaball objects may be converted to PolyMesh
objects using the main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
Metaball objects will be exported as RiPointsGeneralPolygons primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.~a RiGeneralPolygon).
<p>
PV tags are currently not supported.

<#if out=latex><x/newpage/</#if>

<sect1>SDNPatch Object<label id="sdnpatchobj">
<p>
<figure loc="ht">
<eps file="pics/sdnpatch.ps" height="5cm">
<img src="pics/sdnpatch.gif">
<caption>SDNPatches, l: control mesh, m: subdivided mesh with knot, r: subdivided mesh without knot</caption>
</figure>
<p>
The SDNPatch custom object is available since Ayam 1.16 and
allows to model with Subdivision NURBS, which extend the traditional
subdivision schemes with knot values (see also the image above,
where in the middle mesh a knot value has been set in the left hand
side of the mesh).
The SDNPatch plugin is based on libsnurbs by Tom Cashman.
<p>
There are some special modelling actions for Subdivision NURBS
defined (see below) and there are PLY import/export facilities.
Furthermore, there are two conversion operations that convert
NURBS patch and PolyMesh objects to SDNPatch objects.
Thus, SDMesh objects may be converted in two steps to SDNPatch
objects, first to a PolyMesh then to the SDNPatch.
<p>
Please note that the plugin is still in experimental state,
there is limited error checking and crashes may occur, if
the special modelling actions are used.
<p>
The following table briefly lists some capabilities of the SDNPatch object.
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
SDNPatch|No|Yes|PolyMesh|Yes<#if out=latex>@<hline></#if>
</tabular>
<caption>SDNPatch Object Capabilities</caption>
</table>

<sect2>SDNPatchAttr Property<label id=sdnpattr><label id="sdnpatchattrprop">
<p>
The SDNPatchAttr property allows you to set the following SDNPatch specific
attributes:
<p>
<itemize>
<item><tt/"Degree"/ is the degree of the subdivision NURBS surface,
the only valid values are currently 3, 5, and 7.
<item><tt/"Level"/ is the subdivision level, a high level leads to
many polygons and a smooth surface; useful values range from 0 to 5.
</itemize>

<sect2>SDNPatch Modelling Actions
<p>
This section, briefly, explains the special modelling actions defined
for the SDNPatch custom object. In order to select a face or edge for
such an operation, just select all the control points defining the face
or edge.
All modelling actions can be started via the <tt>"Custom/SDNPatch"</tt>
main menu.
<p>
<itemize>
<item><tt/"Face Extrude"/, new faces are inserted in the mesh at all
edges of the selected faces, the selected faces themselves are displaced
along their respective normals. If this operation is picking the wrong
direction, try to revert all faces first, see below.
Since Ayam 1.17 this operation has two parameters that control the
offset of the extrusion operation (parameter <tt/"Length"/) and a
scaling factor applied to the new displaced set of control points
(parameter <tt/"Scale"/). The length parameter may be negative,
to revert the direction of the extrusion.
<item><tt/"Face Remove"/, the selected face is removed from the mesh.
<item><tt/"Face Merge"/, the first two selected faces are removed
from the mesh, the neighboring patches of the second face are connected
to the neighboring faces of the first face.
The decision, which vertices of the faces will actually be connected,
depends on the relative vertice distances: you need to move the two
faces near each other to make clear, how the new connection shall be
established.
<item><tt/"Face Connect"/, the first two selected faces are removed
from the mesh, the neighboring patches of the second face are connected
to the neighboring faces of the first face via a set of new faces.
The decision, between which vertices of the faces the new faces are built,
depends on the relative vertice distances: you need to move the two
faces near each other to make clear, how the new connection shall be
established.
<item><tt/"Reset All Knots"/, set all knot values to 1.0 (the default).
<item><tt/"Set Knot"/, set the knot value of the selected edge.
<item><tt/"Revert"/, reverts all faces.
<item><tt/"Merge"/, merges multiple SDNPatch objects into one new.
<item><tt/"Import PLY"/, import a PLY file.
<item><tt/"Export PLY"/, export the currently selected SDNPatch object
to a PLY file.
</itemize>

In addition, there are two conversion operations that convert
NURBS patch objects (or NURBS patch providing objects) and PolyMesh
objects (or PolyMesh providing objects) to SDNPatch objects.

Note that the PolyMesh to SDNPatch conversion only accepts closed
quadrilateral polygon meshes (Triangles are omitted) and expects
an optimized mesh (i.e.~adjacent faces should share the same vertices).

<sect2>Conversion Support
<p>
SDNPatch objects may be converted to PolyMesh
objects using the main menu entry <tt>"Tools/Convert"</tt>.

<sect2>RIB Export
<p>
SDNPatch objects will be exported as RiPointsGeneralPolygons primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.~a RiGeneralPolygon).
<p>
PV tags are currently not supported.

<#if out=latex><x/newpage/</#if>

<sect1>Standard Properties<label id="stdprop">
<p>
Most Ayam objects have standard properties. They are used
to control transformations and common attributes of objects.
The following sections describe the standard properties
<tt/"Transformations"/, <tt/"Attributes"/, <tt/"Material"/, <tt/"Shaders"/,
and <tt/"Tags"/.

<sect2>Transformations Property<label id="trap"><label id="transformationsprop">
<p>
Use the <tt/"Transformations"/ property to edit the location, orientation,
and size of an object.
<p>
The corresponding property GUI contains the following elements:
<itemize>
<item><tt/"Reset All!"/ immediately resets all transformation
attributes to the default values.

<item><tt/"Translate_X (_Y, _Z)"/ is the displacement of the
object from the world origin in X (Y, Z) direction.

<item><tt/"Rotate_X (_Y, _Z)"/ is the angle (in degrees)
of the rotation of the object around the X (Y, Z) axis.
Read the next section for more information on how to use these
entries. Read it!
<item><tt/"Quaternion"/ the quaternion that is used to determine
the orientation of the object in space.

<item><tt/"Scale_X (_Y, _Z)"/ determines a scale factor that will be
applied to the object in the direction of the local X (Y, Z) axis.
</itemize>

The transformations are applied to the object in the following order:
Scale, Rotation, Translation.
<p>
How to use the rotation attributes?<label id="gimb">
<p>
The orientation of an object in space may be expressed using
so called Euler angles. This notation (simply three angles
determining a rotation about the axes of the coordinate system)
suffers from a phenomenon called gimbal lock.
<p>
To avoid gimbal locks, Ayam internally holds the orientation
of an object in a quaternion.
This quaternion not only holds information about the angles
but also about the order in which partial rotations occured.
<p>
It is important to know, that the values of the angles of
the rotation property must not be read in a way that
the object will first be rotated around X by x-angle degrees
then around Y y-angle degrees then around Z z-angle degrees.
In fact, no information about the order in which partial
rotations occured may be derived from that three values.
This implies, that e.g.~the values 0 0 45 may denote
a different orientation than the very same values
0 0 45 (no joke)!
<p>
But how do you get the three entries to do what you want?
You either want to rotate the object around an axis by a given
amount or you want to undo a rotation or undo all rotations.
<p>
Rotating an object is easy, simply <em>add</em> the amount about
which you want to rotate the object to the value currently
displayed in the appropriate entry. If you want to rotate
about 45 degrees about X and the x-angle entry displays a 30,
enter 75.
Then press the apply button.<newline>
If you change multiple entries the rotations made will be
in the order X (if changed) then Y (if changed) then Z (if changed).
Do not change more than one entry at once unless you exactly
know what you are doing.
<p>
Undoing a single rotation works in the same way, just use a subtraction
instead of an addition.
<p>
Undoing all rotations (resetting the object to its original state)
is simple too: enter 0 for all three entries at once,
then press apply.
<p>
If you want to copy just the orientation of an object to other objects
using the property clipboard, mark/select all Translate and Scale
property elements, then use <tt>"Edit/Copy Property"</tt>.
Just marking the Rotate elements and then using
<tt>"Edit/Copy Marked Prop"</tt>
will <em>not</em> work, because the quaternion will not be copied
properly.

<sect2>Attributes Property<label id="attrs"><label id="attributesprop">
<p>
The <tt/"Attributes"/ property of an object contains currently:
<itemize>
<item><tt/"Objectname"/, the name of the object. It is also displayed
in the object listbox or tree and may be written to RIB streams.

<item><tt/"Hide"/, if this attribute is set this object is not drawn.
It may also be excluded from RIB export.

<item><tt/"HideChildren"/, if this attribute is set, the child objects
of this object are not drawn. This attribute is e.g.~used by
<tt/"NPatch"/ objects to prevent the trim curves from being drawn
in normal views.

<item><tt/"RefCount"/, just displays how many objects point to this
object e.g.~through master-instance or object-material relationships.
Objects with a reference count higher than zero may not be deleted.
</itemize>

<sect2>Material Property<label id="matprop"><label id="materialprop">
<p>
The <tt/"Material"/ property allows you to connect geometric objects
to material objects (see also section
<ref id="materialobj" name="Material Object">).
The material property GUI consist of the following elements:
<itemize>
<item><tt/"Clear Material!"/ immediately clears any connection
of the current object to its material.

<item><tt>"Add/Edit Material!"</tt> adds a material to the
current object (if it has none) and immediately selects
the new material object for editing. If the current object
already has a material, this material object is searched for
and selected for editing.

<item><tt/"Materialname"/ is the name of the material of this object.
If you change the name, the object will be disconnected from the
old material and connected to the new material.
An easier way to connect geometric objects to material objects is to simply
drop the geometric objects onto the material object using drag and drop
in the tree view.
</itemize>

<sect2>Shader Properties<label id="shd"><label id="atmosphereprop">
<label id="imagerprop"><label id="surfaceprop"><label id="displacementprop">
<label id="interiorprop"><label id="exteriorprop"><label id="lightshaderprop">
<p>
Shader properties are used to attach shaders of a certain type to objects.
The name of the property contains the type of the shader, e.g.~light
shaders may be attached using a property named <tt/"LightShader"/ only.
Other types of shaders or shader properties available are: <tt/"Surface"/,
<tt/"Displacement"/, <tt/"Interior"/, <tt/"Exterior"/, <tt/"Atmosphere"/,
and <tt/"Imager"/.
<p>
Each shader property GUI, even if no shader is attached to an object,
starts with the <tt/"Set new shader."/-button. This button allows
to select a new shader of the appropriate type.
If you press the <tt/"Set new shader."/-button, a dialog with a
list of shaders pops up. If this list is empty, Ayam
is probably not set up properly (or you simply do not have
shaders of the appropriate type). Check the preference setting
<tt>"Main/Shaders"</tt>.
After a new shader has been set, the arguments of the shader will be
parsed and a GUI will be generated to allow the arguments of the shader
to be filled with values.
<p>
The <tt/"Delete shader."/-button may be used to
delete the current shader from the selected object.
<p>
The <tt/"Default Values."/-button resets all arguments
of the shader to the default values.
See also section <ref id="workshd" name="Working with Shaders"> below.
<p>
All other elements of the shader property GUI depend on the currently
attached shader.
<p>
<bf>Shader Parsing</bf><label id="parseshd">
<p>
If no plugin is loaded, the official Ayam binaries use libslcargs
(from BMRT) to parse shaders that have been compiled with slc (the
shader compiler from BMRT). Parsing incorporates detecting the
type of the shader and detecting the names, types, and default values of
all shader arguments.
<p>
Note that currently, Ayam only works properly with shaders
that have at most two dots in their file name and that Ayam will simply
skip all array arguments (and emit a warning message) while parsing
a shader. Those array arguments consequently never appear in the
shader property GUIs and RIBs exported by Ayam. Also note that
default values for shader arguments of type color will be silently
clamped to the range 0-255.
<p>
Many shaders use array arguments to define transformation matrices.
If this is the case and you have access to the shader source code
you may want to modify those shaders to enable working with the
transformation matrix carrying shader arguments. To do this, just
change all definitions of transformation matrix carrying floating
point arrays to real matrices. If the shader contains a
<p>
<tt>"float a_matrix_parameter[16]"</tt>
<p>
change this to
<p>
<tt>"matrix a_matrix_parameter"</tt>.
<p>
Note that these changes of the shader argument definitions probably
also require changes of the shader source code that uses those arguments.
Ayam is able to deal with matrices because of their fixed size of 16
float values, and because libslcargs is able to deliver the default
values for a matrix (but not for an array!).
<p>
If Ayam has been compiled without a shader parsing library
(e.g.~without libslcargs), Ayam will parse XML files created
by <tt/"sl2xml"/ from the K-3D project
(see <tt>"http://www.k-3d.org/"</tt>)
instead of compiled shaders.
The <tt/"Set new shader."/-button will in this case always
open a file requester, allowing you to select a XML file,
that has been created by sl2xml.
Furthermore, the <tt/"Default Values."/-button will not be available;
you have to use <tt/"Set new shader."/ instead.
<p>
From version 1.3 on, Ayam also supports shader parsing plugins to allow
parsing of shaders compiled with different shader compilers, see also
section <ref id="spplugins" name="Shader Parsing Plugins">.
<p>
<bf>Working with Shaders</bf><label id="workshd">
<p>
The <tt/"Default Values."/-button resets all arguments of the shader
to the default values.
Additionally, the compiled shader will be parsed again and the property GUI
will be adapted (new shader arguments will appear, removed shader arguments
will disappear).
Therefore, this button is quite handy if you have to deal with
changing shaders: just edit the shader, recompile it, then back
in Ayam just hit the <tt/"Default Values."/-button. Note that
this destroys your possibly carefully adjusted shader argument values.
<p>
If you want to keep the old shader argument values when a shader
changes, simply copy the shader property using the property clipboard
(main menu: <tt>"Edit/Copy Property"</tt>) before
you load the new default values and paste the property
back using <tt>"Edit/Paste Property"</tt> after loading of the
new default values.
Beware! This works properly only, if you do not change the type of
existing shader arguments and if no shader arguments are removed in
the new version of the shader.
<p>
You can also just copy certain parameter values (shader arguments
whose types do not change) by selecting them using double-clicks
on the parameter names in the shader property GUI and then use
e.g.~<tt>"Edit/Copy Marked Prop"</tt>
(see also the description of the property clipboard in section
<ref id="propgui" name="Properties">).

<sect2>Tags Property<label id="tagsprop">
<p>
Use the <tt/"Tags"/ property to edit the tags of an object.
<p>
Tags provide an easy way to attach arbitrary information (e.g.~additional
RenderMan interface attributes, special attributes for plugins or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.
<p>
The tags property GUI consists of the following standard
elements:
<itemize>
<item><tt/"Remove all Tags!"/ immediately removes all tags
from the object.

<item><tt/"Remove Tag!"/ is a menu, that allows you
to select and remove a single tag from the object.

<item><tt/"Add Tag!"/ opens a small dialog box, where you
may enter a new tag type and value. Once you press the <tt/"Ok"/
button, a new entry will be added to the tags property, displaying
the new tag. Just click on the entry to get back to the dialog,
to remove the tag using <tt/"Clear"/ then <tt/"Ok"/, or to change
the type or value of the tag.
</itemize>
<p>
The next sub-sections describe the tag types currently available in Ayam
and the plugins distributed with Ayam.
Note that extensions and plugins may define their own types.

<sect1>Tags<label id="tags">
<p>
Tags provide an easy way to attach arbitrary information (e.g.~additional
RenderMan interface attributes, special attributes for plugins or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.
Tags may be manipulated via the tags property GUI (see
section <ref id="tagsprop" name="Tags Property">)
or the scripting interface.
<p>
The following sections documents all currently known tag types.

<sect2>RiAttribute Tag<label id="riatag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiAttribute"/ can be used to attach
arbitrary RenderMan interface attributes to objects.
This is handy if a renderer with lots of RiAttributes
that differ from the standard RiAttributes is in use.
<p>
<tt/"RiAttribute"/ tags attached to a geometric object override
<tt/"RiAttribute"/ tags possibly attached to the material object of this
geometric object.
<p>
<#if out=latex><x/newpage/</#if>
In order to create a tag of type RiAttribute, the type string must be
<tt/"RiAttribute"/. The syntax of the value string is as following:
<p>
<tt/&lt;attrname&gt;,&lt;paramname&gt;,&lt;paramtype&gt;,&lt;param&gt;/
<p>
where attrname is the name of the attribute (e.g.~"render") paramname
is the name of the parameter (e.g.~"displacementbound") paramtype is a
single character defining the type of the parameter (it may be one of
<tt/f/ &ndash; float, <tt/g/ &ndash; float pair, <tt/i/ &ndash; integer,
<tt/j/ &ndash; integer pair, <tt/s/ &ndash; string, <tt/c/ &ndash; color,
<tt/p/ &ndash; point) and finally
param is the value of the parameter itself (e.g.~a float: "1.2", an
integer value: "3", a string: "on", a color: "1,1,1" or a point:
"0.4,0.5,1.0").
<p>
<bf/Example/
<p>
Some examples for valid RiAttribute tags:
<tscreen><verb>
RiAttribute render,truedisplacement,i,1
RiAttribute dice,numprobes,j,3,3
RiAttribute radiosity,specularcolor,c,0.5,0.5,0.5
</verb></tscreen>
<p>
<bf/Notes/
<p>
The <tt/"RiAttribute"/ tag handles just a single parameter at once.
Also note that <tt/"RiAttribute"/ tags may be created much more easily
using the menu entry <tt>"Special/Tags/Add RiAttribute"</tt>.
The database of RiAttributes for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>RiOption Tag<label id="riotag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiOption"/ can be used to attach arbitrary RenderMan
interface options to the scene. This is handy if a renderer with
lots of RiOptions that differ from the standard RiOptions is in use.
However, they will be only used by the RIB exporter if they are attached
to the <tt/"Root"/ object.
The syntax is similar to the <tt/"RiAttribute"/ tag type, see above.
<p>
<bf/Example/
<p>
<tscreen><verb>
RiOption radiosity,steps,i,16
RiOption shadow,bias0,f,0.01
</verb></tscreen>
<p>
<bf/Notes/
<p>
RiOption tags may be created easily using the menu entry
<tt>"Special/Tags/Add RiOption"</tt>.
Tags created with this GUI will always be added to the <tt/"Root"/ object.
It does not have to be selected when the GUI is used.
Furthermore, the database of RiOptions for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>TC (Texture Coordinates) Tag<label id="tctag">
<p>
<bf/Description/
<p>
The tag type <tt/"TC"/ can be used to attach texture coordinates to
objects or materials.
<p>
The <tt/"TC"/ tag always contains a list of eight comma separated
float values, that specify a mapping for four 2D points (a quadrilateral)
in texture space from the default values (0,0), (1,0), (0,1), and (1,1)
to the new specified values.
<p>
<bf/Example/
<p>
<tscreen><verb>TC 0,0,10,0,0,10,10,10</verb></tscreen>
Changes the texture coordinate space so that more and smaller tiles
of a texture would be displayed on a primitive.

<tscreen><verb>TC 0,0,0,1,1,0,1,1</verb></tscreen>
Flips the texture coordinate space over two corners.
A shader normally generating vertical stripes will create
horizontal stripes now.

<tscreen><verb>TC 0,1,0,0,1,1,1,0</verb></tscreen>
Turns the texture coordinate space by 90 degrees.
A shader normally generating vertical stripes will create
horizontal stripes now.
<p>
<bf/Notes/
<p>
<tt/"TC"/ tags attached to a geometric object override
<tt/"TC"/ tags possibly attached to the material object of this
geometric object.
<p>
The exact behaviour of an object equipped with a <tt/"TC"/ tag
depends heavily on the shader and its use of the texture coordinates.
<p>
Note also that using <tt/"TC"/ tags you change the texture coordinates
of entire primitives only, if you want to change the texture coordinates
of sub-primitives (e.g.~of single control points of a NURBS patch)
you would need to use a <tt/"PV"/ (Primitive Variable) tag instead.
<p>
To ease setting of <tt/"TC"/ tag values Ayam provides a special graphical
editor as outlined below.
<p>
The texture coordinate editor<label id="tce"> may be opened using the
main menu entry <tt>"Special/Tags/Edit TexCoords"</tt> and
lets you edit texture coordinate tags in an intuitive way.
<p>
For that, the current texture coordinates are displayed as a black
polygon in a canvas with regard to the original (default) values,
that are displayed in gray.
Small arrows point to positive s and t direction respectively.
<p>
<figure loc="ht">
<eps file="pics/tce.ps" height="6cm">
<img src="pics/tce.gif">
<caption>Texture Coordinate Editor</caption>
</figure>
<p>
The <tt/"RotateR"/ and <tt/"RotateL"/ buttons shift the coordinate
values between the four points. This results in a 90 degree
rotation of the texture space.
<p>
The <tt/"FlipS"/ and <tt/"FlipT"/ buttons flip the texture
coordinate values in s and t direction respectively. This is
useful, if you, for example, want to correct a texture mapping for
an image that appears upside down.
<p>
The next buttons allow to move (using <tt/"MoveS"/ and <tt/"MoveT"/)
and scale (using <tt/"ScaleS"/ and <tt/"ScaleT"/) the texture coordinates
by a specific amount that is given in the first entry field.
<p>
The <tt/"Load"/ and <tt/"Save"/ menu buttons allow you to:
<itemize>
<item>load the default texture coordinate values ((0,0), (1,0), (0,1), (1,1)),

<item>load texture coordinates from a selected BPatch object:
The xy coordinates of the four points of the selected BPatch
will be interpreted as st coordinates.
This allows for more complex transformations of the texture coordinates
e.g.~rotations about an angle of 45 degrees. For that just create a
BPatch object, rotate it accordingly, then load the coordinates into
the texture coordinate editor.

<item>load TC tags from the selected object,

<item>save the texture coordinates to a BPatch object,

<item>save TC tags to a selected object. Note that it is not
possible to directly save the TC tag to multiple selected objects.
But you can use the property clipboard to copy the tag after saving
to a single object.
</itemize>
Note that the tag numbers in the menu entries count TC tags only.
<p>
The texture coordinate dialog is modeless, it may stay open
while you model. The <tt/"Dismiss"/ button closes the dialog.

<sect2>PV (Primitive Variable) Tag<label id="pvtag">
<p>
<bf/Description/
<p>
The tag type <tt/"PV"/ can be used to attach arbitrary data
to geometric primitives and even sub-primitives.
With the help of primitive variables you can e.g.~attach your
own texture coordinates to a NURBS patch primitive or attach distinct
colors to the faces or even to single vertices of a polygonal mesh.
In the latter case, the data is properly interpolated by the RenderMan
renderer before it is handed over to the surface shader.
<p>
When rendering, all data defined in a <tt/"PV"/ tag is handed over
to the surface shader that is attached to the respective geometric primitive
using additional shader parameters.
For RIB export, proper <tt/"RiDeclare"/ statements will be created
automatically by Ayam.
<p>
However, Ayam does not check, whether your shaders actually use the data
from the <tt/"PV"/ tag.
<p>
The syntax of the value string of a PV tag is as following:
<p>
<tt/&lt;name&gt;,&lt;detail&gt;,&lt;type&gt;,&lt;ndata&gt;,&lt;data&gt;/
<p>
where
<tt/"&lt;name&gt;"/ is the name of the primitive variable;
<tt/"&lt;detail&gt;"/ (or storage class) should be one of
<tt/"uniform"/, <tt/"varying"/, <tt/"vertex"/, or <tt/"constant"/;
<tt/"&lt;type&gt;"/ is a single character describing the type of the
data (one of <tt/"c"/ (color), <tt/"f"/ (float), <tt/"g"/ (float[2]),
<tt/"n"/ (normal), <tt/"p"/ (point), <tt/"s"/ (string), or <tt/"v"/ (vector),
see also the documentation of the <tt/"RiAttribute"/ tag above);
<tt/"&lt;ndata&gt;"/ is an integer number describing how many data
elements will follow; and
<tt/"&lt;data&gt;"/ is a comma separated list
consisting of <tt/"&lt;ndata&gt;"/ elements of type <tt/"&lt;type&gt;"/.
<p>
<bf/Examples/
<p>
<tscreen><verb>PV mycolor,constant,c,1,0,1,0</verb></tscreen>
adds a single color value (0,1,0), which is the same all over the primitive,
the respective surface shader should have a parameter <tt/"color mycolor"/;
<tscreen><verb>PV mys,varying,f,4,0.1,0.2,0.3,0.4</verb></tscreen>
could be used to add a distinct float value to each corner point of a
four point NURBS patch (of order, width, and height 2),
the respective surface shader should have a parameter
<tt/"varying float mys"/.
<p>
<bf/Notes/
<p>
The following data types are <em>not</em> supported: i, j.
Support for the data types n (normal), and v (vector) was added
in Ayam 1.17.
<p>
Not all geometric objects currently honour PV tags
on RIB export. The geometric objects currently supporting PV tags
are: SDMesh, PolyMesh, PatchMesh, NPatch, and BPatch.
Most tool objects that internally create NPatch objects also support PV tags.
<footnote>Since 1.20.</footnote>
Mind that the same set of tags
will be used for all surfaces that make up the tool object, e.g.
the swept surface, the bevels, and the caps.
<p>
Furthermore, the number of data elements, which depends on the
detail or storage class, the type of geometric primitive, and the
configuration of the geometric primitive is <em>not</em> checked by Ayam.
Some RIB writing libraries, however, check the number and silently
omit the primitive variable if there are mismatches. Check your
RIB for the presence of the primitive variable after export,
especially, if you are adding or editing PV tags manually.

<sect2>RiHider Tag<label id="rihtag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiHider"/ can be used to choose and parameterise
different algorithms for hidden surface removal when rendering
the exported scene with a RenderMan compliant renderer.
RiHider tags have to be attached to the root object in order to be used.
The syntax of a RiHider tag is quite similar to a RiAttribute tag:
<tt/"&lt;type&gt;,&lt;parameterlist&gt;"/
where <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
<p>
<bf/Example/
<p>
A RiHider tag could look like this:
<p>
<tscreen><verb>RiHider hidden,depthfilter,s,midpoint</verb></tscreen>

<sect2>RiDisplay Tag<label id="ridtag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiDisplay"/ can be used to add output files of
different type (e.g.~containing depth-buffer information)
to the scene or to directly control the output format when rendering
the exported scene with a RenderMan compliant renderer.
RiDisplay tags have to be attached to the root object in order to be used.
The syntax of a RiDisplay tag is as follows:
<tt/"&lt;name&gt;,&lt;type&gt;,&lt;mode&gt;,&lt;parameterlist&gt;"/,
where name is e.g.~a file or device name, type specifies the
destination of the image data (e.g.~screen or file), mode
specifies which information should be stored or displayed
(e.g.~color values: rgb, or depth values: z),
and <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
<p>
<bf/Example/
<p>
A RiDisplay tag to add output of the depth-buffer information to the
file <tt/"imagez.tif"/ could look like this:
<tscreen><verb>RiDisplay imagez.tif,file,z</verb></tscreen>
<p>
<bf/Notes/
<p>
The name will be automatically changed to <tt/"+name"/ on RIB export
if it does not already start with a plus.

<sect2>NoExport Tag<label id="noexporttag">
<p>
<bf/Description/
<p>
The tag type <tt/"NoExport"/ can be used to exclude certain objects
from exported RIBs. The value string of this tag is ignored. All
that counts is the presence of the tag. Child objects of objects
with the <tt/"NoExport"/ tag will also be excluded from the RIB.
Since Ayam 1.6, light objects also honour the <tt/"NoExport"/ tag.
Note that regardless of potentially present <tt/"NoExport"/ tags,
RIB archives will be created for all referenced objects all the
time (even if <tt/"NoExport"/ tags are added to all instances).

<sect2>SaveMainGeom Tag<label id="savemaingeomtag">
<p>
<bf/Description/
<p>
The tag type <tt/"SaveMainGeom"/ can be used to save the geometry
of the main window and the toolbox window (if open) to a scene
file. For that the scene saving code checks for the presence of
a <tt/"SaveMainGeom"/ tag for the root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <tt/"SaveMainGeom"/ tag for the root object
after replacing a scene and re-establishes the geometries of
main and toolbox window.

<sect2>SavePaneLayout Tag<label id="savepanelayouttag">
<p>
<bf/Description/
<p>
The tag type <tt/"SavePaneLayout"/ can be used to save the relative
sizes of the internal windows of the main window when Ayam runs in
the single window GUI mode to a scene file.
For that the scene saving code checks for the presence of
a <tt/"SavePaneLayout"/ tag for the root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <tt/"SavePaneLayout"/ tag for the root object
after replacing a scene and re-establishes the geometries of the
internal windows.

<sect2>TP (Tesselation Parameter) Tag<label id="tptag">
<p>
<bf/Description/
<p>
The tag type <tt/"TP"/ can be used to save tesselation parameters
to objects of type <tt/"NPatch"/ (and objects that may be converted
to <tt/"NPatch"/ objects). Those tesselation parameters
will be used when the NPatch object is tesselated for e.g.~a
conversion to a PolyMesh object. The syntax of the TP tag is:
<tt>"&lt;tmethod&gt;,&lt;tparamu&gt;,&lt;tparamv&gt;"</tt>
where <tt/"&lt;tmethod&gt;"/ is an integer value between 1 and 3, describing
which tesselation method to use (1 &ndash; ParametricError,
2 &ndash; PathLength, and 3 &ndash; DomainDistance) and
<tt/"&lt;tparamu&gt;"/ and <tt/"&lt;tparamv&gt;"/ are float values
describing the respective parameter value for the chosen tesselation
method. The second parameter value is ignored for the tesselation methods
1 and 2.
<p>
Note that the syntax of the <tt/"TP"/ tag changed in Ayam 1.9,
the old syntax only allowed one parameter.
<p>
TP tags may be easily created using the tesselation GUI, that can
be started with the main menu entry <tt>"Tools/Surface/Tesselate"</tt>
(see also section <ref id="tesst" name="Tesselation Tool">).
<p>
<bf/Example/
<p>
A TP tag could look like this:
<tscreen><verb>TP 1,0.5,0.6</verb></tscreen>

<sect2>DC (Depth Complexity) Tag<label id="dctag">
<p>
<bf/Description/
<p>
The tag type <tt/"DC"/ is only used by the AyCSG CSG preview plugin
to store the depth complexity of CSG primitives.
The syntax of the DC tag is:
<tt>"&lt;dcval&gt;"</tt>
where <tt/"&lt;dcval&gt;"/ is a positive integer value describing the
depth complexity of the CSG primitive. See also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">
for more information regarding the depth complexity value.
<p>
<bf/Example/
<p>
A DC tag (valid for e.g.~a torus) could look like this:
<tscreen><verb>DC 2</verb></tscreen>

<sect2>NP (New Property) Tag<label id="nptag">
<p>
<bf/Description/
<p>
The tag type <tt/"NP"/ (new property) may be used to add new property
GUIs to single objects. The value of the tag is the name of a new
property. The necessary code to manage the property data and the
windows that make up the property GUI itself have to be present in
the Tcl context of Ayam before the user clicks on the new property in the
property list box.
<p>
<bf/Example/
<p>
<tscreen><verb>NP Transformations</verb></tscreen>

<sect2>RP (Remove Property) Tag<label id="rptag">
<p>
<bf/Description/
<p>
The tag type <tt/"RP"/ (remove property) may be used to remove GUI access
to a property from single objects. The value of the tag is the name of the
property to be removed. The GUI access will be blocked by simply omitting
the property from the property listbox.
Note well: the property is still present and active in the objects themselves
and values may still be set using the scripting interface.
<p>
<bf/Example/
<p>
<tscreen><verb>RP Script</verb></tscreen>
removes direct access to the Script property of a Script object.
Ideally, the Script object also has a <tt/"NP"/ tag, to allow
direct control of script parameters. This way, the user does not
see the script (code), just a clean parameter GUI.

<sect2>BNS (Before Notify Script) Tag<label id="bnstag">
<p>
<bf/Description/
<p>
The tag type <tt/"BNS"/ (before notify script) may be used to add scripts
to an object, that will be run <em/before/ the notification callback of
that object completed.
The notification, in turn, will be executed because e.g.~one of the children
of the object changed.
<p>
<bf/Example/
<p>
A simple BNS tag could look like this:
<tscreen><verb>BNS puts "notify callback about to fire"</verb></tscreen>
<p>
<bf/Notes/
<p>
In Ayam versions prior to 1.16 BNS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
BNS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<ref id="safeinterp" name="Safe Interpreter">.
Consequently, the warning dialog that appeared when files with
BNS tags were loaded is also gone.
<p>
You can still re-enable the old functionality by recompiling Ayam.
If you do so, for security reasons, if scene files containing BNS
tags are loaded, Ayam will again raise the warning offering to
temporarily disable all such tags that will be read.
To disable a BNS tag, Ayam simply changes its type from <tt/"BNS"/
to <tt/"DBNS"/ (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <tt/"BNS"/
or by using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>ANS (After Notify Script) Tag<label id="anstag">
<p>
<bf/Description/
<p>
The tag type <tt/"ANS"/ (after notify script) may be used to add scripts
to an object, that will be run <em/after/ the notification callback of
that object completed.
The notification, in turn, will be executed because e.g.~one of the children
of the object changed.
<p>
<bf/Example/
<p>
A simple ANS tag could look like this:
<tscreen><verb>ANS puts "notify callback completed"</verb></tscreen>
<p>
<bf/Notes/
<p>
In Ayam versions prior to 1.16 ANS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
ANS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<ref id="safeinterp" name="Safe Interpreter">.
Consequently, the warning dialog that appeared when files with
ANS tags were loaded is also gone.
<p>
You can still re-enable the old functionality by recompiling Ayam.
If you do so, for security reasons, if scene files containing ANS
tags are loaded, Ayam will again raise the warning offering to
temporarily disable all such tags that will be read.
To disable a ANS tag, Ayam simply changes its type from <tt/"ANS"/
to <tt/"DANS"/ (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <tt/"ANS"/
or by using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>UMM/VMM (U/V Min Max) Tag<label id="ummtag">
<p>
<bf/Description/
<p>
The tag types <tt/"UMM"/ (u min max) and <tt/"VMM"/ (v min max) may
be used to store additional parametric domain trimming values to
NURBS curve and NURBS patch objects. Note that the GLU NURBS display
modes do not honor those tags, but the RIB export does.
<p>
<bf/Example/
<p>
An UMM tag could look like this:
<tscreen><verb>UMM 0.4,0.6</verb></tscreen>

<sect2>BP (Bevel Parameters) Tag<label id="bptag">
<p>
<bf/Description/
<p>
The tag type <tt/"BP"/ (bevel parameters) is used by all bevel
supporting tool objects to store their bevel information.
The syntax of the BP tag is:
<tt>"&lt;side&gt;,&lt;type&gt;,&lt;radius&gt;,&lt;revert&gt;"</tt>
where <tt/"&lt;side&gt;"/ is an integer value from 0 - 3
defining the side of the surface, where the bevel should be applied
to, <tt/"&lt;type&gt;"/ is an integer value from 0 - 4 defining
the type of the bevel, <tt/"&lt;radius&gt;"/ is a floating point
value defining the radius of the bevel, and <tt/"&lt;revert&gt;"/
is either 0 or 1 and may be used to revert the bevel.
<p>
<bf/Example/
<p>
A BP tag could look like this:
<tscreen><verb>BP 0,0,0.1,0</verb></tscreen>

<sect2>Internal Tags
<p>
The following tags are used by Ayam internally only; they will <em>not</em>
appear in the tags property GUI and they can <em>not</em> be deleted or
changed using the scripting interface.
<itemize>
<item>OI (Object ID) Tag<label id="oitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between instance objects and
the original objects they are pointing to.

<item>MI (Material ID) Tag<label id="mitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between material objects and
the objects they are assigned to.

<item>NO/NM Tags<label id="nott"><label id="nmtt">
<p>
These tags are internal binary tags, that transport the notification
across the scene.

</itemize>

<sect2>List of Known Tags
<p>
This section contains a comprehensive list of tag names, that are
known since Ayam 1.10 and in all accompanying extensions (plugins).
<p>
<tt>"RiAttribute", "RiOption", "RiHider", "RiDisplay", "NoExport", "TC",
"PV", "SaveMainGeom", "SavePaneLayout", "TP", "MI", "OI", "DC", "TM", "NP",
"RP", "BNS", "DBNS", "ANS", "DANS", "NO", "NM",
"UMM", "VMM", "BP", "IDR", "IIDR", "RIDR", "R3IDR", "CIDR", "CCIDR"</tt>
<p>
The following tags are for internal use (they will not be displayed in the
Tags property of an object):
<tt>"MI", "OI"</tt>
<p>
Tags of type <tt>"NO", "NM"</tt> are binary, they also never show up in the
Tags property.
<p>
Documentation on all those tags can be found in the sections above.

<sect>NURBS Modelling Tools<label id="nmtool">
<p>
This section describes NURBS curve and surface related modelling
tools.

<sect1>General Remarks
<p>
All NURBS modelling tools are accessible via the <tt/"Tools"/ menu of the
main window or the toolbox. In addition, there are also corresponding
scripting interface commands.
<p>
Many modifying tools work on multiple selected objects and execute
the selected operation on all those selected objects in the order
of their appearance in the current level.
<p>
Tools that take only NURBS curves or only NURBS surfaces from the selection
will warn if the selection contains objects of unsuitable type,
but processing will continue.
<p>
In case of an error, however, the processing of multiple selected
objects immediately stops possibly leaving modified <em>and</em>
unmodified objects behind.
<p>
If an operation executed successfully on an object, the selected
points will be removed from the object. Then the notification
of the object will be run. The notification of the parent object(s)
will be run after processing of all selected objects finished.

<sect1>Circular B-Spline Tool<label id="cbspt">
<p>
<figure loc="ht">
<eps file="pics/cbsps.ps" height="5cm">
<img src="pics/cbsps.gif">
<caption>B-Spline Curves Created by the Circular B-Spline Tool</caption>
</figure>
<itemize>
<item>Arguments: Radius, Arc, Sections, Order.
<item>Operation: This tool creates a non-rational B-Spline curve with
Sections+1+Order (Arc=360.0) or Sections+1+(Order/2) (other Arc values)
control points in the XY plane. The control points
are arranged in a circle of the given radius, centered around the origin.
This gives the curve a circular appearance (see image above) but it
is <em>not</em> a true circle:
If only few control points are used, the radius of the circular curve
is clearly smaller than the specified radius value (see the left curve
in the image above).
Furthermore, shape, parameterisation, and curvature of the
B-Spline curve are not exactly as one would expect from a circle.
To create true circular curves, the NURBCircle tool (see below) should
be used instead.
<item>Note: Sections must be atleast 1. If Arc is 360.0, the first
n control points of the new curve will be identical to the last n
(where n is Order-1). Compare the left and middle curves in the image
above which are of order 4 and 2 respectively, the first having
3 and the latter just having 2-1=1 equal control points.
If Arc is 360.0, the curve will also be marked periodic and the
generation of multiple points will be enabled, so that point edit
actions know that they may need to move two points
(see also section <ref id="ncurvemp" name="Multiple Points">).
If Arc is smaller than 360.0, the curve will be open, and, as is natural
for a B-Spline curve, will not interpolate the first and last control
points unless the order is 2 (see the right curve in the image above,
which was created with an arc value of 180.0, 10 sections, and order 4).
</itemize>

<sect1>NURBCircle Tool<label id="ncirct">
<p>
<figure loc="ht">
<eps file="pics/ncircle.ps" height="5cm">
<img src="pics/ncircle.gif">
<caption>A NURBS Circle</caption>
</figure>
<itemize>
<item>Arguments: Radius, Arc.
<item>Operation: The NURBCircle tool creates a circular NURBS curve
of desired radius and arc in the XY plane, centered around the origin.
The order of the curve will be 3. The number of control points used
differs according to the arc, e.g.~9 points for full circles,
5 for half circles,
3 for a quarter circle.
<item>Note: The NURBS curve created by the NURBCircle tool is rational
(uses weights). This means, editing the curve (e.g.~moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished). Use a closed B-Spline created with the Circular B-Spline tool
(see above) if you want to edit the curve further.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
<p>
You can use a NURBS circle created by this tool to easily create a
NURBS-torus by moving the circle along X a bit and then revolving it.
The amount of movement determines the radius of the torus, whereas
the radius of the circle determines the thickness.
</itemize>

<sect1>TrimRect Tool<label id="trrt">
<p>
<itemize>
<item>Arguments: None
<item>Operation: The TrimRect tool creates a non-rational,
two-dimensional piecewise
linear NURBS curve of rectangular shape in the XY plane, that fits in
the (u,v) parameter space of a NURBS patch, for use as trim curve.
<item>Note: To fit the curve to the parameter space of a NURBS patch,
the NURBS patch object should be selected or the current level should be
inside the NURBS patch.
If no NURBS patch object is selected and the current level is not inside
a NURBS patch, a curve with the coordinates (-1,-1), (-1,1), (1,1),
and (1,-1) will be created instead.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
See section <ref id="trim" name="Trim Curves"> for a more detailed
discussion of trim curves and how to use the rectangular curve created
by the TrimRect tool.
</itemize>

<sect1>NURBSphere Tool<label id="nspt">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a half circle NURBS curve
and revolves it about the Y axis thus forming a sphere of radius 1.
<item>Note: The NURBS curve is deleted afterwards.
</itemize>

<sect1>NURBSphere2 Tool<label id="nsp2t">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a Cobb-NURBSphere,
consisting of six NURBS patches.
<item>Note: The NURBS patches are of high order (5).
</itemize>

<sect1>Revolve Tool<label id="revt">
<p>
<itemize>
<item>Arguments: The revolve tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Revolve object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve     ==>     +-Revolve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="revolveobj" name="Revolve Object">
for more information regarding the revolve object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Extrude Tool<label id="extt">
<p>
<itemize>
<item>Arguments: The extrude tool takes the selected objects from
the selection.
<item>Operation: The tool creates an Extrude object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Extrude
|-NCurve     ==>      |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="extrudeobj" name="Extrude Object">
for more information regarding the extrude object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Sweep Tool<label id="swpt">
<p>
<itemize>
<item>Arguments: The sweep tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Sweep object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Sweep
|-NCurve     ==>      |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="sweepobj" name="Sweep Object">
for more information regarding the Sweep object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Cap Tool<label id="capt">
<p>
<itemize>
<item>Arguments: The cap tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Cap object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Cap
|-NCurve     ==>      |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="capobj" name="Cap Object">
for more information regarding the Cap object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Birail1 Tool<label id="bi1t">
<p>
<itemize>
<item>Arguments: The birail1 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail1 object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Birail1
|-NCurve     ==>      |-NCurve
|-NCurve              |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="birail1obj" name="Birail1 Object">
for more information regarding the Birail1 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Birail2 Tool<label id="bi2t">
<p>
<itemize>
<item>Arguments: The birail2 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail2 object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Birail2
|-NCurve              |-NCurve
|-NCurve     ==>      |-NCurve
|-NCurve              |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="birail2obj" name="Birail2 Object">
for more information regarding the Birail2 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Gordon Tool<label id="gort">
<p>
<itemize>
<item>Arguments: The gordon tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Gordon object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Gordon
|-NCurve              |-NCurve
|-NCurve     ==>      |-NCurve
|-NCurve              |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="gordonobj" name="Gordon Object">
for more information regarding the Gordon object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Skin Tool<label id="skit">
<p>
<itemize>
<item>Arguments: The skin tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Skin object, and moves
the selected objects to it.
<tscreen><verb>
|-NCurve             +-Skin
|-NCurve     ==>      |-NCurve
|-NCurve              |-NCurve
                      \-NCurve
</verb></tscreen>
<item>Note: See section <ref id="skinobj" name="Skin Object">
for more information regarding the Skin object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>Revert Tool<label id="revertt">
<p>
<itemize>
<item>Arguments: The revert tool takes all NCurve,
ICurve, and ACurve objects from the selection.
<item>Operation: The direction of the selected curves will be
reversed. This tool also reverts the relative knot distances
of NURBS curves
so that a NURBS curve defined on the (asymmetric) knot vector

<tt/"0.0 0.0 0.0 0.75 1.0 1.0 1.0"/

will get the knot vector

<tt/"0.0 0.0 0.0 0.25 1.0 1.0 1.0"/

after reversal. This ensures that the shape of a NURBS curve does not
change during reversal. Interpolating and approximating curves may
change their shape as the underlying interpolation/approximation
algorithms are not direction-invariant.
<item>Note: The direction of a curve is shown as
a small arrow at the end of the curve.
Eventually selected points will still be selected after this
operation.
See also the documentation of the corresponding
scripting interface command <ref id="screvert" name="revertC">.
</itemize>

<sect1>Concat Tool<label id="conct">
<p>
<itemize>
<item>Arguments: The concat tool takes two NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be concatenated
and a new third curve will be created.
<tscreen><verb>
|-NCurve             |-NCurve
|-NCurve     ==>     |-NCurve
                     |-NCurve
</verb></tscreen>
<item>Note: If one of the curves has weights, the resulting curve
will have weights too. If the knot type of the first curve
is <tt/"Custom"/, it will be converted to <tt/"NURB"/, otherwise the
knot type of the new curve will be that of the first selected curve.
Due to those changes of the knot values, the resulting curve might
differ from the original curves.
The original NURBS curves will not be deleted by this tool.
See also section <ref id="concatncobj" name="ConcatNC Object">.
<!--
See also the documentation of the corresponding
scripting interface command <ref id="scconcatnc" name="concatNC">.
-->
</itemize>

<sect1>Split Tool<label id="splitt">
<p>
<figure loc="ht">
<eps file="pics/splitnc.ps" height="4cm">
<img src="pics/splitnc.gif">
<caption>Split Tool (left: original curve, right: resulting split curves
for t=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The split curves tool takes a single NURBS curve from
the selection and additionally requests a parametric value.
<item>Operation: The selected NURBS curve will be split into two
new NURBS curves at the designated parametric value. The splitting process
involves application of knot insertion, so that both new curves will
get a custom knot vector.
<tscreen><verb>
|-NCurve     ==>     |-NCurve
                     |-NCurve
</verb></tscreen>
<item>Note: The original selected NURBS curve will be changed and
form the first of the two new curves, so you may want to keep a copy
of it somewhere.
See also the documentation of the corresponding
scripting interface command <ref id="scsplitnc" name="splitNC">.
</itemize>

<sect1>Trim Tool<label id="trimt">
<p>
<figure loc="ht">
<eps file="pics/trimnc.ps" height="4cm">
<img src="pics/trimnc.gif">
<caption>Trim Tool (left: original curve, right: resulting trimmed curve for
umin=0.1, umax=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The trim curves tool takes all selected NURBS curves from
the selection and additionally requests two parametric values, umin and umax.
<item>Operation: The selected NURBS curves will be trimmed to the
designated parametric range (umin, umax).
<item>Note: The trimming process involves the application of knot insertion
so that the curves will get a custom knot vector.
See also the documentation of the corresponding
scripting interface command <ref id="sctrimnc" name="trimNC">.
</itemize>

<sect1>Elevate Tool<label id="elevt">
<p>
<figure loc="ht">
<eps file="pics/elevate.ps" height="4cm">
<img src="pics/elevate.gif">
<caption>Successive Application of Elevate Tool (Order 3 (left), 4 (middle),
5 (right))</caption>
</figure>
<itemize>
<item>Arguments: The elevate tool takes a number of NURBS curves from
the selection and additionally requests an integer value.
<item>Operation: The order of the selected NURBS curves will be raised
by the specified integer value without changing the shape of the curve.
<item>Note: If the knot vector of the curve is not clamped, it
will be clamped automatically. The knot type of the curve will
be changed to custom. New control points will be added and the position
of old control points may be changed in the progress.
See also the documentation of the corresponding
scripting interface command <ref id="scelevatenc" name="elevateNC">.
</itemize>

<sect1>Refine Tool<label id="refit">
<p>
<figure loc="ht">
<eps file="pics/refinecv.ps" height="4cm">
<img src="pics/refinecv.gif">
<caption>Successive Application of Refine Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine tool takes a number of NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be refined by inserting
a control point in the middle of each control point interval, changing
the shape of the curve. The original control points will not be changed.
For periodic curves, no control points will be inserted in the last p
intervals, this allows to maintain the periodicity, see also the
image below where a periodic curve of length 9 (8 sections) has been
refined, resulting in a periodic curve of length 15 (not 17).
<figure loc="ht">
<eps file="pics/refinepe.ps" height="4cm">
<img src="pics/refinepe.gif">
<caption>Refining a Periodic Curve</caption>
</figure>
If there are selected points, only the intervals between the first
and the last selected point are refined, see also the image below.
<figure loc="ht">
<eps file="pics/refinesel.ps" height="4cm">
<img src="pics/refinesel.gif">
<caption>Refining a Selected Region</caption>
</figure>
<item>
See also the documentation of the corresponding
scripting interface command <ref id="screfinenc" name="refineNC">.
</itemize>

<sect1>Refine Knots Tool<label id="refknit">
<p>
<figure loc="ht">
<eps file="pics/refine.ps" height="4cm">
<img src="pics/refine.gif">
<caption>Successive Application of Refine Knots Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine knots tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
refined by inserting a knot in the middle of each inner knot interval
without changing the shape of the curve.
<item>Note: Because a new knot is inserted in the middle of
each interval, knot vectors of type NURB and B-Spline will
not change in type. See the image above for an example of a
successive refinement of a simple NURBS curve. Note that the shape
of the curve does not change, but the position of
certain control points does.
See also the documentation of the corresponding
scripting interface command <ref id="screfinenc" name="refineNC">.
</itemize>

<sect1>Coarsen Tool<label id="coart">
<p>
<figure loc="ht">
<eps file="pics/coarsen.ps" height="4cm">
<img src="pics/coarsen.gif">
<caption>Successive Application of Coarsen Tool</caption>
</figure>
<itemize>
<item>Arguments: The coarsen tool takes a number of NURBS curves from
the selection.
<item>Operation: Every second control point in the control vectors of
the selected NURBS curves will be deleted.
<item>Note: For periodic curves the coarsen tool will not remove
control points from the first (last) p intervals (where p is the degree
of the curve).
For closed curves, the coarsen tool will not remove the last point.
The coarsen tool will also remove knot values from curves with
custom knot vectors.
See also the documentation of the corresponding
scripting interface command <ref id="sccoarsennc" name="coarsenNC">.
</itemize>

<sect1>Clamp Tool<label id="clat">
<p>
<figure loc="ht">
<eps file="pics/clampnc.ps" height="4cm">
<img src="pics/clampnc.gif">
<caption>Clamp Tool (left: original curve, right: clamped curve)</caption>
</figure>
<itemize>
<item>Arguments: The clamp tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
changed using knot insertion so that the first and the last knot
have a multiplicity equal to the order of the curve,
without changing the shape of the curve. The curve will
interpolate the first and the last control point afterwards.
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
In Ayam versions prior to 1.18 it was an error if the curve was already
clamped at either side, this is no longer the case.
Furthermore, curves with multiple knots in the end region(s) could not be
clamped, this works ok now.
See also the documentation of the corresponding
scripting interface command <ref id="scclampnc" name="clampNC">.
</itemize>

<sect1>Insert Knot Tool<label id="insknt">
<p>
<figure loc="ht">
<eps file="pics/inskn.ps" height="4cm">
<img src="pics/inskn.gif">
<caption>Insert Knot Tool (left: original curve, right: a knot has been
inserted 1 time at t=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS curves from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected curves, without changing the
shape of the curve(s).
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
scripting interface command <ref id="scinsknnc" name="insknNC">.
</itemize>

<sect1>Remove Knot Tool<label id="remknt">
<p>
<figure loc="ht">
<eps file="pics/remkn.ps" height="4cm">
<img src="pics/remkn.gif">
<caption>Remove Knot Tool (left: original curve, right: the knot at t=0.5 has been removed 1 time)</caption>
</figure>
<itemize>
<item>Arguments: The remove knot tool takes a number of NURBS curves from
the selection and requests three additional values, a parametric value t,
an integer value i, and a tolerance tol.
<item>Operation: The specified knot (t) will be removed i
times from the knot vector of the selected curves if the shape of the
resulting curve does not deviate more than tol from the original curve
in any point. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (by entering -i index instead of a parametric
value t, i.e.~<tt/"-i 4"/ instead of <tt/"0.5"/).
If the knot can not be removed r times due to the tolerance, an
error is reported and the original curve is left unchanged.
<item>Note: If tol is <tt/"Inf"/ (infinity) the tool tries to work without
changing the shape of the curves, however, this is not guaranteed.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
scripting interface command <ref id="scremknnc" name="remknNC">.
</itemize>

<sect1>Plot Curvature Tool<label id="plotcurt">
<p>
<figure loc="ht">
<eps file="pics/plotcur.ps" height="4cm">
<img src="pics/plotcur.gif">
<caption>Curvature Plot (top) of simple NURBS curve (bottom)</caption>
</figure>
<itemize>
<item>Arguments: The plot curvature tool takes a number of NURBS curves from
the selection and requests three additional values: the number of data
points, the width value and the height value.
<item>Operation: A new NURBS curve, depicting the curvature of the selected
NURBS curve, will be created for each of the selected
NURBS curves. The curvature plots will have a length defined by the
number of data points and will be scaled to the specified width
and by the specified height value. See also the image above.
</itemize>

<sect1>Shift Closed Curve Tool<label id="shiftclc">
<p>
<figure loc="ht">
<eps file="pics/shiftclsbsp.ps" height="4cm">
<img src="pics/shiftclsbsp.gif">
<caption>Shift Closed Curve Tool (left: Closed B-Spline Curve, right: Shifted Curve)</caption>
</figure>
<itemize>
<item>Arguments: The shift closed curve tool takes a number of
closed curves (NCurve, ICurve, and ACurve objects are supported),
from the selection and requests one additional integer parameter.
<item>Operation: The control points of the curve(s) will be shifted.
For a simple closed curve, shifting with i=1, the first control point will get
the coordinates of the former last control point. This means, positive shifts
occur in the direction of the curve. Note that for closed and periodic
NURBS curves, the multiple points will be managed correctly.
The shifting process will be repeated according to the integer parameter i
given. The parameter i may be negative to revert the direction of the
shifting.
<item>Note: Eventually selected points will still be selected after this
operation. See also the image above.
See also the documentation of the corresponding
scripting interface command <ref id="scshiftc" name="shiftC">.
</itemize>

<sect1>To XY Tool<label id="toxyt">
<p>
<figure loc="ht">
<eps file="pics/toxy.ps" height="5cm">
<img src="pics/toxy.gif">
<caption>To XY Tool (left: original curve, right: modified curve)</caption>
</figure>
<itemize>
<item>Arguments: The To XY tool takes a number of
NURBS curves from the selection. The NURBS curves should be planar.
<item>Operation: The control points of the curve(s) will be rotated,
so that they are in the XY plane of the respective object space defined by
the NURBS curve object(s). Additionally, the rotation attributes of
the NURBS curve object(s) will be changed so that the curve does not
change its orientation with regard to other objects or the world space.
See also the image above, where the left curve, planar but not defined
in the XY plane will be changed, so that it is defined in the XY plane
(mind the two different object coordinate systems in conjunction with
the world coordinate system in the middle).
<item>Note: A reverse operation, apart from undo, would be to apply the
current transformation attributes to the control points of the curves.
See also the documentation of the corresponding
scripting interface command <ref id="sctoxyc" name="toXYC">.
</itemize>

<sect1>Make Compatible Tool<label id="makecompt">
<p>
<figure loc="ht">
<eps file="pics/makecomp.ps" height="4cm">
<img src="pics/makecomp.gif">
<caption>Make Compatible Tool (left: Original Curves, right: Compatible Curves)</caption>
</figure>
<itemize>
<item>Arguments: The Make Compatible tool takes a number of
NURBS curves from the selection.
<item>Operation: The curves will be made compatible, so that they
are of the same order and defined on the same knot vector.
<item>Note: This tool does not change the geometry of the curves.
However, since clamping, degree elevation, and knot insertion may be
used on the curves, their order, knot vectors, and control points
may be changed.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
scripting interface command <ref id="scmakecompnc" name="makeCompNC">.
</itemize>

<sect1>Rescale Knots to Range Tool<label id="resckrt">
<p>
<itemize>
<item>Arguments: The rescale knots to range tool takes a number of
NURBS curves from the selection and requests a range (two float values).
<item>Operation: The knot vectors of the curves will be scaled, so that
their first and last values match the given range.
<item>Note: Since Ayam 1.20 the knot type of the curve does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
This tool does not change the geometry of the curves.
See also the documentation of the corresponding
scripting interface command <ref id="screscaleknnc" name="rescaleknNC">.
</itemize>

<sect1>Rescale Knots to Mindist Tool<label id="resckmt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS curves from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the curves will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots).
<item>Note: Since Ayam 1.20 the knot type of the curve does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
This tool does not change the geometry of the curves.
See also the documentation of the corresponding
scripting interface command <ref id="screscaleknnc" name="rescaleknNC">.
</itemize>

<sect1>Collapse Points Tool<label id="collt">
<p>
<itemize>
<item>Arguments: The collapse tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) control points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The selected control points will be made a
single multiple point, all points will get the coordinate values
of the last tagged point.
</itemize>

<sect1>Explode Points Tool<label id="explt">
<p>
<itemize>
<item>Arguments: The explode tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) multiple points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The points forming the selected multiple points will
be made to simple points again and may be edited separately.
<item>Note: Even though you might have exploded some multiple points
Ayam will re-create them on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
or NPatchAttr property if all single control points of the multiple
point(s) still have identical coordinate values (and the <tt/"CreateMP"/
option of the curve or patch object is activated). You should immediately
edit the control points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again.
</itemize>

<sect1>Swap UV Tool<label id="swapuvt">
<p>
<itemize>
<item>Arguments: The swap uv tool takes a number of NURBS patches,
BPatch, or PatchMesh objects from the selection.
<item>Operation: The U and V dimension of the selected objects will
be swapped (width and height will be exchanged) without altering the
shape of the patches.
See also the documentation of the corresponding
scripting interface command <ref id="scswapuvs" name="swapuvS">.
</itemize>

<sect1>Elevate UV Tool<label id="elevuvt">
<p>
<itemize>
<item>Arguments: The elevate uv tool takes a number of NURBS patches from
the selection and additionally requests two integer values.
<item>Operation: The order of the selected NURBS patches will be raised
by the specified integer values without changing the shape of the patches.
<item>Note: If the knot vector of the patch is not clamped, it
will be clamped automatically. The knot type of the patch will
be changed to <tt/"Custom"/. New control points will be added and the position
of old control points may be changed in the progress.
The point selection will be removed from the original object.
See also the documentation of the corresponding scripting interface commands
<ref id="scelevateunp" name="elevateuNP">, and
<ref id="scelevatevnp" name="elevatevNP">.
</itemize>

<sect1>Refine Surface Tool<label id="refinest">
<p>
<figure loc="ht">
<eps file="pics/refinenp.ps" height="4cm">
<img src="pics/refinenp.gif">
<caption>Successive Application of Refine Surface (U) Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine surface tool takes a number of NURBS patches from
the selection.
<item>Operation: The respective knot vectors of the selected NURBS patches
will be refined without changing the shape of the patches. New control
points will be added and the position of old control points may be
changed in the progress (see also the image above).
<item>Note: The respective knot type of the patch may
be changed to <tt/"Custom"/.
The point selection will be removed from the original object.
See also the documentation of the corresponding scripting interface commands
<ref id="screfineunp" name="refineuNP">, and
<ref id="screfinevnp" name="refinevNP">.
</itemize>

<sect1>Revert U Tool<label id="revertut">
<p>
<itemize>
<item>Arguments: The revert u tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the u dimension (width).
For NURBS patches this tool also reverts the relative knot distances
of the corresponding knot vector.
<item>Note: See also the documentation of the corresponding
scripting interface command <ref id="screvertus" name="revertuS">.
</itemize>

<sect1>Revert V Tool<label id="revertvt">
<p>
<itemize>
<item>Arguments: The revert v tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the V dimension (height).
For NURBS patches this tool also reverts the relative knot distances
of the corresponding knot vector.
<item>Note: See also the documentation of the corresponding
scripting interface command <ref id="screvertvs" name="revertvS">.
</itemize>

<sect1>Patch Clamp Tool<label id="clanpt">
<p>
<figure loc="ht">
<eps file="pics/clampnp.ps" height="4cm">
<img src="pics/clampnp.gif">
<caption>Patch Clamp Tool (left: Original Patch with B-Spline Knot Vectors, right: Clamped Patch)</caption>
</figure>
<itemize>
<item>Arguments: The patch clamp tool takes a number of NURBS patches from
the selection.
<item>Operation: The knot vectors of a selected NURBS patch will be
changed using knot insertion so that the first and the last knot
(in each direction) have a multiplicity equal to the order of the patch
(in the respective direction).
<item>Note: The shape of the patch will not change but the position of some
control points will. The patch interpolates the first and the last control
point afterwards. The knot types of the patch will be changed to type
<tt/"Custom"/.
The point selection will be removed from the original object.
There are also tools available that clamp a patch in U or
V direction only.
See also the documentation of the corresponding scripting interface commands
<ref id="scclampunp" name="clampuNP">, and
<ref id="scclampvnp" name="clampvNP">.
</itemize>

<sect1>Patch Rescale Knots to Range Tool<label id="resckrnpt">
<p>
<itemize>
<item>Arguments: The patch rescale knots to range tool takes a number of
NURBS patches from the selection and requests a range.
<item>Operation: The knot vectors of the patches will be scaled, so that
their first and last values match the given range. Trim curves, if
present, will also be scaled to match the new range.
<item>Note: Since Ayam 1.20 the knot type of the surface does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
This tool does not change the geometry of the patches.
See also the documentation of the corresponding
scripting interface command <ref id="screscaleknnp" name="rescaleknNP">.
</itemize>

<sect1>Patch Rescale Knots to Mindist Tool<label id="resckmnpt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS patches from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the patches will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots). Trim curves, if present, will also be scaled
to match the new range.
<item>Note: Since Ayam 1.20 the knot type of the surface does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
This tool does not change the geometry of the patches.
See also the documentation of the corresponding
scripting interface command <ref id="screscaleknnp" name="rescaleknNP">.
</itemize>

<sect1>Patch Insert Knot Tool<label id="insknnpt">
<p>
<figure loc="ht">
<eps file="pics/insknnp.ps" height="5cm">
<img src="pics/insknnp.gif">
<caption>Patch Insert Knot Tool (left: original patch, right: a knot has been
inserted 1 time at t=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS patches from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected patches, without changing the
shape of the patches.
<item>Note: The knot type of the patch will be changed to <tt/"Custom"/.
This tool does not change the geometry of the patches.
The point selection will be removed from the original object.
See also the documentation of the corresponding scripting interface commands
<ref id="scinsknunp" name="insknuNP">, and
<ref id="scinsknvnp" name="insknvNP">.
</itemize>

<sect1>Patch Remove Knot Tool<label id="remknts">
<p>
<figure loc="ht">
<eps file="pics/remknnp.ps" height="5cm">
<img src="pics/remknnp.gif">
<caption>Remove Knot Tool (left: original surface, right: the knot at t=0.5 has been removed 1 time)</caption>
</figure>
<itemize>
<item>Arguments: The remove knot tool takes a number of NURBS surfaces from
the selection and requests three additional values, a parametric value t,
an integer value i, and a tolerance tol.
<item>Operation: The specified knot (t) will be removed i
times from the knot vector of the selected surfaces if the shape of the
resulting surfaces does not deviate more than tol from the original surfaces
in any point. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (by entering -i index instead of a parametric
value t, i.e.~<tt/"-i 4"/ instead of <tt/"0.5"/).
If the knot can not be removed r times due to the tolerance, an
error is reported and the original surface is left unchanged.
<item>Note: If tol is <tt/"Inf"/ (infinity) the tool tries to work without
changing the shape of the surfaces, however, this is not guaranteed.
The point selection will be removed from the original objects.
See also the documentation of the corresponding scripting interface commands
<ref id="scremknunp" name="remknuNP">, and
<ref id="scremknunp" name="remknvNP">.
</itemize>


<sect1>Patch Split Tools<label id="splitnpt">
<p>
<itemize>
<item>Arguments: The patch split tools take a number of NURBS patches from
the selection and request a parametric value t (in U or V parametric dimension,
respectively).
<item>Operation: The patches will be split at the parametric value t
into two patches (in U or V parametric dimension, respectively) using
knot insertion.
<tscreen><verb>
|-NPatch     ==>     |-NPatch
                     |-NPatch
</verb></tscreen>
<item>Note: The original patch will be modified and a new patch will be
created.
The point selection will be removed from the original object.
Trim curves will not be honored properly.
See also the documentation of the corresponding scripting interface commands
<ref id="scsplitunp" name="splituNP">, and
<ref id="scsplitvnp" name="splitvNP">.
</itemize>

<sect1>Extract Curve Tool<label id="extnct">
<p>
<itemize>
<item>Arguments: The extract curve tool takes the first of the selected
objects from the selection.
<item>Operation: The tool creates an instance the first of the selected
objects then creates an ExtrNC object and moves the instance to it.
<tscreen><verb>
|-NPatch             |-NPatch
             ==>     +-ExtrNC
                      \-Instance_of_NPatch(Instance)
</verb></tscreen>
<item>Note: This tool uses the object clipboard to move the objects
around so that the original clipboard contents are lost when this tool
finishes.
Eventually present trim curves will <em>not</em> be honored properly.
See section <ref id="extrncobj" name="ExtrNC Object">
for more information regarding the ExtrNC object.
</itemize>

<sect1>Extract Patch Tool<label id="extrnpt">
<p>
<itemize>
<item>Arguments: The extract patch tool takes the first of the selected
objects from the selection.
<item>Operation: The tool creates an instance from the first of the
selected objects then creates an ExtrNP object and moves the
instance to it.
<tscreen><verb>
|-NPatch             |-NPatch
             ==>     +-ExtrNP
                      \-Instance_of_NPatch(Instance)
</verb></tscreen>
<item>Note: This tool uses the object clipboard to move the objects
around so that the original clipboard contents are lost when this tool
finishes.
Eventually present trim curves will <em>not</em> be honored properly.
See section <ref id="extrnpobj" name="ExtrNP object">
for more information regarding the ExtrNP object.
See also the documentation of the corresponding
scripting interface command <ref id="scextrnp" name="extrNP">.
</itemize>

<sect1>Split to Curves Tool<label id="sptct">
<p>
<itemize>
<item>Arguments: The split to curves tool takes a single NURBS patch from
the selection.
<item>Operation: The selected NURBS patch will be split into NURBS curves,
along direction U or V.
<tscreen><verb>
|-NPatch             |-NPatch
                     |-NCurve
             ==>     |-NCurve
                     |-NCurve
                     |-NCurve
</verb></tscreen>
<item>Note: The original NURBS patch object is not deleted.
See also the documentation of the corresponding
scripting interface command <ref id="scsplitnp" name="splitNP">.
</itemize>

<sect1>Build from Curves Tool<label id="bfct">
<p>
<itemize>
<item>Arguments: The build from curves tool takes a number of NURBS
curves from the selection.
<item>Operation: The selected NURBS curves will be parsed, all curves
that are of equal length or longer than the first selected curve
will be used to form a new NURBS patch of the following dimensions:
Width: length of the first selected curve,
Height: number of used curves.
The order in U direction (Order_U) will be equal to the number of used curves
for numbers of two to four and four for bigger numbers of used curves.
The knot type in U direction (Knot-Type_U) will always be NURB.
Other parameters (Order_V, Knot-Type_V, Knots_V) are taken from
the first curve.
<tscreen><verb>
|-NCurve               |-NCurve
|-NCurve               |-NCurve
|-NCurve     ==>       |-NCurve
|-NCurve               |-NCurve
                       |-NPatch
</verb></tscreen>
<item>Note: The original NURBS curves objects are not deleted.
See also the documentation of the corresponding
scripting interface command <ref id="scbuildnp" name="buildNP">.
</itemize>

<sect1>Tesselation Tool<label id="tesst">
<p>
<figure loc="ht">
<eps file="pics/tgui.ps" height="3cm">
<img src="pics/tgui.gif">
<caption>GUI of Tesselation Tool</caption>
</figure>
<itemize>
<item>Arguments: The tesselation tool takes all NURBS patches and
NURBS patch providing objects from the selection.
<item>Operation: A modal dialog box (see image above) will pop up,
that allows to select a tesselation method via a drop-down menu
and to tune the corresponding tesselation parameter(s) using a slider and
an entry widget. The initial method and parameter values will be derived
from the <tt/"TP"/ tag of the first of the selected objects (if it has such
a tag).
<p>
The selected or provided NURBS patches will be tesselated with the
chosen method and parameters.
The PolyMesh objects created by the tesselation will immediately be
displayed in all view windows instead of the original objects.
Whenever tesselation method or parameters are changed, the tesselation
will be recomputed and displayed, thus, allowing an immediate estimation
of the tesselation quality.
<p>
If the preference option <tt>"Modelling/LazyNotify"</tt> is enabled,
updates of the tesselation that normally occur while dragging the
slider(s) will be deferred until the mouse button is released.
<p>
If the <tt/"Ok"/ button is pressed to close the tesselation tool, all
selected objects will be replaced by their tesselated
counterparts; if <tt/"Cancel"/ is used, all selected objects remain
unchanged.
<p>
If the check box <tt/"SaveToTag"/ is activated, closing the tesselation
tool using <tt/"Cancel"/ will also add a <tt/"TP"/ tag containing
the currently selected method and parameter value to all selected
objects. This tag can be evaluated later, when the respective
objects are converted to PolyMesh objects. Since Ayam 1.11 also the
conversion mechanism of objects keeps the <tt/"TP"/ tags intact, so
that one may e.g.~save tesselation parameters for a Sphere or a Revolve
object. Upon conversion of the Sphere or Revolve object via a NURBS
patch to a PolyMesh, the tesselation parameters will be retained.
Mind that the <tt/"SaveToTag"/ option will be activated automatically
if any of the objects to tesselate already have a <tt/"TP"/ tag.

<item>Note: The tesselation tool will block most other parts of Ayam
while it is running. It is, however, possible to adjust view parameters
while the tesselation tool is open, to examine the tesselation result
more closely or from different viewing angles. The initial values of the
parameter slider bounds may be changed by simply entering values
that are out of bounds into the respective entry widget, then pressing the
<tt/&lt;Tab&gt;/ key. The resolution of the slider is calculated
automatically from the resolution of the value entered in the entry
widget.
</itemize>

See section
<ref id="prefmisc" name="Miscellaneous Preferences">
for a more extensive discussion of the tesselation methods
and their parameter(s).

<sect>Scripting Interface<label id="script">
<p>
The Ayam scripting interface is mainly a number of Tcl procedures
and Tcl commands that are also used internally by the application,
e.g.~the main menu entry <tt>"File/New"</tt> calls the
scripting interface command <tt/"newScene"/ (among other commands).
Using the scripting interface means to call these commands on
your own possibly in a mix with standard Tcl script code.
<p>
Furthermore, using Tcl and its introspection facilities, you could
easily modify the code Ayam consists of. This is, however, not
recommended for good reasons (unless you read the Ayam source code
and really know, what you are doing).
So watch out for already existing procedures and commands when
implementing your own.
Using procedures and commands not listed in this documentation
is dangerous too. Implementation and interfaces of those
procedures and commands may change in future versions of Ayam without
notice.
<p>
In Tcl, all variables, procedures, and commands are case sensitive,
it really is <tt/"sL"/ and <em>not</em> <tt/"sl"/ and <em>not</em>
<tt/"SL"/.
<p>
The scripting interface may be used directly from the console
of Ayam. You can, of course, also write scripts in your own
Tcl script files, that may be loaded at any time into Ayam using
the console and the Tcl command <tt/"source"/.
You can also arrange for a script file to be executed automatically
on every application startup using the preference setting
<tt>"Main/Scripts"</tt>.
Moreover, on the X11 and Aqua window systems, Ayam is able to execute
script code sent via the Tk <tt/"send"/ command or the AppleScript
<tt/"tell"/ command from external applications.
<p>
In contrast to other modelling environments, in Ayam there is
another way to run scripts. In Ayam, scripts may also be attached
to script objects and run when the notification mechanism updates
the scene. See also section
<ref id="scriptobj" name="Script object">.
Even normal objects can trigger scripts upon notification using
BNS or ANS tags. See also sections
<ref id="bnstag" name="Before Notify Script"> and
<ref id="anstag" name="After Notify Script">.
<p>
Note that most of the scripting interface commands listed in this
documentation work in the background, without changing anything to
the Ayam GUI and Ayam view windows, for the sake of execution speed.
If you want your changes to become visible you have to update the
various parts of the GUI (property GUIs, view windows) explicitly
(see also section <ref id="sciupd" name="Updating the GUI">).
However, since Ayam 1.13 it is also possible to automatically run GUI
updating commands in the console by using <tt/&lt;Shift+Return&gt;/
instead of <tt/&lt;Return&gt;/ when issuing scripting interface commands.
<p>
If you want your changes to be recorded in the undo buffer, you have
to arrange for this manually too (see the documentation of the undo
command: <ref id="scundo" name="Undo">).
<p>
From scripts it may be necessary to check whether an error occured
during the execution of a command. All commands return
TCL_OK in <em>any</em> case, so checking their return value avails
to nothing, but they set the global Tcl variable <tt>"ay_error"</tt>
to a value higher than 1 if an error occured. You need to set
ay_error to zero before and check it after the operation in question
to see whether the operation performed successfully:
<#if out=latex><x/needspace 8/</#if>
<code>
proc myProc { } {
  set ::ay_error 0
  copOb
  if { $::ay_error > 1 } {
    ayError 2 "myProc" "Error copying object!"
  }
}
</code>

<sect1>Global Variables and Arrays
<p>
Several global variables and arrays exist in the Ayam Tcl context, that
may be useful for scripts.

<sect2>Global Variables
<p>
<itemize>
<item> The <tt/"ay_error"/ variable holds the current error state.
See also section <ref id="scierr" name="Reporting Errors">.
<item> The variable <tt/"i"/ is used by all <tt/"forAll"/
command variants. See also section
<ref id="scifall" name="Applying Commands to a Number of Objects">.
</itemize>

<sect2>The Global Array ay<label id="ayarray">
<p>
The global array <tt/"ay"/ holds application state variables.
Furthermore, you can find the paths to important widgets
(e.g.~the tree widget for the object hierarchy or the currently
active view) in this array.
Use <tt/"parray ay"/ in the console to see what is there.
More documentation to come.

<sect2>The Global Array ayprefs<label id="ayprefs">
<p>
The global array <tt/"ayprefs"/ holds preferences data.
The <em>complete</em> array is saved in the <tt/"ayamrc"/ file upon exit,
so be careful when adding new elements to this array.
See also section <ref id="ayamrc" name="Ayamrc File">.
Use <tt/"parray ayprefs"/ in the console to see what is there.
More documentation to come.
<p>
Note that changes to this array on the Tcl side do not immediately
take effect as the data needs to be transferred to the C context
using the <tt/"setPrefs"/ command.
See also section <ref id="sciprefs" name="Managing Preferences">.

<sect2>The Global Property Management and Data Arrays<label id="ayproparr">
<p>
For every property, a corresponding global arrays exists, where the
property is managed. For the Transformations property, this array looks
like this:
<#if out=latex><x/needspace 7/</#if>
<code>
Transformations {
arr   transfPropData
sproc setTrafo
gproc getTrafo
w     fTrafoAttr
}
</code>
The first entry, <tt/"arr"/, designates the name of the global property
data array (thus, transformation data is stored in an array called
<tt/"transfPropData"/).
The entries <tt/"sproc"/ and <tt/"gproc"/ designate the set-property and
get-property callbacks (procedures or commands) respectively.
If sproc or gproc are empty strings (<tt/""/), standard callbacks
named <tt/"setProp"/ or <tt/"getProp"/ should be used to get
or set the property values.
But for the transformations property, the <tt/"setTrafo"/ and
<tt/"getTrafo"/ commands should be used.
The last entry, <tt/"w"/, is the name of the main property GUI window.
To get the full widget path of this window, the current value of
ay(pca) needs to be prepended.
<p>
Note that the global property data array only holds useful data when the
respective property GUI is active, or when it has been filled explicitly
by the so called get-property callback.
<p>
The following global arrays and callbacks to get or set the data
exist:
<p>
<table loc="ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/property/|<bf/array/|<bf/get-property callback/|<bf/set-property callback/@<hline>
Transformations|transfPropData|getTrafo|setTrafo@<hline>
Attributes|attrPropData|getAttr|setAttrp@<hline>
Material|matPropData|getMat|setMat@<hline>
Tags|tagsPropData|getTagsp|setTagsp<#if out=latex>@<hline></#if>
</tabular>
<caption>Property Arrays and Callbacks</caption>
</table>
<p>
Note that this list is pretty much incomplete, however you can always
infer such information using commands like <tt/"parray Tags"/ in the Ayam
console.
<p>
See also section
<ref id="sciprop" name="Manipulating Properties">
for more information on how to edit property values from the
scripting interface.
<p>
Since Ayam 1.16, the global property management array may be created
easily using the new scripting interface command <tt/"addPropertyGUI"/.

<sect1>Index of Procedures and Commands<label id="sccomm">
<p>
This section provides documentation on the most important
scripting interface commands and procedures of Ayam sorted
by category.
<p>
All commands are documented in the following scheme:
<itemize>
 <item><bf/Synopsis:/ <tt/"command param1 param2 [optionalparam1]"/
(syntax of the command and its parameters),
 <item><bf/Background:/ does the command run in the background,
<bf/Undo:/ can the result of the command be undone,
<bf/Safe:/ is the command available in the safe interpreter (for Script
objects and notify script tags),
 <item><bf/Description:/ detailed description of the command and its
parameters,
 <item><bf/Notes:/ additional information completing the detailed description,
 <item><bf/Example:/ <tt/"command 1 2"/ (example application of the command
with explanation of expected results).
</itemize>

<sect2>Getting Help on Scripting Interface Commands<label id="schelp">
<p>
Since Ayam 1.8.2 a scripting interface command named <tt/"help"/ is available,
that displays the help of scripting interface commands using a web
browser (similar to the <tt/"Help on Object"/ feature):
<itemize>
 <item>Synopsis: <tt/"help command"/
 <item>Background: N/A, Undo: No, Safe: No
 <item>Description: Fire up a web browser and display the help for
the designated Ayam scripting interface command.
 <item>Example: <tt/"help help"/ displays the help of the help command.
</itemize>

<sect2>Creating Objects<label id="crtob">
<p><label id="sccrtob">
To create new objects the <tt/"crtOb"/ command can be used.
<itemize>
 <item>Synopsis: <tt/"crtOb type [args]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: New objects may be created with the command <tt/"crtOb"/,
<tt/"type"/ may be derived from the object type names, as displayed in the
tree view.
The new object will be created and linked to the scene as last object
in the current level, no part of the GUI (object selection widget, property
GUI, views) will be updated. Furthermore, the new object will <em>not</em>
be selected.
<p>
Depending on the type, further arguments may (or have to) be given;
some object types expect other objects to be selected upon creation.
<p>
All arguments consist of a option name part and a value part (i.e.~it is
<tt/"-center 1"/ and <em/not/ <tt/"-center"/ and also <em/not/
<tt/"-center=1"/).
The option names can be abbreviated. Useful default and fallback
values exist (see below). The arguments can be mixed freely (their
order is not important) and repeated. If arguments are repeated, only the
last set value is used, even if this leads to errors and application of
fallback values later on.
<p>

Here is a comprehensive list of available arguments sorted by
object type:
<p>

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtnc">
  <itemize>
  <item><tt/"NCurve"/: NURBS curves accept the following arguments:
  <itemize>
  <item><tt/"-length"/: length of the new curve, the length defaults to 4.
  <item><tt/"-order"/: order of the new curve, the order defaults to 4.
If a value greater than the length is specified, the order will be made
identical to the length value.
  <item><tt/"-kt"/: the knot type of the new curve, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <tt/"-kv"/ option below,
the knot type will always be set to 3 &ndash; Custom.

  <item><tt/"-kv"/: the knot vector of the new curve. The value of this
option is a list of floating point numbers of length curve length plus
curve order, e.g.~for a curve with 2 control points and order 2, specify
4 knots: <tt/"-kv {0.0 0.0 1.0 1.0}"/. The knot vector defaults to
an automatically created knot vector of the type specified by the
<tt/"-kt"/ option above.

  <item><tt/"-kn"/: the knot vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-kv"/ option
above.

  <item><tt/"-cv"/: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 4D euclidean
rational (weight <em>not</em> multiplied in) coordinates of the control
points.
This list may also only specify one point, which is then taken as starting
point and DX/DY/DZ (see below) are used to create the missing control points
automatically.
To specify a complete control vector, this list should have
length&thinsp;&middot;&thinsp;4 elements, e.g.~for a curve of length 3,
specify 12 values:
<tt/"-cv {0.0 0.0 0.0 1.0  1.0 0.0 0.0 1.0  2.0 0.0 0.0 1.0}"/.

  <item><tt/"-cn"/: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-dx"/: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.

  <item><tt/"-dy"/: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.

  <item><tt/"-dz"/: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0

  <item><tt/"-center"/: If the value of the <tt/"-center"/ option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <tt/"-cv"/ option is specified.

  <item><tt/"-createmp"/: The <tt/"-createmp"/ option toggles creation
of multiple points. The default value is 0.
  </itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb NCurve"//<newline>
creates a curve with length 4, order 4, standard (clamped) NURBS knot
vector, control points at 0 0 0, 0.25 0 0, 0.5 0 0, 0.75 0 0 (all weights 1).
<item><bf/<tt/"crtOb NCurve -center 1"//<newline>
creates a centered curve with length 4, order 4, standard (clamped) NURBS knot
vector, control points at -0.375 0 0, -0.125 0 0, 0.125 0 0, 0.375 0 0
(all weights 1).
<item><bf/<tt/"crtOb NCurve -length 5 -center 1 -dx 0.5"//<newline>
creates a centered curve with length 5, order 4, standard (clamped) NURBS knot
vector, control points at -1 0 0, -0.5 0 0, 0 0 0, 0.5 0 0, 1 0 0
(all weights 1).
</enum>
<p>
In versions of Ayam prior to 1.17, NURBS curves only accepted the
<tt/"-length"/ argument.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtic">
  <item><tt/"ICurve"/: Interpolating curves accept the following arguments:
  <itemize>

  <item><tt/"-type"/: the type of the new curve, must be one of
0 &ndash; Open, 1 &ndash; Closed; default is 0.

  <item><tt/"-length"/: length (number of data points to interpolate)
of the new curve; the length defaults to 4.

  <item><tt/"-order"/: order of the new curve, the order defaults to 4.
If a value greater than the length is specified, the order will be made
identical to the length value.

  <item><tt/"-pt"/: the parameter type of the new curve, must be one of
0 &ndash; Chordal, 1 &ndash; Centripetal, 2 &ndash Uniform; default is 0.

  <item><tt/"-cv"/: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control points. This list may also
only specify one point, which is then taken as starting point and
DX/DY/DZ (see below)
are used to create the missing control points automatically.
To specify a complete
control vector, this list should have curve length&thinsp;&middot;&thinsp;3
elements, e.g.~for a curve of length 3, specify 9 values:
<tt/"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0}"/.

  <item><tt/"-cn"/: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-dx"/: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.

  <item><tt/"-dy"/: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.

  <item><tt/"-dz"/: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0

  <item><tt/"-center"/: If the value of the <tt/"-center"/ option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <tt/"-cv"/ option is specified.

  <item><tt/"-derivs"/: the value of this option controls whether
user defined end derivatives should be used: 0 &ndash; no, 1 &ndash; yes,
default is 0.

  <item><tt/"-sdlen"/: the value of this option specifies the
relative length (in relation to the distance of the first and second
control point) of the start derivative, default is 0.125.

  <item><tt/"-sderiv"/: is the start derivative, specified as
a list of three float values. The derivative is specified relative to the
first control point. The start derivative defaults to an automatically created
derivative of a direction taken from the first two control points
and length specified by the <tt/"-sdlen"/ option.

  <item><tt/"-edlen"/: the value of this option specifies the
relative length (in relation to the distance of the second to last and last
control point) of the end derivative, default is 0.125.

  <item><tt/"-ederiv"/: is the end derivative, specified as
a list of three float values. The derivative is specified relative to the
last control point. The end derivative defaults to an automatically created
derivative of a direction taken from the last two control points
and length specified by the <tt/"-edlen"/ option.

</itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb ICurve"//<newline>
creates a curve with length 4, order 4, data points at
0 0 0, 0.25 0 0, 0.5 0 0, 0.75 0 0.
<item><bf/<tt/"crtOb ICurve -l 5 -sderiv {0.0 -0.5 0.0} -ederiv {0.0 -0.5 0.0} -derivs 1 -center 1"//<newline>
creates a curve with length 5, order 4, data points at
-0.5 0 0, -0.25 0 0, 0 0 0, 0.25 0 0, 0.5 0 0, end derivatives pointing
straight upwards with length 0.5 in their respective end.
</enum>
<p>
In versions of Ayam prior to 1.17, interpolating curves only accepted the
<tt/"-length"/ argument.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtac">
  <item><tt/"ACurve"/: Approximating curves accept the following arguments:
  <itemize>

  <item><tt/"-type"/: the type of the new curve, must be one of
0 &ndash; Open, 1 &ndash; Closed; default is 0.

  <item><tt/"-length"/: length (number of data points to approximate)
of the new curve, the length defaults to 4.

  <item><tt/"-alength"/: number of control points to use for the
approximating curve, the alength defaults to 3.

  <item><tt/"-order"/: order of the new curve, the order defaults to 3.
If a value greater than the length is specified, the order will be made
identical to the length value.

  <item><tt/"-symmetric"/: toggles creation of symmetric curves,
must be one of 0 &ndash; Asymmetric, 1 &ndash; Symmetric; default is 0.

  <item><tt/"-cv"/: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control points. This list may also
only specify one point, which is then taken as starting point and
DX/DY/DZ (see below)
are used to create the missing control points automatically.
To specify a complete
control vector, this list should have curve length&thinsp;&middot;&thinsp;3
elements, e.g.~for a curve of length 3, specify 9 values:
<tt/"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0}"/.

  <item><tt/"-cn"/: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-dx"/: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.

  <item><tt/"-dy"/: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.

  <item><tt/"-dz"/: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0

  <item><tt/"-center"/: If the value of the <tt/"-center"/ option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <tt/"-cv"/ option is specified.

</itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb ACurve -length 6"//<newline>
creates an approximating curve from 6 data points: 0 0 0, 0.25 0 0, 0.5 0 0,
0.75 0 0, 1 0 0, 1.25 0 0.
<item><bf/<tt/"crtOb ACurve -l 5 -center 1"//<newline>
creates a centered approximating curve from 5 data points: -0.5 0 0,
-0.25 0 0, 0 0 0, 0.25 0 0, 0.5 0 0.
</enum>
<p>
In versions of Ayam prior to 1.17, approximating curves only accepted the
<tt/"-length"/ argument.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtnp">
  <item><tt/"NPatch"/: NURBS patches accept the following arguments:
  <itemize>
  <item><tt/"-width"/: width of the new patch, the width defaults to 4.
  <item><tt/"-height"/: height of the new patch, the height defaults to 4.
  <item><tt/"-uorder"/: order of the new patch in U parametric dimension,
the order defaults to 4. If a value greater than the width is specified,
the order will be made identical to the width value.
  <item><tt/"-ukt"/: the U knot type of the new patch, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <tt/"-ukv"/ option below,
the knot type will always be set to 3 &ndash; Custom.
  <item><tt/"-ukv"/: the U knot vector of the new patch. The value of this
option is a list of floating point numbers of length width plus
patch U order, e.g.~for a patch with width 2 and U order 2, specify
4 knots: <tt/"-ukv {0.0 0.0 1.0 1.0}"/. The knot vector defaults to
an automatically created knot vector of the type specified by the
<tt/"-ukt"/ option above.

  <item><tt/"-un"/: the U knot vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-ukv"/ option
above.

  <item><tt/"-vorder"/: order of the new patch in V parametric dimension,
the order defaults to 4. If a value greater than the height is specified,
the order will be made identical to the height value.
  <item><tt/"-vkt"/: the V knot type of the new patch, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <tt/"-vkv"/ option below,
the knot type will always be set to 3 &ndash; Custom.
  <item><tt/"-vkv"/: the V knot vector of the new patch. The value of this
option is a list of floating point numbers of length height plus
patch V order, e.g.~for a patch with height 2 and V order 2, specify
4 knots: <tt/"-vkv {0.0 0.0 1.0 1.0}"/. The knot vector defaults to
an automatically created knot vector of the type specified by the
<tt/"-vkt"/ option above.

  <item><tt/"-vn"/: the V knot vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-vkv"/ option
above.

  <item><tt/"-cv"/: the control vector of the new patch. The value of this
option is a list of floating point numbers that describe the 4D euclidean
rational (weight <em>not</em> multiplied in) coordinates of the control
points.
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.
To specify a complete control vector, this list should have
width&thinsp;&middot;&thinsp;height&thinsp;&middot;4 elements,
e.g.~for a patch of width 2 and height 2, specify 16 values:
<tt/"-cv {0.0 0.0 0.0 1.0  1.0 0.0 0.0 1.0  2.0 0.0 0.0 1.0  2.0 1.0 0.0 1.0}"/.

  <item><tt/"-cn"/: the control vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-udx"/: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.

  <item><tt/"-udy"/: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.

  <item><tt/"-udz"/: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0

  <item><tt/"-vdx"/: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.

  <item><tt/"-vdy"/: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.

  <item><tt/"-vdz"/: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0

  <item><tt/"-center"/: If the value of the <tt/"-center"/ option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <tt/"-cv"/ option is specified.

  <item><tt/"-createmp"/: The <tt/"-createmp"/ option toggles creation
of multiple points. The default value is 0.
</itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb NPatch"//<newline>
creates a flat patch with width 4, height 4, uorder 4, vorder 4,
standard (clamped) NURBS knot vectors, control points arranged in a
equidistant grid in the XY plane from 0 0 0 to 0.75 0.75 0 (all weights 1).
<item><bf/<tt/"crtOb NPatch -vdy 0 -vdz 0.25"//<newline>
creates the same patch as above in the XZ plane (ground plane).
<item><bf/<tt/"crtOb NPatch -udy 0.25"//<newline>
creates a sheared version of the standard NURBS patch in the XY plane.
<item><bf/<tt/"crtOb NPatch -udy 0.25 -vdz 0.25"//<newline>
creates a 3D sheared version of the standard NURBS patch.
<item><bf/<tt/"crtOb NPatch -width 2 -height 2 -center 1 -udx 2 -vdy 2"//
<newline>
creates a centered patch with width 2, height 2, uorder 2, vorder 2,
standard (clamped) NURBS knot vectors, control points at -1 0 0, 1 0 0,
-1 1 0, 1 1 0 (all weights 1).
<item><bf/<tt/"crtOb NPatch -width 3 -height 2 -uorder 2 -cv {-1 0 1 1  1 0 1 1  -1 0 0 1  1 0 0 1  -1 1 0 1  1 1 0 1}"//<newline>
creates a angular patch in the XZ and XY plane (remove <tt/-uorder 2/ to get
a smooth shape).
</enum>

<p>
In versions of Ayam prior to 1.17, NURBS patches only accepted the
<tt/"-width"/ and <tt/"-height"/ argument.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtip">
  <item><tt/"IPatch"/: Interpolating patches accept the following arguments:
  <itemize>
  <item><tt/"-width"/: width of the new patch, the width defaults to 4.
  <item><tt/"-height"/: height of the new patch, the height defaults to 4.
  <item><tt/"-uorder"/: order of the new patch in U parametric dimension,
the order defaults to 4. If a value greater than the width is specified,
the order will be made identical to the width value.
A value of 0 switches off interpolation along U.
  <item><tt/"-ukt"/: the U parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal, 2 &ndash Uniform.
  <item><tt/"-vorder"/: order of the new patch in V parametric dimension,
the order defaults to 4. If a value greater than the height is specified,
the order will be made identical to the height value.
A value of 0 switches off interpolation along V.
  <item><tt/"-vkt"/: the V parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal, 2 &ndash Uniform.

  <item><tt/"-deriv_u"/: the end derivative mode for U, must be one of
0 &ndash; None (default), 1 &ndash; Automatic, or 2 &ndash; Manual.
In manual mode full derivative vectors must be provided via
<tt/"-ederiv_u"/ <em>and</em> <tt/"-sderiv_u"/.
  <item><tt/"-edlen_u"/: the length of automatically calculated end
derivatives at end of patch in U (default 0.125).
  <item><tt/"-sdlen_u"/: the length of automatically calculated end
derivatives at start of patch in U (default 0.125).
  <item><tt/"-ederiv_u"/: end derivatives for U at end of patch.
The value of this option is a list of 3&thinsp;&middot;&thinsp;height
floating point numbers.
There is no default value.
  <item><tt/"-sderiv_u"/: end derivatives for U at start of patch.
The value of this option is a list of 3&thinsp;&middot;&thinsp;height
floating point numbers.
There is no default value.

  <item><tt/"-deriv_v"/: the end derivative mode for V, must be one of
0 &ndash; None (default), 1 &ndash; Automatic, or 2 &ndash; Manual.
In manual mode full derivative vectors must be provided via
<tt/"-ederiv_v"/ <em>and</em> <tt/"-sderiv_v"/.
  <item><tt/"-edlen_v"/: the length of automatically calculated end
derivatives at end of patch in V (default 0.125).
  <item><tt/"-sdlen_v"/: the length of automatically calculated end
derivatives at start of patch in V (default 0.125).
  <item><tt/"-ederiv_v"/: end derivatives for V at end of patch.
The value of this option is a list of 3&thinsp;&middot;&thinsp;width
floating point numbers.
There is no default value.
  <item><tt/"-sderiv_v"/: end derivatives for V at start of patch.
The value of this option is a list of 3&thinsp;&middot;&thinsp;width
floating point numbers.
There is no default value.

  <item><tt/"-cv"/: the control vector of the new patch. The value of this
option is a list of floating point numbers that describe the 3D
non rational coordinates of the data points to be interpolated.
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.
To specify a complete control vector, this list should have
width&thinsp;&middot;&thinsp;height&thinsp;&middot;&thinsp;3 elements,
e.g.~for a patch of width 2 and height 2, specify 12 values:
<tt/"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0  2.0 1.0 0.0}"/.

  <item><tt/"-cn"/: the control vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-udx"/: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.

  <item><tt/"-udy"/: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.

  <item><tt/"-udz"/: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0

  <item><tt/"-vdx"/: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.

  <item><tt/"-vdy"/: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.

  <item><tt/"-vdz"/: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0

  <item><tt/"-center"/: If the value of the <tt/"-center"/ option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <tt/"-cv"/ option is specified.

</itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb IPatch"//<newline>
creates a flat patch with width 4, height 4, uorder 4, vorder 4,
chordal parameterisation, data points arranged in a
equidistant grid in the XY plane from 0 0 0 to 0.75 0.75 0.
<item><bf/<tt/"crtOb IPatch -vdy 0 -vdz 0.25"//<newline>
creates the same patch as above in the XZ plane (ground plane).
<item><bf/<tt/"crtOb IPatch -udy 0.25"//<newline>
creates a sheared version of the standard IPatch in the XY plane.
<item><bf/<tt/"crtOb IPatch -udy 0.25 -vdz 0.25"//<newline>
creates a 3D sheared version of the standard IPatch.
<item><bf/<tt/"crtOb IPatch -width 3 -height 3 -center 1 -udx 2 -vdy 2"//
<newline>
creates a centered patch with width 3, height 3, uorder 3, and vorder 3.
</enum>

<#if out=latex><x/newpage/</#if>

  <item><tt/"PolyMesh"/: Polymeshes accept the following arguments:
  <itemize>

  <item><tt/"-polys"/: the value of this option specifies the number of
polygons/faces in the mesh. The number of polygons defaults to 0.

  <item><tt/"-loops"/: the value of this option specifies the number of
loops per polygon. It is therefore a list of positive integer values of a
length equal to the value of the <tt/"-polys"/ option. The default value
of this option is a list of proper length with all elements set to 1
(only normal polygons, without holes, are specified).

  <item><tt/"-nverts"/: the value of this option specifies the number of
vertices per loop. It is therefore a list of positive integer
values of a length equal to the sum of all elements of the <tt/"-loops"/
option.
The default value of this option is a list of proper length with all
elements set to 3 (only triangles are in the mesh).

  <item><tt/"-iverts"/: the value of this option specifies all the (zero
based) indices of the vertices of all loops. It is therefore a list of
integer values of a length equal to the sum of all elements of the
<tt/"-nverts"/ option.
The default value of this option is a list of proper length with the
elements set to a sequence of integers so that the control points are
used in the same order as specified via the <tt/"-cv"/ option
(0, 1, 2, 3, &hellip;).

  <item><tt/"-cv"/: the control points of the new mesh. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control
points. The indices specified via the <tt/"-iverts"/ option point to
this list. If the <tt/"-vnormals"/ option is 1, also vertex normals are
specified in this list (directly following the coordinate values of each
control point) and stride is 6, otherwise stride is 3.
This list must have a length of stride by the highest value in
the list provided via the <tt/"-iverts"/ option.
The default value of this option is an empty list, this implies that this
option must be specified to create a non-empty PolyMesh object.

  <item><tt/"-cn"/: the control points of the new mesh. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-vnormals"/: determines whether vertex normals are present.
The default value is 0 &ndash; no vertex normals are present.

  </itemize>
Examples:
<enum>
<item><bf/<tt/"crtOb PolyMesh -p 1 -cv {0 0 0  1 0 0  0 1 0}"//<newline>
creates a polymesh with a single triangular face.

<item><bf/<tt/"crtOb PolyMesh -p 2 -cv {0 0 0  1 0 0  1 1 0  0 1 0} -iv {0 1 2 0 2 3}"//<newline>
creates a polymesh with two connected (vertex sharing) triangular faces.
<p>
<item><bf/<tt/"crtOb PolyMesh -p 3 -cv {0 0 0  1 0 0  1 1 0  0 1 0  1.5 0 0  1.5 1 0} -iv {0 1 2 0 2 3 1 4 5 2} -nv {3 3 4}"//<newline>
creates a polymesh with two triangles and one quad all connected
(vertex sharing).

<item><bf/<tt/"crtOb PolyMesh -p 1 -loops {2} -cv {0 0 0  1 0 0  0 1 0  .25 .25 0  .5 .25 0  .25 .5 0}"//<newline>
creates a polymesh with one triangular face that has a triangular hole.
</enum>
Notes:<newline>
Besides checking the lengths of arrays, maximum indices, and minimum
number of vertices per loop, there is <em>no</em> error checking.
Undetected errors include: degenerated or non-planar polygons,
hole loops geometrically outside or touching the outline loop, disagreeing
loop winding orders between faces, non-manifold meshes, unused control points.
Those errors may be problematic for further processing steps &ndash; some
may go unnoticed in Ayam and will only be detected later in other applications.

<#if out=latex><x/newpage/</#if>

  <item><tt/"SDMesh"/: Subdivision meshes accept the following arguments:
  <itemize>

  <item><tt/"-scheme"/: the value of this option specifies the subdivision
scheme, it may be set to 0 &ndash; Catmull-Clark or 1 &ndash; Loop only.
Default is 0.

  <item><tt/"-faces"/: the value of this option specifies the number of
faces in the mesh. The number of faces defaults to 0.

  <item><tt/"-nverts"/: the value of this option specifies the number of
vertices per face. It is therefore a list of positive integer
values of a length equal to the number of faces.
The default value of this option is a list of proper length with all
elements set to 3 (only triangles are in the mesh).

  <item><tt/"-verts"/: the value of this option specifies all the (zero
based) indices of the vertices of all faces. It is therefore a list of
integer values of a length equal to the sum of all elements of the
<tt/"-nverts"/ option.
The default value of this option is a list of proper length with the
elements set to a sequence of integers so that the control points are
used in the same order as specified via the <tt/"-cv"/ option
(0, 1, 2, 3, &hellip;).

  <item><tt/"-cv"/: The value of this option is a list of floating point
numbers that describe the 3D (non rational) coordinates of the control
points. The indices specified via the <tt/"-verts"/ option point to
this list.
This list must have a length of 3 multiplied by the highest value in
the list provided via the <tt/"-verts"/ option.
The default value of this option is an empty list, this implies that this
option must be specified to create a non-empty SDMesh object.

  <item><tt/"-cn"/: the control points of the new mesh. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <tt/"-cv"/ option
above.

  <item><tt/"-tags"/: the value of this option specifies a number of tags.
It is therefore a list of positive integer values of arbitrary length.
The only allowed values are 0 &ndash; hole, 1 &ndash; corner,
2 &ndash; crease, and 3 &ndash; interpolateboundary.
The default value of this option is an empty list: no tags.

  <item><tt/"-args"/: the value of this option specifies the number of
integer and floating point arguments per tag.
It is therefore a list of positive integer values of length:
double number of tags. The even entries specify the number of integer and
the odd entries the number of floating point arguments per tag.
The content of this list is partially dictated by the <tt/"-tags"/
option, e.g.~a crease entry has atleast two integer arguments and one
floating point argument.
The default value of this option is list of proper length, with all
elements set to zero (no tags have any arguments).

  <item><tt/"-intargs"/: the value of this option specifies the
integer arguments of all tags.
It is therefore a list of integer values of length
sum of all even elements given by the <tt/"-args"/ option.

  <item><tt/"-doubleargs"/: the value of this option specifies the
floating point arguments of all tags.
It is therefore a list of double values of length
sum of all odd elements given by the <tt/"-args"/ option.

  </itemize>

<#if out=latex><x/newpage/</#if>

Examples:
<enum>
<item><bf/<tt/"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5}"//<newline>
creates a tetrahedral (four triangular faces) mesh.
<item><bf/<tt/"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5} -tags {1} -args {1 1} -intargs {0} -doubleargs {3.0}"//<newline>
creates a tetrahedral mesh with a semi-sharp corner.
<item><bf/<tt/"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5} -tags {2} -args {2 1} -intargs {0 1} -doubleargs {10.0}"//<newline>
creates a tetrahedral mesh with a crease.
</enum>
Notes:<newline>
Besides checking the lengths of arrays, maximum indices, and minimum
number of vertices per face, there is <em>no</em> error checking.
Undetected errors include: degenerated or non-planar faces,
faces with unsuitable vertex counts (for the selected subdivision scheme),
non-manifold meshes, unused control points, wrong tag arguments.
Those errors may be problematic for further processing steps &ndash; some
may go unnoticed in Ayam and will only be detected later in other applications.

<#if out=latex><x/newpage/</#if>

  <item><tt/"Level"/: Levels must be given an additional argument
determining the type of the new level, this argument may be one of:
<tt/"0"/ (level), <tt/"1"/ (union), <tt/"2"/ (intersection),
<tt/"3"/ (difference), or <tt/"4"/ (primitive).

Examples:
<enum>
<item><bf/<tt/"crtOb Level 0"//<newline>
creates a simple level object.
<item><bf/<tt/"crtOb Level 3"//<newline>
creates a CSG difference level object.
</enum>
 <item><tt/"Material"/: Materials must be given an additional
argument giving the name of the new material.

Example:
<enum>
<item><bf/<tt/"crtOb Material Wood"//<newline>
creates a material named Wood.
</enum>

 <item><tt/"Instance"/: creates an instance of the selected object.
 <item>...
 </itemize>
 <item>Example: Create a sphere and update the GUI:
<tt/"crtOb Sphere; uS; rV"/.
</itemize>

There are some helper commands, that create certain often used
curves:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtncircle">
crtNCircle &ndash; create NURBS circle:
<itemize>
 <item>Synopsis: <tt/"crtNCircle [-r radius] [-a arc]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command creates a circular NURBS curve
with radius as defined via the <tt/-r/ option and arc as
defined via the <tt/-a/ option. The curve always starts on the
positive X axis. The radius defaults to 1.0 and
the arc to 360.0. The arc option supports negative values.
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtclosedbs">
crtClosedBS &ndash; create closed (circular) B-Spline:
<itemize>
 <item>Synopsis: <tt/"crtClosedBS sections [order [arc [radius]]]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command creates a circular B-Spline curve
with desired number of sections, order (defaults to 4), arc (defaults
to 360.0, negative values are allowed), and radius (defaults to 1.0).
The curve always starts on the positive X axis. 
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccrtnrect">
crtNRect &ndash; create a rectangular NURBS curve:
<itemize>
 <item>Synopsis: <tt/"crtNRect"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command creates a rectangular NURBS curve
that fits the parameter space of the currently selected NURBS
patch object (or the current parent object, if it is a NPatch).
If no NURBS patch is selected or parent, this command will create a
centered quadratic curve with width 2.0 and height 2.0 instead.
</itemize>


<sect2>Manipulating the Selection<label id="selob">
<p>
These commands are probably the most important ones, because many other
scripting interface commands operate on selected objects only:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scselob">
selOb &ndash; select object(s):
<itemize>
 <item>Synopsis: <tt/"selOb [index]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Use this command to set or clear the current
selection, index may be an ordered list of indices, a single index or empty.
If no index is given, the current selection will be cleared.
 <item>Examples: <tt/"selOb"/ clears the current selection, <tt/"selOb 0"/
selects the first object in the current level, <tt/"selOb 0 1"/ selects
the first two objects in the current level.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scwithob">
withOb &ndash; execute a command on certain selected object(s):
<itemize>
 <item>Synopsis: <tt/"withOb index [do] command"/
 <item>Background: depends on command, Undo: depends on command, Safe: Yes
 <item>Description: Use this command to execute command on a
single object (designated by index) from a multiple selection
without changing the selection state of any objects.
 <item>Example: <tt>"withOb 2 {movOb 0 1 0}"</tt> moves the third
object from multiple selected objects. All objects stay selected.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsl">
sL &ndash; select last object:
<itemize>
 <item>Synopsis: <tt/"sL"/
 <item>Background: No, Undo: No, Safe: Yes
 <item>Description: Select the last object in the current level
and, if run in the Ayam interpreter, update the GUI.
If run in the safe interpreter (e.g.~from a Script objects script)
this command will create a hidden selection.
This command is often called in a sequence
after creating a new object like this:

<code>
# create object
crtOb NCurve
# update tree
uCR
# select new object
sL
</code>
In Script objects scripts the above example command sequence would leave out
the <tt/"uCR"/ command, as access to the GUI is blocked anyway in this
context:
<code>
# create object
crtOb NCurve
# select new object
sL
</code>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="schsl">
hSL &ndash; hidden select last object:
<itemize>
 <item>Synopsis: <tt/"hSL"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Select the last object in the current level
but do not update the GUI.
Note: prior to Ayam 1.18 this command used to be available in the
safe interpreter. This is no longer the case, use <tt/"sL"/ instead.
</itemize>

<sect2>Selecting Points
<p>
This command manipulates the point selection.
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scselpnts">
selPnts &ndash; select points:
<itemize>
 <item>Synopsis: <tt/"selPnts [-all | index1 index2 ...]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description:
 <itemize>
  <item>If called without arguments, this command deselects all points.
  <item>If the argument is <tt/"-all"/, this command selects all points.
  <item>If the argument contains an index, the corresponding point(s) will
be added to the selection; already selected points will not be deselected.
The index is zero-based and always one dimensional (even
for surfaces). Multiple indices may be provided.
 </itemize>
 <item>Example: Given that a single NCurve object is selected, its
points may be selected using the command <tt/"selPnts -all"/; the first
and third point of the same curve may be selected using <tt/"selPnts 0 2"/.
</itemize>

<sect2>Manipulating Properties<label id="sciprop">
<p>
Since Ayam 1.9 two new commands are implemented that ease
the manipulation of property values from the scripting interface:

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgetproperty">
getProperty &ndash; get single property value
<itemize>
 <item>Synopsis: <tt/"getProperty propname(elemname) varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command gets a single property element
named elemname from the property named propname of the currently
selected object and writes the result into the variable named varname.
 <item>Notes: In contrast to many other helper commands, the variable
varname does not have to be global.
This command runs more slowly than calling the appropriate get-procedure and
accessing the data array that is associated with a property
directly, especially if multiple values are to be fetched.
See below for more information regarding direct access of property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be retrieved in the variable <tt/"r"/ easily using the command
<tscreen><verb>getProperty SphereAttr(Radius) r</verb></tscreen>
</itemize>
In contrast to using <tt/"getProperty"/, here is an equivalent example for the
direct (fast) access of property values:
<code>
getProp
set r $::SphereAttrData(Radius)
</code>
See also section
<ref id="ayproparr" name="Global Property Management and Data Arrays">.

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsetproperty">
setProperty &ndash; set single property value
<itemize>
 <item>Synopsis: <tt/"setProperty propname(elemname) value"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: This command sets a single property element
named elemname of the property named propname for the currently
selected object to the new value given in value.
 <item>Notes: This command runs more slowly than accessing the data array
that is associated with a property and calling the appropriate set-procedure
directly, especially if multiple values are to be set.
See below for more information regarding direct access of property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be set to the new value <tt/"3.0"/ easily using the command
<tscreen><verb>setProperty SphereAttr(Radius) 3.0</verb></tscreen>
</itemize>
<p>
In contrast to using <tt/"setProperty"/, here is an equivalent example for the
direct (fast) access of property values:
<code>
getProp
set SphereAttrData(Radius) 3.0
setProp
</code>
See also section
<ref id="ayproparr" name="Global Property Management and Data Arrays">.

<sect2>Clipboard Operations<label id="sciclip">
<p>
These commands operate the object clipboard:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccopob">
copOb &ndash; copy object:
<itemize>
 <item>Synopsis: <tt/"copOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Copy the selected object(s) to the object clipboard.
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccutob">
cutOb &ndash; cut object:
<itemize>
 <item>Synopsis: <tt/"cutOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Move the selected object(s) into the object clipboard.
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scpasob">
pasOb &ndash; paste object:
<itemize>
 <item>Synopsis: <tt/"pasOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Copy the selected object(s) from the object
clipboard to the current level.
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scdelob">
delOb &ndash; delete object:
<itemize>
 <item>Synopsis: <tt/"delOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Delete the selected object(s) from the scene.
</itemize>
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccmovob"><label id="scpasmovob">
pasmovOb &ndash; paste (move) object:
<itemize>
 <item>Synopsis: <tt/"pasmovOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Move the objects from the object
clipboard to the current level.
</itemize>

<p>
The following commands operate the property clipboard,
which is totally independent from the object clipboard.
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scpclip_copy"><label id="sccopyprop">
pclip_copy/copyProp &ndash; copy a property to the property clipboard
<itemize>
 <item>Synopsis: <tt/"pclip_copy mode"/ or <tt/"copyProp mode"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Copy the currently selected
property from the currently selected
object to the property clipboard.
If mode is 0, omit all marked entries, if mode is 1 copy just
marked entries. Entries can also be marked programmatically
by adding the respective entry names to the global array
<tt/"pclip_omit"/.
Note that you may call this procedure also using the shortcut
<tt/"copyProp"/.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scpclip_paste"><label id="scpasteprop">
pclip_paste/pasteProp &ndash; paste a property
<itemize>
 <item>Synopsis: <tt/"pclip_paste"/ or <tt/"pasteProp"/
 <item>Background: Yes, Undo: Yes, Safe: No
 <item>Description: Copy the property from the property clipboard
to the currently selected object.
Note that you may call this procedure also using the shortcut
<tt/"pasteProp"/.
</itemize>

<sect2>Hierarchy Operations<label id="scihier">
<p>
These commands manipulate the current level of Ayam:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgodown">
goDown:
<itemize>
 <item>Synopsis: <tt/"goDown index"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Enter the object determined by index. If index is 0
and the current level is inside some other object (not the root)
the parent level will be entered instead. If index is -1, the last
object of the current level will be entered.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgoup">
goUp:
<itemize>
 <item>Synopsis: <tt/"goUp"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Go one level up in the object hierarchy.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgotop">
goTop:
<itemize>
 <item>Synopsis: <tt/"goTop"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Go to the top level of the object hierarchy.
</itemize>

<sect2>Transformations<label id="scitrafo">
<p>
These commands transform objects or selected points of objects:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scmovob">
movOb &ndash; move objects:
<itemize>
 <item>Synopsis: <tt/"movOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Move the selected object(s) by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scrotob">
rotOb &ndash; rotate objects:
<itemize>
 <item>Synopsis: <tt/"rotOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rotate the selected object(s) by dx degrees around the
objects X axis, then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scscalob">
scalOb &ndash; scale objects:
<itemize>
 <item>Synopsis: <tt/"scalOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Scale the selected object(s) by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scmovsel"><label id="scmovpnts">
movPnts &ndash; move selected points:
<itemize>
 <item>Synopsis: <tt/"movPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Move the selected points by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scrotsel"><label id="scrotpnts">
rotPnts &ndash; rotate selected points:
<itemize>
 <item>Synopsis: <tt/"rotPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rotate the selected points by dx degrees around the
objects X axis then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scscalsel"><label id="scscalpnts">
scalPnts &ndash; scale selected points:
<itemize>
 <item>Synopsis: <tt/"scalPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Scale the selected points by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scdelegtrafo">
delegTrafo &ndash; delegate transformations:
<itemize>
 <item>Synopsis: <tt/"delegTrafo"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: delegates the transformations associated
with the selected objects to their child objects. Additionally,
the transformations of the selected objects will be reset to the
default values.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scapplytrafo">
applyTrafo &ndash; apply transformations:
<itemize>
 <item>Synopsis: <tt/"applyTrafo [-sel]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: applies the transformations encoded in the
transformation attributes of the selected objects to their points.
Either all points (default) or just the selected ones (if the option
<tt/"-sel"/ is given) are modified.
It is no error, if an object has no points at all or if the points
are readonly.
Additionally, if any points of an object are modified, the transformations
of this object will be reset to the default values.
</itemize>

<sect2>Manipulating Shaders<label id="scishaders">
<p>
These commands operate the shader properties:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scshaderset">
shaderSet:
<itemize>
 <item>Synopsis: <tt/"shaderSet shadertype [varname]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Set the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. If varname is not given, the shader in question
is deleted from the object instead.
Otherwise, varname points to an associative array that contains
the data (arguments) of the shader. Example content may be created
with the <tt/"shaderGet"/ command below. The data is <em>not</em> checked
against the internal shader database for correctness or completeness.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scshaderget">
shaderGet:
<itemize>
 <item>Synopsis: <tt/"shaderGet shadertype varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. The shader data will be written to an associative
array pointed to by varname.
</itemize>

<sect2>Manipulating Tags<label id="scitags">
<p>
These commands may be used to modify the tags of an object:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scaddtag">
addTag:
<itemize>
 <item>Synopsis: <tt/"addTag type value"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Add a tag with type-string type and value-string
value to the currently selected objects(s).
It is legal to deliver <tt>""</tt> as value parameter. This is
e.g.~needed for the <tt/"NoExport"/ tag.
<item>Examples:
<enum>
<item><bf><tt>"addTag NoExport """</tt></bf><newline>
adds a <tt/"NoExport"/ tag to the selected objects.
<item><bf><tt>"addTag RP Transformations"</tt></bf><newline>
adds a <tt/"RP"/ (remove property) tag to the selected objects
that hides the Transformations property GUI.
</enum>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scdeltags">
delTags:
<itemize>
 <item>Synopsis: <tt/"delTags type"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Delete all tags of designated type from
the currently selected objects(s).
If type is <tt/"all"/, all tags are deleted from the
currently selected objects(s).
<item>Examples:
<enum>
<item><bf><tt>"delTags all"</tt></bf><newline>
removes all tags from the selected objects.
<item><bf><tt>"delTags RP"</tt></bf><newline>
removes all <tt>"RP"</tt> tags from the selected objects.
</enum>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgettags">
getTags:
<itemize>
 <item>Synopsis: <tt/"getTags tvname vvname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get all tags from
the currently selected objects and put them as lists into two
variables named tvname for the tag types and vvname for the tag
values.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsettags">
setTags:
<itemize>
 <item>Synopsis: <tt/"setTags tags"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clear all tags from the currently selected object
and set new tags. The tag types are taken from the list elements
with even index numbers
and the tag value-strings from the list elements with odd index numbers.
<item>Examples:
<enum>
<item><bf><tt>"setTags &lcub;RP Transformations RP Attributes&rcub;"</tt></bf><newline>
replaces all tags from the selected objects with two <tt>"RP"</tt>
tags.
</enum>
</itemize>

<sect2>Manipulating NURBS Curves and Surfaces<label id="scinurbs">
<p>
These are more specialized commands to change NURBS curve and surface
properties:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scclampnc">
clampNC &ndash; clamp NURBS curve:
<itemize>
 <item>Synopsis: <tt/"clampNC [side]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve will be changed to <tt/"Custom"/ and
the knots will have o equal values at the desired side(s), where o is the
order of the curve.
<p><p>
If the side parameter is omitted or 0, both sides
are clamped.
If the side parameter is 1 only the start, and if it is 2 only the end
is clamped.
<p>
In Ayam versions prior to 1.18 it was an error if the curve was already
clamped at either side, this is no longer the case.
Furthermore, curves with multiple knots in the end region(s) could not be
clamped, this works ok now.
See also section <ref id="clat" name="Clamp Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scelevatenc">
elevateNC &ndash; elevate NURBS curve:
<itemize>
 <item>Synopsis: <tt/"elevateNC n"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Elevate the order of the selected NURBS curves
without changing the shape of the curves by n.
The knot type of the elevated curves will be changed to <tt/"Custom"/.
See also section <ref id="elevt" name="Elevate Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinsknnc">
insknNC &ndash; insert knot into NURBS curve:
<itemize>
 <item>Synopsis: <tt/"insknNC u r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curves) r times. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the curve and n is the length of the curve.
The knot type of the curves will always be changed to custom but
the shape of the curves will not change.
See also section <ref id="insknt" name="Insert Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scremknnc">
remknNC &ndash; remove knot from NURBS curve:
<itemize>
 <item>Synopsis: <tt/"remknNC (u | -i ind) r [tol]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove a knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curve) r times from the curve. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.~use <tt/"remknNC -i 4 1"/ instead of
<tt/"remknNC 0.5 1"/).
<p><p>
Note that the
shape of the curve may be changed by this tool unless the parameter
tol is specified. If tol is specified the new curve does not deviate
from the original curve more than tol in any point on the curve.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original curve is left unchanged.
See also section <ref id="remknt" name="Remove Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screfinenc">
refineNC &ndash; refine NURBS curve:
<itemize>
 <item>Synopsis: <tt/"refineNC [-cv | {u1 u2 un}]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Refine the knot vector of the selected NURBS curve
without changing the shape of the curve with n new knots {u1 u2 un}
or refine the control vector (if <tt/"-cv"/ option is given).
If no list of new knots is given a new knot is inserted into each interval
in the old knot vector.
See also section <ref id="refit" name="Refine Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sccoarsennc">
coarsenNC &ndash; coarsen NURBS curve:
<itemize>
 <item>Synopsis: <tt/"coarsenNC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove every second control point from the
selected NURBS curves.
See also section <ref id="coart" name="Coarsen Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screvert"><label id="screvertc">
revertC &ndash; revert curves:
<itemize>
 <item>Synopsis: <tt/"revertC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected NURBS,
interpolating, and approximating curves.
See also section <ref id="revertt" name="Revert Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screvertu"><label id="screvertus">
revertuS &ndash; revert surfaces:
<itemize>
 <item>Synopsis: <tt/"revertuS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected surfaces in
the u parametric dimension.
See also section <ref id="revertut" name="Revert U Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screvertv"><label id="screvertvs">
revertvS &ndash; revert surfaces:
<itemize>
 <item>Synopsis: <tt/"revertvS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected surfaces in
the v parametric dimension.
See also section <ref id="revertvt" name="Revert V Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scswapuvs">
swapuvS &ndash; swap dimensions of surfaces:
<itemize>
 <item>Synopsis: <tt/"swapuvS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Swap the dimensions of the selected surfaces, thus
exchanging width and height (without altering the shape of the surfaces).
See also section <ref id="swapuvt" name="Swap UV Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screscaleknnc">
rescaleknNC &ndash; rescale knots of NURBS curves:
<itemize>
 <item>Synopsis: <tt/"rescaleknNC [-r rmin rmax | -d mindist]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rescale the knot vector(s) of the selected NURBS curve(s)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. Scaling to a minimum
distance ensures that all knots (except for multiple knots) have a distance
bigger than mindist afterwards.
<p><p>
Since Ayam 1.20 the knot type of the curve does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
<p>
This operation does not change the shape of the curve.
See also section <ref id="resckrt" name="Rescale Knots to Range Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsplitnc">
splitNC &ndash; split NURBS curve
<itemize>
 <item>Synopsis: <tt/"splitNC u"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: splits the selected NURBS curve at designated parametric
value into two curves, creating one new curve and
<em>modifying the original</em> selected curve.
See also section <ref id="splitt" name="Split Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scshiftc">
shiftC &ndash; shift control points of a (closed) curve:
<itemize>
 <item>Synopsis: <tt/"shiftC i"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: shifts the control points of the selected
NCurve, ACurve, and ICurve objects by an amount specified by the
parameter i (which may be negative to revert the direction of the shifting).
For a simple closed curve, shifting with i=1, the first control point will get
the coordinates of the former last control point. This means, positive shifts
occur in the direction of the curve. Note that for closed and periodic
NURBS curves, the multiple points will be managed correctly.
See also section <ref id="shiftclc" name="Shift Closed Curve Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sctoxyc"><label id="sctoxync">
toXYC &ndash; move NURBS curve to XY plane
<itemize>
 <item>Synopsis: <tt/"toXYC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: moves the control points of the selected NURBS curve
objects to its XY plane.
See also section <ref id="toxyt" name="To XY Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sctrimnc">
trimNC &ndash; trim NURBS curve
<itemize>
 <item>Synopsis: <tt/"trimNC umin umax"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: trims the selected NURBS curve to the designated
parametric range (umin-umax), modifying the original selected curve.
See also section <ref id="trimt" name="Trim Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scestlennc">
estlenNC &ndash; estimate length of NURBS curve:
<itemize>
 <item>Synopsis: <tt/"estlenNC [-trafo] varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: estimate the length of the currently selected NURBS curve
or NURBS curve providing object and put the result into the designated variable.
If the optional parameter <tt/"-trafo"/ is given, the transformation
attributes of the curve will be applied to the control points for the
length estimation.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screparamnc">
reparamNC &ndash; reparameterise a NURBS curve:
<itemize>
 <item>Synopsis: <tt/"reparamNC type"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: reparameterise all selected NURBS curves to have
chordal knots (type: 0), or centripetal knots (type: 1). The knot type
of the curve will be changed to <tt/"Custom"/.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scmakecompnc">
makeCompNC &ndash; make NURBS curves compatible
<itemize>
 <item>Synopsis: <tt/"makeCompNC"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: makes the selected NURBS curves compatible
i.e.~of the same order and defined on the same knot vector.
See also section <ref id="makecompt" name="Make Compatible Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scclampnpu"><label id="scclampunp">
clampuNP &ndash; clamp NURBS patch in U direction:
<itemize>
 <item>Synopsis: <tt/"clampuNP [side]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the U direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
U direction).
<p><p>
If the side parameter is omitted or 0, both sides
are clamped.
If the side parameter is 1 only the start, and if it is 2 only the end
is clamped.
<p>
In Ayam versions prior to 1.18 it was an error if the patch was already
clamped at either side, this is no longer the case.
Furthermore, patches with multiple knots in the end region(s) could not be
clamped, this works ok now.
See also section <ref id="clanpt" name="Patch Clamp Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scclampnpv"><label id="scclampvnp">
clampvNP &ndash; clamp NURBS patch in V direction:
<itemize>
 <item>Synopsis: <tt/"clampvNP [side]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the V direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
V direction).
<p><p>
If the side parameter is omitted or 0, both sides
are clamped.
If the side parameter is 1 only the start, and if it is 2 only the end
is clamped.
<p>
In Ayam versions prior to 1.18 it was an error if the patch was already
clamped at either side, this is no longer the case.
Furthermore, patches with multiple knots in the end region(s) could not be
clamped, this works ok now.
See also section <ref id="clanpt" name="Patch Clamp Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screscaleknnp">
rescaleknNP &ndash; rescale knots of NURBS patches:
<itemize>
 <item>Synopsis: <tt/"rescaleknNP [-r[u|v] rmin rmax | -d[u|v] mindist]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rescale the knot vector(s) of the selected NURBS patch(es)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. The <tt/"-ru"/, <tt/"-rv"/,
<tt/"-du"/, and <tt/"-dv"/ variants scale only the designated dimension.
Scaling to a minimum distance ensures that all knots (except for multiple
knots) have a distance bigger than mindist afterwards. Trim curves, if
present, will also be scaled to match the new range.
Since Ayam 1.20 the knot type of the curve does
not have to be <tt/"Custom"/ anymore. Furthermore, rescaling the knots
does not change the knot type.
This operation does not change the shape of the patch.
See also sections
<ref id="resckrnpt" name="Patch Rescale Knots to Range Tool">
and
<ref id="resckmnpt" name="Patch Rescale Knots to Mindist Tool">.
 <item>Example: <tt/"rescaleknNP -ru 0.2 0.3"/ scales the u knot vector
of the selected NURBS patch objects to the new range (0.2, 0.3).
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinsknnpu"><label id="scinsknunp">
insknuNP &ndash; insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknuNP u r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot in U direction at the position
specified by u, r times. u must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the patch in U direction and n is the
width of the patch.
The u knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change.
See also section <ref id="insknnpt" name="Patch Insert Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinsknnpv"><label id="scinsknvnp">
insknvNP &ndash; insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknvNP v r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot in V direction at the position
specified by v, r times. v must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector V as follows: <tt/V[p] <= v <= V[n]/, where
p is the degree (order-1) of the patch in V direction and n is the
height of the patch.
The v knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change.
See also section <ref id="insknnpt" name="Patch Insert Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scremknunp">
remknuNP &ndash; remove u knot from NURBS surface:
<itemize>
 <item>Synopsis: <tt/"remknuNP (u | -i ind) r [tol]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove a knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected surface) r times from the surface. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.~use <tt/"remknuNP -i 4 1"/ instead of
<tt/"remknuNP 0.5 1"/). Note that the
shape of the surface may be changed by this tool unless the parameter
tol is specified. If tol is specified, the new surface does not deviate
from the original surface more than tol in any point.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original surface is left unchanged.
See also section <ref id="remknts" name="Patch Remove Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scremknvnp">
remknvNP &ndash; remove v knot from NURBS surface:
<itemize>
 <item>Synopsis: <tt/"remknvNP (v | -i ind) r [tol]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove a knot at the position
specified by v (v must be in the valid range of the knot vector
of the selected surface) r times from the surface. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.~use <tt/"remknvNP -i 4 1"/ instead of
<tt/"remknvNP 0.5 1"/). Note that the
shape of the surface may be changed by this tool unless the parameter
tol is specified. If tol is specified, the new surface does not deviate
from the original surface more than tol in any point.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original surface is left unchanged.
See also section <ref id="remknts" name="Patch Remove Knot Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screfineunp">
refineuNP &ndash; refine NURBS surface in u direction:
<itemize>
 <item>Synopsis: <tt/"refineuNP"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Refine the selected NURBS surfaces in u direction
without changing their shape.
The u knot type of the refined surfaces may be changed to <tt/"Custom"/.
See also section <ref id="refinest" name="Refine Surface Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screfinevnp">
refinevNP &ndash; refine NURBS surface in v direction:
<itemize>
 <item>Synopsis: <tt/"refinevNP"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Refine the selected NURBS surfaces in v direction
without changing their shape.
The v knot type of the refined surfaces may be changed to <tt/"Custom"/.
See also section <ref id="refinest" name="Refine Surface Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scelevateunp">
elevateuNP &ndash; elevate NURBS surface in u direction:
<itemize>
 <item>Synopsis: <tt/"elevateuNP n"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Elevate the u order of the selected NURBS surfaces
without changing the shape of the surfaces by n.
The u knot type of the elevated surfaces will be changed to <tt/"Custom"/.
See also section <ref id="elevuvt" name="Elevate UV Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scelevatevnp">
elevatevNP &ndash; elevate NURBS surface in v direction:
<itemize>
 <item>Synopsis: <tt/"elevatevNP n"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Elevate the v order of the selected NURBS surfaces
without changing the shape of the surfaces by n.
The v knot type of the elevated surfaces will be changed to <tt/"Custom"/.
See also section <ref id="elevuvt" name="Elevate UV Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsplitnpu"><label id="scsplitunp">
splituNP &ndash; split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splituNP u"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Splits the selected NPatch objects into two patches
at parametric value u.
The selected NPatch will be modified and a new NPatch object will
be created and appended as new object to the
current level of the scene.
See also section <ref id="splitnpt" name="Patch Split Tools">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsplitnpv"><label id="scsplitvnp">
splitvNP &ndash; split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitvNP v"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Splits the selected NPatch objects into two patches
at parametric value v.
The selected NPatch will be modified and a new NPatch object will
be created and appended as new object to the
current level of the scene.
See also section <ref id="splitnpt" name="Patch Split Tools">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scextrnp">
extrNP &ndash; extract NURBS patch:
<itemize>
 <item>Synopsis: <tt/"extrNP umin umax vmin vmax"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Extracts a sub-patch from the selected NPatch
objects. The extracted patch will be appended as new object to the
current level of the scene. The sub-patch to be extracted is specified
by the parametric values umin, umax,
vmin, and vmax which have to be in the respective valid knot range.
See also section <ref id="extrnpt" name="Extract Patch Tool">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinterpunp">
interpuNP &ndash; interpolate NURBS surface in u direction:
<itemize>
 <item>Synopsis: <tt/"interpuNP [-order order | -ktype type | -closed (0|1) | -sdlen length | -edlen length]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Interpolate the selected NURBS surfaces
in u direction with desired order and parameterisation type.
Order defaults to 4 and must be higher than 2.
The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.
The interpolation can create a closed surface but this will also increase
the width of the resulting NURBS surface (the default is to
create an open surface).
Using the options <tt/"-sdlen"/ and <tt/"-edlen"/ (which both default
to 0.0) the length of automatically created start/end derivatives
can be adjusted. If any of these is not 0.0, a different interpolation
algorithm will be used, which increases the width of the resulting NURBS
surface.
The surface will interpolate all current control points after the
interpolation and the position of certain control points will be
changed in this process so that, after interpolation, the new control
points will not be interpolated by the surface. The surface will
interpolate the old control point positions.
The u knot type of the interpolated surfaces will be changed to <tt/"Custom"/.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinterpvnp">
interpvNP &ndash; interpolate NURBS surface in v direction:
<itemize>
 <item>Synopsis: <tt/"interpvNP [-order order | -ktype type | -closed (0|1) | -sdlen length | -edlen length]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Interpolate the selected NURBS surfaces
in v direction with desired order and parameterisation type.
Order defaults to 4 and must be higher than 2.
The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.
The interpolation can create a closed surface but this will also increase
the height of the resulting NURBS surface (the default is to
create an open surface).
Using the options <tt/"-sdlen"/ and <tt/"-edlen"/ (which both default
to 0.0) the length of automatically created start/end derivatives
can be adjusted. If any of these is not 0.0, a different interpolation
algorithm will be used, which increases the height of the resulting NURBS
surface.
The surface will interpolate all current control points after the
interpolation and the position of certain control points will be
changed in this process so that, after interpolation, the new control
points will not be interpolated by the surface. The surface will
interpolate the old control point positions.
The v knot type of the interpolated surfaces will be changed to <tt/"Custom"/.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scconcats">
concatS &ndash; concatenate surfaces:
<itemize>
 <item>Synopsis: <tt/"concatS [-o order | -t type | -k knottype | -u uvselect]"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Concatenate the selected surface objects into a
single NURBS patch. The option <tt/"-o"/ determines the desired order
of the surface in U-direction. The option <tt/"-t"/ allows to set a
surface type
(0 &ndash; open, 1 &ndash; closed, 3 &ndash; periodic; default 0), and
<tt/"-k"/ allows to set a knot type (default 1 - NURB).
Finally, the <tt/"-u"/ option allows to specify the uv-select-string.
See also section <ref id="concatnpp" name="ConcatNPAttr Property">
for more information on these options.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsplitnp">
splitNP &ndash; split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitNP (u | v)"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Splits the selected NPatch objects into NURBS curves,
along parametric dimension u or v.
See also section <ref id="splitnpt" name="Patch Split Tools">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scbuildnp">
buildNP &ndash; build NURBS patch:
<itemize>
 <item>Synopsis: <tt/"buildNPatch"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Builds a NURBS patch from the selected NURBS curves.
See also section <ref id="bfct" name="Build from Curves Tool">.
</itemize>


<sect2>Manipulating Points<label id="scipoints">
<p>
Use these two commands to read or manipulate single points of arbitrary
objects.
Note that the exact arguments needed depend on the type of the selected
object, e.g.~manipulating the points of a NURBS curve requires just one
index parameter (indexu), whereas manipulating the points of a NURBS
patch requires two index parameters (indexu and indexv) to be specified.

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgetpnt">
getPnt &ndash; get point(s):
<itemize>
 <item>Synopsis: <tt/"getPnt [-trafo | -world | -eval] (index | indexu indexv | u | u v (varx vary varz [varw] | -vn varname) | -all varname)"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get a control point of the currently selected object
and write the coordinate values into the variables varx, vary, varz, and
varw.
<p><p>
If the optional argument <tt/"-trafo"/ is given, the coordinates
will additionally be transformed by the values given in the objects
Transformation property.
<p>
If the optional argument <tt/"-world"/ is used, the coordinates
will additionally be transformed to world space.
<p>
If the optional argument <tt/"-eval"/ is specified, the <tt/"indexu"/
and <tt/"indexv"/ values are interpreted as parametric values of a
NURBS curve or surface and the corresponding point on the curve or
surface is delivered in varx, vary, and varz.
<p>
If the alternative argument <tt/"-vn"/ is given, the coordinate values
will be appended to the list variable specified by <tt/"varname"/.
<p>
If the alternative argument <tt/"-all"/ is used, all coordinate values
of the selected objects will be appended to the list variable
specified by <tt/"varname"/.

<item>Notes: In Ayam versions prior to 1.20, only global variables
were written, this is no longer the case.
<item>Examples:
<enum>
<item><bf/<tt/"getPnt 1 x y z w"//<newline>
gets the coordinate values of the second point of the selected NURBS
curve and writes the values to the variables <tt/"x y z w"/.
<item><bf/<tt/"getPnt -eval 0.5 x y z w"//<newline>
gets the curve point at parametric value <tt/"0.5"/ and writes the
values to the variables <tt/"x y z w"/.
</enum>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsetpnt">
setPnt &ndash; set point(s):
<itemize>
 <item>Synopsis:
<tt/"setPnt [-world] (indexu [indexv] (x y z [w] | -vn varname) | -all varname)"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Set a control point of the
currently selected object to the coordinates x, y, z, and w or to
coordinates from a list, or set all control points from a list of
coordinate values.
<p><p>
If the optional parameter <tt/"-world"/ is given, the coordinate values are
expressed in world space and will be transformed to appropriate
object space coordinates before setting.
<p>
If the optional parameter <tt/"w"/ is omitted,
but the selected object has rational points, a default value of 1.0 will
be used for the weight.
<p>
If the alternative parameter <tt/"-vn"/ is used, the coordinate
values will be read from the variable specified by <tt/"varname"/
which must be a list of double values.
<p>
If the alternative parameter <tt/"-all"/ is provided, all control
points of the selected objects will be set and the coordinate
values will be read from the variable specified by <tt/"varname"/
which must be a list of double values.
<p>
When reading data from list variables, no precision will be lost
as there are no double-string-double conversions involved.

 <item>Examples:
<enum>
<item><bf/<tt/"setPnt 1 0.0 0.2 0.3 1.0"//<newline>
sets the coordinate values of the second point of the selected NURBS
curve object to <tt/"0.0 0.2 0.3 1.0"/.
<item><bf/<tt/"setPnt -world 0 0 0 0"//<newline>
sets the first point of the selected NURBS
curve object to the world origin, regardless of the transformation
attributes of the curve object (or any of its potential parent objects).
<item><bf/<tt/"setPnt 2 1 0.0 0.2 0.3"//<newline>
sets the coordinate values of the second point in the third column of
the control mesh of the selected NURBS
patch object to <tt/"0.0 0.2 0.3 1.0"/.
</enum>
</itemize>


<sect2>Updating the GUI<label id="sciupd">
<p>
These commands update various parts of the Ayam user interface:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scrv">
rV &ndash; redraw all views:
<itemize>
 <item>Synopsis: <tt/"rV"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Redraws all currently open views, except for
iconified views and views where automatic redraw has been turned off.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scus">
uS &ndash; update select:
<itemize>
 <item>Synopsis: <tt/"uS [update_prop maintain_selection]"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update the object listbox or tree view after a change
to the object hierarchy.
<p>
If update_prop is 0 no update of the property GUIs will take place.
<p>
If maintain_selection is 1 the old selection will be established again.
<p>
If both arguments are omitted update_prop defaults
to 1 and maintain_selection to 0.
 <item>Deficiencies: uS completely removes the object tree from
the tree widget and rebuilds it, which can be a very time consuming
operation (depending on the complexity of the scene). There are some
options to speed this process up:
 <itemize>
 <item>If there were just changes to the current level (and below)
the global array entry <tt/"ay(ul)"/ (UpdateLevel) may be set
to the current level before calling <tt/"uS"/. This will not remove
and update the complete scene but just the part below <tt/"ay(ul)"/.
Example:
<code>global ay; set ay(ul) $ay(CurrentLevel); uS;</code>.
 <item>If objects have been created and thus just need to be
added to the current level of the object tree view, the command
<tt/"uCR"/ may be used instead of <tt/"uS"/.
 <item>If just names or types of objects of the current level changed,
the command <tt/"uCL cl"/ may be used instead of <tt/"uS"/.
 </itemize>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scucl">
uCL &ndash; update current level:
<itemize>
 <item>Synopsis: <tt/"uCL mode [args]"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update only the current level of the object listbox
or tree view after changes. See also the discussion of <tt/"uS"/ above.
The parameter <tt/"mode"/ may be "cl" or "cs", where "cl" is the normal
operation mode, and "cs" just clears the selection.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scucr">
uCR &ndash; update current level after create:
<itemize>
 <item>Synopsis: <tt/"uCR"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update only the current level of the object listbox
or tree view after objects have been created and need to be added to
the current level. See also the discussion of <tt/"uS"/ above.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scplb_update">
plb_update &ndash; property listbox update:
<itemize>
 <item>Synopsis: <tt/"plb_update"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Clear the current property GUI, ask the currently
selected object for a list of properties and insert them in the
property listbox, then rebuild the property GUI of the property
with the same index in the property listbox
as the property selected before plb_update was started (this is not
necessarily a property of the same type).
</itemize>

Since Ayam 1.13 it is also possible to automatically run GUI updating
commands in the console by using <tt/&lt;Shift+Return&gt;/ instead
of <tt/&lt;Return&gt;/. The commands from the hidden preference setting
<tt/"AUCommands"/ will be executed after the commands from the command
line, if the <tt/&lt;Shift&gt;/ key is held down. <tt/&lt;Shift+Return&gt;/
may also be used without commands on the command line.
By default, the <tt/"AUCommands"/ are <tt/"uS; rV;"/, leading to
updated object tree, property GUI, and views.

<sect2>Managing Preferences<label id="sciprefs">
<p>
These commands manage preferences data:
<p><label id="scgetprefs">
getPrefs &ndash; get preferences data:
<itemize>
 <item>Synopsis: <tt/"getPrefs"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Copy preferences data from the C to the Tcl context.
</itemize>

<p><label id="scsetprefs">
setPrefs &ndash; set preferences data:
<itemize>
 <item>Synopsis: <tt/"setPrefs"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Copy preferences data from the Tcl to the C context.
This is necessary after a change to the global ayprefs Tcl array to let
the changes take effect.
</itemize>


<sect2>Custom Objects<label id="scicust">
<p>
This command manages custom objects (plugins):
<p><label id="scio_lc">
io_lc &ndash; load custom:
<itemize>
 <item>Synopsis: <tt/"io_lc filename"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Load the custom object (plugin) from file filename.
Note that it is currently not possible to unload a custom object from
Ayam.
</itemize>

<sect2>Applying Commands to a Number of Objects<label id="scifall">
<p>
There are two commands that help to apply arbitrary commands
to a number of objects, forAll and forAllT:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scforall">
forAll:
<itemize>
 <item>Synopsis: <tt>"forAll recursive command"</tt>
 <item>Background: depends, Undo: depends, Safe: No
 <item>Description: The forAll command executes command for all
objects that have been selected currently, or for every object
of the current level if nothing has been selected. If recursive
is 1 then forAll will recurse into every object (if it has child objects)
before the execution of command. Note that forAll will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g.~the property context menu first.
 <item>Deficiencies:
 <itemize>
  <item>A recursive forAll will
e.g.~also descend into NURBS patches (if they have trim curves) and apply
the command to the trim curves, which might not exactly be what you
want. Use <tt>"forAllT"</tt> in this case.
  <item>The command will not have access to global arrays unless
e.g.~one of the following constructs is in use:
<p><p>
<tt>"forAll 0 &lcub; uplevel &num;0 &lcub; commands &rcub; &rcub;"</tt><p>
<tt>"forAll 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g.~deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAll"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scforallt">
forAllT:
<itemize>
 <item>Synopsis: <tt>"forAllT type recursive command"</tt>
 <item>Background: depends, Undo: depends, Safe: No
 <item>Description: forAllT works the same way as forAll, with an
additional type check. The command will not be executed if the type of the
current object does not match the argument type. Note that forAllT will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g.~the property context menu first.
<p><p>
Note that the type strings will be converted to lowercase before
comparison, so that it is legal to use forAllT e.g.~this way:
<p><tt>"forAllT ncurve 0 &lcub;puts $i&rcub;"</tt><p>
 <item>Deficiencies:
 <itemize>
  <item>The command will not have access to global arrays unless
e.g.~one of the following constructs is in use:<p>
<tt>"forAllT ncurve 0 &lcub;uplevel &num;0 &lcub;commands&rcub; &rcub;"</tt><p>
<tt>"forAllT ncurve 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g.~deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAllT"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<sect2>Scene IO<label id="scio">
<p>
These commands help to load scenes from and save them to Ayam scene
files:
<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scnewscene">
newScene:
<itemize>
 <item>Synopsis: <tt>"newScene"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: clears the current scene.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="screplacescene">
replaceScene:
<itemize>
 <item>Synopsis: <tt>"replaceScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: clears the current scene, then loads a new scene
from filename.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scinsertscene">
insertScene:
<itemize>
 <item>Synopsis: <tt>"insertScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: inserts a scene from filename.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scsavescene">
saveScene:
<itemize>
 <item>Synopsis: <tt>"saveScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: saves the current scene to filename.
</itemize>

<sect2>RIB Export<label id="scribex">
<p>
This command allows to export the current scene to a RenderMan
Interface Bytestream (RIB):

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scwrib">
wrib &ndash; RIB export:
<itemize>
 <item>Synopsis:
<tt>"wrib filename [-image imagename] [-smonly | -selonly | -objonly]"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: exports the current scene to a RIB file designated
by <tt/"filename"/.
<p><p>
If the argument <tt/"-image"/ is given, the RIB file
will create an image file named <tt/"imagename"/ upon rendering. The export
will use the camera transformation from the currently selected Camera
object.
<p>
If the argument <tt/"-smonly"/ is provided, a RIB to render shadow maps
will be created and the argument of <tt/"-image"/ will be ignored.
<p>
If the argument <tt/"-selonly"/ is used, only the selected (geometric)
objects will be exported, which will result in a RIB file not
suitable for rendering (no setup, camera transformation, or lights
are in it) but for inclusion into other scenes via RiArchive.
Likewise <tt/"-objonly"/ leads to a RIB file containing all objects in the
scene but not suitable for rendering.
<p>
The <tt>"wrib"</tt> command always needs a selected camera object
(unless the <tt/"-selonly"/ or <tt/"-objonly"/ options are given); if
there is none or if the camera transformations of the camera associated
with a view window shall be used, the corresponding Togl callback for
the view might be used like this instead:
<code>
.view1.f3D.togl wrib -file filename.rib
</code>
The Togl callback understands the same options as the <tt>"wrib"</tt>
command.
<item>Notes: In Ayam versions prior to 1.15, the filename had to be prepended
by a <tt/"-filename "/, this is no longer the case.
</itemize>

<sect2>Reporting Errors<label id="scierr">
<p>
This command is for error reporting from scripts:

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scayerror">
ayError:
<itemize>
 <item>Synopsis: <tt>"ayError code place detail"</tt>
 <item>Background: No, Undo: No, Safe: No
 <item>Description: This command reports errors or warnings.
You should always use ayError instead of puts because the error
reporting mechanism of Ayam features consistently formatted output,
compression of repeated messages, and logging.
Code should be one of: 1: warning, 2:
error, 3: flush messages, 4: unspecified output.
There are more codes defined (see ayam.h, look for Return/Error Codes)
but they are not needed in the Tcl script context.
Place should describe the procedure where the error occured.
Detail is the string to be output.
<item>Notes: The actual output in the Ayam console depends on the
preference option <tt/"ErrorLevel"/ see section
<ref id="prefmisc" name="Miscellaneous Preferences">.
</itemize>

<sect2>Miscellaneous<label id="scimisc">
<p>
Miscellaneous commands:

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scgettype">
getType:
<itemize>
 <item>Synopsis: <tt>"getType varname"</tt>
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command writes the type of the
selected object into the variable varname. The types are
the well known strings that are displayed in the hierarchy list box
if the objects are not named (NPatch, NCurve, Sphere, etc.).
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="sctmpget">
tmpGet:
<itemize>
 <item>Synopsis: <tt>"tmpGet tmpdir varname"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command calculates a name for a temporary
file in tmpdir and puts the complete name into varname.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="schaschild">
hasChild:
<itemize>
 <item>Synopsis: <tt>"hasChild"</tt>
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command returns 1 if the selected object
has child objects, otherwise it returns 0.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scundo">
undo:
<itemize>
 <item>Synopsis: <tt>"undo [redo | save opname [0|1] | clear | rewind]"</tt>
 <item>Background: Yes, Undo: Yes, Safe: No
 <item>Description:
 <itemize>
  <item>If called without arguments, this command performs the undo
  operation.
  <item>If the argument is <tt/"redo"/, this command performs the redo
  operation.
  <item>If the argument is <tt/"save"/, the currently selected objects
are saved to the undo buffer for future undo operations. The name
of the now following modelling operation <em>has</em> to be provided in
a second argument (<tt/"opname"/).
This name will be displayed in the default console prompt, to inform the
user about which operation would be undone/redone, if undo/redo would be
used (e.g.~<tt>"[Undo:MoveObj/Redo:none].../bin&gt;"</tt>).
Since Ayam 1.13, a third argument may be given, that controls whether
all the children of the selected objects should also be saved. This may
be needed if the modelling action that follows the undo save is about to
change the selected objects and also their children.
Note: undo save does not fail if no objects are selected.
  <item>If the argument is <tt/"clear"/, all currently saved states
will be cleared from the undo buffer.
  <item>The argument <tt/"rewind"/ is available since Ayam 1.14. With
this command you can undo the last undo save operation. This may be
necessary, if a modelling operation failed. Care should be taken,
however, to <em>not</em> rewind the undo state, when a modelling
operation only failed for some (not for all) of the selected objects.
 </itemize>
 <item>Example:
<code>
undo save "MovOb"
set ay_error ""
movOb 0 1 0
if { $ay_error > 1 } {
  undo rewind
}
</code>
<item>Notes: See also section <ref id="undos" name="The Undo System">.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scconvob">
convOb:
<itemize>
 <item>Synopsis: <tt>"convOb [-inplace]"</tt>
 <item>Background: Yes, Undo: depends (if -inplace: Yes), Safe: Yes
 <item>Description: This command calls the registered converter
for the selected object(s). If the option <tt>"-inplace"</tt> is
used, the new object(s) will replace the old object(s).
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scnotifyob">
notifyOb:
<itemize>
 <item>Synopsis: <tt>"notifyOb [-all | -modified | -parent]"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command calls the registered notification
callback for the selected object(s) and their parents, or, if no object
is selected, for all objects of the scene.

<p>
If the <tt>"-modified"</tt> parameter is used, only modified objects
will be notified.
<p>
If the <tt>"-all"</tt> parameter is used, all objects
will be notified regardless of the selection.
<p>
If the <tt>"-parent"</tt> parameter is used, only the current
parent object of the current level will be notified.
<p>
Prior to Ayam 1.20 this command was named <tt>"forceNot"</tt>,
the old name is still available for compatibility but its
use is deprecated.
</itemize>

<p>
<#if out=latex><x/phantomsection/</#if>

<label id="scaddtoproc">
addToProc:
<itemize>
 <item>Synopsis: <tt>"addToProc procedure addition"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command adds the code from addition to
the procedure procedure.
 <item>Note: This command uses the introspection facilities of
Tcl and works only correctly for procedures, that end with
a single <tt>"return;"</tt> statement.
</itemize>

<#if out=latex><x/newpage/</#if>

<sect1>Expression Support in Dialog Entries<label id="scexpdiag">
<p>
Various entries of dialogs for object creation and modelling tools
support Tcl variables and expressions.

One can e.g.~enter
<code>
$::u
</code>
instead of a numeric knot value in the insert knot tool parameter dialog
to infer the parametric value from the global variable u (that
may have been set before using the find u modelling action) and
insert a knot at the picked point.

It is also possible to enter complex mathematical expressions:
<code>
[expr sin(45)]
</code>

or call into own procedures (that have to return appropriately
typed values):
<code>
[myproc]
</code>
.

Repeated calling of the tool without opening the dialog (using
the keyboard shortcut <tt/&lt;Ctrl+T&gt;/), will execute the
provided expression again.
This means, one can e.g.~create a number of curves with increasing
length by entering into the Ayam console
<code>
set ::myvar 1
</code>
then entering for the length in the create NURBS curve dialog:
<code>
[incr ::myvar]
</code>
then pressing <tt/&lt;Ctrl+T&gt;/ multiple times.

<#if out=latex><x/newpage/</#if>

<sect1>Scripting Interface Examples
<p>
Here are some complete example scripts for the Ayam Tcl scripting interface.
<p>
You may copy and paste all examples directly from the documentation
into the console of Ayam.

<sect2>Moving Objects<label id="scexmov">
<p>
The following example script shows how to move a selected object
to a specified position in space.
<code>
proc placeOb { x y z } {
  global transfPropData

  # copy Transformations-property data to
  # global array "transfPropData"
  getTrafo

  # set array values according to procedure parameters
  set transfPropData(Translate_X) $x
  set transfPropData(Translate_Y) $y
  set transfPropData(Translate_Z) $z

  # copy Transformations-property data from
  # global array "transfPropData" to selected object
  setTrafo
}
# placeOb
</code>
In order to move all selected objects to 1 1 1 you may enter the
following into the console:
<code>
forAll 0 {placeOb 1 1 1}
</code>
But perhaps you would rather like a small GUI for that?
No problem, the following snippet adds an entry to the custom
menu that opens a small requester for the x-, y-, and z-values and
calls the <tt/"placeOb"/ procedure (defined above) with them:
<code>
global ay
$ay(cm) add command -label "Place Object" -command {
 runTool {x y z} {"X:" "Y:" "Z:"} "forAll 0 {placeOb %0 %1 %2}"
 plb_update; rV
}
</code>
The trailing <tt/"plb_update; rV"/ command ensures that the GUI is updated
properly and all views display the new position of the moved objects.

<#if out=latex><x/newpage/</#if>

<sect2>Moving NURBS points<label id="scexnurb">
<p>
The following example script snippet shows how to move control points
of a NURBS curve.
<#if out=latex><x/needspace 3/</#if>
<code>
# first, we create a new NURBS curve with 30 control points
set len 30
crtOb NCurve -length $len
# update selection
uS
# select last object (the newly created curve)
sL
# prepare moving
set i 0
set r 3.0
set angle 0
set angled [expr 3.14159265/2.0]
while { $i < $len } {

    set x [expr $r*cos($angle)]
    set y [expr $r*sin($angle)]
    set z [expr $i/3.0]

    # move control point to new position
    setPnt $i $x $y $z 1.0

    set angle [expr $angle + $angled]
    incr i
}
# redraw all views
rV
</code>
Now use this as path for a Sweep.
For instance, using the next small script.

<#if out=latex><x/newpage/</#if>

<sect2>Easy Sweep<label id="scexsweep">
<p>
The following example script shows how to easily create a sweep from a
selected path curve (avoiding the manual and lengthy creation and
parameterisation of a suitable cross section).
<code>
proc easySweep { } {
 # first, we create a sweep object
 crtOb Sweep

 # now, we need to move the selected curve (path) to
 # the sweep and create a cross-section curve there too
 # for that, we move the currently selected curve to the clipboard
 cutOb

 # enter the Sweep (the last object in the current level)
 goDown -1

 # now, we create a new curve (a closed B-Spline suitable as cross section)
 crtClosedBS 8

 # select the new object
 selOb 0

 # now, we rotate and scale the curve
 rotOb 0 90 0
 scalOb 0.25 0.25 1.0

 # move trajectory back (we use "pasmovOb" and _not_ "pasOb", because we
 # really want to move (and not copy) the curve object
 pasmovOb

 # go up to where we came from
 goUp

 # finally, update the GUI...
 uS
 sL

 # ...and redraw all views
 rV
}
# easySweep
</code>

Run this pocedure by selecting a NURBS curve object, then type
into the console:
<code>
easySweep
</code>

You may add this command to the main menu as well:
<code>
global ay
$ay(cm) add command -label "Easy Sweep" -command {
 easySweep
}
</code>
After running the above script you should have a new menu
entry <tt>"Custom/Easy Sweep"</tt> that calls the <tt>easySweep</tt>
procedure.

<#if out=latex><x/newpage/</#if>

<sect2>Toolbox Buttons<label id="scextoolbox">
<p>
Here is another example script that shows how you may add buttons
to the toolbox.
myImage should be an image created e.g.~from a GIF file of
the size 25 by 25 pixels.
<code>
global ay ayprefs

# create an image from a GIF file:
image create photo myImage -format gif -file /home/user/giffile

if { $ayprefs(SingleWindow) } {
  set b .fv.fTools.f.mybutton
} else {
  set b .tbw.f.mybutton
}

# if the button does not already exist:
if { ![winfo exists $b] } {

  # create it:
  button $b -padx 0 -pady 0 -image myImage -command myCommand

  # tell Ayam about the new button:
  # you can use "linsert", to insert the button in a specific
  # place or just append to the end of the list using "lappend"
  lappend ay(toolbuttons) mybutton

  # display the button:
  toolbox_layout

  # from now on, it will be under the
  # automatic toolbox layout management
}
</code>

This example shows that a) toolbox buttons have to be created in the
frame <tt/".tbw.f"/ for multi-window GUI configurations or
<tt/".fv.fTools.f"/ for single-window GUI configurations,
b) Ayam manages a list of all toolbox buttons in the global array ay
in <tt/"ay(toolbuttons)"/, the order in that list is the order
in which the buttons appear in the toolbox, c) automatic layout
management is carried out by the procedure <tt/"toolbox_layout"/.
<p>
Adding buttons with just text is a little bit more involved,
as the sizes of the new buttons often do not fit well in the
icon button scheme with its constant button size. However,
the procedure <tt/"toolbox_add"/ can be of
considerable help.
<footnote>Since 1.14.</footnote>
<p>
See also the script <tt>"scripts/topoly.tcl"</tt>
for an example.
<p>
Here is another example that adds two buttons to the bottom of the
toolbox spanning the whole window (this works best with the
standard toolbox layout of 4 by 12 buttons used in the multi-window
GUI configuration):
<code>
# create a frame:
set f [frame .tbw.f.fcollex]

# calculate the row number below the last row:
set row [expr [lindex [grid size .tbw.f] 1] + 1]

# now display the frame at calculated row, spanning the whole window:
grid $f -row $row -column 0 -columnspan [lindex [grid size .tbw.f] 0]\
     -sticky we
# create two buttons inside the frame:
button $f.b1 -width 5 -text "Coll." -command { collMP; rV; }
button $f.b2 -width 5 -text "Expl." -command { explMP; rV; }
pack $f.b1 $f.b2 -side left -fill x -expand yes
</code>

<sect1>Helper Scripts
<p>
This sections contains the documentation of some helper scripts
that are distributed with Ayam.
<p>
The helper scripts may be run via the context menu of the console, the
Tcl <tt>"source"</tt> command, or the <tt>"Scripts"</tt> preference
setting of Ayam on each start (the latter except for repairAyam.tcl and
bgconvert.tcl).

<sect2>Repair Ayam<label id="repayam">
<p>
The external Tcl script <tt>"repairAyam.tcl"</tt>
may be used to repair the application state of Ayam,
should it be stuck e.g.~in an endless loop of Tcl error messages.
<footnote>Since 1.8.2.</footnote>
<p>
On Unix systems <tt>"repairAyam"</tt> may be started from any
shell simply by typing
<tscreen>
./repairAyam.tcl
</tscreen>
or
<tscreen>
wish repairAyam.tcl
</tscreen>
on the command prompt; if the script detects that it is running on Unix
and not in Ayam it will send itself to the Tcl interpreter Ayam is
running in using the Tk send command. On Mac OS X Aqua (not X11!)
AppleScript events will be used instead of the Tk send command.
If this does not work as expected <tt>"repairAyam.tcl"</tt> may still
be run via the Ayam console (as on Win32).
<p>
On Win32 one has to start <tt>"repairAyam.tcl"</tt> from the Ayam console
using the command:
<tscreen>
source scripts/repairAyam.tcl
</tscreen>
or via the consoles context menu: <tt>"Console/Load File"</tt>.
<p>
The script <tt>"repairAyam.tcl"</tt> should be considered a
<em>last resort</em> to help saving the current state of
modified objects.
<p>
The script will close all views, clean up the application state variables,
reset the mouse cursor and the console prompt, and try to update important
main window widgets.
<p>
Furthermore, the script will also clear the console and
try to break potential endless loops running e.g.~in the console or
in script objects.
<footnote>Since 1.9.</footnote>
<p>
After running <tt>"repairAyam.tcl"</tt> the scene (or the most
important objects currently worked on) should be immediately
saved to a new scene file, <em>not</em> the file currently loaded,
using <tt>"File/Save As"</tt> or
<tt>"Special/Save Selected"</tt>) and Ayam should be restarted
afterwards.
<p>
Simply saving the scene using <tt>"File/Save"</tt> or <tt/&lt;Ctrl+s&gt;/
should be avoided because views were possibly deleted.

<sect2>Convert Everything to Polygons<label id="topolytcl">
<p>
The script <tt>"topoly.tcl"</tt>
recursively browses through the scene and converts everything
to a polygonal representation.
<footnote>Since 1.13.</footnote>
<p>
After running the script, there is a new button in the toolbox
named <tt>"ToPolyMesh"</tt>. Additionally, there is a corresponding
entry in the <tt>"Custom"</tt> main menu.
Pressing the button or using the menu entry immediately starts the
conversion process.
<p>
Since the changes of the conversion can not be undone, the conversion
will not run if the scene contains unsaved changes.
<p>
The conversion will use the current parameters from the preference settings
<tt/"SMethod"/, <tt/"SParamU"/, and <tt/"SParamV"/; <tt/"TP"/
tags (if present) will override these parameters.
TP tags may be created easily using the tesselation tool, see also
section <ref id="tesst" name="Tesselation Tool">.

<sect2>Convert Everything to NURBS patches<label id="tonpatchtcl">
<p>
The script <tt>"tonpatch.tcl"</tt>
recursively browses through the scene and converts everything
to a NURBS patch representation effectively flattening the tool object
hierarchy.
<footnote>Since 1.14.</footnote>
<p>
After running the script, there is a new button in the toolbox
named <tt>"ToNPatch"</tt>. Additionally, there is a corresponding
entry in the <tt>"Custom"</tt> main menu.
Pressing the button or using the menu entry immediately starts the
conversion process.
<p>
Since the changes of the conversion can not be undone, the conversion
will not run if the scene contains unsaved changes.

<sect2>Restrict the Console<label id="twolconstcl">
<p>
The script <tt>"2lcons.tcl"</tt> (for two line console) may be
used to restrict the screen space occupied by the console.
<p>
Normally, the Ayam console is resized with the main window and
occupies a varying amount of screen space.
After running the script, the console will always resize to exactly
two lines of text. Different values may be chosen easily by adapting the
script.

<sect2>Color the Focus Ring<label id="colfocustcl">
<p>
The script <tt>"colfocus.tcl"</tt> (for colored focus) may be
used to paint the focus ring in a more visible color.
<p>
After running the script, the focus ring will be painted in blue
(instead of black): focussed sub-windows (views, console, object
tree) will be more easily recognizable.

<sect2>Automatic About Center Actions<label id="aactcl">
<p>
The script <tt>"aac.tcl"</tt> (for automatic about center) may be
used to switch all modelling actions to their about variants with
the mark set to the center of the current selection automatically.
<p>
After running the script, invoking e.g.~the scale 2D action using
the shortcut <tt/&lt;s&gt;/ will:
<itemize>
<item>if the modelling mode is object,
<enum>
<item>set the mark to the center of all selected objects
<item>invoke the about variant of scale 2D
</enum>
(this is the equivalent of <tt/&lt;sac&gt;/)
<item>if the modelling mode is point,
<enum>
<item>set the mark to the center of all selected points
<item>invoke the about variant of scale 2D
</enum>
(this is the equivalent of <tt/&lt;saC&gt;/)
</itemize>

The script modifies all rotate and scale actions (including their axis
confined variants).
<p>
Note, that the mark is not reset to a new center, when the selection
changes. After a selection change (e.g.~by selecting points in a
different view) simply restart the action to transform about the
new center.
<p>
To rotate or scale about a different point than the center, the mark
may still be set manually using <tt/&lt;a&gt;/.
<p>
To temporarily disable the modified behavior, the global keyboard
shortcut <tt/&lt;F11&gt;/ can be used.

<sect2>Automatic Point Actions<label id="apnttcl">
<p>
The script <tt>"apnt.tcl"</tt> (for automatic point) may be
used to switch the modelling mode of the current or all views
to point modelling automatically after a point selection.
<p>
After running the script, selecting (tagging) a point using the
select point action (shortcut <tt/&lt;t&gt;/) will automatically
switch the view to point modelling so that the next modelling
actions (e.g.~move, via shortcut <tt/&lt;m&gt;/) will always
transform the points and not modify the objects transformations.
Note that currently the switch to point modelling will also occur,
if no points are actually selected, it is just the mouse click that
counts.
<p>
Selecting all points via the keyboard shortcut <tt/&lt;A&gt;/
will switch to point modelling and de-selecting all points via
<tt/&lt;N&gt;/ will switch to object modelling.
<footnote>Since 1.21.</footnote>
<p>
It is also still possible to switch back to object modelling anytime
via the keyboard shortcut <tt/&lt;o&gt;/.
<p>
To temporarily disable the modified behavior, the global keyboard
shortcut <tt/&lt;F12&gt;/ can be used.

<sect2>Use Ayam as Command Line Converter<label id="bgconverttcl">
<p>
The external Tcl script <tt>"bgconvert.tcl"</tt>
converts scene files from one 3D file format to another,
with the help of Ayam which is running in the background.
<footnote>Since 1.15.</footnote>
<p>
In the most simple form, bgconvert may be used from a Unix command line
(or shell script) like this:
<code>
bgconvert.tcl infile.x3d outfile.dxf
</code>
The above command would load the X3D file <tt>"infile.x3d"</tt>
into Ayam and export the scene as DXF file to <tt>"outfile.dxf"</tt>.
<p>
For a successfull conversion Ayam has to run and the plugins required
for the import and export processes need to be available and properly
configured (check the <tt>"Plugins"</tt> preference setting).
The plugins necessary for the conversion will be loaded automatically.
<p>
Import and export options may also be given like this:
<code>
bgconvert.tcl "infile.rib -p 1" outfile.dxf
</code>
In the example above the <tt>"-p 1"</tt> option switches on reading
of partial RIB files.
Available options and their syntax may be inquired from the
import and export plugin Tcl scripts (e.g.~<tt>"plugins/rrib.tcl"</tt>).

<sect2>Access Core Functions from the Toolbox<label id="zaptcl">
<p>
The script <tt>"zap.tcl"</tt> demonstrates, how arbitrary core
functionality that is just available through a main menu entry
or the scripting interface might be accessed easily via the
toolbox window.
<p>
After running the script <tt>"zap.tcl"</tt>, there will be a new
toolbox button, labeled <tt>"Zap!"</tt>, that simply runs the zap
command (which iconifies the complete application).

<sect2>Switch File Dialogs to Kdialog<label id="kdialogtcl">
<p>
The script <tt>"kdialog.tcl"</tt> switches all file dialogs of
Ayam to use the kdialog application of the KDE project instead
of the native Tk file dialog.

<sect2>Switch File Dialogs to Zenity<label id="zdialogtcl">
<p>
The script <tt>"zdialog.tcl"</tt> switches all file dialogs of
Ayam to use the zenity application of the Gnome project instead
of the native Tk file dialog.

<sect2>Use Aqsis from Application Directory<label id="useaqsisapptcl">
<p>
The script <tt>"useaqsisapp.tcl"</tt> sets up Ayam to use Aqsis
from the application directory structure (<tt>"/Applications/Aqsis.app"</tt>)
on Mac OS X. This is the default installation location of Aqsis on Mac OS X.
<p>
The script adapts the executable and shader search paths.
Furthermore, environment variables vital for Aqsis to work will
be set up properly.
<p>
Note that the script does not change the <tt>"RIB-Export/Renderer"</tt>
preferences, you still have to switch to Aqsis using the main menu
<tt>"Special/Select Renderer"</tt> once.

<sect2>Use Pixie from Library Directory<label id="usepixietcl">
<p>
The script <tt>"usepixie.tcl"</tt> sets up Ayam to use Pixie
from the <tt>"/Library/pixie"</tt> directory on Mac OS X.
This is the default installation location of Pixie on Mac OS X.
<p>
The script adapts the executable, shared library, and shader search paths.
Furthermore, environment variables vital for Pixie to work will
be set up properly.
<p>
Note that the script does not change the <tt>"RIB-Export/Renderer"</tt>
preferences, you still have to switch to Pixie using the main menu
<tt>"Special/Select Renderer"</tt> once.

<#if out=latex><x/newpage/</#if>

<sect2>Create Polyhedrons from Conway Notations<label id="polyhedronjs">
<p>
<figure loc="ht">
<eps file="pics/polyh-jtD.ps" height="5cm">
<img src="pics/polyh-jtD.gif">
<caption>Polyhedron generated from Conway notation: jtD</caption>
</figure>
<p>
Since Ayam 1.18 there is a complete example script for the JavaScript
scripting interface distributed as <tt>"polyhedron.js"</tt> which
creates polyhedrons from Conway notations.
The script is based on the online Polyhedron VRML generator by
George W. Hart.
<p>
This script must be used in a Script object of type <tt/"Create"/.
For convenience, there is also a property GUI; one must add a <tt/"NP"/ tag
of value <tt/"PolyhedronAttr"/ to the script object to see it.
<p>
The Conway notation defines a set of operations executed consecutively
on a seed/basic shape.
The script currently supports the following seeds and operations
(information taken from George W. Harts fine web pages,
see also section <ref id="secref" name="References">).
<p>
<bf/Seeds:/<newline>
The Platonic solids are denoted T, O, C, I, and D, according to their
first letter. Other polyhedra which are implemented here include prisms:
Pn, antiprisms: An, and pyramids: Yn, where n is a number (3 or greater)
which must be specified to indicate the size of the base, e.g.,
Y3=T, P4=C, and A3=O.
<p>
<bf/Operations:/<newline>
Currently, d, t, k, a, j, s, g, e, b, o, m, r, and p are defined.
They are motivated by the operations needed to create the Archimedean
solids and their duals from the Platonic solids. The following tables
explain the operations in more detail:

<table loc="p">
<#if out=latex><tabular ca="|c|p{1.5cm}|p{11cm}|"><hline></#if><#unless out=latex><tabular ca="|c|c|c|"><hline></#unless>
<bf/Letter/|<bf/Name/|<bf/Description/@<hline>
<tt/d/|dual|The dual of a polyhedron has a vertex for each face, and a face for each vertex, of the original polyhedron, e.g.~dC=O.@<hline>
<tt/t/&thinsp;/&thinsp;<tt/t/<em/n/|truncate all&thinsp;/&thinsp;just <em/n/-fold vertices|Truncating a polyhedron cuts off each vertex, producing a new <em/n/-sided face for each <em/n/-fold vertex.@<hline>
<tt/k/&thinsp;/&thinsp;<tt/k/<em/n/|kis all&thinsp;/&thinsp;just <em/n/-sided faces|The kis operation divides each <em/n/-sided face into <em/n/ triangles. A new vertex is added in the center of each face.@<hline>
<tt/a/|ambo|The ambo operation can be thought of as truncating to the edge midpoints. It produces a polyhedron, aX, with one vertex for each edge of X.@<hline>
<tt/j/|join|The join operator is dual to ambo, so jX=dadX=daX. jX is like kX without the original edges of X.@<hline>
<tt/e/|expand|Each face of X is separated from all its neighbors and reconnected with a new 4-sided face, corresponding to an edge of X. An n-gon is then added to connect the 4-sided faces at each n-fold vertex.@<hline>
<tt/s/|snub|The snub operation can be thought of as eC followed by the operation of slicing each of the new 4-fold faces along a diagonal into two triangles. With a consistent handedness to these cuts, all the vertices of sX are 5-fold.@<hline>
<tt/g/|gyro|The dual operation to s is g. g is like k but with the new edges connecting the face centers to the 1/3 points on the edges rather than the vertices.@<hline>
<tt/b/|bevel|The bevel operation can be defined by bX=taX.@<hline>
<tt/o/|ortho|Dual to e, oX=deX=jjX. oX has the effect of putting new vertices in the middle of each face of X and connecting them, with new edges, to the edge midpoints of X.@<hline>
<tt/m/|meta|Dual to b, m is like k and o combined; new edges connect new vertices at the face centers to the old vertices and new vertices at the edge midpoints.<#if out=latex>@<hline></#if>
</tabular>
<caption>Conway Notation Operations</caption>
</table>

<table loc="p">
<#if out=latex><tabular ca="|c|p{1.5cm}|p{11cm}|"><hline></#if><#unless out=latex><tabular ca="|c|c|c|"><hline></#unless>
<bf/Letter/|<bf/Name/|<bf/Description/@<hline>
<tt/r/|reflect|Changes a left-handed solid to right handed, or vice versa, but has no effect on a reflexible solid. So rC=C, but compare sC and rsC.@<hline>
<tt/p/|propellor|Makes each n-gon face into a "propellor" of an n-gon surrounded by n quadrilaterals, e.g.~pT is the tetrahedrally stellated icosahedron. Try pkD and pt6kT. p is a self-dual operation, i.e., dpdX=pX and dpX=pdX, and p also commutes with a and j, i.e.~paX=apX.<#if out=latex>@<hline></#if>
</tabular>
<caption>Additional Operations</caption>
</table>

These abbreviated explanations were again taken from George W. Hart.

<#if out=latex><x/newpage/</#if>

<sect1>JavaScript Scripting Interface<label id="jsinterp">
<p>
This sections contains the documentation of the JavaScript scripting
interface which is available after loading of the <tt>"jsinterp"</tt>
plugin.
<p>
The JavaScript scripting interface exists since Ayam 1.18 and
is based on the Mozilla SpiderMonkey JavaScript engine.
<p>
Upon loading, the <tt>"jsinterp"</tt> plugin creates <em>one</em> JavaScript
context that lives (with all variables and objects defined therein)
until Ayam exits.

<sect2>Accessing JavaScript from Tcl and Script Objects
<p>
To access the JavaScript functionality from the Tcl scripting interface,
the <tt>"jsEval"</tt> command can be used to directly execute JavaScript
code (Tcl code in <bf>bold</bf>):
<tscreen>
<tt><bf>jsEval {</bf>var a = 0; a = a + 5.5; tclset("a", a);<bf>}</bf></tt>
</tscreen>
or from a file:
<tscreen>
<tt><bf>jsEval -f scriptfile.js</bf></tt>
</tscreen>
Furthermore, Script object scripts may also be implemented in JavaScript,
provided the first line of the script is a comment that instructs Ayam to
use the JavaScript interpreter:
<tscreen><tt>
/* Ayam, use: JavaScript */<newline>
var a = 0;<newline>
...
</tt></tscreen>
Note that the JavaScript scripting context inherits the limitations
of the calling Tcl context.
For example, when running in a Script object,
the following code fails:
<tscreen>
<tt>tcleval("<bf>exit</bf>");</tt>
</tscreen>
it does not fail, when the calling context ist the main Tcl interpreter;
one can e.g.~type into the Ayam console:
<tscreen>
<tt><bf>jsEval {</bf>tcleval("<bf>exit</bf>");<bf/}/</tt>
</tscreen>
and Ayam quits (see also section:
<ref id="safeinterp" name="Safe Interpreter">).

<sect2>JavaScript Functions
<p>
This subsection informs about the global functions additionally
available in the Ayam JavaScript interpreter.
<p>
Those are converted Tcl commands, <tt>"tcleval"</tt>, <tt>"tclvar"</tt>,
and <tt>"tclset"</tt>.
<p>
The functionality of Ayam is accessible from JavaScript via a larger
set of global functions, named as the corresponding Tcl commands.
One may e.g.~create Ayam objects in JavaScript using a function call
like this:
<tscreen><tt>
crtOb("NCircle");
</tt></tscreen>
or, with additional arguments:
<tscreen><tt>
crtOb("NCircle", "-radius", 3.0);
</tt></tscreen>
In general, all commands available in the safe Ayam Tcl interpreter are also
available as converted function (refer to section
<ref id="sccomm" name="Index of Procedures and Commands">
for a more or less complete list of those commands).
<p>
Note that many Tcl procedures are not available as global JavaScript
function, but they can be called using <tt>"tcleval"</tt> as documented
in the next paragraph.

<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tcleval://<label id="tcleval"><newline>
Apart from Tcl commands converted to JavaScript functions, there is the
global JavaScript function <tt>"tcleval"</tt>, that allows to evaluate
arbitrary Tcl scripts:
<tscreen><tt>
var a = 42;<newline>
a = tcleval("<bf>puts </bf>" + a + "<bf>; return 5;</bf>");<newline>
tcleval("<bf>puts </bf>" + a);<newline>
/* expected output: 42 5 */
</tt></tscreen>
The <tt>"tcleval"</tt> function provides access to all the
functionality of Ayam that is just available as a Tcl procedure.
Note that return values are properly transferred back to JavaScript
according to the rules for data conversion as documented below.

<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tclvar://<label id="tclvar"><newline>
Using the JavaScript function <tt>"tclvar"</tt> one may establish a
link between a Tcl variable and a corresponding variable in the
JavaScript context.
The <tt>"tclvar"</tt> function establishes a write trace on the Tcl
variable, so that changes on the Tcl side are always automatically
reflected on the JavaScript side:
<tscreen><tt>
tclvar("a");<newline>
tcleval("<bf>set a 42</bf>");<newline>
tcleval("<bf>puts </bf>" + a);<newline>
/* expected output: 42 */
</tt></tscreen>
Mind that the corresponding variable on the JavaScript side does
<em>not</em> exist until the first write operation on the Tcl variable
occurs.
The Tcl variable, in turn, does not have to exist, when the
<tt>"tclvar"</tt> function is called (i.e.~all the work is done
in the trace callback).
<p>
Even though it looks a perfect fit, <tt/"tclvar"/ can not be used to
manage a property data array. Atleast not if the array contains components
to be saved to Ayam scene files. This is, because upon reading a scene
file with such saved array items, the items will be read (and put into
the Tcl context) before the script can establish the write trace using
<tt/"tclvar"/ and the data from the scene file never arrives in the JavaScript
context.
There is no easy way to get around this.
A suggested way to manage a property data array is shown in the
complete examples section below.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tclset://<label id="tclset"><newline>
The third global JavaScript function is <tt>"tclset"</tt> that
allows to efficiently set Tcl variables from the JavaScript context
avoiding conversion to string data and back.
For example:
<tscreen><tt>
var a = 3.3;<newline>
var b = new Array(1, 3, 5);<newline>
tclset("a", a);<newline>
tclset("b", b);
</tt></tscreen>
sets the Tcl variable <tt>"a"</tt> to the floating point value 3.3,
and <tt>"b"</tt> to a list of integer values (<tt>"{ 1 3 5 }"</tt>).
Note that the variable names may also point to Tcl array elements:
<tt>"tclset("SphereAttrData(Radius)", 1.2);"</tt>
or contain name-space specifiers
<tt>"tclset("::MyNameSpace::Radius", 1.2);"</tt>
.

<sect2>Data Conversion
<p>
When data is transferred from the Tcl to the JavaScript side
(e.g.~while converting return values of <tt/"tcleval"/ or variable
values linked via <tt/"tclvar"/),
the following conversions are in effect:
Scalar data types will be converted to their directly matching counterparts,
except for Booleans, which will be converted to integer values.
Lists will be converted to Array objects (nesting is allowed and will
produce accordingly nested arrays).
Associative arrays will be converted to objects with named properties.
Unicode strings are currently not supported.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/Tcl/|<bf/JavaScript/@<hline>
Boolean (true, false)|Integer (1, 0)@<hline>
Integer (2)|Integer (2)@<hline>
Double (3.14)|Double (3.14)@<hline>
String ("mystr")|String ("mystr")@<hline>
List ({0 1 2})|Array ((0, 1, 2))@<hline>
Array (mya(mye) = 0.1)|Object (mya.mye = 0.1)<#if out=latex>@<hline></#if>
</tabular>
<caption>Tcl to JavaScript Data Conversions</caption>
</table>

When data is transferred from the JavaScript side to the Tcl side
(e.g.~as function argument), the following conversions are in
effect:
Scalar data types will be converted to their directly matching counterparts,
Array objects will be converted to lists (nesting is allowed and will
produce accordingly nested lists).
Unicode strings and objects of a type other than Array (e.g.~Boolean) are
currently not supported.
See also the following table.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/JavaScript/|<bf/Tcl/@<hline>
Integer (2)|Integer (2)@<hline>
Double (3.14)|Double (3.14)@<hline>
String ("mystr")|String ("mystr")@<hline>
Array ((0, 1, 2))|List ({0 1 2})<#if out=latex>@<hline></#if>
</tabular>
<caption>JavaScript to Tcl Data Conversions</caption>
</table>
<p>
The transport/conversion of object properties (to e.g.~associative array
elements) can be arranged manually like this:
<tscreen><tt>
var a = new Object();<newline>
a.b = 3.14;<newline>
tclset("a(b)", a.b);
</tt></tscreen>

<#if out=latex><x/newpage/</#if>

<sect2>Complete Examples
<p>
This section contains two complete examples for Script objects
written in JavaScript.
<p>
For the first example use Script object type <tt/"Modify"/ and put a Sphere
as child object of the Script object.
<code>
/* Ayam, use: JavaScript */
tclvar("SphereAttrData");
getProp();
if(SphereAttrData)
{
  tclset("SphereAttrData(ZMin)", -SphereAttrData.Radius);
  tclset("SphereAttrData(ZMax)", SphereAttrData.Radius);
  setProp();
}
</code>
The above script will make sure, that the ZMin and ZMax parameters of
the Sphere object always match its radius.

First, a link from the original Sphere object property data array
<tt/"SphereAttrData"/ is established, so that when <tt/"getProp()"/
(a converted Tcl Ayam command) is called, also the JavaScript
object <tt/"SphereAttrData"/ is filled with meaningful data.
The next line (the if) is a safety measure that prevents the script from
failing if the child object of the Script object is not a Sphere
object.
Now the radius value is transferred back to Tcl directly into
the property data array to the ZMin and ZMax entries respectively
with the help of <tt/"tclset"/.
Finally the modified property is transferred back to the Sphere object
again with a converted Tcl Ayam command <tt/"setProp()"/.

<#if out=latex><x/newpage/</#if>

The next example shows, how to manage a property GUI in a JavaScript
implemented Script object script. Use Script object type <tt/"Create"/
and add a tag <tt/"NP MyProp"/ to see the property GUI.
<code>
/* Ayam, use: JavaScript, save array: MyPropData */
var MyPropData = new Object();
if(!tcleval("info exists MyPropData;"))
{
  /* initial script run (but not when loaded from scene file!) */
  MyPropData.MyItem = tcleval("set MyPropData(MyItem) 1.0;");
  tcleval("set MyPropData(SP) {MyItem};");
}
else
{
  /* all following script runs (and also when loaded from scene file!) */
  MyPropData.MyItem = tcleval("set MyPropData(MyItem);");
}
if(!tcleval("info exists MyPropGUI;"))
{
  tcleval("set ::phw [addPropertyGUI MyProp \"\" \"\"];");
  tcleval("addParam $::phw MyPropData MyItem;");
}
crtOb("Sphere");
sL();
getProp();
tclset("SphereAttrData(Radius)", MyPropData.MyItem);
tclset("SphereAttrData(ZMin)", -MyPropData.MyItem);
tclset("SphereAttrData(ZMax)", MyPropData.MyItem);
setProp();
</code>

This example demonstrates how to manage property data using the
JavaScript object variable <tt/"MyPropData"/. The property data
can be saved to and read from Ayam scene files with the help of
a mirroring array variable on the Tcl side (also named
<tt/"MyPropData"/).
To make this work properly, the initialisation of the JavaScript
object must be constrained to the first script run: when the
property data was read from a scene file, initialisation must
not be run, instead the read data must be fetched from the Tcl
context.
This is what the first <tt/"if"/ statement, checking for existence
of the mirroring Tcl array variable, in above example is all about.
<p>
Following this scheme of dual mirroring data structures on the
Tcl and Javascript sides now follows the creation of the
property GUI which is also constrained to just one script run
by an <tt/"if"/ statement.
<p>
Following the GUI, a sphere object is created and parameterized
according to the data in the property GUI, which is used as
radius, zmin, and zmax value.

<sect1>Lua Scripting Interface<label id="luainterp">
<p>
This sections contains the documentation of the Lua scripting
interface which is available after loading of the <tt>"luainterp"</tt>
plugin.
<footnote>Since 1.21.</footnote>
<p>
Upon loading, the <tt>"luainterp"</tt> plugin creates <em>one</em> Lua
context that lives (with all variables and objects defined therein)
until Ayam exits.

<sect2>Accessing Lua from Tcl and Script Objects
<p>
To access the Lua functionality from the Tcl scripting interface,
the <tt>"luaEval"</tt> command can be used to directly execute Lua
code (Tcl code in <bf>bold</bf>):
<tscreen>
<tt><bf>luaEval {</bf>a = 0; a = a + 5.5; tclset("a", a);<bf>}</bf></tt>
</tscreen>
or from a file:
<tscreen>
<tt><bf>luaEval -f scriptfile.lua</bf></tt>
</tscreen>
Furthermore, Script object scripts may also be implemented in Lua,
provided the first line of the script is a comment that instructs Ayam to
use the Lua interpreter:
<tscreen><tt>
<f/--/ Ayam, use: Lua<newline>
a = 0;<newline>
...
</tt></tscreen>
Note that the Lua scripting context inherits the limitations
of the calling Tcl context.
For example, when running in a Script object,
the following code fails:
<tscreen>
<tt>tcleval("<bf>exit</bf>");</tt>
</tscreen>
it does not fail, when the calling context ist the main Tcl interpreter;
one can e.g.~type into the Ayam console:
<tscreen>
<tt><bf>luaEval {</bf>tcleval("<bf>exit</bf>");<bf/}/</tt>
</tscreen>
and Ayam quits (see also section:
<ref id="safeinterp" name="Safe Interpreter">).

<sect2>Lua Functions
<p>
This subsection informs about the global functions additionally
available in the Ayam Lua interpreter.
<p>
Those are converted Tcl commands, <tt>"tcleval"</tt>, <tt>"tclvar"</tt>,
and <tt>"tclset"</tt>.
<p>
The functionality of Ayam is accessible from Lua via a larger
set of global functions, named as the corresponding Tcl commands.
One may e.g.~create Ayam objects in Lua using a function call
like this:
<tscreen><tt>
crtOb("NCircle");
</tt></tscreen>
or, with additional arguments:
<tscreen><tt>
crtOb("NCircle", "-radius", 3.0);
</tt></tscreen>
In general, all commands available in the safe Ayam Tcl interpreter are also
available as converted function (refer to section
<ref id="sccomm" name="Index of Procedures and Commands">
for a more or less complete list of those commands).
<p>
Note that Tcl procedures are not available as global Lua function,
but they can be called using <tt>"tcleval"</tt> as documented
in the next paragraph.

<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tcleval://<label id="luatcleval"><newline>
Apart from Tcl commands converted to Lua functions, there is the
global Lua function <tt>"tcleval"</tt>, that allows to evaluate
arbitrary Tcl scripts:
<tscreen><tt>
a = 42;<newline>
a = tcleval("<bf>puts </bf>" ..&ensp;a ..&ensp;"<bf>; return 5;</bf>");<newline>
tcleval("<bf>puts </bf>" ..&ensp;a);<newline>
<f/--/ expected output:&ensp;42 5
</tt></tscreen>
The <tt>"tcleval"</tt> function provides access to all the
functionality of Ayam that is just available as a Tcl procedure.
Note that return values are properly transferred back to Lua
according to the rules for data conversion as documented below.

<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tclvar://<label id="luatclvar"><newline>
Using the Lua function <tt>"tclvar"</tt> one may establish a
link between a Tcl variable and a corresponding variable in the
Lua context.
The <tt>"tclvar"</tt> function establishes a write trace on the Tcl
variable, so that changes on the Tcl side are always automatically
reflected on the Lua side:
<tscreen><tt>
tclvar("a");<newline>
tcleval("<bf>set a 42</bf>");<newline>
tcleval("<bf>puts </bf>" ..&ensp;a);<newline>
<f/--/ expected output:&ensp;42
</tt></tscreen>
Mind that the corresponding variable on the Lua side does
<em>not</em> exist until the first write operation onto the Tcl
variable occurs.
The Tcl variable, in turn, does not have to exist, when the
<tt>"tclvar"</tt> function is called (i.e.~all the work is done
in the trace callback).
<p>
Even though it looks a perfect fit, <tt/"tclvar"/ can not be used to
manage a property data array. Atleast not if the array contains components
to be saved to Ayam scene files. This is, because upon reading a scene
file with such saved array items, the items will be read (and put into
the Tcl context) before the script can establish the write trace using
<tt/"tclvar"/ and the data from the scene file never arrives in the Lua
context.
There is no easy way to get around this.
A suggested way to manage a property data array is shown in the
complete examples section below.

<#if out=latex><x/newpage/</#if>
<#if out=latex><x/phantomsection/</#if>

<tt/<bf/tclset://<label id="luatclset"><newline>
The third global Lua function is <tt>"tclset"</tt> that
allows to efficiently set Tcl variables from the Lua context
avoiding conversion to string data and back.
For example:
<tscreen><tt>
a = 3.3;<newline>
b = {1, 3, 5};<newline>
tclset("a", a);<newline>
tclset("b", b);
</tt></tscreen>
sets the Tcl variable <tt>"a"</tt> to the floating point value 3.3,
and <tt>"b"</tt> to a list of integer values (<tt>"{ 1 3 5 }"</tt>).
Note that the variable names may also point to Tcl array elements:
<tt>"tclset("SphereAttrData(Radius)", 1.2);"</tt>
or contain name-space specifiers
<tt>"tclset("::MyNameSpace::Radius", 1.2);"</tt>
.

<sect2>Data Conversion
<p>
When data is transferred from the Tcl to the Lua side
(e.g.~while converting return values of <tt/"tcleval"/ or variable
values linked via  <tt/"tclvar"/),
the following conversions are in effect:
Scalar data types will be converted to their directly matching counterparts.
Lists will be converted to array-tables (nesting is allowed and will
produce accordingly nested tables).
Associative arrays will be converted to tables with properly named keys.
Unicode strings are currently not supported.
See also the table below.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/Tcl/|<bf/Lua/@<hline>
Boolean (true, false)|Boolean (true, false)@<hline>
Integer (2)|Integer (2)@<hline>
Double (3.14)|Double (3.14)@<hline>
String ("mystr")|String ("mystr")@<hline>
List ({0 1 2})|Array ({0, 1, 2})@<hline>
Array (mya(mye) = 0.1)|Table (mya.mye = 0.1)<#if out=latex>@<hline></#if>
</tabular>
<caption>Tcl to Lua Data Conversions</caption>
</table>

When data is transferred from the Lua side to the Tcl side
(e.g.~as function argument), the following conversions are in
effect:
Scalar data types will be converted to their directly matching counterparts,
array-tables will be converted to lists (nesting is allowed and will
produce accordingly nested lists). Sparse and mixed tables are currently not
supported.
Unicode strings are also currently not supported.
See also the following table.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/Lua/|<bf/Tcl/@<hline>
Boolean (true, false)|Boolean (true, false)@<hline>
Integer (2)|Integer (2)@<hline>
Double (3.14)|Double (3.14)@<hline>
String ("mystr")|String ("mystr")@<hline>
Array ({0, 1, 2})|List ({0 1 2})<#if out=latex>@<hline></#if>
</tabular>
<caption>Lua to Tcl Data Conversions</caption>
</table>
<p>
The transport/conversion of table entrys (to e.g.~associative array
elements) can be arranged manually like this:
<tscreen><tt>
a.b = 3.14;<newline>
tclset("a(b)", a.b);
</tt></tscreen>

<#if out=latex><x/newpage/</#if>

<sect2>Complete Examples
<p>
This section contains two complete examples for Script objects
written in Lua.
<p>
For the first example use Script object type <tt/"Modify"/ and put a Sphere
as child object of the Script object.
<code>
-- Ayam, use: Lua
tclvar("SphereAttrData");
getProp();
if(SphereAttrData)
{
  tclset("SphereAttrData(ZMin)", -SphereAttrData.Radius);
  tclset("SphereAttrData(ZMax)", SphereAttrData.Radius);
  setProp();
}
</code>
The above script will make sure, that the ZMin and ZMax parameters of
the Sphere object always match its radius.

First, a link from the original Sphere object property data array
<tt/"SphereAttrData"/ is established, so that when <tt/"getProp()"/
(a converted Tcl Ayam command) is called, also the Lua
object <tt/"SphereAttrData"/ is filled with meaningful data.
The next line (the if) is a safety measure that prevents the script from
failing if the child object of the Script object is not a Sphere
object.
Now the radius value is transferred back to Tcl directly into
the property data array to the ZMin and ZMax entries respectively
with the help of <tt/"tclset"/.
Finally the modified property is transferred back to the Sphere object
again with a converted Tcl Ayam command <tt/"setProp()"/.

<#if out=latex><x/newpage/</#if>

The next example shows, how to manage a property GUI in a Lua
implemented Script object script. Use Script object type <tt/"Create"/
and add a tag <tt/"NP MyProp"/ to see the property GUI.
<code>
-- Ayam, use: Lua, save array: MyPropData
if(!tcleval("info exists MyPropData;"))
{
  -- initial script run (but not when loaded from scene file!)
  MyPropData.MyItem = tcleval("set MyPropData(MyItem) 1.0;");
  tcleval("set MyPropData(SP) {MyItem};");
}
else
{
  -- all following script runs (and also when loaded from scene file!)
  MyPropData.MyItem = tcleval("set MyPropData(MyItem);");
}
if(!tcleval("info exists MyPropGUI;"))
{
  tcleval("set ::phw [addPropertyGUI MyProp \"\" \"\"];");
  tcleval("addParam $::phw MyPropData MyItem;");
}
crtOb("Sphere");
sL();
getProp();
tclset("SphereAttrData(Radius)", MyPropData.MyItem);
tclset("SphereAttrData(ZMin)", -MyPropData.MyItem);
tclset("SphereAttrData(ZMax)", MyPropData.MyItem);
setProp();
</code>

This example demonstrates how to manage property data using the
Lua object variable <tt/"MyPropData"/. The property data
can be saved to and read from Ayam scene files with the help of
a mirroring array variable on the Tcl side (also named
<tt/"MyPropData"/).
To make this work properly, the initialisation of the Lua
object must be constrained to the first script run: when the
property data was read from a scene file, initialisation must
not be run, instead the read data must be fetched from the Tcl
context.
This is what the first <tt/"if"/ statement, checking for existence
of the mirroring Tcl array variable, in above example is all about.
<p>
Following this scheme of dual mirroring data structures on the
Tcl and Lua sides now follows the creation of the
property GUI which is also constrained to just one script run
by an <tt/"if"/ statement.
<p>
Following the GUI, a sphere object is created and parameterized
according to the data in the property GUI, which is used as
radius, zmin, and zmax value.

<sect>Import and Export<label id="impex">
<p>
This section contains the documentation of all import and export
modules of Ayam.

<sect1>Import and Export Plugin Management<label id="impexpl">
<p>
Except for RIB export, all import/export modules of Ayam
are plugins that need to be loaded into the application before possible
usage.
Loading of an import/export plugin may be done in three different ways:
<enum>
<item><em>explicitly</em> via the main menu entry <tt>"File/Load Plugin"</tt>,
<item><em>automatically</em> on application startup via a script (by adding
e.g.~<tt>"plugins/loaddxfio.tcl"</tt> to the <tt>"Scripts"</tt> preference
setting),
<item><em>implicitly</em> via normal scene IO.
<p>
Implicit loading means one can simply use the main menu entries
<tt>"File/Open"</tt> and <tt>"File/Save as"</tt> (or the corresponding
keyboard shortcuts) and specify a filename with the appropriate
extension (e.g.~<tt/".dxf"/).
<footnote>Since 1.13.</footnote>
Ayam will automatically load the matching plugin
(<tt/"dxfio"/) and open the import (or export) options dialog with
the <tt/"FileName"/ option already set to the filename chosen before.
This feature requires that the
<tt/"Plugins"/ preferences are correctly set.
</enum>

<sect1>Import and Export Plugin Overview<label id="impexft">
<p>
The following table lists the Ayam features supported by the various
import plugins.

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Feature/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>

Quadrics|Yes|No|Yes|No|Yes|Yes@<hline>

Trimmed NURBS|Yes|Yes|Yes|No|Yes|Yes@<hline>

Parametrics|No|No|No|No|No|Yes@<hline>

Curves|No|Yes|Yes|Yes|Yes|Yes@<hline>

Transformations|Yes|No|Yes|No|No|Yes@<hline>

Hierarchy|Yes|No|Yes|No|No|Yes@<hline>

Instances|Yes|No|No|No|No|No@<hline>

CSG|Yes|No|No|No|No|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Ayam Features Supported by Various Import Plugins</caption>
</table>

Not all features of Ayam are supported in the various export
options. The following table gives an overview of the supported
features per export file format.

<#if out=latex><x/newpage/</#if>

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Feature/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>

Quadrics|Yes|No<f><sup>a</sup></f>|Some<f><sup>d</sup></f>|No<f><sup>b</sup></f>|Some<f><sup>d</sup></f>|Some<f><sup>d</sup></f>@<hline>

Trimmed NURBS|Yes|Yes|Yes|No<f><sup>b</sup></f>|Yes|Yes<f><sup>c</sup></f>@<hline>

Parametrics|No<f><sup>a</sup></f>|No<f><sup>a</sup></f>|No<f><sup>a</sup></f>|No<f><sup>b</sup></f>|No<f><sup>a</sup></f>|Some<f><sup>e</sup></f>@<hline>

Curves|No|Yes|Yes|Yes|Yes|Yes@<hline>

Transformations|Yes|No|Yes|No|No|Yes@<hline>

Hierarchy|Yes|No|Yes|No|No|Yes@<hline>

Instances|Yes|No|No|No|No|Yes@<hline>

CSG|Yes|No|No|No|No|No<#if out=latex>@<hline></#if>
</tabular>
<caption>Ayam Features Supported by Various Export Formats</caption>
</table>

<quote><#if out=latex>&thinsp;<newline></#if>
<f><sup>a</sup></f>&thinsp;: will be converted to NURBS<newline>
<f><sup>b</sup></f>&thinsp;: will be converted to PolyMeshes<newline>
<f><sup>c</sup></f>&thinsp;: 3D trimcurves exported as PolyLines<newline>
<f><sup>d</sup></f>&thinsp;: some quadrics are converted to NURBS (refer to plugin documentation)<newline>
<f><sup>e</sup></f>&thinsp;: some parametrics are converted to NURBS (refer to plugin documentation)<newline>
</quote>
Note that a successful export of a 3D scene to a different application
not only depends on Ayam but also on the quality of the importing
application. For instance, many applications claim to read files in the
Wavefront OBJ format but only import polygonal data or, even worse, only
triangles from such files. By default, Ayam tries to preserve as much
information as possible in the respective export format leading to the
use of NURBS in Wavefront OBJ files.
Consequently, to successfully transfer an Ayam scene to a different
application, in some cases you may need to convert the NURBS objects in
the Ayam scene to polygonal geometry before export. There is a script
provided that helps you doing this (<tt>"topoly.tcl"</tt>, see also section
<ref id="topolytcl" name="Convert Everything to Polygons">).
<p>
Ayam is not perfect either, as in most import options material and
animation data is completely ignored.
<p>
The following table gives an overview of the file format versions
supported by the various import and export plugins. Import of files
from a different version should be considered unsupported.

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Format/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>
Version|3.0|3.0|1.0|14|3.0|3.1<#if out=latex>@<hline></#if>
</tabular>
<caption>Supported File Format Versions Overview</caption>
</table>

The next sections document the various import and export plugins
in detail.

<sect1>RenderMan Interface Bytestream (RIB) Import<label id="imprib">
<p>
Using the RRIB (for <bf/R/ead <bf/RIB/) plugin you may import RenderMan
Interface Bytestreams of version 3.0 into Ayam.
Start importing a RIB using the menu entry
<tt>"File/Import/RenderMan RIB"</tt>
(if this menu entry is not available, you have to load the
<tt>"rrib"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
<sect2>RIB Primitive Support
<p>
The RRIB plugin supports import of the following geometric
primitives:
<itemize>
<item>Quadrics (Sphere, Disk, Cylinder, Cone, Paraboloid, Hyperboloid, Torus)
<item>bilinear and bicubic patches and patch meshes
<item>NURBS patches (with trim curves)
<item>(general) polygons and (general) polygon meshes
<item>subdivision meshes (with all tags)
</itemize>

Furthermore, the plugin supports reading of CSG, object-instances,
archives, light sources (including area-lights), arbitrary linear
transformations (except shear transformations), arbitrary
RiOptions and RiAttributes, shaders (except transformation
shaders and without array arguments), arbitrary primitive variables
(e.g.~varying or vertex)
<footnote>Since 1.7.</footnote>
, and procedural objects and delayed read archives
<footnote>Since 1.9.</footnote>
.
Texture coordinates will import as TC tags
(see also section <ref id="tctag" name="TC (Texture Coordinates) Tag">).
<p>
The RRIB plugin does not support reading of curves, implicit surfaces
(blobby models) and calls to the RenderMan Interface that are not
so much useful for a RIB import like e.g.~RiMakeTexture.
Unsupported geometric primitives and other calls to the RenderMan Interface
are silently ignored.
<p>
Also note that for NURBS patches and bicubic patch meshes, points of type
"P" will be promoted to "Pw". Points of type "Pz" are not supported
by the plugin. Trimming of NURBS patches by clamping
the knot ranges is also not supported (however, UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values).
<footnote>Since 1.9.</footnote>
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
<p>
Furthermore, objects of type (general) polygon and polygon mesh will
always be promoted to general polygon meshes.
<p>
Object-instances are resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
Procedural objects will not be evaluated, instead, RiProc objects
will be created, that carry all arguments and create the same
sequence of RIB requests upon export as was read upon import.
<p>
Note that in the case of serious syntactic errors of the RIB file
more informative error messages are printed to the stderr channel
of Ayam (which is not redirected to the Ayam console).

<sect2>RIB Import Options<label id="rribopt">
<p>
The RIB import may be controlled via different options:
<itemize>
<item><tt/"ScaleFactor"/, determines a global scale factor to be applied
to all imported objects.
<item><tt/"ReadFrame"/, specifies the number of the frame in the RIB
to read. A value of -1 means, all frames are to be read. If you specify
a frame number and this frame does not show up in the RIB as
<tt/"FrameBegin &lt;yournumber&gt;"/ nothing will be
imported.
<item><tt/"ReadCamera"/: if this is switched on, a Camera object will
be created when the RIB plugin encounters a <tt/"WorldBegin"/. You may drag
this camera object onto a perspective View object in Ayam after import
to see through the camera of the imported RIB.
<item><tt/"ReadOptions"/, controls whether RiOptions are
to be imported from the RIB to the scene. Note that those
RiOptions will overwrite the current global settings in the Ayam scene.
<item><tt/"ReadLights"/, if this is enabled the lights from the
RIB will be imported.
<item><tt/"ReadMaterial"/, controls whether material objects
are to be created for the imported objects. All material objects
are created in a special level named <tt/"Materials"/ in the top level
of the scene. The plugin tries to keep the number of generated
material objects as low as possible by comparing with already
existing materials in this level. This also works with material
objects that exist before the RRIB plugin is invoked (as long as
they reside in this special level).
<item><tt/"ReadPartial"/, this option is useful if you want to
import partial RIBs (e.g.~archives) that do not
contain a <tt/"WorldBegin"/.
Be careful with this option (i.e.~use it only if reading of a RIB fails),
as it switches reading of all types of objects on, regardless of
the RIB structure.
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are
the only trim curves.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS patches and trim curves so that the distances between different
knots are not smaller than the given value. Using a value of 1.0e-04 leads
to NURBS that may be safely drawn using GLU. The default value 0.0 means
no scaling.
</itemize>

<sect1>RenderMan Interface Bytestream (RIB) Export<label id="exprib">
<p>
RenderMan Interface Bytestream (RIB) export is the most important export
module of Ayam and in fact justifies its existence. All features of the
Ayam object and scene structure are supported (hierarchy, CSG, instances,
materials, lights).
Furthermore, Ayam also supports direct rendering from view windows,
rendering in multiple passes for shadow maps, and permanent previews
(where a RenderMan renderer is directly coupled to an Ayam view window).
<p>
The documentation on RIB export is spread over the Ayam documentation,
this section gives some general information and otherwise just points
to the real documentation sections.
<p>
RIB export is always available, it does not need a plugin to be loaded.
The corresponding main menu entry is <tt>"File/Export/RenderMan RIB"</tt>
and the corresponding keyboard shortcut is <tt/&lt;Ctrl+E&gt;/.
To control the RIB export and rendering, many options exist that are
documented in section <ref id="prefrib" name="RIB-Export preferences">.
<p>
There are also some special ways to export RIBs available in the
main menu: <tt>"Special/RIB-Export"</tt>; this is documented in
section <ref id="mmspecial" name="Special Menu">.
<p>
Ayam can not only export scenes as RIB but also call various
RenderMan renderers to directly render the exported RIB files to
the screen or to an image file.
Documentation on how to export/render directly from a view window
can be found in section <ref id="vmview" name="View Menu">.
<p>
Invoking RIB export is also possible using the scripting interface,
see the section <ref id="scwrib" name="RIB export"> for more information.
<p>
RIB export always honors <tt/"NoExport"/ tags and the <tt/"HideChildren"/
attribute.

<sect1>Mops Import<label id="impmops">
<p>
In older versions of Ayam, Mops scenes could be imported using the main
menu entry: <tt>"File/Import Mops"</tt>. Since Ayam 1.13 Mops import is
a plugin named <tt>"mopsi"</tt>. After loading the plugin, Mops scenes
may be imported using the main menu entry <tt>"File/Import/Mops"</tt>.
<p>
Ayam is able to import most elements of a Mops scene except for
RiAttributes attached to arbitrary geometric objects,
because attributes and shaders are managed by material objects in Ayam.
However, if a Mops object has a surface or displacement shader,
a material object with the shaders from the Mops object
and its RiAttributes will be automatically created and linked with
the geometric object while importing. Only Mops objects
with surface or displacement shaders are considered because
otherwise a material object would have to be created for every
imported Mops object.
The material objects are named <tt/"mat0"/, <tt/"mat1"/ and so on.
Make sure, that the current scene in Ayam does not contain material
objects with those names, otherwise Mops import will not be able to
create material objects for the scene to import.
<p>
The import options <tt>"ResetDM"</tt> and <tt>"ResetST"</tt> control,
whether GLU display mode and tolerance settings (see sections
<ref id="ncattr" name="NCurveAttr">,
and <ref id="npattr" name="NPatchAttr">
for more information about display mode and tolerance) of NURBS primitives
should be reset to using global preference values (the default in Ayam)
instead of using the values from the Mops scene file.

<sect1>AutoCAD DXF Import<label id="impdxf">
<p>
The <tt>"dxfio"</tt> plugin allows to import AutoCAD DXF (drawing interchange
format) files into Ayam with the help of the Dime library (from Systems in
Motion, Kongsberg SIM AS, Norway).
<p>
Start importing a DXF file using the main menu entry
<tt>"File/Import/AutoCAD DXF"</tt>
(if this menu entry is not available, you have to load the
<tt>"dxfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
Note that the entire DXF file is read into memory before any geometry is
created.
<p>
<sect2>DXF Entity Support
<p>
The DXF import plugin supports reading of the following DXF entities:
3DFACE, ARC, CIRCLE, ELLIPSE, LINE, SOLID, TRACE, BLOCK, INSERT,
POLYLINE, LWPOLYLINE, and SPLINE. Entities not listed here will
be silently ignored.
<p>
3DFACE entities are imported as PolyMesh objects if either only the first
three points are unique (the entity describes a triangle) or the face
is planar else as BPatch objects.
<p>
ARC, CIRCLE, and ELLIPSE entities will be read as NCircle objects with
corresponding <tt/"TMin"/, <tt/"TMax"/ parameters (for arcs and ellipses)
and scale transformation values (for ellipses) set.
<p>
POLYLINE entities are completely supported:
<itemize>
<item>Polylines will be imported as NCurve objects;
<item>PolyMeshes and PolyFaceMeshes will be imported as PolyMesh objects;
<item>B-Spline and Bezier surfaces will be imported as NPatch objects.
</itemize>
<p>
LINE, LWPOLYLINE, and SPLINE entities will be imported as NCurve objects.
<p>
SOLID and TRACE entities are imported as BPatch objects.
<p>
BLOCK and INSERT entities will be converted to appropriate master (referenced)
and instance objects (references).
<p>
Bulges and extrusions are <em>not</em> supported.
<p>
The following table comprehensively lists the supported DXF entities and
their Ayam counterparts that will be created upon import.

<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/DXF Entity/|<bf/Ayam Object/@<hline>
3DFACE|PolyMesh&thinsp;/&thinsp;BPatch@<hline>
ARC|NCircle@<hline>
CIRCLE|NCircle@<hline>
ELLIPSE|NCircle@<hline>
LINE|NCurve@<hline>
SOLID|BPatch@<hline>
TRACE|BPatch@<hline>
POLYLINE|NCurve&thinsp;/&thinsp;PolyMesh&thinsp;/&thinsp;NPatch@<hline>
LWPOLYLINE|NCurve@<hline>
SPLINE|NCurve@<hline>
INSERT|Instance<#if out=latex>@<hline></#if>
</tabular>
<caption>DXF Import Conversion Table</caption>
</table>

<sect2>DXF Import Options<label id="impdxfopt">
<p>
The DXF import may be controlled via different options:
<itemize>
<item><tt>"FileName"</tt>: is the path and name of the DXF file to import.
<item><tt>"ReadCurves"</tt>: if this is disabled, no freeform curves will
be imported.
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
imported objects.
<item><tt/"ReadLayers"/: By default, all entities from all layers will be
imported.
Using the <tt/"ReadLayers"/: import option, a single layer or a range
of layers may be selected for import.
<item><tt/"RescaleKnots"/: allows to rescale the knot vectors of imported
NURBS curves so that the distances between different knots are not smaller
than the given value. A <tt/"RescaleKnots"/ value of 1.0e-04 leads to NURBS
that may be safely drawn using GLU. The default value 0.0 means no scaling.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, Dime is reading the DXF file; from 50 to 100 percent,
the dxfio plugin is converting the DXF entities to Ayam objects.
</itemize>

<sect1>AutoCAD DXF Export<label id="expdxf">
<p>
The <tt>"dxfio"</tt> plugin allows to export Ayam scenes to AutoCAD DXF
(drawing interchange format) files with the help of the Dime library
(from Systems in Motion, Kongsberg SIM AS, Norway).
<p>
Start exporting to a DXF file using the main menu entry
<tt>"File/Export/AutoCAD DXF"</tt>
(if this menu entry is not available, you have to load the
<tt>"dxfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
Note that the entire Ayam scene is converted to a corresponding
DXF model in memory before it is written to the DXF file.
<p>
Ayam only creates entities of type POLYLINE and SPLINE and misses very
much information that could be saved to other formats (e.g.~normals and
texture coordinates). Therefore, the DXF export format should be avoided
if possible.

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the dxfio plugin currently covers
export of all boxes, quadrics, NURBS, PolyMeshes, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/), and objects that
may be converted to NURBS curves or surfaces or to PolyMeshes.
However, all boxes and quadrics will always be converted to NURBS surfaces
and NURBS surfaces will be tesselated to PolyMeshes for export.
<p>
The scene hierarchy and CSG operations are fully ignored, all objects will
be written as if combined by the union operator.
<p>
All transformations will be applied to the control points of the
exported objects.
<p>
PolyMesh objects will be exported to POLYLINE (subtype PolyFaceMesh) entities.
If a PolyMesh object contains faces with holes or with more than four
points, it will be tesselated for export. Eventually existing normals
will not be exported.
<p>
NURBS curves will be exported as SPLINE entities.
<p>
Instance objects are resolved for export.
<p>
Light sources, as well as Cameras, Views, and Materials are not exported.
<p>
Clamping the knot ranges of NURBS curves or surfaces via UMM/VMM tags is
not supported. Texture coordinates will not be exported.

<sect2>DXF Export Options<label id="expdxfopt">
<p>
The DXF export may be controlled via different options:
<itemize>
<item><tt>"FileName"</tt>: is the path and name of the DXF file to export to.
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
exported objects.
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"ObeyNoExport"/: ignores all objects with <tt/"NoExport"/ tags.
<item><tt/"IgnoreHidden"/: ignores all hidden objects.
<item><tt>"WriteCurves"</tt>: if this is disabled, no freeform curves will
be exported.
<item><tt>"TopLevelLayers"</tt>: controls whether the top level Level
objects in the Ayam scene to be exported should be interpreted as layers.
If this option is enabled, all objects in these levels will be placed on
the respective layer. Objects that are not in one of those levels
will be written to the default layer. Furthermore, top level object names
will become layer names.
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the dxfio plugin is converting the Ayam objects
to DXF entities; from 50 to 100 percent, Dime is writing the DXF file.
</itemize>

<sect1>Wavefront OBJ Import<label id="impwav">
<p>
Since Ayam 1.8.3 a Wavefront OBJ (version 3.0) import facility is available
and since Ayam 1.13 it is a plugin (objio) that needs to be loaded
before import.
The corresponding main menu entry is <tt>"File/Import/Wavefront OBJ"</tt>
(if this menu entry is not available, you have to load the <tt>"objio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).

<sect2>Wavefront OBJ Statement Support
<p>
Wavefront OBJ import supports reading of polygonal lines and faces with vertex
normals and texture coordinates (the latter are read as primitive variable
tags); statements: <tt>v, vt, vn, l, f</tt>.
<p>
Furthermore, freeform curves and surfaces (NURBS) with trim curves and with
texture coordinates (again read as primitive variable tags) are supported;
statements: <tt>vp, cstype, deg, curv, curv2, surf, parm, trim, hole, end</tt>.
<p>
Freeform curves and surfaces of basis type bmatrix, cardinal and taylor
are currently not supported. Also, import of special curves and
points (e.g.~curve on surface) is currently not supported. Furthermore,
trimming of freeform curves and surfaces by clamping their knot ranges
is not supported (however, proper UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values).
<footnote>Since 1.9.</footnote>
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
No material and grouping information will be imported.
Unsupported statements will be silently ignored.
<p>
Wavefront OBJ import expects the file to be syntactically correct.
The plugin is not very good in detecting and reporting errors. If the
import fails, you might want to use a third party tool first to check
whether the Wavefront OBJ file is valid at all.
<p>
Furthermore, note that the objio plugin supports Wavefront version 3.0
syntax only, files that use older syntax will not be imported correctly.

<sect2>Wavefront OBJ Import Options<label id="impwavopt">
<p>
The following options control the Wavefront OBJ import process:
<itemize>
<item><tt>"FileName"</tt>: is the name of the Wavefront OBJ file (version 3.0)
<item><tt>"MergeFaces"</tt>: controls whether consecutive polygonal
faces should be merged into a single PolyMesh object for import.
Note that the merged PolyMesh objects probably needs to be optimized if there
are vertices used by multiple faces
(main menu <tt>"Tools/PolyMesh/Optimize"</tt>).
<item><tt>"MergePVTags"</tt>: controls whether the PV tags of PolyMesh
objects should be merged as well if they are subject to automatic
merging (see above).
<item><tt>"ReadCurves"</tt>: if this is disabled, no freeform curves will
be imported. This option does <em>not</em> influence the import of trim
curves.
<item><tt/"ReadSTrim"/: if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/: allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
imported objects.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 100 percent, the objio plugin is reading lines from the
Wavefront OBJ file and creating Ayam objects. The number may be a
bit off occasionally, as the progress meter just counts lines and
assumes a fixed medium line length of 28 characters.
</itemize>

<sect1>Wavefront OBJ Export<label id="expwav">
<p>
Since Ayam 1.7, it is possible to export scenes or objects to the Wavefront
OBJ format (version 3.0). Since Ayam 1.13, Wavefront OBJ export is a plugin
(objio) that needs to be loaded before export.
The corresponding main menu entry is <tt>"File/Export/Wavefront OBJ"</tt>
(if this menu entry is not available, you have to load the <tt>"objio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).

<sect2>Ayam Object and Properties Support
<p>
The Wavefront export currently supports the following
objects:
<itemize>
<item>NCurve and objects that may be converted to NCurve
objects (ICurve, ConcatNC, ExtrNC)
<item>NPatch (with trim curves) and objects that may be converted
to NPatch objects (BPatch, PatchMesh, Revolve, Sweep, Extrude, Skin,
Cap, Gordon, Birail1, Birail2, Text); since Ayam 1.8.3 also Quadrics
will be automatically converted to NURBS surfaces and exported
<item>PolyMesh and objects that may be converted to PolyMesh objects
(MetaObj), faces with holes are not supported by the Wavefront OBJ
format and will be tesselated to triangles for export automatically
<item>Box
<item>Instance, Clone; both will be resolved to normal objects for export
as Wavefront OBJ does not support referenced geometry
<item>Level, CSG operations are not supported and will be written
as normal Level objects, transformations will be delegated
to the child objects
</itemize>

Since the Wavefront OBJ format does not support separate transformation
attributes, all transformation attributes will be used to transform the
coordinate values (the control points) of the exported objects.
The hierarchy of the Ayam scene will be squashed.
<p>
CSG operations are fully ignored, all objects will be written
as if combined by the union operator.
<p>
The Wavefront OBJ export, currently, ignores all material information.
Only the pure geometry information is written to the OBJ file.
However, texture coordinates from primitive variable
tags can be exported.
<footnote>Since 1.8.3.</footnote>
<p>
UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
<footnote>Since 1.9.</footnote>
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
<p>
Light sources, as well as Cameras, and Views will not be exported.
<p>
Object names will be exported as <tt>o</tt> statements.

<sect2>Wavefront OBJ Export Options<label id="expwavopt">
<p>
The following parameters control the Wavefront OBJ export:
<itemize>
<item><tt>"FileName"</tt>: is the filename of the Wavefront OBJ file;
<item><tt>"WriteSelected"</tt>: exports only the currently selected object(s);
<item><tt>"TessPoMesh"</tt> automatically tesselates all PolyMesh objects
to triangles for export;
<item><tt>"WriteCurves"</tt>: toggles writing of NURBS curves and NURBS
curve providing objects to the exported Wavefront OBJ file (This option does
<em>not</em> influence the export of trim curves.);
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
exported objects;
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 100 percent, the objio plugin is writing the Ayam objects
to the Wavefront OBJ file.
</itemize>

<sect1>3DMF (Apple) Import<label id="imp3dmf">
<p>
Using the MFIO plugin you may import scenes from the 3DMF format
(QuickDraw 3D Metafile)
from Apple with the help of a free 3DMF parser created
by Duet Development Corp. and distributed by Apple.
Start importing a 3DMF file using the menu entry
<tt>"File/Import/Apple 3DMF"</tt> (if this menu entry is not available,
you have to load the <tt>"mfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The MFIO plugin only supports the 3DMF version 1.0!

<sect2>3DMF Primitive and Attribute Support
<p>
The MFIO plugin supports import of the following geometric primitives:
<itemize>
<item>Polyline, Triangle, TriGrid, Polygon, general Polygon, Box,
<item>NURBS curve, NURBS surface (with trim curves),
<item>Ellipsoid, Cylinder, Cone, Disk, and Torus.
</itemize>
<p>
The following table comprehensively lists the supported 3DMF primitives
and their Ayam counterparts that will be created upon import.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/3DMF Primitive/|<bf/Ayam Object/@<hline>
Polyline|NCurve@<hline>
Triangle|PolyMesh@<hline>
TriGrid|PolyMesh@<hline>
Polygon|PolyMesh@<hline>
Box|Box@<hline>
Ellipsoid|Sphere@<hline>
Cylinder|Cylinder@<hline>
Cone|Cone@<hline>
Disk|Disk@<hline>
Torus|Torus@<hline>
NURBCurve|NCurve@<hline>
NURBCurve2D|NCurve@<hline>
NURBPatch|NPatch@<hline>
Container|Level<#if out=latex>@<hline></#if>
</tabular>
<caption>3DMF (Apple) Import Conversion Table</caption>
</table>

The following transformations are supported in 3DMF import:
<itemize>
<item>Scale,
<item>Translate,
<item>Rotate, RotateQuaternion, RotateAxis (if axis is X, Y, or Z).
</itemize>
<p>
Furthermore, the import plugin reads the structure of the scene from Container
objects. Reference objects will be resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
Support for import of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect2>3DMF Import Options<label id="imp3dmfopt">
<p>
The following parameters, additionally, control the 3DMF import:
<itemize>
<item><tt>"FileName"</tt>: is the filename of the 3DMF file to import;
<item><tt/"ScaleFactor"/: The <tt/"ScaleFactor"/ option allows to apply a
scaling factor to all imported objects.
<item><tt/"ReadCurves"/:
If the <tt/"ReadCurves"/: import option is switched off, no curves will be
imported. This option does <em>not</em> influence the import of trim curves.
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/: allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
</itemize>

<sect1>3DMF (Apple) Export<label id="exp3dmf">
<p>
Using the MFIO plugin you may export scenes to the 3DMF format
(QuickDraw 3D Metafile)
from Apple with the help of a free 3DMF parser created by Duet
Development Corp. and distributed by Apple. Start exporting to a
3DMF file using the menu entry <tt>"File/Export/Apple 3DMF"</tt>
(if this menu entry is not available, you have to load the <tt>"mfio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).
<p>
The MFIO plugin only supports the 3DMF version 1.0!

<sect2>Ayam Object and Properties Support
<p>
The MFIO export supports the following geometric objects:
<itemize>
<item>NURBS curve and NURBS surface (with trim curves) including all
NURBS curve/surface providing objects, such as ICurve, Skin etc.,
<item>Sphere, Disk, Cone, Cylinder, Torus,
<item>Box, and PolyMesh.
</itemize>

Objects of types not listed here will be converted to NURBS
(if possible) or to PolyMesh objects automatically for export.
<p>
All transformations are supported and will be written as
Translate, Rotate, and Scale transformations, respectively.
<p>
All Instance objects will be resolved for export.
Level objects (regardless of type) will be written as Container objects.
<p>
If an object has a material, the color and opacity of the material
will be written as DiffuseColor and TransparencyColor, if the respective
red color component has a value different from -1.
<p>
Support for export of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect2>Trim Curves Support
<p>
The 3DMF file format specification for version 1.0 is unfortunately very
terse, when it comes to trim curves. There is no clearly defined way of
saving trim curves in 3DMF 1.0. However, the method presented here is the
only way that works with the free provided 3DMF parser.
Trimmed NURBS patches will be written by Ayam like this:
<tscreen><verb>
Container (
	NURBPatch ( ...
        )
	[transformations & attributes of NURBS patch]
	TrimCurves ( )
	NURBCurve2D ( ...
	)
	Container (
	        NURBCurve2D ( ...
	        )
	        NURBCurve2D ( ...
	        )
        )
)
</verb></tscreen>
There will always be an enclosing container for a NURBS patch.
If the patch is trimmed, after the transformations and attributes
of the patch, a <tt/TrimCurves/ element will follow (which does
<em>not</em> contain the trim curves but is empty). The trim curves follow
now as 2D NURBS curves (simple trims) or container objects (trim loops)
with 2D NURBS curves until the end of the enclosing container. The
transformation attributes of the trim curves will be applied to the NURBS
curve control points for export (there will be no transformations or
attributes for the trim curve elements).
<p>
The Ayam 3DMF import expects the trim curves to be delivered in this
manner.

<sect2>3DMF Export Options<label id="exp3dmfopt">
<p>
The following parameters, additionally, control the 3DMF export:
<itemize>
<item><tt>"FileName"</tt>: is the filename of the 3DMF file to export;
<item><tt/"WriteBinary"/: This option controls whether the text version
or the binary version of the 3DMF file format should be used for export.
<item><tt/"ScaleFactor"/:
This option allows to apply a scaling factor to all
exported objects.
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"WriteCurves"/: If this option is disabled,
no curves will be written to the exported 3DMF file. This option does
<em>not</em> influence the export of trim curves.
</itemize>

<sect1>3DM (Rhino) Import<label id="imprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that may import
scenes from the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio &ndash; <bf/O/pen<bf/N/URBS <bf/IO/)
by Robert McNeel & Associates.
<p>
Start importing from a Rhino 3DM file using the menu entry
<tt>"File/Import/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The onio plugin only supports import of 3DM files of version 3.0
and earlier.

<sect2>3DM Object Support
<p>
The import functionality of the onio plugin currently covers
import of all NURBS and BRep objects and objects that may
be converted to NURBS with routines from the OpenNURBS toolkit
(those objects are: PolylineCurve, PolyCurve, LineCurve, ArcCurve,
CurveOnSurface, RevSurface, SumSurface, and PlaneSurface).
References will be resolved. Names will be imported, but
converted to an ASCII representation. Since Ayam 1.8.3
also Mesh objects will be imported to PolyMesh objects, texture
coordinates will be read and appropriate PV tags will be
created for them.
<p>
The following table comprehensively lists the supported Rhino
3DM primitives and their Ayam counterparts that will be created
upon import.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/Rhino 3DM Primitive/|<bf/Ayam Object/@<hline>
PolyLineCurve|NCurve@<hline>
PolyCurve|NCurve@<hline>
LineCurve|NCurve@<hline>
ArcCurve|NCurve@<hline>
CurveOnSurface|NCurve@<hline>
Mesh|PolyMesh@<hline>
NurbsCurve|NCurve@<hline>
NurbsSurface|NPatch@<hline>
RevSurface|NPatch@<hline>
SumSurface|NPatch@<hline>
PlaneSurface|NPatch<#if out=latex>@<hline></#if>
</tabular>
<caption>3DM (Rhino) Import Conversion Table</caption>
</table>

<sect2>3DM Import Options<label id="imp3dmopt">
<p>
The 3DM import process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/: This option allows to apply a
scaling factor to all imported objects.
<item><tt/"Accuracy"/: This option controls the
tolerance of OpenNURBS internal operations, in this case the value is
mostly used for conversion operations to the NURBS form.
<item><tt/"ReadCurves"/: If this option is
switched off, no curves will be imported. This option does <em>not</em>
influence the import of trim curves.
<item><tt/"ReadLayers"/: By default, all objects from all layers will be
imported.
Using the <tt/"ReadLayers"/ import option, a single layer or a range
of layers may be selected for import.
<item><tt/"ReadSTrim"/: This option helps to ignore single bounding
trim loops of NURBS surfaces.
Importing this single bounding trim loop would just make the Ayam scene
more complex than needed in many cases.
If <tt/"ReadSTrim"/ is switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
This option replaces the <tt/"IgnoreFirstTrim"/ import option
available before Ayam 1.13 with slightly different semantics.
<item><tt/"RescaleKnots"/: allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling. Since Ayam 1.13 also eventually
present trim curves will be scaled properly to the new knot ranges of
NURBS patches.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, OpenNURBS is reading the 3DM file into memory;
from 50 to 100 percent, the onio plugin is converting the 3DM objects
to Ayam objects.
</itemize>

<sect1>3DM (Rhino) Export<label id="exprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that exports scenes
to the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio &ndash; <bf/O/pen<bf/N/URBS <bf/IO/)
by Robert McNeel & Associates.
<p>
Start exporting to a Rhino 3DM file using the menu entry
<tt>"File/Export/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The onio plugin exports 3DM files of version 3.0.

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the onio plugin currently covers
export of all boxes, quadrics, NURBS, polymeshes, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/) and objects that
may be converted to NURBS curves or surfaces.
<p>
Even though export of planar cap surfaces of various
tool objects is fully supported, the export of general trimmed NURBS
patches is not well supported. This is because of a missing feature
(pushing up 2D trim curves to 3D curves for arbitrary NURBS
surfaces) in the OpenNURBS toolkit. A coarse
polygonal 3D representation of the 2D trim curves will be
created automatically, so that general trimmed NURBS patches
may be exported, albeit with lower quality and bigger file size
as would be necessary.
<footnote>Since 1.9.</footnote>
<p>
UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
<footnote>Since 1.9.</footnote>
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
<p>
Since the Rhino 3DM file format does not support hierarchy and
transformation attributes per object, the hierarchy of the Ayam scene
will be squashed and all transformation attributes will be applied to
the control points of the objects for export. CSG operations are fully
ignored, all objects will be written as if combined by the union operator.
Furthermore, all instance objects will be resolved to normal objects.
<p>
All objects will be written to the first layer, the default layer (unless
the <tt>"TopLevelLayers"</tt> option is used). Object names will be exported
as well. Names of level objects will be prepended to the names of their
child objects. The object hierarchy:
<tscreen><verb>
+-Arm(Level)
 | MySphere(Sphere)
 \ MyCylinder(Cylinder)
</verb></tscreen>
for instance, leads to two objects in the Rhino file
named <tt>"Arm/MySphere"</tt> and <tt>"Arm/MyCylinder"</tt>.
<p>

<sect2>3DM Export Options<label id="exp3dmopt">
<p>
The 3DM export process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/: The <tt/"ScaleFactor"/ option allows to apply a
scaling factor to all exported objects.
<item><tt/"Accuracy"/: The <tt/"Accuracy"/ option controls the tolerance
of internal OpenNURBS operations (currently those are:
pushing up 2D trim curves to 3D curves and
checking NURBS surfaces for planarity).
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"ObeyNoExport"/: ignores all objects with <tt/"NoExport"/ tags.
<item><tt/"IgnoreHidden"/: ignores all hidden objects.
<item><tt/"WriteCurves"/: If this option is disabled,
no curves will be written to the exported Rhino 3DM file. This option does
<em>not</em> influence the export of trim curves.
<item><tt/"QuadAsBRep"/: If this option is enabled
spheres, cylinders, cones, and torii will not be exported as collection
of NURBS surfaces (as converted by Ayam) but as BRep objects (as converted
by the OpenNURBS toolkit).
However, not all features of the quadric objects will be translated in
this case:
 <itemize>
 <item>The BRep sphere does not support ZMin, ZMax, and ThetaMax.
 <item>The BRep cylinder does not support ThetaMax (base caps will
be created if the cylinder is closed).
 <item>The BRep cone does not support ThetaMax (a base cap will be
created, if the cone is closed).
 <item>The BRep torus does not support PhiMin, PhiMax, and ThetaMax.
 </itemize>
The <tt/"QuadAsBRep"/ option has no effect on the export of disks,
hyperboloids, and paraboloids. Those will always be exported as NURBS
surfaces.
<item><tt>"TopLevelLayers"</tt>: controls whether the top level Level
objects in the Ayam scene to be exported should be interpreted as layers.
If this option is enabled, all objects in these levels will be placed on
the respective layer. Objects that are not in one of those levels
will be written to the default layer. Furthermore, top level object names
will become layer names.
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the onio plugin is converting the Ayam objects
to 3DM objects; from 50 to 100 percent OpenNURBS is writing the 3DM file.
</itemize>

<sect1>X3D (Web3D) Import<label id="impx3d">
<p>
Since version 1.13 Ayam provides a plugin named <tt>"x3dio"</tt> that may
import scenes from the XML based X3D file format published by the Web3D
Consortium. The XML parser used in this plugin is based on Expat and SCEW.
<p>
Binary and compressed versions of X3D, as well as VRML files are <em/not/
supported. Only pure XML files are read by the <tt>"x3dio"</tt> plugin.
<p>
Start importing from a Web3D X3D file using the menu entry
<tt>"File/Import/Web3D X3D"</tt>
(if this menu entry is not available, you have to load the
<tt>"x3dio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
<sect2>X3D Element Support
<p>
The import functionality of the <tt>"x3dio"</tt> plugin currently covers
import of the following X3D elements (grouped by components):
<itemize>
<item><bf/Geometry3D:/
Box, Sphere, Cylinder, Cone, ElevationGrid, Extrusion,
IndexedFaceSet, IndexedTriangleSet, IndexedTriangleStripSet,
IndexedTriangleFanSet, TriangleSet, TriangleStripSet, TriangleFanSet,
IndexedLineSet, and LineSet.
<p><p>
Cylinders with just one cap are imported as two objects (a Cylinder and
a Disk). In all other cases and also for Cones, the <tt>"Closed"</tt>
attribute of the Ayam object is set according to the cap information of
the X3D element.
<p>
ElevationGrids are imported as bilinear patch meshes.
<p><p>

<item><bf/Geometry2D:/
Arc2D, ArcClosed2D, Circle2D, Disk2D, Polyline2D.
<p><p>
Arcs and Circles are imported as NCircle objects.
Closed arcs and Polylines are imported as NURBS curves.
Disks with an inner radius > 0.0 are imported as flat Hyperboloids
(otherwise as Disks).
<p><p>

<item><bf/NURBS:/
NurbsCurve, NurbsCurve2D, NurbsPatchsurface,
TrimmedNurbsPatchsurface, Contour2D, ContourPolyline2D,
NurbsSweptSurface, NurbsSwungSurface, NurbsSet.
<p><p>
All NURBS elements are fully supported.
<p><p>

<item><bf/CAD:/
QuadSet, IndexedQuadSet, CADLayer, CADAssembly, CADPart, CADFace.
<p><p>
CADLayer objects will be imported as top level level objects.
CADAssembly and CADPart objects will be imported as level objects.
<p><p>

<item><bf/Light sources:/
DirectionalLight, PointLight, SpotLight.
<p><p>
The lights will be directly mapped to the standard RenderMan
light sources distant, point, and spot, respectively.
Therefore, the <tt>"radius"</tt> and the <tt>"attenuation"</tt> attributes
of point and spotlights are not supported. However, point and spotlights
still have a quadratic falloff with distance.
<p><p>

<item><bf/Navigation:/
Viewpoint.
<p><p>
Viewpoint elements will be imported as view objects (with corresponding
view window) or camera objects depending on the <tt>"ReadViewpoints"</tt>
import option.
<p><p>

<item><bf>Non geometric/Scene structure:</bf>
Transformation, Shape, Group, Inline.
<p><p>
Shear transformations are not supported.
<p>
The semantics for inlining are currently not fully standards compliant.
By default, DEFs in inlined files live in their own namespace.
It is not possible to USE a DEF from an inlined file in the
inlining file.
However, if the <tt>"MergeInlineDefs"</tt> import option is switched on,
<em>all</em> DEF namespaces (of inlining and inlined files) will be
merged into one big namespace.
Now it would be possible to USE a DEF from an inlined file in the
inlining file. But beware, this only works correctly, if the DEF
names in all the files are unique.
It is not possible to transfer single definitions from an inlined file
to the inlining file or from the inlining file to the inlined file.
<p>
Also note: Inline URLs that do not point to the file system are not
supported.

</itemize>

Unsupported X3D elements will be silently ignored. Prototyping and
dynamic scenes as well as scripts are not supported.
<p>
Shape elements that contain more than one geometric elements as child
objects will be imported as level objects with the child objects using
the default transformations and the level object using the current
transformation attributes.
<p>
The following table comprehensively lists the supported Web3D
X3D primitives and their Ayam counterparts that will be created
upon import.
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/X3D Primitive/|<bf/Ayam Object/|<bf/X3D Primitive/|<bf/Ayam Object/@<hline>
<em/Geometry3D:/|&ensp;|<em/CAD:/|&ensp; @<hline>
Box|Box|QuadSet|PolyMesh@<hline>
Sphere|Sphere|IndexedQuadSet|PolyMesh@<hline>
Cylinder|Cylinder|CADLayer|Level@<hline>
Cone|Cone|CADAssembly|Level@<hline>
ElevationGrid|PaMesh|CADPart|Level@<hline>
Extrusion|PolyMesh|CADFace|Level@<hline>
IndexedFaceSet|PolyMesh|<em/Light:/|&ensp;@<hline>
IndexedTriangleSet|PolyMesh|DirectionalLight|Light@<hline>
IndexedTriangleStripSet|PolyMesh|SpotLight|Light@<hline>
IndexedTriangleFanSet|PolyMesh|PointLight|Light@<hline>
TriangleSet|PolyMesh|&ensp;|&ensp;@<hline>
TriangleStripSet|PolyMesh|&ensp;|&ensp;@<hline>
TriangleFanSet|PolyMesh|&ensp;|&ensp;@<hline>
IndexedLineSet|NCurve|&ensp;|&ensp;@<hline>
LineSet|NCurve|&ensp;|&ensp;@<hline>
<em/Geometry2D:/|&ensp;|&ensp;|&ensp;@<hline>
Arc2D|NCircle|&ensp;|&ensp;@<hline>
ArcClosed2D|NCurve|&ensp;|&ensp;@<hline>
Circle2D|NCircle|&ensp;|&ensp;@<hline>
Polyline2D|NCurve|&ensp;|&ensp;@<hline>
Disk2D|Disk&thinsp;/&thinsp;Hyperboloid|&ensp;|&ensp;@<hline>
<em/NURBS:/|&ensp;|&ensp;|&ensp;@<hline>
NurbsCurve|NCurve|&ensp;|&ensp;@<hline>
NurbsCurve2D|NCurve|&ensp;|&ensp;@<hline>
NurbsSurface|NPatch|&ensp;|&ensp;@<hline>
NurbsPatchsurface|NPatch|&ensp;|&ensp;@<hline>
TrimmedNurbsPatchsurface|NPatch|&ensp;|&ensp;@<hline>
NurbsSweptSurface|Sweep|&ensp;|&ensp;@<hline>
NurbsSwungSurface|Swing|&ensp;|&ensp;<#if out=latex>@<hline></#if>
</tabular>
<caption>X3D (Web3D) Import Conversion Table</caption>
</table>

<sect2>X3D Attribute Support
<p>
The <tt>"solid"</tt>, <tt>"ccw"</tt>, and <tt>"convex"</tt>
attributes are always ignored.
<p>
The <tt>"DEF"</tt> and <tt>"USE"</tt> attributes are supported for all
elements, however, the corresponding master-instance relationships are
completely resolved upon import.
Instances of objects may be easily created again using Automatic Instancing
(please refer to section <ref id="ai" name="Automatic Instancing">).
<p>
Normals will currently not be generated automatically for any X3D element
and thus the <tt>"creaseAngle"</tt> attribute will be fully ignored.
Note however, that if normals are specified, e.g.~for an
<tt>"IndexedFaceSet"</tt> element, they will be imported correctly.
<p>
Furthermore, if normals, colors, or texture coordinates
are provided to an element that imports as a PolyMesh (IndexedFaceSet
and the likes) proper PV (primitive variable) tags will be created.
<footnote>Since 1.17.</footnote>
<p>
Moreover, of there is an index provided to the normals, colors, or
texture coordinates, the relevant affected data (e.g.~the vertex
coordinates) will be expanded properly (as RenderMan does not support
multiple different indices on the vertex related data).
Note that currently the mere presence of an index will lead to this expansion,
the index is not checked for, whether it is identical to the vertex coordinate
index (and thus no expansion would be necessary).
<p>
The <tt>"DEF"</tt> attributes will be converted to object names
in some cases.

<sect2>X3D Import Options<label id="impx3dopt">
<p>
The following options further control the X3D import process:
<itemize>
<item><tt>"FileName"</tt>: is the name of the X3D file to be imported
<item><tt>"ReadCurves"</tt>: if this is disabled, no freeform curves will
be imported. This option does <em>not</em> influence the import of trim
curves.
<item><tt>"ReadViewpoints"</tt>: controls whether viewpoints should
be read as view, camera, or not at all.
<item><tt/"ReadSTrim"/: if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/: allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
imported objects.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, the x3dio plugin is reading the XML file,
from 50 to 100 percent the x3dio plugin is creating Ayam objects.
</itemize>

<sect1>X3D (Web3D) Export<label id="expx3d">
<p>
Since version 1.13 Ayam provides a plugin named x3dio that exports
scenes to the XML based X3D file format published by the Web3D Consortium.
The XML parser used in this plugin is based on Expat and SCEW.
<p>
Start exporting to a X3D file using the menu entry
<tt>"File/Export/Web3D (X3D)"</tt>
(if this menu entry is not available, you have to load the
<tt>"x3dio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the x3dio plugin currently covers
export of all boxes, quadrics, NURBS, PolyMeshes, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/) and objects that
may be converted to NURBS curves or surfaces or to PolyMeshes
(e.g.~SDMesh objects).
<p>
Some NURBS tool objects can be exported as parametric NURBS nodes,
e.g.~Sweep objects may be exported as NurbsSweptSurface nodes.
<p>
The scene hierarchy (level objects) will be converted to a
matching transform node hierarchy.
<p>
CSG operations are fully ignored, all objects will be written as
if combined by the union operator.
<p>
Clamping the knot ranges of NURBS via UMM/VMM tags is not supported.
<p>
PolyMesh objects will be exported to IndexedFaceSet nodes.
PolyMesh faces with holes are automatically tesselated. PolyMesh faces
with more than three points are tesselated if the export option
<tt>"TessPoMesh"</tt> is used.
All tesselated faces will be exported to a second IndexedFaceSet
element.
<p>
Light sources are exported if they are point, distant, or spot lights.
<p>
Cameras and Views are exported as Viewpoint nodes. Note however, that
X3D always assumes a perspective viewing transformation. This means,
views of type <tt/"Front"/, <tt/"Side"/, or <tt/"Top"/ will not be
exported properly.
<p>
Object names will be converted to DEF attributes.
<p>
Instances can be resolved or exported as USE/DEF pairs.

<sect2>X3D Export Options<label id="expx3dopt">
<p>
The following parameters, additionally, control the X3D (Web3D) export:
<itemize>
<item><tt>"FileName"</tt>: is the filename of the X3D file;
<item><tt/"ScaleFactor"/: allows to apply a scaling factor to all
exported objects;
<item><tt>"WriteSelected"</tt>: exports only the currently selected object(s);
<item><tt>"ObeyNoExport"</tt>: toggles export of objects with <tt/"NoExport"/
tags;
<item><tt>"IgnoreHidden"</tt>: toggles export of hidden objects;
<item><tt>"TessPoMesh"</tt>: automatically tesselates all PolyMesh objects
to triangles for export;
<item><tt>"WriteCurves"</tt>: toggles writing of NURBS curves and
NURBS curve providing objects to the exported file (This option does
<em>not</em> influence the export of trim curves.);
<item><tt>"WriteViews"</tt>: controls whether views should be exported as
view points;

<item><tt>"WriteParametrics"</tt>: toggles writing of the following
tool objects as plain NURBS surface or the following higher level
primitives:
 <itemize>
 <item>Revolve as NurbsSwungSurface,
 <item>Swing as NurbsSwungSurface,
 <item>Sweep as NurbsSweptSurface,
 <item>Extrude as NurbsSweptSurface;
 </itemize>
<item><tt>"ResolveInstances"</tt>: controls whether instance objects should
be resolved to normal objects or exported as DEF/USE pairs, note that no
attempt is made to detect whether the master objects (the DEFs) will be
exported for all exported instances (USE); this may happen especially in
conjunction with the X3D export options <tt>"WriteSelected"</tt> or
<tt>"IgnoreHidden"</tt>, incomplete/erroneous X3D files may result unless the
<tt>"ResolveInstances"</tt> option is switched on;

<item><tt>"TopLevelLayers"</tt>: arranges for all child objects of top level
objects in the Ayam scene to be put in CADLayer nodes;
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the x3dio plugin is creating a XML document
in memory and from 50 to 100 percent this XML document will be written
to the X3D file.
</itemize>

<sect>Miscellaneous
<p>
This section contains all information about Ayam not fitting elsewhere.

<sect1>The Undo System<label id="undos">
<p>
With the help of the undo system, one may correct mistakes made while
modelling.
However, only modifications of objects can be undone. This includes changes
made by modelling actions, changes made using property GUIs, but also
changes to views (type changes or changes to the camera settings associated
with a view).
<p>
It is currently <em>not</em> possible to undo any changes to the object
hierarchy, including clipboard (e.g.~cut, paste) and drag and drop
operations. If you delete an object, it is gone! If you, accidentally, move
an object using drag and drop, undo will not help!
<p>
The undo system works by storing copies of the different states of changed
objects in an undo buffer. You may step backwards through the saved states
using <tt/&lt;Ctrl+z&gt;/ (undo) but also forward using <tt/&lt;Ctrl+y&gt;/
(redo).
<p>
The storage space occupied by the undo buffer may be adjusted using the
preferences (<tt>"Prefs/Modelling/UndoLevels"</tt>). A value of -1 for
<tt>"UndoLevels"</tt> completely disables the undo system.
The values 0 and 1 are not allowed. The value 2 means that there is
always one state of the scene that can be restored, plus, a potential
undo operation can also always be undone using redo.
<p>
The changes that would be undone or redone are shown in abbreviated form
in the default prompt of the Ayam console and also in
the main menu entries <tt>"Edit/Undo"</tt> and <tt>"Edit/Redo"</tt>.
<footnote>Since 1.14.</footnote>
<p>
Several actions will completely clear the undo buffer (no undo is
possible after those actions):
New Scene, Open (Replace) Scene, and Close View.
<p>
Note that undo/redo will also modify objects that currently reside in the
object clipboard (if they have saved states in the undo buffer).
This means that the following sequence of operations leads to a sphere
placed at <tt>"0,0,0"</tt>:
<code>
create Sphere (at 0,0,0)
move Sphere (to 1,1,0)
cut Sphere (to clipboard)
undo
paste Sphere (from clipboard)
</code>

<sect1>The Modelling Concept Tool-Objects<label id="toolobj">
<p>
This section introduces the modelling concept <em>Tool-Objects</em>,
as used in Ayam.
<p>
In a standard modelling application, to create a surface of revolution,
one would either first create a curve then call the revolve tool to get
an appropriate surface (losing the curve as object, or even keeping it,
but without relation to the surface), or call the revolve tool first,
which would then require the user to draw a curve with similar results:
the created surface will typically lose the relation to the surface of
revolution tool and the curve (even if kept intact) will lose the relation
to the surface. There is no easy way to change parameters for the surface
creation or to change the geometry of the curve later on without doing it
all over again.
<p>
The modelling concept Tool-Objects overcomes these drawbacks by
transforming the revolve <em>tool</em> into a scene <em>object</em>.
<p>
The following example hierarchy shows two objects in a parent-child relation:
<tscreen><verb>
+-Tool_Object(Revolve)
 |         ^
 |         :
 |   <Notification>
 |         :
 \ Parameter_Object(NCurve)
</verb></tscreen>
The parent object is called <em>Tool-Object</em> and the child object is
called <em>Parameter-Object</em>. There is a flow of information from the
parameter object to the tool object. This information flow is controlled
by the so called <em>Notification</em> mechanism. The notification mechanism
makes sure that whenever the parameter objects change, the tool object is
informed so that it may adapt to the changes.
For interactive modelling actions, the notification will be carried out
while dragging the mouse or after release of the mouse button (i.e.~after
the modelling action finished),
depending on the main preference setting <tt/"LazyNotify"/.
<p>
In the example above, a NURBS curve is the parameter object and the
tool object is creating a surface of revolution from the curve data.
The NURBS curve and parameters of the Revolve object may change at any
time. When saved to an Ayam scene file, no surface data will be written,
leading to very small files that additionally contain a modelling history
and capture design intent to a certain degree.
<p>
Tool objects may be parameter objects of other tool objects:
<tscreen><verb>
+-Tool_Object(ExtrNP)
 +-Parameter_and_Tool_Object(Revolve)
  \ Parameter_Object(NCurve)
</verb></tscreen>
and there may be more than one parameter object per tool object:
<tscreen><verb>
+-Tool_Object(Skin)
 | Parameter_Object_1(NCurve)
 | Parameter_Object_2(NCurve)
 | ...
 \ Parameter_Object_n(NCurve)
</verb></tscreen>
<p>
Tool objects create new geometric objects from the information delivered
by the parameter object(s) or they modify the parameter object(s) and
deliver them to their respective parent object.
<p>
The pure hierarchical dependency scheme may be broken up by instance objects:
<#if out=latex><x/needspace 4/</#if>
<tscreen><verb>
+-Tool_Object(Revolve)
 \ Parameter_Object(NCurve) --------------
+-Tool_Object(Revolve)                    | !
 \ Parameter_Object(Instance_of_NCurve) <-
</verb></tscreen>
In the scene above, the second Revolve tool object depends on the shape
of the first parameter object. The Instance object transports the data
from one part of the hierarchy to another.
The notification mechanism is aware of this and initiates updates
in the scene hierarchy wherever needed and efficiently (not updating any
objects twice) according to the <tt/"CompleteNotify"/ main preference
setting. In the example above, due to complete notification, the second
Revolve object will get updated automatically whenever the original
NCurve object changes.
<p>
Two other mechanisms exist, that help tool objects to get the information
they need and to increase flexibility in hierarchy building and modelling:
<em>Provision</em> and <em>Conversion</em>. Both mechanisms are quite similar
and convert objects temporarily/transparently (provision) or finally
(conversion) from one type to another, e.g.~they convert an ICurve
(interpolating curve) to a plain NCurve (NURBS curve).
<p>
Due to the provision mechanism, an ICurve object could be used instead
of an NCurve as parameter object in all examples above easily.
And with the help of the conversion mechanism, the Revolve
tool objects could be converted to plain NPatch objects (e.g.~for
modelling operations not available to Revolve objects).
<p>
Note that instance objects are subject to a second round of provision,
i.e.~the master does not need to be of the wanted type but rather
provide the wanted type.
<p>
Even though, theoretically, every tool could be implemented as tool object,
this has not been done in Ayam (mainly, because this would unnecessarily
increase the code base). Only the most often used tools that convey and
capture much design intent were implemented as tool objects (those are
surface or curve creating tools). But also seldom used tools can be elevated
to nearly full tool object capabilities through the employment of the concept
of scripting objects
(see section <ref id="scriptobj" name="Script Object">).
<p>
This can be done easily by e.g.~creating script objects of type <tt/"Modify"/
that call those tools from their script (after possible conversion of the
provided object(s) to a proper type, the tool may need to operate on).
Even property GUIs to let the user adjust tool parameters as they know it
from the other Ayam objects can be added and different tools can be combined
in single objects with normal script code for unmatched flexibility.
But let us see a simple example first:
<tscreen><verb>
+-Skin
 +-Script
  \ ExtrNC
</verb></tscreen>
In the scene hierarchy above, the script object could be simply reverting the
extracted curve with code like this:
<code>
convOb -inplace; revertC
</code>
effectively elevating the tool <tt/"revertC"/ to an object.
<p>
A more useful example can be found in the Marsrakete sample scene
(as available from the Ayam home page). Here, a curve extracted
from a patch is trimmed to the right length using a script like this:
<code>
convOb -inplace; trimNC 0.0 0.5
</code>.
See section <ref id="scriptobjex" name="Script Object Example"> for
information on how this script might be expanded to support a
GUI and more error checking.

<sect1>Scene File Management<label id="scenefile">
<p>
This section contains exhaustive information on what exactly happens, when
Ayam reads or writes a scene file.

<sect2>Opening Scene Files<label id="opensf">
<p>
When reading a scene using <tt>"File/Open"</tt> or the MRU list:
<enum>
<item> Ayam will first check the scene changed state of the currently
loaded scene and warn the user, if the current scene contains unsaved
changes,
<item> then Ayam will clear the undo buffer and the current scene
(the clipboard content is not touched, except for instance objects,
whose masters are cleared with the scene: those instance objects will
be deleted from the clipboard),
<item> if the new file appears not to be an Ayam scene file (judged solely
by the file name extension) Ayam will try to import the file using
an import plugin responsible for the file (automatically loading the
matching plugin if not already loaded),
<item> Ayam will change the application working directory to the
directory of the scene file,
<item> now, a backup copy of the file to read will be made (depending
on the preference setting <tt>"Main/BakOnReplace"</tt>), a potentially
existing old backup copy will be silently overwritten,
note: even if the backup fails, scene reading continues,
<item> the header of the scene file will be read to derive the scene
file format version,
<item> the file will be read with all objects,
<item> all instances will be connected to their masters using the
information stored in <tt/"OI"/ tags; if a master can not be found in
the scene, the instance will be removed,
<item> all objects will be connected to their materials using the
information stored in <tt/"MI"/ tags; if no matching material can
be found, the connection will not be established,
<item> a complete notification will be run,
<item> if the file contains a root object with <tt/"SaveMainGeom"/
and/or <tt/"SavePaneLayout"/ tags, the respective window/widget
geometries from the tags will be re-established,
<item> if no errors occurred during reading, the current scene name
will be set to that of the file,
otherwise the current scene name will be reset to "unnamed" (to avoid
clobbering good scene files that failed to load for some reason with a
single, maybe even unintentional, press of <tt/&lt;Ctrl+s&gt;/),
<item> the file name will be put to the first most recently used
files entry in the file menu,
<item> the scene changed state will be reset to "unchanged",
<item> if a root object was read, a save views flag will be set,
otherwise it will be cleared and following save operations will not save
the root and any views (i.e.~scene files without root and views
stay scene files without root and views, even if new views
are opened and parameterized).
</enum>

When reading objects from a file:
<enum>
<item> if a view object is read, a new view window will be opened
(except for the first three view objects in single window GUI mode,
where only the configuration of the view objects read will be copied
to the already existing view objects of the three internal views),
<item> if one object is of a currently undefined type (i.e.~defined
by a plugin), Ayam will derive a potential plugin name from the
object type name and attempt to load the plugin, then scene reading
continues,
<item> if a material object is read, Ayam will immediately register
it; if this registration fails (because there is already a material
with that name registered; this material can <em>only</em> be in the
clipboard, as all other objects were deleted before opening the file),
the material object will be created, but objects from the file will
not be be linked to the material object from the file, but to the
material object that was already registered before,
<item> if loading of an object fails, Ayam skips to the next object
and continues to read from the file.
</enum>

<sect2>Inserting Scene Files<label id="insertsf">
<p>
In contrast to reading scenes via <tt>"File/Open"</tt> or the MRU list,
reading scenes via <tt>"File/Insert"</tt> does some things differently:
<enum>
<item> the current scene will not be cleared before reading the file,
<item> the current level will not be reset before reading the file;
if the scene file to be inserted contains no root and no views,
the new objects will be created in the current level, otherwise the
objects will be created in the topmost level of the scene, which will
also be the new current level in any case (after reading),
<item> no backup copy will be made of the file to be inserted,
<item> if a material is missing from the file, and a matching (by name)
material exists in the scene, the objects will be connected to this
material,
<item> view windows will be opened for every view object,
<item> the current directory will only be changed during the file
read operation,
<item> if a material object is read, Ayam will immediately register
it; if this registration fails (because there is already a material
with that name registered), the material object will be created, but
objects from the file will not be be linked to the material object
from the file, but to the material object that was already registered
before,
<item> the current file name will not be changed,
<item> the scene changed state will be set to "changed",
<item> the save views flag will not be changed, this means that
inserting a scene file without views into an empty scene
(e.g.~directly after application startup or after <tt>"File/New"</tt>)
and then saving the scene, will enrich the scene file with root
and views (in contrast to loading this scene via <tt>"File/Open"</tt>).
</enum>

<sect2>Saving Scene Files<label id="savesf">
<p>
When saving a scene using <tt>"File/Save"</tt>:
<enum>
<item> Ayam will first check the current scene file name, if the name is
"unnamed", a new file name will be requested,
<item> if the file appears not to be an Ayam scene file (judged solely
by the file name extension) Ayam will try to export the current scene
using an export plugin responsible for the file type instead of saving
to an Ayam scene file (automatically loading the
matching plugin if not already loaded),
<item> the geometry of the main window and internal widgets is saved
to <tt/"SaveMainGeom"/ and/or <tt/"SavePaneLayout"/ tags (if present
in the Root object),
<item> <tt/"OI"/ tags and <tt/"MI"/ tags will be created to allow
instances to be connected to their respective masters and objects
to their materials, when reading the scene file again,
<item> then, all objects from the scene will be saved to the file;
if the save views flag was cleared while reading the previous scene file,
root and views will be omitted (i.e.~scene files without root and views
stay scene files without root and views, even if new views
are opened and parameterized),
<item> if no errors occured during saving the file, the file name
will be put to the first most recently used files entry in the file menu,
and the scene changed state will be set to "unchanged",
<item> if errors occured, the current scene changed state will be kept.
</enum>


<sect1>Ayamrc File<label id="ayamrc">
<p>
To customize Ayam the ayamrc file may be used.
This file is either pointed to by the environment
variable <tt>AYAMRC</tt> or is determined as following:
<itemize>
<item>On Unix it is <tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On the Win32 platform (Windows95 - XP) it is
<tt>"&dollar;(HOME)/ayamrc"</tt> if the environment variable
<tt>HOME</tt> exists, else <tt>"&dollar;(TEMP)/ayamrc"</tt>.<p>
<item>On Mac OS X Aqua (not X11!) it is
<tt>"&tilde;/Library/Preferences/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On Mac OS X X11 (not Aqua!) it is
<tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
</itemize>

The ayamrc file is read on each start of Ayam and saved again on exit
(if the preference setting <tt>"Main/AutoSavePrefs"</tt> is enabled).
<p>
The ayamrc file contains:
<enum>
<item>preference settings (including some hidden settings that require
just occasional tweaking and are not reachable using the GUI preference
editor)
<item>position and size of the main window and the toolbox window
<item>keyboard shortcuts to menu entries and modelling actions
<item>RiOption and RiAttribute databases
</enum>

You may edit the file with any text editor (while Ayam is <em>not</em>
running), but keep in mind, that the file will be parsed by Tcl.
Should you, for some reason, destroy your ayamrc file so that Ayam does
not start correctly anymore you can always start Ayam
with the command line option <tt>"-failsafe"</tt>.
When the application is left the next time, or the main menu entry
<tt>"File/Save Prefs"</tt> is invoked, a correct ayamrc file will be
created again.
All preference settings will be reset to factory defaults and all your
edits of the ayamrc file will be lost, however.
<p>
Another way to reset the ayamrc file is to simply delete the file manually
or using the main menu entry <tt>"Special/Reset Preferences"</tt>.
<p>
To reset single elements to factory defaults, just remove the corresponding
lines from the ayamrc file.
<p>
Finally, resetting single preference settings without a text editor is
also possible with the help of the scripting interface by manipulating
the global <tt/"ayprefs"/ array. The following example leads to a reset
of the tolerance preference setting to the factory default for the
<em>next</em> start of Ayam.
<code>
unset ayprefs(Tolerance)
</code>

<sect2>Changing Keyboard Shortcuts
<p>
You may adapt the keyboard shortcuts used in the GUI to your special
needs using the ayamrc file. Note that if you do that, the GUI (the menu
entries and the <tt>"Show Shortcuts"</tt> window) will adapt to your
changes but certainly neither this documentation, nor the reference card
(unless recreated using refcard.tcl), nor the tutorials.
<p>
Ayam does not check for clashes in key bindings. This means, the last set
binding for a key will be used.
<p>
On Unix, the output of the program <tt/"xev"/ and the
manual page for the <tt/"bind"/ command of Tk provide helpful
information about which strings may be used to describe
key presses.
You can also directly use the Ayam console to infer key names, just enter:
<code>
toplevel .keytest
bind .keytest <Key> {puts %K}
</code>
into the Ayam console.
Now you can activate the new top level window and type on your keyboard
while the Ayam console prints the names of the keys.
<p>
For your convenience, the special string <tt/"Ctrl"/ will be replaced by
<tt/"Control"/ before a shortcut is handed to the <tt/bind/ command.
<p>
Example:
<code>
set aymainshortcuts(Prefs) {Ctrl-p}
</code>
sets the keyboard shortcut for opening of the preferences editor
to <tt/&lt;Ctrl+p&gt;/.
See the ayamrc file itself for a complete listing of available shortcuts.

<sect2>Hidden Preference Settings<label id="hidprefs">
<p>
The ayamrc file currently contains the following adjustable hidden
preference settings:
<itemize>

<item><tt/"AddViewParams"/ allows to add custom parameters to the
view OpenGL widget creation, like e.g.~<tt/"-stereo true"/. The default
value is <tt>""</tt> (empty string).

<item><tt/"ALFileTypes"/, <tt/"ALPlugins"/ two lists that describe
file name extensions and corresponding plugins that import and export
files of the type designated by the file name extensions.

<item><tt/"AllowWarp"/: controls whether the mouse pointer should be
moved to the new position of points snapped to the grid while editing
(default: 1 &ndash; yes).

<item><tt/"AskScriptDisable"/ controls the warning dialog that
appears if scenes with script objects or tags are loaded. The default
value is 1 &ndash; yes, warn about script objects and tags.

<item><tt/"AUCommands"/, commands that will be run in the console
when <tt/&lt;Shift+Return&gt;/ is used instead of <tt/&lt;Return&gt;/.
See also section <ref id="sciupd" name="Updating the GUI">.
The default value is <tt>"uS;rV;"</tt>, leading to a complete
update of the object hierarchy, the property GUI and all view
windows.

<item><tt/"BackupExt"/: is the file name extension to be used for backup
files. Default values are <tt>"&tilde;"</tt> for Unix and
<tt>".bak"</tt> for Win32.

<item><tt/"Balloon"/: time in ms until the tooltip window appears
(default: 1500 - 1.5s).

<item><tt/"Cat"/: name of a program that can read from and write to
a pipe (used by the Rendering GUI) (default: <tt>"cat"</tt>)
(a setting of <tt>"cat"</tt> will be
automatically replaced by <tt>"cat.exe"</tt> on Win32)

<item><tt/"ConsoleTakeFocus"/: can be used to exclude the console
from focus traversal via <tt/&lt;Tab&gt;/ when set to 0, the default
value is 1.

<item><tt/"ConsoleCursorEnd"/, if switched
on, the first click into the console will move the cursor to the input
prompt, ready for command input, instead of moving the cursor to the
point of the click. This option is enabled by default.

<item><tt/"DailyTips"/: a list of strings that appear as tips
on startup in the console (default: large).

<item><tt/"EFlush"/: time in ms between two flushes of the error message
buffer (default: 2000 - 2s).

<item><tt/"FixDialogTitles"/, this option prepends the title of a message box
that is normally displayed in the window frame of the message box to the
message in the box. This may be necessary because on some systems the title
string might be displayed in an unreadable font or not at all.
On Mac OS X Aqua (not X11!) this option is enabled by default.
On all other systems this option is disabled by default.

<item><tt/"FixImageButtons"/, enables a workaround for buttons
(e.g.~in the toolbox) that stay depressed when used. This option is disabled
by default on all platforms.

<item><tt/"FixX11Menu"/ enables a workaround for non-sticky menus
on X11 (displaced menus do not stay open). This option is enabled
by default and not used on the Win32 and Aqua platforms.

<item><tt/"IconGamma"/: this setting may be used to adapt the contrast
of all icons (in view menu and the toolbox) to your display gamma. If you
are on a SGI it is recommended to set this to about "0.7". The default
value <tt>""</tt> (empty string) leads to no changes of any icon images.

<item><tt/"KeepNTmpFiles"/: how many
incarnations of the scene in RIB form (which actually may be split
in more than one file due to e.g.~instances) created when directly
rendering from a view window should be kept on disk (default: 5)

<item><tt/"Kill"/: name of a program that kills other processes and accepts
a process id as argument (used by the Rendering GUI)
(default: <tt>"kill"</tt>) (a setting of <tt>"kill"</tt> will be
automatically replaced by <tt>"kill.exe"</tt> on Win32)
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.

<item><tt/"LineWidth"/, line width used for drawing the lines of
unselected objects (blue lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"ListTypes"/ determines, whether the type of an
object should be displayed in braces in the tree view or listbox.
The default value is 1 &ndash; yes, list the types.

<item><tt/"MarkHidden"/ determines, whether hidden objects
should be marked (using a preceding exclamation mark)
in the tree view or object listbox.
The default value is 1 &ndash; yes, mark hidden objects.

<item><tt/"MaxTagLen"/: the maximum number of characters to be displayed
in the buttons in the Tag Property GUI (default: 30)

<item><tt/"NewLoadsEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ also when the scene is
cleared using the main menu entry <tt>"File/New"</tt>.
The default value is 1 &ndash; yes, load the environment file on
<tt>"File/New"</tt>.

<item><tt/"PaneMargins"/, is a list of currently five floating
point values, used as a safety margin for the panes:
console vs. hierarchy, hierarchy vs. upper-views, lower-view vs. property,
property vs. hierarchy, upper-view-2 vs. upper-view-1 (in this
order).
These values control the minimum size of a pane expressed in an
inverse (1/x) and relative way:
the smaller the number, the bigger the margin. The safety margin
of the uppermost horizontal pane (that divides the upper internal
views from the hierarchy and the third view) is e.g.~a bit larger
so that the main menu may not be obscured easily (the corresponding
value is 5.0). The default value for the console (20.0) leads to a
small margin, so that the console may be shrunk to 2 or even 1 lines
of text. The default values are
<tscreen><tt>
{20.0 5.0 10.0 10.0 10.0}
</tt></tscreen>

<item><tt/"PickTolerance"/: the tolerance used to determine whether an object
should be picked or not (default: 5); this setting determines the size
of a rectangular area around the picked point in pixels, all objects that
are inside or touch this area are considered picked.

<item><tt/"PolyOffset0"/, <tt/"PolyOffset1"/ two float values, that
control the offsetting of shaded surfaces in the shade and draw
drawing mode (so that the curves always appear on top of the surfaces).
Default values are 1.0, 1.0.

<item><tt/"Prompt"/: controls the prompt for the Ayam console. If
set to an empty string, a default of
<tscreen><tt>
\[Undo:$ay(undoo)/Redo:$ay(redoo)\].../[file tail [pwd]]&gt;
</tt></tscreen>
will be used, which displays the name of the operations that one can
undo and redo and the last component of the current
directory of Ayam like this:
<tscreen><tt>
[Undo:None/Redo:None].../scn&gt;
</tt></tscreen>
.

<p>
One may e.g.~change this to <tt/"[pwd]&gt;"/ to see just the full path
name of the current directory.

To display the value of a variable in the prompt (e.g.~designating
the current level in the scene hierarchy) a write-trace
must be bound to that variable.
The write trace in turn must call the procedure <tt/"ayam_updateprompt"/
and may e.g.~be established using a small script like this:
<tscreen><tt>
trace variable &lt;vname&gt; ayam_updateprompt
</tt></tscreen>
.

<item><tt/"PVTexCoordName"/, default name for texture coordinate PV
tags, the default value is "st".

<item><tt/"PVNormalName"/, default name for vertex normal PV
tags, the default value is "N".

<item><tt/"PVColorName"/, default name for vertex color PV
tags, the default value is "Cs".

<item><tt/"SafeAutoFocus"/ disables AutoFocus
(see section <ref id="prefgui" name="preference settings">)
when certain dialog windows are open, so that they do not get
shuffled under other windows by accidental mouse movements on systems
where the window manager does only auto raise in conjunction with
auto focus.
This option is enabled by default on Win32.

<item><tt/"SelLineWidth"/, line width used for drawing the lines of
selected objects (white lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"SelXOR_R"/, <tt/"SelXOR_G"/, <tt/"SelXOR_B"/: determine
a color value that is used for drag selection rectangles.
Note that the color is not used directly but combined with the
color value of already drawn pixels by XOR. The default values
are 255 for the red, 128 for the green, and 0 for the blue component.

<item><tt/"ShiftTab"/, allows to set a specific keyboard symbol for
systems where pressing the Shift together with the Tab key does not
produce "&lt;Shift-Tab&gt;" (the default) but some other symbol like
e.g.~"&lt;ISO_Left_Tab&gt;" (many, but not all, modern X11 systems often use
this).

<item><tt/"SwapMB"/, <tt/"SwapMBSC"/ allow to swap mouse buttons 2 and 3
on MacOSX/Aqua (not X11!) for specified mouse bindings (<tt/"SwapMBSC"/),
because on MacOSX/Aqua, traditionally, the naming of the
middle and rightmost mouse button is reversed compared to X11/Win32.
This option is enabled by default on MacOSX/Aqua and allows to use
the same set of mouse bindings (the same ayamrc file) for X11 and
Aqua without sacrificing user experience. The middle mouse button,
by default, zooms the view, and the right one moves the view.

<item><tt/"toolBoxList"/: a list of sections or groups of buttons
describing the appearance of the toolbox window (default, using all
available sections: <tt>{trafo trafo2 solids misco nurbs toolobjs points
nctools1 nctools2 camera misc}</tt>)

<item><tt>"ToolBoxShrink"</tt>, controls whether the toolbox window
should shrink wrap around its contents after a resize operation.
This option is not used in single window GUI mode. Default is 1 &ndash; yes.

<item><tt>"ToolBoxTrans"</tt>, decides if the toolbox window should
be made transient. It will then, depending on the window manager or its
configuration, get a different or no decoration, no icon (or no entry in the
task bar on Windows), and will always be iconified when the main window
gets iconified. Not used in single window GUI mode. 
The default value is 1 &ndash; yes.

<item><tt/"UseInternalFD"/ switches to an internal file dialog for loading
of plugins. This option is only used on MacOSX/Aqua (not X11!), because
there the normal file dialog will not enter application bundle directory
structures. This option is enabled by default on MacOSX/Aqua and not
used on any other platform.

<item><tt/"WarnPropPasteToSel"/: should
<tt>"Special/Clipboard/Paste Property to Selected"</tt> raise a warning
requester? (default: 1 &ndash; yes)

<item><tt/"WarnUnknownTag"/ controls the warning messages for
unknown tag types. (default: 1 &ndash; yes)

<item><tt/"Wait"/: set this to <tt/"waitPid"/ if you want to enable
the work around for zombie processes created by the Rendering GUI.
This is e.g.~necessary for the Linux platform.

<item><tt/"WheelZoom"/, a float value that controls the zoom factor,
for the mouse wheel; default value is 0.5.

</itemize>

<sect2>RiOption and RiAttributes Database<label id="rioptdb">
<p>
With the ayamrc file, one may also adapt the database of RiOptions and
RiAttributes to the current RenderMan rendering system.
<p>
One can then easily add renderer specific options and attributes
to the scenes using tags and the main menu entries
<tt>"Special/Tags/Add RiOption"</tt> and
<tt>"Special/Tags/Add RiAttribute"</tt>,
see also sections
<ref id="riatag" name="RiAttribute Tag"> and
<ref id="riotag" name="RiOption Tag">.
<p>
The syntax for a new RiOption is quite simple as the following example shows:
<code>
set riopt(runtime) {
 { verbosity s { "silent" "normal" "stats" "debug" } }
}
</code>
This snippet sets the section <tt>"runtime"</tt> and adds a single
option, <tt>"verbosity"</tt>, to it. The option is declared to be of type
string using <tt>"s"</tt> and provided with a list of default values:
<tt>"{ "silent" "normal" "stats" "debug" }"</tt>.

To add another option to this section, say the option <tt>"op"</tt>
which shall be an integer value you have to change the aforementioned
snippet to:
<code>
set riopt(runtime) {
 { verbosity s { "silent" "normal" "stats" "debug"} }
 { op i }
}
</code>
As you can see, it is not mandatory to provide default values.
Be sure to correctly close all the curly braces, otherwise the next
start of Ayam may fail.

Available types of parameters are:
<itemize>
<item>i: a scalar integer value
<item>j: a pair of integer values
<item>f: a scalar float value
<item>g: a pair of float values
<item>s: a string value
<item>p: a point in space (simply three float values), the default
values (if provided) are three float values in curly braces, such as
<tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
<item>c: a color, the default values (if provided) are three float
values in curly braces, such as <tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
</itemize>

<sect1>Environment Variables<label id="envvars">
<p>
This section documents the environment variables used by Ayam.
<itemize>
<item><tt>"AYAMRC"</tt>: designates the full filename of the ayamrc file.
<item><tt>"HOME"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> is not set).
<item><tt>"TEMP"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> and <tt>"HOME"</tt> are not set); also initial value of the
<tt>"TmpDir"</tt> preference setting (used on Win32 if no ayamrc file exists,
that specifies <tt>"TmpDir"</tt>).
<item><tt>"AYNOSPLASH"</tt>: if this variable is set to 1, the splash
screen will not be shown
<item><tt>"BROWSER"</tt>: filename of the preferred WWW browser (used to
display the documentation URL)
<item><tt>"NETSCAPE"</tt>: (if <tt>"BROWSER"</tt> does not exist) filename
of the Netscape WWW browser (used to display the documentation URL)
<item><tt>"SHADERS"</tt>: initial value of <tt>"Shaders"</tt> preference
setting (used if no ayamrc file exists).
</itemize>

<sect1>Plugins Overview<label id="plugov">
<p>
This section serves as a overview of the various plugins available
in Ayam.
<p>
There are currently four major types of plugins for Ayam: shader parsing
plugins, custom objects, import/export plugins, and modelling helper
plugins:
<enum>
<item>shader parsing plugins:<newline>
aysdr, ayslb, ayslc, ayslo, ayslo3d, ayslx, ayso.

See also section <ref id="spplugins" name="Shader Parsing Plugins">.

<item>custom objects:<newline>
metaobj, sdnpatch, csphere.

See also section <ref id="customobj" name="Custom Objects">.

<item>import/export plugins:<newline>
dxfio, mfio, mopsi, objio, onio, rrib, x3dio.

See also section <ref id="impex" name="Import and Export">.

<item>modelling helper plugins:
<itemize>
<item>jsinterp &ndash; JavaScript scripting interface
(see section <ref id="jsinterp" name="JavaScript Scripting Interface">),
<item>luainterp &ndash; Lua scripting interface
(see section <ref id="luainterp" name="Lua Scripting Interface">),
<item>AyCSG &ndash; CSG rendering
(see section <ref id="aycsg" name="CSG preview using the AyCSG plugin">),
<item>IDR &ndash; Importance Driven Rendering
(see section <ref id="idr" name="Importance Driven Rendering">),
<item>aydnd &ndash; inter-application drag and drop
<item>subdiv &ndash; Catmull-Clark and Loop subdivision for the SDMesh
object (see section <ref id="sdmeshobj" name="SDMesh Object">).
</itemize>

</enum>

<sect1>Shader Parsing Plugins<label id="spplugins">
<p>
The following plugins are provided to allow
parsing of shaders
<footnote>Since 1.3.</footnote>
: <tt/"ayslb"/ for Air, <tt/"ayslx"/ for Aqsis,
<tt/"ayso"/ for RDC, <tt/"ayslo"/ for PRMan, <tt/"ayslo3d"/ for 3Delight,
<tt/"aysdr"/ for Pixie
<footnote>Since 1.6.</footnote>
, and <tt/"aygso"/ for Gelato.
<footnote>Since 1.11.</footnote>
<p>
After loading of one of the aforementioned plugins, Ayam will
be able to parse shaders compiled with the shader compiler
of the respective renderer.
<p>
There can only be one active shader parsing plugin. You can not
first load ayslb and then ayslx and expect Ayam to parse slb
<em>and</em> slx shaders.
<p>
A shader parsing plugin may be loaded
automatically on startup of Ayam using one of the provided Tcl scripts:
<tt/"loadayslb.tcl"/, <tt/"loadayslo.tcl"/, <tt/"loadayslo3d.tcl"/,
<tt/"loadayslx.tcl"/, <tt/"loadayso.tcl"/, <tt/"loadaysdr.tcl"/,
and <tt/"loadaygso.tcl"/.
To automatically load a plugin simply add the appropriate
script to the preference setting
<tt>"Main/Scripts"</tt> using the <tt>"Add"</tt> button in the
preferences editor.
<p>
Additionally, those scripts may be further adapted to
set a different <tt/"Shaders"/ preference setting or to immediately
scan for shaders after loading of the plugin. For that, just remove
the leading hash-marks (&num;) from the corresponding lines in the script.
Note that changing the scripts for immediate shader parsing is not
necessary if you load the shader parsing plugin automatically on startup
of Ayam, as the loading of the scripts will happen before the Ayam startup
sequence executes the initial shader scanning pass.
The shader search path used for the initial shader scanning pass
is taken from the <tt/"Shaders"/ preference setting.
<p>
If you load a shader parsing plugin manually or via unchanged
load script you need to adapt the shaders search path manually and also
initiate a shader scan manually.
Both actions may be carried out using the preferences editor. Scanning
for shaders may also be started using the main menu:
<tt>"Special/Scan Shaders"</tt>.
<p>
To better accommodate the fast changing world of RenderMan renderers,
since Ayam 1.11 all shader parsing plugins are Ayam version independent
(but still renderer version dependent <em>and</em> Tcl version dependent).
This allows to distribute updated shader parsing plugins without updating
Ayam too and thus in a higher frequency.
Furthermore, compiling a shader parsing plugin is now much easier.

<sect1>Automatic Instancing<label id="ai">
<p>
Automatic Instancing is available via the main menu entry:
<tt>"Special/Instances/Automatic Instancing"</tt>.
Automatic Instancing creates instances from all instantiable
objects, using a simple algorithm that recursively compares
objects. The comparison of materials and tags may be turned off in the
small dialog that pops up after selection of the menu entry
<tt>"Special/Instances/Automatic Instancing"</tt>.
<p>
The algorithm is able to create instances of grouping objects
too (objects with child objects, e.g.~levels or tool-objects
like revolve).
However, in order for two grouping objects to be instantiated
not only all child objects and the grouping objects
have to be instantiable, but the child objects also
have to be in the right order. It is not sufficient,
that for every child of the potential master, a matching
child of the potential instance exists.
Instantiation of grouping objects may drastically decrease
the total number of objects in a scene.
<p>
Note that before the automatic instantiation starts, all currently
existing instances will be resolved.<newline>
After instantiation some statistics will be displayed in the console.
<p>
Also note that the instantiation obeys the object selection:
<footnote>Since 1.14.</footnote>
<newline>
instances are only created from the selected objects.
If no objects are selected, instances are created from all objects
in the current level and below.
<p>
More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Automatic Instancing of
Hierarchically Organized Objects", in: Kunii T.L. (ed.): Spring
Conference on Computer Graphics (SCCG 2001) Conference Proceedings, Budmerice,
Slovakia, 25-28 April 2001, ISBN 80-223-1606-7</it>

<sect1>Importance Driven Rendering (IDR)<label id="idr">
<p>
The importance driven rendering plugin may be used to drastically
reduce rendering times while developing a scene.
It works in three main steps:
<enum>
<item>Importance values are assigned to elements of the scene.
<item>Two rendering passes are started according to the
assigned importance values. Elements of different importance
values are mutually masked out using <tt>"RiMatte"</tt> statements.
<item>The resulting partial images are composed to a single
resulting image, which is then displayed.
</enum>
The parameterisation of the two rendering passes ensures, that
the total rendering time is lower than the rendering time of
a single pass with high quality.
<p>
Many options exist to assign importance and parameterise the
rendering passes:
<p>
Elements of the scenes may be geometric objects, regions in image space,
or regions in object space.
Importance values are currently just binary values.
Assignment may take place manually (using IDR tags) or half-automatic
by derivation of importance from currently selected or changed
objects. To avoid inconsistency in the resulting images, importance
values may be propagated between (geometrically or hierarchically) near
objects, or between objects that are related (e.g.~from a material to a
geometric object).
<p>
Parameterisation of the two rendering passes currently includes selection of
a different renderer and the possibility to reduce rendering resolution and
shading rate. To further reduce rendering times for raytracing
renderers, the size of the region to render may be automatically adapted to
the elements of the current importance value (including an optimisation
run that balances renderer startup times and times needed to render
regions not originally occupied by two regions to merge).
<p>
Furthermore, caching of partial images is possible. However, the implementation
of this feature is not very sophisticated at the moment, as it
uses the Unix text tool <tt>"diff"</tt> to decide whether two RIB streams are
identical and hence need no re-rendering.

To start using IDR:
<enum>
<item>load a scene (e.g.~the cactus example scene),
<item>load the IDR plugin (menu <tt>"File/Load Plugin"</tt>),
<item>open the IDR control window using the main menu
<tt>"Custom/Open IDR"</tt>,
<item>set the assign mode to <tt>"Selection"</tt>,
<item>select an object in the scene (e.g.~the object named <tt>"Pot"</tt>),
<item>then press the <tt>"Render!"</tt> button.
</enum>
Compare the rendering time with a full render from the view window.

IDR requires that atleast the renderer of the second rendering pass
honours RiMatte. Since rgl does not honour RiMatte, it is sometimes
necessary to simply exclude objects of different importance value.
No wrong images are to be expected from this, as rgl does not calculate
other than local lighting effects.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Importance Driven
Rendering - Using Importance Information in the Rendering Process",
in: Hamza M., Sarfraz M. (ed.): Computer Graphics and Imaging (CGIM 2001)
Conference Proceedings, Honolulu, Hawaii, 13-16 August 2001,
ISBN 0-88986-303-2</it>

<sect1>CSG preview using the AyCSG plugin<label id="aycsg">
<p>
<figure loc="ht">
<eps file="pics/csgex.ps" height="5cm">
<img src="pics/csgex.gif">
<caption>CSG preview example (left without, right with CSG)</caption>
</figure>
<p>
The AyCSG plugin may be used to resolve and preview CSG operations.
For this, the plugin uses image based CSG rendering algorithms provided
by the OpenCSG library by Florian Kirsch. The OpenCSG library, currently,
supports the Goldfeather and the SCS algorithm. The latter only works
properly with convex primitives. Since both, Goldfeather and SCS, are
image based rendering algorithms, there is no limit in geometric object
types that may be used in CSG hierarchies. You may e.g.~use Quadrics, NURBS,
and Metaballs in every possible combination. You just have to make sure,
that every CSG primitive describes a closed space.
<p>
In order for the CSG rendering algorithms to work properly, the depth
complexity (convexity) of a primitive must be known.
The depth complexity of a primitive determines the maximum number
of forward oriented surfaces any ray through this primitive would pass.
A regular sphere has a depth complexity of 1, a torus of 2, but do
not confuse depth complexity with genus, they are different values.
A 3D representation of the letter A e.g.~has a genus of
1 but a depth complexity of 3.
The depth complexity of a primitive can be stored in a <tt/"DC"/ tag.
A torus would e.g.~get a tag named <tt/"DC"/ with the value <tt/"2"/.
If no <tt/"DC"/ tag is present for a primitive, a default value for
the depth complexity of <tt/"1"/ will be used.
If you fail to correctly specify the depth complexity, rendering
errors, like missing parts of surfaces, will occur.
<p>
Note that the correct operation of AyCSG not only depends on the
depth complexity but also the winding order of the OpenGL primitives
(triangles or quads) used for drawing of the CSG primitives. The
winding order has to be consistent in a scene, so that the rendering
algorithm can decide what is inside and what is outside by looking
at a single OpenGL primitive. For all quadric primitives of Ayam
the winding order is always consistent. However, for NURBS patches
the winding order depends on the orientation of the patch dimensions.
If NURBS patches are used in CSG operations one, consequently, may
need to revert the patches (e.g.~using the <tt/"RevertU"/ tool,
see <ref id="revertut" name="Revert U tool">).
If the winding order of some of the primitives in a CSG hierarchy
is not right, the respective primitives will not be effective
in the CSG operations to the extent that the rendered image becomes
completely empty.
<p>
The AyCSG rendering obeys the <tt>"Draw Selection only"</tt> and
<tt>"Draw Level only"</tt> view options as well as the hide attribute
of objects. If the CSG rendering fails for complete complex scenes,
you might still get a preview of the important CSG using objects by
selecting them and enabling the <tt>"Draw Selection only"</tt> view
option.
<p>
Also note that CSG rendering requires fast graphics hardware
(the more fillrate, the better). Furthermore, your OpenGL subsystem
has to support the PBuffers extension and, depending on the
rendering options chosen, a stencil buffer. Speedups may be
achieved using the <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt> extensions (if available to you).
<p>
Once the AyCSG plugin is loaded successfully you can render the CSG
preview in any view window using the keyboard shortcut
<tt>&lt;Ctrl+Shift+c&gt;</tt> or using the new button in the menu
bar of every view window (see image below).
If you hold down <tt>&lt;Shift&gt;</tt>
while pressing the button the view will continually render CSG
(the button stays pressed to signify this) until you click onto
the button again.
<p>
<figure loc="ht">
<eps file="pics/aycsgic.ps" height="4cm">
<img src="pics/aycsgic.gif">
<caption>View With AyCSG Icon</caption>
</figure>
<p>
The AyCSG plugin supports the following options, that are available
through the main menu entry <tt>"Custom/AyCSG Preferences"</tt>:
<itemize>
<item><tt/"Algorithm"/ allows to switch between the Goldfeather and
SCS algorithm. Note again that the SCS algorithm only works correctly
for convex primitives. The <tt/"Automatic"/ setting chooses one
of the algorithms based on whether concave primitives (depth complexity
&gt; 1) are present or not.

<item><tt/"DCSampling"/ determines a depth complexity sampling
strategy. Quoting from the OpenCSG documentation, the following options
are available:

<p>
<tt/"NoDCSampling"/: Does not employ the depth complexity. This essentially
makes the algorithm O(n&sup2;), but with low constant costs.
This is the standard Goldfeather algorithm, DC tags <em>must</em> be present
for primitives with a depth complexity greater than one, or rendering
errors may occur.

<p>
<tt/"OcclusionQuery"/: Uses occlusion queries to profit implicitly from
depth complexity without calculating it. This is especially useful for the
SCS algorithm where this strategy is applied at shape level, resulting in
a O(n*k') algorithm (where k' <= k), without significant constant overhead.
This strategy requires hardware occlusion queries, i.e.~the OpenGL
extension <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt>.
If this is enabled (and the <tt/"Algorithm"/ is set to Goldfeather),
DC tags need <em>not</em> to be present.

<p>
<tt/"DCSampling"/: Calculates the depth complexity k using the stencil
buffer. This makes the algorithm O(n*k), but with high constant costs.
In case of the Goldfeather algorithm, the literature denotes this as
layered Goldfeather algorithm.
Note that this option requires a stencil buffer which must be enabled
on the creation of a view window using additional view parameters
(preferences option AddViewParams, see also the section on
<ref id="hidprefs" name="hidden preference settings">).
If stencil buffers are not enabled, Ayam will automatically add the
relevant option to the preferences but this only has an effect on newly
created view windows (i.e.~you might also want to restart Ayam, if you
switch to DCSampling).
If <tt/"DCSampling"/ is enabled (and the <tt/"Algorithm"/ is set to
Goldfeather), DC tags need <em>not</em> to be present as the
depth complexity of primitives is calculated internally.

<item><tt/"OffscreenType"/: This option allows to switch between two
offscreen rendering techniques, PBuffers and Frame Buffer Objects;
depending on your graphics hardware and driver, one or the other
might work better for you.

<item><tt/"Optimization"/: Currently unused.

<item><tt/"CalcBBS"/ determines whether bounding boxes should be
calculated and used for speed up (not working at the moment).
</itemize>

See also:
<it>Kirsch F. and Doellner J.: "Rendering Techniques for Hardware-Accelerated
Image-Based CSG", in: Skala V. (ed.): Journal of WSCG'04, 221-228,
ISSN 1213-6972</it>

<sect1>Increasing drawing speed<label id="incds">
<p>
In case of sluggish response of the user interface of Ayam
(not accounting for long tree update operations) several
things to increase drawing speed can be done:
<itemize>
<item>Hide objects or complete object hierarchies
using <tt/"Hide"/ in the <tt/"Tools"/ menu.
<item>Disable drawing of true NURBS curves/surfaces, if you can. Use the
ControlHull display modes.
<item>If you need to see curves/surfaces, try to increase the
(GLU) sampling tolerance of the objects (use a value of about 60.0).
<item>Switch the primary modelling view to draw just the selected
object(s) or the current level.
<item>Iconify views you do not need, they will not be redrawn then.
<item>Switch off automatic redrawing of slow redrawing (e.g.~shaded)
views, and control their redraw by pressing <tt/&lt;Ctrl+d&gt;/ manually.
<item>Do not create unnecessary caps, they are trimmed NURBS patches
that render very slowly.
<item>Disable <tt/"UseMatColor"/.
</itemize>

<sect1>Modelling Without Views<label id="modsanv">
<p>
To work with very large/complex scenes, it may be necessary to turn off
all views. In Ayam one can do this in the multi window GUI mode
(see section <ref id="prefgui" name="GUI preference settings">).
If there are many objects, it is also advisable to switch the object
selection widget from tree view mode to list box mode (menu:
<tt>"Special/Toggle TreeView"</tt>.
<p>
Modelling without views does not work on Apple MacOSX (Aqua) if
GLU functionality is involved (as every GLU functionality on MacOSX
needs a GL context). GLU is needed for the PolyMesh and NURBS
tesselation.

<sect1>Restrictions and Implementation Deficiencies<label id="defi">
<p>
Due to the way Ayam is implemented, several restrictions and
deficiencies exist:
<itemize>
<item>Almost all strings in Ayam (scene file names, object names,
material names) are restricted to be 7-bit ASCII. If the scene is
not to be transported between platforms (e.g.~between UNIX and Win32),
using 8-bit ASCII should be fine, however.
<item>The maximum scene depth (i.e.~the maximum number of nested levels)
depends on the maximum stack size of the operating system Ayam is
running on (due to the use of recursion almost everywhere when traversing
the scene, e.g.~for drawing purposes).
<item>Ayam internally operates on double precision math, however,
no control over roundoff error in lengthy calculations exists.
Saving of scene files only uses the precision dictated by the current
standard C library. This may degrade the precision of the models.
The usage of double precision numbers via the Tcl scripting interface or
the GUI also can reduce model precision due to
double-string-double-conversions (the precision of those conversion
operations can be adjusted by the user via the <tt/"TclPrecision"/
preference setting, however).
<item>Materials may only be assigned to complete objects, not to
certain parts of objects.
<item>Undo/Redo are not possible for scene structure changes.
<item>In the user interface, colors are always represented as
three 8-bit RGB values, even though the RenderMan interface allows
e.g.~for different color sample numbers or floating point samples
instead of integers to be used for colors.
<item>There are no acceleration structures for e.g.~drawing and object
tree updates. This limits the number of objects that Ayam can handle
simultaneously without big lags in redraws or after scene structure
changes to about 1000. However, Ayam objects should be high-level objects,
not single polygons, anyway, i.e.~one usually gets away with about 100
objects for moderately complex scenes, the Marsrakete uses just 62 objects.
</itemize>

Ayam user interface deficiencies:
<itemize>
<item>The application state is often communicated via window title
strings only. But certain window systems do not display those
titles well, and they are not to be seen in the single window GUI
mode at all.
</itemize>

<sect1>How to join the fun<label id="fun">
<p>
Helping to make Ayam even better will spice up your life too.
Here is how to do it:
<enum>
<item>Write/translate tutorials.
<item>Create and submit example objects, scenes, and images.
<item>Implement custom objects like trees, landscape, sky, XSplines,
T-Splines, or whatever you can think of. Note that the license of Ayam
does not prevent you from implementing your custom object as shareware
or even commercial software. However, free software is preferred for
obvious reasons.
<item>Donate source to improve several critical parts of the modeler,
some ideas are: better (more exact) lighting simulation (is this
possible to do with OpenGL at all?), transformation widgets,
true support for subdivision surfaces, lift some deficiencies (see above),
import/export plugins.
The project page of Ayam on SourceForge lists some more tasks and
you are always welcome to discuss such matters in the public forum
or in the feature request tracker.
<item>Donate money by registering ShellyLib.
ShellyLibs source will be converted to a first high level custom object
that creates objects of type seashell for Ayam. This object, however,
will be Shareware.
</enum>

Please do not implement custom objects like simple triangles or polygons.
This would be something that really is not intended by the Ayam Team,
and it would surely show the limits of the current design of all code
operating on the scene structure.

Ayam objects should be high-level objects!

Reading the last paragraph you might think that we are a bit biased
against polygonal models. We are not. Polygonal models are the only
way to preview complex geometry using hardware accelerated graphics,
for the moment. But even while RenderMan supports rendering of
polygonal models, their use as a primitive is not recommended for
good reasons. In other words, use polygonal models in the modeler
as quick representation of your higher level objects, but please,
if you are going to actually render something, do not use that
polygonal representation.
If you want to go a complete polygonal way instead, voila, there
are good modelers out there.

<sect1>References<label id="secref">
<p>
Suggested reading:
<itemize>
<item>Advanced RenderMan: Creating CGI for Motion Pictures by
Tony Apodaca and Larry Gritz (Morgan-Kaufmann, 1999)
<item>The RenderMan Companion: A Programmer's Guide
to Realistic Computer Graphics by Steve Upstill (Addison-Wesley,
1989)
<item>Textures and Modelling: A Procedural Approach by Ebert,
Musgrave, Peachey, Perlin, and Worley (Academic Press, 1994)
</itemize>

WWW resources:
<itemize>
<item>If you are reading this document from a local file system,
maybe an updated version is available from the internet:
<tt>http://www.ayam3d.org/docs/ayam.html</tt>
<item>Ayam Tutorial #1:
<tt>http://www.ayam3d.org/tut1/tutorial1.html</tt>
<item>The Ayam FAQ: <tt>http://www.ayam3d.org/faq.html</tt>
<item>The RenderMan Repository: <tt>http://www.renderman.org/</tt>
<item>The RenderMan Academy: <tt>http://www.rendermanacademy.com/</tt>
<item>George W. Hart, Virtual Polyhedra<newline>
<tt>http://www.georgehart.com/virtual-polyhedra/conway_notation.html</tt>
</itemize>

<sect1>Acknowledgements
<p>
First of all, I would like to express a big "Thank you!"
to Bernd (Pink) Sieker. He is the first real Mops user
and beta tester, who urged me during the last years
via E-Mail and on IRC to fix this particular bug, add some
essential features, move the lights again etc. pp. in countless
iterations.
Bernd, without your help I surely would not be that far, thanks!

Furthermore, I would like to thank the following people:
<itemize>
<item>Hynek Schlawack: Ayam Makefile configuration GUI
<item>Florian Kirsch: OpenCSG
<item>Bertrand Coconnier: implementation of object picking
<item>Hermann Birkholz: initial implementation of the tree widget, shadow map
support, AI, and IDR
<item>Frank (Copper) Pagels: MetaBalls custom object, TTF parser,
providing a lot of good music
<item>Stephen Echavia: Icons
<item>Larry Gritz: BMRT
<item>Benjamin Bederson, Brian Paul et. al.: The Togl Widget
<item>Jeffrey Hobbs: tkMegaWidget set
<item>Jan Nijtmans: Tcl/Tk PlusPatches, tcl2c, Wrap
<item>Georgios Petasis: tkdnd
<item>Thomas E. Burge: The Affine Toolkit
<item>Apple, Duet Development Corp.: 3DMF parser
<item>Mark J. Kilgard: GLUT
<item>Les A. Piegl and Wayne Tiller: The NURBS Book
<item>W. T. Hewitt and D. Yip: The NURBS Procedure Library
<item>Philippe Lavoie: The NURBS++ Library
<item>Tom Cashman: snurbs (Subdivision NURBS) library
<item>George W. Hart: Conway notation polyhedron generator
<item>Everyone involved in the development of Tcl/Tk, OpenGL, The RenderMan
Interface
</itemize>

OpenGL (R) is a registered trademark of Silicon Graphics, Inc.

The RenderMan (R) Interface Procedures and Protocol are:
Copyright 1988, 1989, 2000 Pixar
All Rights Reserved

RenderMan (R) is a registered trademark of Pixar

The Affine Libraries and Tools are
Copyright (c) 1995, 1996, 1997, 1998 Thomas E. Burge
All rights reserved.

Affine (R) is a registered trademark of Thomas E. Burge.

TIFF Software is
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.

Dime is
Copyright (c) 1998-1999 Systems In Motion, SA
All rights reserved.

AutoCAD (R) is a registered trademark of Autodesk, Inc.

DXF (R) is a registered trademark of Autodesk, Inc.


<sect>Index
<p>
Overview:
<#if out=latex>
<list>
<item><tt/<bf/0// &ndash; page <pageref id="index0">
<item><tt/<bf/A// &ndash; page <pageref id="indexa">
<item><tt/<bf/B// &ndash; page <pageref id="indexb">
<item><tt/<bf/C// &ndash; page <pageref id="indexc">
<item><tt/<bf/D// &ndash; page <pageref id="indexd">
<item><tt/<bf/E// &ndash; page <pageref id="indexe">
<item><tt/<bf/F// &ndash; page <pageref id="indexf">
<item><tt/<bf/G// &ndash; page <pageref id="indexg">
<item><tt/<bf/H// &ndash; page <pageref id="indexh">
<item><tt/<bf/I// &ndash; page <pageref id="indexi">
<item><tt/<bf/J// &ndash; page <pageref id="indexj">
<item><tt/<bf/K// &ndash; page <pageref id="indexk">
<item><tt/<bf/L// &ndash; page <pageref id="indexl">
<item><tt/<bf/M// &ndash; page <pageref id="indexm">
<item><tt/<bf/N// &ndash; page <pageref id="indexn">
<item><tt/<bf/O// &ndash; page <pageref id="indexo">
<item><tt/<bf/P// &ndash; page <pageref id="indexp">
<item><tt/<bf/Q// &ndash; page <pageref id="indexq">
<item><tt/<bf/R// &ndash; page <pageref id="indexr">
<item><tt/<bf/S// &ndash; page <pageref id="indexs">
<item><tt/<bf/T// &ndash; page <pageref id="indext">
<item><tt/<bf/U// &ndash; page <pageref id="indexu">
<item><tt/<bf/V// &ndash; page <pageref id="indexv">
<item><tt/<bf/W// &ndash; page <pageref id="indexw">
<item><tt/<bf/X// &ndash; page <pageref id="indexx">
<item><tt/<bf/Y// &ndash; page <pageref id="indexy">
<item><tt/<bf/Z// &ndash; page <pageref id="indexz">
</list>
</#if>
<#if out=html>
<ref id="index0" name=" 0 ">&nbsp;
<ref id="indexa" name=" A ">&nbsp;
<ref id="indexb" name=" B ">&nbsp;
<ref id="indexc" name=" C ">&nbsp;
<ref id="indexd" name=" D ">&nbsp;
<ref id="indexe" name=" E ">&nbsp;
<ref id="indexf" name=" F ">&nbsp;
<ref id="indexg" name=" G ">&nbsp;
<ref id="indexh" name=" H ">&nbsp;
<ref id="indexi" name=" I ">&nbsp;
<ref id="indexj" name=" J ">&nbsp;
<ref id="indexk" name=" K ">&nbsp;
<ref id="indexl" name=" L ">&nbsp;
<ref id="indexm" name=" M ">&nbsp;
<ref id="indexn" name=" N ">&nbsp;
<ref id="indexo" name=" O ">&nbsp;
<ref id="indexp" name=" P ">&nbsp;
<ref id="indexq" name=" Q ">&nbsp;
<ref id="indexr" name=" R ">&nbsp;
<ref id="indexs" name=" S ">&nbsp;
<ref id="indext" name=" T ">&nbsp;
<ref id="indexu" name=" U ">&nbsp;
<ref id="indexv" name=" V ">&nbsp;
<ref id="indexw" name=" W ">&nbsp;
<ref id="indexx" name=" X ">&nbsp;
<ref id="indexy" name=" Y ">&nbsp;
<ref id="indexz" name=" Z ">&nbsp;
</#if>
Index:
<p>
<label id="index">
<label id="index0"><tt/<bf/0//
<list>
<item>2lcons.tcl: <ref id="twolconstcl" name="example/helper script">
<item>3DM:
<itemize>
<item><ref id="imprhino" name="3DM (Rhino) Import">,
<item><ref id="exprhino" name="3DM (Rhino) Export">
</itemize>
<item>3DMF:
<itemize>
<item><ref id="imp3dmf" name="3DMF (Apple) Import">,
<item><ref id="exp3dmf" name="3DM (Apple) Export">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexa"><tt/<bf/A//
<list>
<item>aac.tcl: <ref id="aactcl" name="example/helper script">
<item>About: <ref id="mmhelp" name="main menu entry">
<item>Accuracy:
<itemize>
<item><ref id="imprhino" name="3DM (Rhino) import option">,
<item><ref id="exprhino" name="3DM (Rhino) export option">
</itemize>
<item>ACurve: <ref id="acurveobj" name="ACurve object">
<item>Action: <ref id="iac" name="interactive actions">
<item>Active: <ref id="scriptattr" name="Script attribute">
<item>Adaptive: <ref id="moattr" name="MetaObj attributes">
<item>AddExtensions: <ref id="prefgui" name="preference setting">
<item>addToProc: <ref id="scaddtoproc" name="scripting interface command">
<item>AddViewParams: <ref id="hidprefs" name="hidden preference setting">
<item>ALength: <ref id="acp" name="ACurve attribute">
<item>ALFileTypes, ALPlugins: <ref id="hidprefs" name="hidden preference setting">
<item>AllowWarp: <ref id="hidprefs" name="hidden preference setting">
<item>Algorithm: <ref id="aycsg" name="AyCSG plugin option">
<item>Align to Object:
<itemize>
<item><ref id="vmconf" name="view menu entry">,
<item><ref id="vwsc" name="view action">
</itemize>
<item>ANS: <ref id="anstag" name="tag type">
<item>AntiAlias Lines: <ref id="vmconf" name="view menu entry">
<item>apnt.tcl: <ref id="apnttcl" name="example/helper script">
<item>Apply: <ref id="propgui" name="apply property GUI">
<item>applyTrafo: <ref id="scapplytrafo" name="scripting interface command">
<item>Archives: <ref id="rio" name="RenderMan interface option">
<item>Area Light: <ref id="alob" name="creation of">
<item>Array: <ref id="cloneobj" name="Clone object">
<item>AskScriptDisable: <ref id="hidprefs" name="hidden preference setting">
<item>Atmosphere: <ref id="imager" name="property">
<item>Attributes:
<itemize>
<item><ref id="attrs" name="attributes property">,
<item><ref id="riattrs" name="RenderMan/BMRT attributes property">
</itemize>
<item>AUCommands: <ref id="hidprefs" name="hidden preference setting">
<item>AutoCAD DXF:
<itemize>
<item><ref id="impdxf" name="AutoCAD DXF import">,
<item><ref id="expdxf" name="AutoCAD DXF export">
</itemize>
<item>AutoFocus: <ref id="prefgui" name="preference setting">
<item>Automatic Instancing: <ref id="mmspecial" name="main menu entry">
<item>Automatic Redraw: <ref id="vmconf" name="view menu entry">
<item>AutoResize: <ref id="prefgui" name="preference setting">
<item>AutoSavePrefs: <ref id="prefgui" name="preference setting">
<item>Attribute: <ref id="riatag" name="RiAttribute tag type">
<item>ayamrc: <ref id="ayamrc" name="Ayamrc File">
<item>ayError: <ref id="scayerror" name="scripting interface command">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexb"><tt/<bf/B//
<list>
<item>Background: <ref id="prefdraw" name="preference setting">
<item>Background Image: <ref id="vat" name="View attribute">
<item>BackupExt: <ref id="hidprefs" name="hidden preference setting">
<item>BakOnReplace: <ref id="prefmain" name="preference setting">
<item>Balloon: <ref id="hidprefs" name="hidden preference setting">
<item>Basis_U, Basis_V: <ref id="pmattr" name="PatchMesh attribute">
<item>BeamDistrib: <ref id="lip" name="Light attribute">
<item>Bevel:
<itemize>
<item><ref id="bevelobj" name="Bevel object">,
<item><ref id="handb" name="using bevels">,
<item><ref id="offsetncp" name="offset mode">
</itemize>
<item>Bevel3D: <ref id="offsetncp" name="offset mode">
<item>BevelRadius, BevelRevert, BevelType: <ref id="bevelp" name="Bevel attribute">
<item>bgconvert.tcl: <ref id="bgconverttcl" name="example/helper script">
<item>BGImage: <ref id="vat" name="View attribute">
<item>bicubic/bilinear PatchMesh: <ref id="patchmeshobj" name="PatchMesh object">
<item>Birail1: <ref id="birail1obj" name="Birail1 object">
<item>Birail2: <ref id="birail2obj" name="Birail2 object">
<item>BNS: <ref id="bnstag" name="tag type">
<item>Bound: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>BoundCoord: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Box: <ref id="boxobj" name="Box object">
<item>BP: <ref id="bptag" name="tag type">
<item>BPatch: <ref id="bpatchobj" name="BPatch object">
<item>BType_U, BType_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Build: <ref id="bfct" name="build from curves tool">
<item>buildNP: <ref id="scbuildnp" name="scripting interface command">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexc"><tt/<bf/C//
<list>
<item>CalcBBS: <ref id="aycsg" name="AyCSG plugin option">
<item>Camera:
<itemize>
<item><ref id="cameraobj" name="Camera object">,
<item><ref id="camp" name="view property">
</itemize>
<item>Cap: <ref id="capobj" name="Cap object">
<item>CastShadows: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Cat: <ref id="hidprefs" name="hidden preference setting">
<item>Chamfer: <ref id="bevelobj" name="Bevel object">,
<item>CheckLights: <ref id="prefrib" name="preference setting">
<item>Center All Points: <ref id="mmspecial" name="main menu entry">
<item>Circle:
<itemize>
<item><ref id="ncirct" name="NURBS circle tool">,
<item><ref id="ncircleobj" name="NCircle object">
</itemize>
<item>Clamp:
<itemize>
<item><ref id="clat" name="clamp curve tool">,
<item><ref id="clanpt" name="clamp patch tool">
</itemize>
<item>clampNC: <ref id="scclampnc" name="scripting interface command">
<item>clampuNP: <ref id="scclampunp" name="scripting interface command">
<item>clampvNP: <ref id="scclampvnp" name="scripting interface command">
<item>Clipboard: <ref id="sciclip" name="scripting interface commands">
<item>Clone: <ref id="cloneobj" name="Clone object">
<item>Close: <ref id="treecontm" name="tree context menu entry">
<item>Closed:
<itemize>
<item><ref id="spattr" name="Sphere attribute">,
<item><ref id="cnp" name="Cone attribute">,
<item><ref id="cyp" name="Cylinder attribute">,
<item><ref id="top" name="Torus attribute">,
<item><ref id="pap" name="Paraboloid attribute">,
<item><ref id="hyp" name="Hyperboloid attribute">,
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="concatncp" name="ConcatNC attribute">
</itemize>
<item>Closed B-Spline: <ref id="cbspt" name="closed B-Spline tool">
<item>Close_U, Close_V:
<itemize>
<item><ref id="pmattr" name="PatchMesh attribute">,
<item><ref id="ipattr" name="IPatch attribute">
</itemize>
<item>coarsenNC:
<itemize>
<item><ref id="sccoarsennc" name="scripting interface command">,
<item><ref id="coart" name="coarsen tool">
</itemize>
<item>Collapse:
<itemize>
<item><ref id="collt" name="Collapse tool">,
<item><ref id="treecontm" name="tree context menu entry">
</itemize>
<item>colfocus.tcl: <ref id="colfocustcl" name="example/helper script">
<item>Color:
<itemize>
<item><ref id="riattrs" name="RenderMan/BMRT attribute">,
<item><ref id="lip" name="Light attribute">
</itemize>
<item>CompleteNotify: <ref id="prefmodel" name="preference setting">
<item>copOb: <ref id="sccopob" name="scripting interface command">
<item>Copy: <ref id="mmedit" name="main menu entry">
<item>Copy Property:
<itemize>
<item><ref id="mmedit" name="main menu entry">,
<item><ref id="propgui" name="copying properties">
</itemize>
<item>Concat: <ref id="conct" name="Concat tool">
<item>ConcatNC: <ref id="concatncobj" name="ConcatNC object">
<item>ConcatNP: <ref id="concatnpobj" name="ConcatNP object">
<item>concatS: <ref id="scconcats" name="scripting interface command">
<item>Cone: <ref id="coneobj" name="Cone object">
<item>ConeAngle, ConeDAngle: <ref id="lip" name="Light attribute">
<item>Console: <ref id="cons" name="what is">
<item>ConsoleCursorEnd: <ref id="hidprefs" name="hidden preference setting">
<item>ConsoleTakeFocus: <ref id="hidprefs" name="hidden preference setting">
<item>Convert: <ref id="mmtools" name="main menu entry">
<item>convOb: <ref id="scconvob" name="scripting interface command">
<item>Coons Patch: <ref id="gordonobj" name="Gordon object">
<item>Create: <ref id="mmcreate" name="create menu">
<item>CreateMP:
<itemize>
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="npattr" name="NPatch attribute">
</itemize>
<item>Create ShadowMap:
<itemize>
<item><ref id="mmspecial" name="main menu entry">,
<item><ref id="vmview" name="view menu entry">
</itemize>
<item>crtClosedBS: <ref id="sccrtclosedbs" name="scripting interface command">
<item>crtNCircle: <ref id="sccrtncircle" name="scripting interface command">
<item>crtNRect: <ref id="sccrtnrect" name="scripting interface command">
<item>crtOb: <ref id="sccrtob" name="scripting interface command">
<item>CSG:
<itemize>
<item><ref id="levelobj" name="Level object">,
<item><ref id="aycsg" name="AyCSG CSG preview plugin">
</itemize>
<item>Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Custom:
<itemize>
<item><ref id="cul" name="light type">,
<item><ref id="mmcustom" name="custom menu">
</itemize>
<item>Custom Object: <ref id="customobj" name="what is">
<item>Cut: <ref id="mmedit" name="main menu entry">
<item>cutOb: <ref id="sccutob" name="scripting interface command">
<item>Cylinder: <ref id="cylinderobj" name="Cylinder object">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexd"><tt/<bf/D//
<list>
<item>DANS: <ref id="anstag" name="tag type">
<item>Data: <ref id="riprocp" name="RiProc attribute">
<item>DC: <ref id="dctag" name="tag type">
<item>DCSampling: <ref id="aycsg" name="AyCSG plugin option">
<item>DefaultAction: <ref id="prefmodel" name="preference setting">
<item>DefaultMat: <ref id="prefrib" name="preference setting">
<item>Degree: <ref id="sdnpattr" name="SDNPatch attribute">
<item>DelayedReadArchive: <ref id="riprocp" name="RiProc attribute">
<item>delegTrafo: <ref id="scdelegtrafo" name="scripting interface command">
<item>Delete:
<itemize>
<item><ref id="mmedit" name="main menu entry">,
<item><ref id="insdelac" name="delete points">
</itemize>
<item>delOb: <ref id="scdelob" name="scripting interface command">
<item>Derivatives: <ref id="icp" name="ICurve attribute">
<item>Derivatives_U, Derivatives_V: <ref id="ipattr" name="IPatch attribute">
<item>Difference: <ref id="levelobj" name="Level object">
<item>Direct Editing: <ref id="editac" name="edit points">
<item>Disk: <ref id="diskobj" name="Disk object">
<item>Displacement: <ref id="matshader" name="shader">
<item>Display: <ref id="ridtag" name="RiDisplay tag type">
<item>DisplayMode:
<itemize>
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="npattr" name="NPatch attribute">
</itemize>
<item>Distant: <ref id="pdsl" name="light type">
<item>DBNS: <ref id="bnstag" name="tag type">
<item>Docs: <ref id="prefgui" name="preference setting">
<item>Double Size: <ref id="vmconf" name="view menu entry">
<item>DrawGrid, DrawLevel, DrawSel, DrawBG: <ref id="vat" name="View attribute">
<item>Draw BGImage: <ref id="vmconf" name="view menu entry">
<item>Draw Grid: <ref id="vmconf" name="view menu entry">
<item>Draw Level only: <ref id="vmconf" name="view menu entry">
<item>Draw Object CS: <ref id="vmconf" name="view menu entry">
<item>Draw Selection only: <ref id="vmconf" name="view menu entry">
<item>DrawSub: <ref id="sdmattr" name="SDMesh attribute">
<item>DXF:
<itemize>
<item><ref id="impdxf" name="DXF import plugin">,
<item><ref id="expdxf" name="DXF export plugin">
</itemize>
<item>DynamicLoad: <ref id="riprocp" name="RiProc attribute">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexe"><tt/<bf/E//
<list>
<item>Edit:
<itemize>
<item><ref id="editac" name="edit points">,
<item><ref id="mmedit" name="edit menu">
</itemize>
<item>Edit Local:
<itemize>
<item><ref id="vmconf" name="view menu entry">,
<item><ref id="editlocal" name="Editing in Local Space">
</itemize>
<item>EditSnaps: <ref id="prefmodel" name="preference setting">
<item>EDLen: <ref id="icp" name="ICurve attribute">
<item>EFlush: <ref id="hidprefs" name="hidden preference setting">
<item>Elevate: <ref id="elevt" name="elevate tool">
<item>elevateNC: <ref id="scelevatenc" name="scripting interface command">
<item>Elevate UV: <ref id="elevuvt" name="elevate uv tool">
<item>EnableUndo: <ref id="vat" name="View attribute">
<item>Enable Scripts: <ref id="mmspecial" name="main menu entry">
<item>EndCap:
<itemize>
<item><ref id="extrattr" name="Extrude attribute">,
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="swp" name="Sweep attribute">,
<item><ref id="skp" name="Skin attribute">,
<item><ref id="birail1p" name="Birail1 attribute">,
<item><ref id="birail2p" name="Birail2 attribute">
</itemize>
<item>EnvFile: <ref id="prefgui" name="preference setting">
<item>Environment Variables: <ref id="envvars" name="Environment Variables">
<item>Epsilon: <ref id="moattr" name="MetaObj attributes">
<item>ErrorLevel: <ref id="prefmisc" name="preference setting">
<item>estlenNC: <ref id="scestlennc" name="scripting interface command">
<item>evaluate curve/suface: <ref id="scgetpnt" name="scripting interface command">
<item>ExcludeHidden: <ref id="prefrib" name="preference setting">
<item>Expand: <ref id="treecontm" name="tree context menu entry">
<item>ExpGain, ExpGamma: <ref id="rio" name="RenderMan interface option">
<item>Explode: <ref id="explt" name="Explode tool">
<item>Export:
<itemize>
<item><ref id="exprhino" name="3DM (Rhino) export">,
<item><ref id="exp3dmf" name="3DMF (Apple) export">,
<item><ref id="expdxf" name="AutoCAD DXF Export">,
<item><ref id="expwav" name="OBJ (Wavefront) export">,
<item><ref id="exprib" name="RIB Export">,
<item><ref id="impx3d" name="X3D Export">
</itemize>
<item>Export RIB: <ref id="mmfile" name="main menu entry">
<item>Expression: <ref id="mcattr" name="MetaComp attribute">
<item>Exterior: <ref id="matshader" name="shader">
<item>ExtrNC:
<itemize>
<item><ref id="extrncobj" name="ExtrNC object">,
<item><ref id="extnct" name="extract curve tool">
</itemize>
<item>ExtrNP:
<itemize>
<item><ref id="extrnpobj" name="ExtrNP object">,
<item><ref id="scextrnp" name="scripting interface command">,
<item><ref id="extrnpt" name="extract patch tool">
</itemize>
<item>Extrude:
<itemize>
<item><ref id="extrudeobj" name="Extrude object">,
<item><ref id="extt" name="Extrude tool">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexf"><tt/<bf/F//
<list>
<item>FAQ: <ref id="secref" name="Ayam FAQ WWW reference">
<item>Far: <ref id="camp" name="camera property">
<item>File:
<itemize>
<item><ref id="mmfile" name="file menu">,
<item><ref id="riincp" name="RiInc attribute">,
<item><ref id="riprocp" name="RiProc attribute">
</itemize>
<item>FillGaps:
<itemize>
<item><ref id="concatncp" name="ConcatNC attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
<item>FilterFunc: <ref id="rio" name="RenderMan interface option">
<item>FilterWidth: <ref id="rio" name="RenderMan interface option">
<item>FindU: <ref id="finduac" name="modelling action">
<item>FindUV: <ref id="finduvac" name="modelling action">
<item>FixDialogTitles: <ref id="hidprefs" name="hidden preference setting">
<item>FixImageButtons: <ref id="hidprefs" name="hidden preference setting">
<item>FixX11Menu: <ref id="hidprefs" name="hidden preference setting">
<item>FlashPoints: <ref id="prefmodel" name="preference setting">
<item>Flatness: <ref id="moattr" name="MetaObj attributes">
<item>FontName: <ref id="textattr" name="Text attribute">
<item>forAll, forAllT: <ref id="scforall" name="scripting interface command">
<item>Force Notification: <ref id="mmtools" name="main menu entry">
<item>Formula: <ref id="mcattr" name="MetaComp attribute">
<item>From:
<itemize>
<item><ref id="camp" name="camera property">,
<item><ref id="lip" name="Light attribute">
</itemize>
<item>From Camera:
<itemize>
<item><ref id="mmspecial" name="main menu entry">,
<item><ref id="vmconf" name="view menu entry">
</itemize>
<item>Front: <ref id="vmtype" name="view menu entry">
<item>FTLength:
<itemize>
<item><ref id="concatncp" name="ConcatNC attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexg"><tt/<bf/G//
<list>
<item>getPnt: <ref id="scgetpnt" name="scripting interface command">
<item>getPrefs: <ref id="scgetprefs" name="scripting interface command">
<item>getProperty: <ref id="scgetproperty" name="scripting interface command">
<item>getType: <ref id="scgettype" name="scripting interface command">
<item>Gimbal Lock: <ref id="gimb" name="avoiding gimbal locks">
<item>Global: <ref id="editlocal" name="Editing in Local Spaces">
<item>GlobalMark: <ref id="prefmodel" name="preference setting">
<item>goDown: <ref id="scgodown" name="scripting interface command">
<item>goTop: <ref id="scgotop" name="scripting interface command">
<item>Gordon: <ref id="gordonobj" name="Gordon object">
<item>goUp: <ref id="scgoup" name="scripting interface command">
<item>Grid:
<itemize>
<item><ref id="vat" name="View attribute">,
<item><ref id="prefdraw" name="drawing preference setting">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexh"><tt/<bf/H//
<list>
<item>Half Size: <ref id="vmconf" name="view menu entry">
<item>HandleSize: <ref id="prefmodel" name="preference setting">
<item>hasChild: <ref id="schaschild" name="scripting interface command">
<item>Height:
<itemize>
<item><ref id="rio" name="RenderMan interface option">,
<item><ref id="bxp" name="Box attribute">,
<item><ref id="cnp" name="Cone attribute">,
<item><ref id="npattr" name="NPatch attribute">,
<item><ref id="ipattr" name="IPatch attribute">,
<item><ref id="pmattr" name="PatchMesh attribute">,
<item><ref id="extrattr" name="Extrude attribute">,
<item><ref id="vat" name="View attribute">,
<item><ref id="textattr" name="Text attribute">
</itemize>
<item>Help:
<itemize>
<item><ref id="mmhelp" name="main menu entry">,
<item><ref id="schelp" name="scripting interface command">
</itemize>
<item>Help on object: <ref id="mmhelp" name="main menu entry">
<item>Hidden Preferences: <ref id="hidprefs" name="hidden preference settings">
<item>Hide:
<itemize>
<item><ref id="mmtools" name="main menu entry">,
<item><ref id="attrs" name="attribute">
</itemize>
<item>Hide All: <ref id="mmtools" name="main menu entry">
<item>Hider: <ref id="rihtag" name="RiHider tag type">
<item>Highlight Material: <ref id="mmtools" name="main menu entry">
<item>Hole: <ref id="handb" name="using holes">
<item>hSL: <ref id="schsl" name="scripting interface command">
<item>Hyperboloid: <ref id="hyperboloidobj" name="Hyperboloid object">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexi"><tt/<bf/I//
<list>
<item>IconGamma: <ref id="hidprefs" name="hidden preference setting">
<item>ICurve: <ref id="icurveobj" name="ICurve object">
<item>IDR: <ref id="idr" name="IDR plugin">
<item>IgnoreFirstTrim: <ref id="imprhino" name="3DM (Rhino) import option">
<item>IgnoreHidden: <ref id="exprhino" name="3DM (Rhino) export option">
<item>IgnoreNormals: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>Image: <ref id="prefrib" name="preference setting">
<item>Imager: <ref id="imager" name="property">
<item>Import:
<itemize>
<item><ref id="imprhino" name="3DM (Rhino) Import">,
<item><ref id="imp3dmf" name="3DMF (Apple) Import">,
<item><ref id="impdxf" name="AutoCAD DXF Import">,
<item><ref id="impmops" name="Mops Import">,
<item><ref id="imprib" name="RIB Import">,
<item><ref id="impwav" name="Wavefront OBJ Import">,
<item><ref id="impx3d" name="X3D Import">
</itemize>
<item>Importance Driven Rendering: <ref id="idr" name="IDR plugin">
<item>Insert:
<itemize>
<item><ref id="mmfile" name="main menu entry">,
<item><ref id="insdelac" name="insert points">
</itemize>
<item>insknNC: <ref id="scinsknnc" name="scripting interface command">
<item>insknuNP: <ref id="scinsknunp" name="scripting interface command">
<item>insknvNP: <ref id="scinsknvnp" name="scripting interface command">
<item>Insert Knot: <ref id="insknt" name="insert knot tool">
<item>insertScene: <ref id="scinsertscene" name="scripting interface command">
<item>Instance: <ref id="instanceobj" name="Instance object">
<item>Instant Apply: <ref id="propgui" name="instant apply facility">
<item>Intensity: <ref id="lip" name="Light attribute">
<item>Interior: <ref id="matshader" name="shader">
<item>Interpolation:
<itemize>
<item><ref id="attrs" name="RenderMan/BMRT attribute">,
<item><ref id="icurveobj" name="interpolating curve">,
<item><ref id="swp" name="Sweep attribute">,
<item><ref id="skp" name="Skin attribute">
</itemize>
<item>InterpolCtrl: <ref id="birail2p" name="Birail2 attribute">
<item>Intersection: <ref id="levelobj" name="Level object">
<item>Invert Selection: <ref id="mmspecial" name="main menu entry">
<item>IPatch: <ref id="ipatchobj" name="IPatch object">
<item>IsLocal: <ref id="lip" name="Light attribute">
<item>IsoLevel: <ref id="moattr" name="MetaObj attribute">
<item>IsOn: <ref id="lip" name="Light attribute">
<item>IsRat:
<itemize>
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="npattr" name="NPatch attribute">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexj"><tt/<bf/J//
<list>
<item>JavaScript: <ref id="jsinterp" name="JavaScript Scripting Interface">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexk"><tt/<bf/K//
<list>
<item>kdialog.tcl: <ref id="kdialogtcl" name="example/helper script">
<item>Keyboard Shortcuts:
<itemize>
<item><ref id="mwsc" name="main window shortcuts">,
<item><ref id="mm" name="main menu shortcuts">,
<item><ref id="vwsc" name="view window shortcuts">,
<item><ref id="vm" name="main menu shortcuts">,
<item><ref id="treesc" name="object tree shortcuts">,
<item><ref id="olbsc" name="object list shortcuts">,
</itemize>

<item>Kill: <ref id="hidprefs" name="hidden preference setting">
<item>Knots: <ref id="ncattr" name="NCurve attribute">
<item>Knot-Type:
<itemize>
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="concatncp" name="ConcatNC attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
<item>Knot-Type_U:
<itemize>
<item><ref id="npattr" name="NPatch attribute">,
<item><ref id="ipattr" name="IPatch attribute">,
<item><ref id="skp" name="Skin attribute">
</itemize>
<item>Knot-Type_V:
<itemize>
<item><ref id="npattr" name="NPatch attribute">,
<item><ref id="ipattr" name="IPatch attribute">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexl"><tt/<bf/L//
<list>
<item>Last (None): <ref id="mmtools" name="main menu entry">
<item>LazyNotify: <ref id="prefmodel" name="preference setting">
<item>Length:
<itemize>
<item><ref id="bxp" name="Box attribute">,
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="acp" name="ACurve attribute">,
<item><ref id="icp" name="ICurve attribute">
</itemize>
<item>Level:
<itemize>
<item><ref id="levelobj" name="Level object">,
<item><ref id="sdmattr" name="SDMesh attribute">,
<item><ref id="sdnpattr" name="SDNPatch attribute">
</itemize>
<item>Light:
<itemize>
<item><ref id="lightobj" name="Light object">,
<item><ref id="prefdraw" name="preference setting">
</itemize>
<item>LightAttr: <ref id="lip" name="property">
<item>LightShader: <ref id="lightobj" name="light">
<item>LineWidth: <ref id="hidprefs" name="hidden preference setting">
<item>ListTypes: <ref id="hidprefs" name="hidden preference setting">
<item>LoadEnv: <ref id="hidprefs" name="hidden preference settings">
<item>Load Plugin: <ref id="mmfile" name="main menu entry">
<item>Local:
<itemize>
<item><ref id="vat" name="View attribute">,
<item><ref id="editlocal" name="Editing in Local Spaces">
</itemize>
<item>Locale: <ref id="prefgui" name="preference setting">
<item>Loft: <ref id="skinobj" name="Skin object">
<item>LogFile: <ref id="prefgui" name="preference setting">
<item>Logging: <ref id="prefgui" name="preference setting">
<item>LowerBevel: <ref id="extrattr" name="Extrude attribute">,
<item><ref id="textattr" name="Text attribute">
<item>LowerCap:
<itemize>
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="textattr" name="Text attribute">
</itemize>
<item>Lua: <ref id="luainterp" name="Lua Scripting Interface">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexm"><tt/<bf/M//
<list>
<item>MajorRad: <ref id="top" name="Torus attribute">
<item>Make Compatible: <ref id="makecompt" name="NCurve tool">
<item>Mark: <ref id="vat" name="View attribute">
<item>MarkHidden: <ref id="hidprefs" name="hidden preference settings">
<item>Master: <ref id="mmedit" name="edit menu entry">
<item>Material:
<itemize>
<item><ref id="materialobj" name="Material object">,
<item><ref id="mmedit" name="edit menu entry">
</itemize>
<item>Materialname:
<itemize>
<item><ref id="matattr" name="attribute">,
<item><ref id="matprop" name="material property attribute">
</itemize>
<item>MaxRayLevel: <ref id="rio" name="RenderMan interface option">
<item>MaxTagLen: <ref id="hidprefs" name="hidden preference settings">
<item>MaxX, MaxY, MaxZ: <ref id="riprocp" name="RiProc attribute">
<item>Menu:
<itemize>
<item><ref id="mm" name="main menu">,
<item><ref id="vm" name="view menu">,
<item><ref id="treecontm" name="tree context menu">,
<item><ref id="lbcontm" name="listbox context menu">
</itemize>
<item>Merge: <ref id="mmtools" name="Merge PolyMesh tool">
<item>MergeFaces <ref id="impwav" name="Wavefront OBJ import option">
<item>MergePVTags <ref id="impwav" name="Wavefront OBJ import option">
<item>MetaObj, MetaComp: <ref id="metaobjobj" name="MetaObj object">
<item>MFIO Plugin:
<itemize>
<item><ref id="imp3dmf" name="3DMF (Apple) import">,
<item><ref id="exp3dmf" name="3DMF (Apple) export">
</itemize>
<item>MinorRad: <ref id="top" name="Torus attribute">
<item>MinSamples, MaxSamples: <ref id="rio" name="RenderMan interface option">
<item>MinX, MinY, MinZ: <ref id="riprocp" name="RiProc attribute">
<item>Mirror: <ref id="mirrorobj" name="Mirror object">
<item>Modelling: <ref id="iac" name="Modelling Actions">
<item>Mode: <ref id="offsetncp" name="OffsetNC attribute">
<item>Mops Import: <ref id="impmops" name="Import of Mops Scenes">
<item>Move:
<itemize>
<item><ref id="vwsc" name="view action">,
<item><ref id="iac" name="modelling action">
</itemize>
<item>movOb: <ref id="scmovob" name="scripting interface command">
<item>movPnts: <ref id="scmovpnts" name="scripting interface command">
<item>Multiple Point: <ref id="ncurvemp" name="Multiple Points">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexn"><tt/<bf/N//
<list>
<item>NCDisplayMode: <ref id="prefdraw" name="preference setting">
<item>NCircle: <ref id="ncircleobj" name="NCircle object">
<item>NCurve: <ref id="ncurveobj" name="NCurve object">
<item>Near: <ref id="camp" name="camera property">
<item>Negative: <ref id="mcattr" name="MetaComp attribute">
<item>Network Surface: <ref id="gordonobj" name="Gordon object">
<item>New: <ref id="mmfile" name="main menu entry">
<item>NewLoadsEnv: <ref id="hidprefs" name="hidden preference settings">
<item>newScene: <ref id="scnewscene" name="scripting interface command">
<item>NoExport: <ref id="noexporttag" name="tag type">
<item>notifyOb: <ref id="scnotifyob" name="scripting interface command">
<item>NP: <ref id="nptag" name="tag type">
<item>NPatch: <ref id="npatchobj" name="NPatch object">
<item>NPDisplayMode: <ref id="prefdraw" name="preference setting">
<item>NumClones: <ref id="cloneattr" name="Clone attribute">
<item>NumSamples: <ref id="moattr" name="MetaObj attribute">
<item>NURBCircle: <ref id="ncirct" name="NURBS circle tool">
<item>NURBCurve: <ref id="ncurveobj" name="NCurve object">
<item>NURBPatch: <ref id="npatchobj" name="NPatch object">
<item>NURBS: <ref id="scinurbs" name="scripting interface commands">
<item>NURBSphere: <ref id="nspt" name="NURBS sphere tool">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexo"><tt/<bf/O//
<list>
<item>ObeyNoExport: <ref id="exprhino" name="3DM (Rhino) export option">
<item>OBJ:
<itemize>
<item><ref id="impwav" name="Wavefront OBJ import">,
<item><ref id="expwav" name="Wavefront OBJ export">
</itemize>
<item>Object: <ref id="prefdraw" name="preference setting">
<item>Objectname: <ref id="attrs" name="attribute">
<item>Objects:
<itemize>
<item><ref id="obj" name="tree/listbox">,
<item><ref id="objsel" name="selection within a view">
</itemize>
<item>OffsetNC: <ref id="offsetncobj" name="OffsetNC object">
<item>OffsetNP: <ref id="offsetnpobj" name="OffsetNP object">
<item>OI: <ref id="oitt" name="tag type">
<item>Open:
<itemize>
<item><ref id="mmfile" name="main menu entry">,
<item><ref id="treecontm" name="tree context menu entry">
</itemize>
<item>OpenNURBS:
<itemize>
<item><ref id="imprhino" name="3DM (Rhino) Import">,
<item><ref id="exprhino" name="3DM (Rhino) Export">
</itemize>
<item>Optimize: <ref id="mmtools" name="Optimize PolyMesh tool">
<item>OptimizeCoords: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeFaces: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeNew: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Option: <ref id="riotag" name="RiOption tag type">
<item>Order:
<itemize>
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="npattr" name="NPatch attribute">,
<item><ref id="acp" name="ACurve attribute">,
<item><ref id="icp" name="ICurve attribute">,
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
<item>Order_U:
<itemize>
<item><ref id="skp" name="Skin attribute">,
<item><ref id="ipattr" name="IPatch attribute">
</itemize>
<item>Order_V: <ref id="ipattr" name="IPatch attribute">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexp"><tt/<bf/P//
<list>
<item>P1, P2: <ref id="hyp" name="Hyperboloid attribute">
<item>PaneMargins: <ref id="hidprefs" name="hidden preference setting">
<item>Paraboloid: <ref id="paraboloidobj" name="Paraboloid object">
<item>Parameter: <ref id="extrncp" name="ExtrNC attribute">
<item>Parameter Object: <ref id="toolobj" name="modelling concept">
<item>ParamType: <ref id="icp" name="ICurve attribute">
<item>pasOb: <ref id="scpasob" name="scripting interface command">
<item>Paste: <ref id="mmedit" name="main menu entry">
<item>Paste (Move): <ref id="mmspecial" name="main menu entry">
<item>Paste Property: <ref id="mmedit" name="main menu entry">
<item>PatchMesh: <ref id="patchmeshobj" name="PatchMesh object">
<item>PatchNum:
<itemize>
<item><ref id="extrncp" name="ExtrNC attribute">,
<item><ref id="selectp" name="Select attribute">,
<item><ref id="trimp" name="Trim attribute">
</itemize>
<item>PatchSamples: <ref id="rio" name="RenderMan interface option">
<item>Perspective: <ref id="vmtype" name="view menu entry">
<item>PhiMin, PhiMax: <ref id="top" name="Torus attribute">
<item>Pick: <ref id="objsel" name="pick objects within a view">
<item>PickEpsilon: <ref id="prefmodel" name="preference setting">
<item>PickTolerance: <ref id="hidprefs" name="hidden preference setting">
<item>Pivot: <ref id="rotaac" name="modelling action">
<item>Plane: <ref id="mirrorattr" name="Mirror attribute">
<item>Plot Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Point: <ref id="pdsl" name="light type">
<item>polyhedron.js: <ref id="polyhedronjs" name="example/helper script">
<item>PolyMesh: <ref id="polymeshobj" name="PolyMesh object">
<item>PolyOffset: <ref id="hidprefs" name="hidden preference setting">
<item>PPRender: <ref id="prefrib" name="preference setting">
<item>Preferences:
<itemize>
<item><ref id="prefs" name="Preferences">,
<item><ref id="hidprefs" name="hidden preference settings">
</itemize>
<item>Procedurals: <ref id="rio" name="RenderMan interface option">
<item>Prompt: <ref id="hidprefs" name="hidden preference setting">
<item>Properties: <ref id="propgui" name="property GUI">
<item>Primitive: <ref id="levelobj" name="Level object">
<item>Primitive Variable: <ref id="pvtag" name="tag type">
<item>PRManSpec: <ref id="rio" name="RenderMan interface option">
<item>PV: <ref id="pvtag" name="tag type">
<item>PVColorName: <ref id="hidprefs" name="hidden preference setting">
<item>PVNormalName: <ref id="hidprefs" name="hidden preference setting">
<item>PVTexCoordName: <ref id="hidprefs" name="hidden preference setting">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexq"><tt/<bf/Q//
<list>
<item>QuadAsBRep: <ref id="exprhino" name="3DM (Rhino) export option">
<item>QRender: <ref id="prefrib" name="preference setting">
<item>QRenderPT, QRenderUI: <ref id="prefrib" name="preference setting">
<item>Quat: <ref id="trap" name="transformations property">
<item>QuickDraw 3D Metafile:
<itemize>
<item><ref id="imp3dmf" name="3DMF import">,
<item><ref id="exp3dmf" name="3DMF export">
</itemize>
<item>Quick Render: <ref id="vm" name="view menu entry">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexr"><tt/<bf/R//
<list>
<item>Radius:
<itemize>
<item><ref id="spattr" name="Sphere attribute">,
<item><ref id="dkp" name="Disk attribute">,
<item><ref id="cnp" name="Cone attribute">,
<item><ref id="cyp" name="Cylinder attribute">,
<item><ref id="ncircleattrprop" name="NCircle attribute">,
<item><ref id="mcattr" name="MetaComp attribute">
</itemize>
<item>RadSteps: <ref id="rio" name="RenderMan interface option">
<item>ReadCurves:
<itemize>
<item><ref id="impdxfopt" name="DXF import option">,
<item><ref id="imp3dmfopt" name="3DMF (Apple) import option">,
<item><ref id="impwav" name="Wavefront OBJ import/export option">,
<item><ref id="imprhino" name="3DM (Rhino) import option">,
<item><ref id="impx3dopt" name="X3D import option">
</itemize>
<item>ReadFrame, ReadCamera, ReadOptions, ReadLights, ReadMaterial,
ReadPartial: <ref id="rribopt" name="RIB import option">
<item>ReadLayers:
<itemize>
<item><ref id="impdxfopt" name="DXF import option">,
<item><ref id="imprhino" name="3DM (Rhino) import option">
</itemize>
<item>ReadSTrim:
<itemize>
<item><ref id="impwav" name="Wavefront OBJ import option">,
<item><ref id="imprhino" name="3DM (Rhino) import option">,
<item><ref id="rribopt" name="RIB import option">,
<item><ref id="impx3dopt" name="X3D import option">
</itemize>
<item>Rebuild: <ref id="treecontm" name="tree context menu entry">
<item>Rectangle: <ref id="trrt" name="TrimRect tool">
<item>RedirectTcl: <ref id="prefmisc" name="preference setting">
<item>Redo:
<itemize>
<item><ref id="undos" name="The Undo System">,
<item><ref id="mmedit" name="main menu entry">
</itemize>
<item>Redraw:
<itemize>
<item><ref id="vm" name="view menu entry">,
<item><ref id="incds" name="speeding up">,
<item><ref id="vat" name="View attribute">
</itemize>
<item>Refcount: <ref id="attrs" name="attribute">
<item>Reference Counter:
<itemize>
<item><ref id="instanceobj" name="Instance Object">,
<item><ref id="materialobj" name="Material Object">
</itemize>
<item>Reference: <ref id="referencing" name="Reference">
<item>References: <ref id="secref" name="references">
<item>Refine:
<itemize>
<item><ref id="refit" name="curve tool">,
<item><ref id="refinest" name="surface tool">
</itemize>
<item>Refine Knots: <ref id="refknit" name="Refine Knots Tool">
<item>refineNC: <ref id="screfinenc" name="scripting interface command">
<item>refineuNP: <ref id="screfineunp" name="scripting interface command">
<item>refinevNP: <ref id="screfinevnp" name="scripting interface command">
<item>Relative:
<itemize>
<item><ref id="extrncp" name="ExtrNC attribute">,
<item><ref id="extrnpp" name="ExtrNP attribute">
</itemize>
<item>remknNC: <ref id="scremknnc" name="scripting interface command">
<item>remknuNP: <ref id="scremknunp" name="scripting interface command">
<item>remknvNP: <ref id="scremknvnp" name="scripting interface command">
<item>Remove Knot: <ref id="remknt" name="remove knot tool">
<item>RemoveMerged: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Render:
<itemize>
<item><ref id="vm" name="view menu entry">,
<item><ref id="prefrib" name="preference setting">
</itemize>
<item>Renderer: <ref id="mmspecial" name="select a different renderer">
<item>RenderMode: <ref id="prefrib" name="preference setting">
<item>RenderPT, RenderUI: <ref id="prefrib" name="preference setting">
<item>Repair Ayam: <ref id="repayam" name="Tcl helper script">
<item>Reparameterise: <ref id="screparamnc" name="scripting interface command">
<item>Replace: <ref id="mmspecial" name="main menu entry">
<item>replaceScene: <ref id="screplacescene" name="scripting interface command">
<item>Rescale Knots to Mindist: <ref id="resckmt" name="NURBCurve tool">
<item>Rescale Knots to Range: <ref id="resckrt" name="NURBCurve tool">
<item>rescaleknNC: <ref id="screscaleknnc" name="scripting interface command">
<item>rescaleknNP: <ref id="screscaleknnp" name="scripting interface command">
<item>RescaleKnots:
<itemize>
<item><ref id="impdxfopt" name="DXF import option">,
<item><ref id="imprhino" name="3DM (Rhino) import option">,
<item><ref id="imprib" name="RIB import option">,
<item><ref id="impwav" name="Wavefront OBJ import option">
</itemize>
<item>Reset: <ref id="propgui" name="reset property GUI">
<item>ResetDM, ResetST: <ref id="impmops" name="Mops import option">
<item>Reset Preferences: <ref id="mmspecial" name="main menu entry">
<item>ResInstances: <ref id="prefrib" name="preference setting">
<item>Resolve all Instances: <ref id="mmspecial" name="main menu entry">
<item>ResolveInstances: <ref id="expx3dopt" name="X3D (Web3D) export option">
<item>Revert:
<itemize>
<item><ref id="revertt" name="Revert tool">,
<item><ref id="textattr" name="Text attribute">,
<item><ref id="concatncp" name="ConcatNC attribute">,
<item><ref id="offsetncp" name="OffsetNC attribute">,
<item><ref id="extrncp" name="ExtrNC attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
<item>RevertBevels: <ref id="textattr" name="Text attribute">
<item>revertC: <ref id="screvertc" name="scripting interface command">
<item>RevertU, RevertV:
<itemize>
<item><ref id="revertut" name="Revert U tool">,
<item><ref id="revertvt" name="Revert V tool">
</itemize>
<item>Revolve:
<itemize>
<item><ref id="revolveobj" name="Revolve object">,
<item><ref id="revt" name="Revolve tool">
</itemize>
<item>RGBA_ONE, RGBA_MIN, RGBA_MAX, RGBA_Dither:
<ref id="rio" name="RenderMan interface option">
<item>Rhino:
<itemize>
<item><ref id="imprhino" name="3DM (Rhino) Import">,
<item><ref id="exprhino" name="3DM (Rhino) Export">
</itemize>
<item>RiAttribute:
<itemize>
<item><ref id="riattrs" name="property">,
<item><ref id="riatag" name="tag type">,
<item><ref id="rioptdb" name="RiOption and RiAttributes Database">
</itemize>
<item>RIB import: <ref id="imprib" name="RIB Import">
<item>RIBFile: <ref id="prefrib" name="preference setting">
<item>RiDisplay: <ref id="ridtag" name="tag type">
<item>RiHider: <ref id="rihtag" name="tag type">
<item>RiInc: <ref id="riincobj" name="RiInc object">
<item>RiOption: <ref id="riotag" name="tag type">
<item>RiOptions:
<itemize>
<item><ref id="rio" name="RenderMan interface options property">,
<item><ref id="rioptdb" name="RiOption and RiAttributes Database">
</itemize>
<item>RIStandard: <ref id="prefrib" name="preference setting">
<item>RMax: <ref id="pap" name="Paraboloid attribute">
<item>Roll: <ref id="camp" name="Camera attribute">
<item>Root: <ref id="rootobj" name="Root object">
<item>Rotate:
<itemize>
<item><ref id="vwsc" name="view action">,
<item><ref id="rotac" name="modelling action">,
<item><ref id="swp" name="Sweep attribute">,
<item><ref id="cloneattr" name="Clone attribute">
</itemize>
<item>Rotation:
<itemize>
<item><ref id="trap" name="transformations property">,
<item><ref id="gimb" name="using the transformations property">
</itemize>
<item>Rotational Sweep: <ref id="swingobj" name="Swing object">
<item>rotOb: <ref id="scrotob" name="scripting interface command">
<item>rotPnts: <ref id="scrotpnts" name="scripting interface command">
<item>RP: <ref id="rptag" name="tag type">
<item>Ruled surface: <ref id="skinobj" name="Skin object">
<item>RunProgram: <ref id="riprocp" name="RiProc attribute">
<item>rV: <ref id="scrv" name="scripting interface command">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexs"><tt/<bf/S//
<list>
<item>SafeAutoFocus: <ref id="hidprefs" name="hidden preference setting">
<item>Samples: <ref id="lip" name="Light attribute">
<item>Samples_X: <ref id="rio" name="RenderMan interface option">
<item>Samples_Y: <ref id="rio" name="RenderMan interface option">
<item>Save: <ref id="mmfile" name="main menu entry">
<item>Save as: <ref id="mmfile" name="main menu entry">
<item>Save Prefs: <ref id="mmfile" name="main menu entry">
<item>SaveAddsMRU: <ref id="prefmisc" name="preference setting">
<item>SaveMainGeom: <ref id="savemaingeomtag" name="tag type">
<item>SavePaneLayout: <ref id="savepanelayouttag" name="tag type">
<item>SavePrefsGeom: <ref id="prefmisc" name="preference setting">
<item>saveScene: <ref id="scsavescene" name="scripting interface command">
<item>Scale:
<itemize>
<item><ref id="trap" name="transformations property">,
<item><ref id="scalac" name="modelling action">
</itemize>
<item>ScaleFactor:
<itemize>
<item><ref id="impdxfopt" name="DXF import option">,
<item><ref id="expdxfopt" name="DXF export option">,
<item><ref id="imprhino" name="3DM (Rhino) import option">,
<item><ref id="exprhino" name="3DM (Rhino) export option">,
<item><ref id="impwav" name="Wavefront OBJ import option">,
<item><ref id="expwav" name="Wavefront OBJ export option">,
<item><ref id="rribopt" name="RIB import option">
</itemize>
<item>scalOb <ref id="scscalob" name="scripting interface command">
<item>scalPnts <ref id="scscalpnts" name="scripting interface command">
<item>Scan Shaders: <ref id="mmspecial" name="main menu entry">
<item>Scheme: <ref id="sdmattr" name="SDMesh attribute">
<item>Script:
<itemize>
<item><ref id="script" name="scripting interface">,
<item><ref id="scriptobj" name="Script object">
</itemize>
<item>Scripts: <ref id="prefgui" name="preference setting">
<item>SDLen: <ref id="icp" name="ICurve attribute">
<item>SDMesh: <ref id="sdmeshobj" name="SDMesh object">
<item>SDNPatch: <ref id="sdnpatchobj" name="SDNPatch object">
<item>Sections:
<itemize>
<item><ref id="swp" name="Sweep attribute">,
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="birail1p" name="Birail1 attribute">,
<item><ref id="birail2p" name="Birail2 attribute">
</itemize>
<item>Select:
<itemize>
<item><ref id="selectobj" name="Select object">,
<item><ref id="obj" name="select objects with the tree/listbox">,
<item><ref id="objsel" name="select objects within a view">,
<item><ref id="selac" name="select points">
</itemize>
<item>Select All: <ref id="mmedit" name="main menu entry">
<item>Select None: <ref id="mmedit" name="main menu entry">
<item>Selected Objects: <ref id="mmspecial" name="main menu entry">
<item>Select Renderer: <ref id="mmspecial" name="main menu entry">
<item>Selection: <ref id="prefdraw" name="preference setting">
<item>SelLineWidth: <ref id="hidprefs" name="hidden preference setting">
<item>selOb: <ref id="scselob" name="scripting interface command">
<item>SelXOR_R, SelXOR_G, SelXOR_B: <ref id="hidprefs" name="hidden preference setting">
<item>Set BGImage: <ref id="vmconf" name="view menu entry">
<item>Set Gridsize: <ref id="vmconf" name="view menu entry">
<item>Set FOV: <ref id="vmconf" name="view menu entry">
<item>SetMark: <ref id="vat" name="View attribute">
<item>setPnt: <ref id="scsetpnt" name="scripting interface command">
<item>setPrefs: <ref id="scsetprefs" name="scripting interface command">
<item>setProperty: <ref id="scsetproperty" name="scripting interface command">
<item>Shade:
<itemize>
<item><ref id="prefdraw" name="preference setting">,
<item><ref id="vmconf" name="view menu entry">
</itemize>
<item>Shader: <ref id="shd" name="properties">
<item>Shader Parsing: <ref id="spplugins" name="shader parsing plugins">
<item>Shaders:
<itemize>
<item><ref id="prefmain" name="preference setting">,
<item><ref id="rio" name="RenderMan interface option">,
<item><ref id="scishaders" name="scripting interface commands">
</itemize>
<item>ShadingRate: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>ShadowBias: <ref id="rio" name="RenderMan interface option">
<item>ShadowMaps:
<itemize>
<item><ref id="prefrib" name="preference setting">,
<item><ref id="shadowmaps" name="using shadowmaps">
</itemize>
<item>Shadows: <ref id="lip" name="Light attribute">
<item>Shift Closed Curve:
<item><ref id="shiftclc" name="shift closed curve tool">
<item>ShiftTab: <ref id="hidprefs" name="hidden preference setting">
<item>Show: <ref id="mmtools" name="main menu entry">
<item>Show All: <ref id="mmtools" name="main menu entry">
<item>Show Shortcuts: <ref id="mmhelp" name="main menu entry">
<item>Show Tooltips: <ref id="mmhelp" name="main menu entry">
<item>Side:
<itemize>
<item><ref id="vmtype" name="view menu entry">,
<item><ref id="extrncp" name="ExtrNC attribute">
</itemize>
<item>SingleWindow: <ref id="prefmain" name="preference setting">
<item>Skin:
<itemize>
<item><ref id="skinobj" name="Skin object">,
<item><ref id="skit" name="Skin tool">
</itemize>
<item>sL: <ref id="scsl" name="scripting interface command">
<item>SMChangeShaders: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMFileFormat: <ref id="prefrib" name="preference setting">
<item>SMFileType: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMRender, SMRenderUI, SMRenderPT: <ref id="prefrib" name="preference setting">
<item>SMRes: <ref id="lip" name="Light attribute">
<item>Snap Points to Grid: <ref id="snapac" name="modelling action">
<item>Snap3D: <ref id="prefmodel" name="preference setting">
<item>SP: <ref id="scriptattrprop" name="Script object">
<item>SParamU, SParamV: <ref id="prefmisc" name="preference setting">
<item>Special: <ref id="mmspecial" name="special menu">
<item>Sphere:
<itemize>
<item><ref id="sphereobj" name="Sphere object">,
<item><ref id="nspt" name="NURBS sphere tool">
</itemize>
<item>Split:
<itemize>
<item><ref id="sptct" name="split to curves tool">,
<item><ref id="mmtools" name="split polymesh tool">
</itemize>
<item>Split Curve: <ref id="splitncac" name="modelling action">
<item>splitNC: <ref id="scsplitnc" name="scripting interface command">
<item>splitNP: <ref id="scsplitnp" name="scripting interface command">
<item>splituNP: <ref id="scsplitunp" name="scripting interface command">
<item>splitvNP: <ref id="scsplitvnp" name="scripting interface command">
<item>Spot: <ref id="pdsl" name="light type">
<item>StartCap:
<itemize>
<item><ref id="extrattr" name="Extrude attribute">,
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="swp" name="Sweep attribute">,
<item><ref id="skp" name="Skin attribute">,
<item><ref id="birail1p" name="Birail1 attribute">,
<item><ref id="birail2p" name="Birail2 attribute">
</itemize>
<item>StdDisplay: <ref id="rio" name="RenderMan interface option">
<item>Step_U, Step_V: <ref id="pmattr" name="PatchMesh attribute">
<item>StepSize: <ref id="moattr" name="MetaObj attributes">
<item>Stretch: <ref id="scalac" name="stretch object">
<item>String: <ref id="textattr" name="Text attribute">
<item>Subdivision Mesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Surface: <ref id="matshader" name="shader">
<item>SwapMB: <ref id="hidprefs" name="hidden preference setting">
<item>Swap UV: <ref id="swapuvt" name="swap uv tool">
<item>swapuvS <ref id="scswapuvs" name="scripting interface command">
<item>Sweep:
<itemize>
<item><ref id="sweepobj" name="Sweep object">,
<item><ref id="swpt" name="Sweep tool">
</itemize>
<item>Swing: <ref id="swingobj" name="Swing object">
<item>Symmetric: <ref id="acp" name="ACurve attribute">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indext"><tt/<bf/T//
<list>
<item>Tag: <ref id="prefdraw" name="preference setting">
<item>Tags:
<itemize>
<item><ref id="tags" name="tags property">,
<item><ref id="scitags" name="scripting interface commands">
</itemize>
<item>TC: <ref id="tctag" name="tag type">
<item>tcleval:
<itemize>
<item><ref id="tcleval" name="JavaScript scripting interface function">,
<item><ref id="luatcleval" name="Lua scripting interface function">
</itemize>
<item>TclPrecision: <ref id="prefmisc" name="preference setting">
<item>tclset:
<itemize>
<item><ref id="tclset" name="JavaScript scripting interface function">,
<item><ref id="luatcleval" name="Lua scripting interface function">
</itemize>
<item>tclvar:
<itemize>
<item><ref id="tclvar" name="JavaScript scripting interface function">
<item><ref id="luatcleval" name="Lua scripting interface function">
</itemize>
<item>Tesselate: <ref id="tesst" name="tesselation tool">
<item>TessPoMesh <ref id="expwav" name="Wavefront OBJ export option">
<item>Text: <ref id="textobj" name="Text object">
<item>Textures: <ref id="rio" name="RenderMan interface option">
<item>Texture Coordinates:
<itemize>
<item><ref id="tctag" name="tag type">,
<item><ref id="tce" name="texture coordinate editor">
</itemize>
<item>ThetaMax:
<itemize>
<item><ref id="spattr" name="Sphere attribute">,
<item><ref id="dkp" name="Disk attribute">,
<item><ref id="cnp" name="Cone attribute">,
<item><ref id="cyp" name="Cylinder attribute">,
<item><ref id="top" name="Torus attribute">,
<item><ref id="pap" name="Paraboloid attribute">,
<item><ref id="hyp" name="Hyperboloid attribute">,
<item><ref id="rep" name="Revolve attribute">
</itemize>
<item>Threshold: <ref id="moattr" name="MetaObj attributes">
<item>TMin, TMax: <ref id="ncircleattrprop" name="NCircle attribute">
<item>TmpDir: <ref id="prefgui" name="preference setting">
<item>To:
<itemize>
<item><ref id="camp" name="camera property">,
<item><ref id="lip" name="Light attribute">
</itemize>
<item>To Camera: <ref id="vmconf" name="view menu entry">
<item>Toggle Toolbox: <ref id="mmspecial" name="main menu entry">
<item>Toggle TreeView: <ref id="mmspecial" name="main menu entry">
<item>Tolerance:
<itemize>
<item><ref id="prefdraw" name="preference setting">,
<item><ref id="ncattr" name="NCurve attribute">,
<item><ref id="npattr" name="NPatch attribute">
</itemize>
<item>tonpatch.tcl: <ref id="tonpatchtcl" name="example/helper script">
<item>Tool Objects: <ref id="toolobj" name="modelling concept">
<item>Toolbox: <ref id="toolb" name="toolbox window">
<item>toolBoxList: <ref id="hidprefs" name="hidden preference setting">
<item>ToolBoxShrink: <ref id="hidprefs" name="hidden preference setting">
<item>ToolBoxTrans: <ref id="hidprefs" name="hidden preference setting">
<item>Tools: <ref id="mmtools" name="tools menu">
<item>Top: <ref id="vmtype" name="view menu entry">
<item>TopLevelLayers:
<itemize>
<item><ref id="expdxfopt" name="DXF export option">,
<item><ref id="exp3dmopt" name="3DM (Rhino) export option">,
<item><ref id="expx3dopt" name="X3D (Web3D) export option">
</itemize>
<item>topoly.tcl: <ref id="topolytcl" name="example/helper script">
<item>Torus: <ref id="torusobj" name="Torus object">
<item>To XY: <ref id="toxyt" name="To XY tool">
<item>TP: <ref id="tptag" name="tag type">
<item>Transformations: <ref id="trap" name="transformations property">
<item>Translation: <ref id="trap" name="transformations property">
<item>Tree View: <ref id="treeview" name="Tree View">
<item>Trim:
<itemize>
<item><ref id="trimobj" name="Trim object">,
<item><ref id="vmtype" name="view menu entry">
</itemize>
<item>Trim Curve: <ref id="trim" name="using trim curves">
<item>trimNC: <ref id="sctrimnc" name="scripting interface command">
<item>TrimRect: <ref id="trrt" name="TrimRect tool">
<item>TrueDisp: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>TwmCompat: <ref id="prefgui" name="preference setting">
<item>Type:
<itemize>
<item><ref id="levelobj" name="Level attribute">,
<item><ref id="lip" name="Light attribute">,
<item><ref id="pmattr" name="PatchMesh attribute">,
<item><ref id="vat" name="View attribute">,
<item><ref id="scriptattr" name="Script attribute">,
<item><ref id="riprocp" name="RiProc attribute">,
<item><ref id="capattrprop" name="Cap attribute">,
<item><ref id="ncurveattrprop" name="NCurve attribute">,
<item><ref id="icp" name="ICurve attribute">,
<item><ref id="concatnpp" name="ConcatNP attribute">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexu"><tt/<bf/U//
<list>
<item>uCL: <ref id="scucl" name="scripting interface command">
<item>uCR: <ref id="scucr" name="scripting interface command">
<item>UMM: <ref id="ummtag" name="tag type">
<item>Undo:
<itemize>
<item><ref id="undos" name="The Undo System">,
<item><ref id="mmedit" name="main menu entry">,
<item><ref id="scundo" name="scripting interface command">
</itemize>
<item>UndoLevels: <ref id="prefmodel" name="preference setting">
<item>Union: <ref id="levelobj" name="Level object">
<item>UpperCap:
<itemize>
<item><ref id="rep" name="Revolve attribute">,
<item><ref id="textattr" name="Text attribute">
</itemize>
<item>Up Vector: <ref id="camp" name="camera property">
<item>uS: <ref id="scus" name="scripting interface command">
<item>useaqsisapp.tcl: <ref id="useaqsisapptcl" name="example/helper script">
<item>UseGrid:
<itemize>
<item><ref id="vat" name="View attribute">,
<item><ref id="vmconf" name="view menu entry">
</itemize>
<item>UseInternalFD: <ref id="hidprefs" name="hidden preference setting">
<item>UseMatColor: <ref id="prefdraw" name="preference setting">
<item>usepixie.tcl: <ref id="usepixietcl" name="example/helper script">
<item>UseSM: <ref id="lip" name="Light attribute">
<item>UVSelect: <ref id="concatnpp" name="ConcatNP attribute">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexv"><tt/<bf/V//
<list>
<item>Variance: <ref id="rio" name="RenderMan interface option">
<item>View:
<itemize>
<item><ref id="viewobj" name="View object">,
<item><ref id="viewwin" name="Anatomy of a View">
</itemize>
<item>ViewAttrib: <ref id="vat" name="property">
<item>VMM: <ref id="ummtag" name="tag type">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexw"><tt/<bf/W//
<list>
<item>Wait: <ref id="hidprefs" name="hidden preference setting">
<item>WarnPropPasteToSel: <ref id="hidprefs" name="hidden preference setting">
<item>WarnUnknownTag: <ref id="hidprefs" name="hidden preference setting">
<item>Wavefront OBJ:
<itemize>
<item><ref id="impwav" name="Wavefront OBJ import">,
<item><ref id="expwav" name="Wavefront OBJ export">
</itemize>
<item>Weight: <ref id="iac" name="single point weight editing">
<item>WheelZoom: <ref id="hidprefs" name="hidden preference setting">
<item>Width:
<itemize>
<item><ref id="rio" name="RenderMan interface option">,
<item><ref id="bxp" name="Box attribute">,
<item><ref id="npattr" name="NPatch attribute">,
<item><ref id="ipattr" name="IPatch attribute">,
<item><ref id="pmattr" name="PatchMesh attribute">,
<item><ref id="vat" name="View attribute">
</itemize>
<item>withOb: <ref id="scwithob" name="scripting interface command">
<item>wrib: <ref id="scwrib" name="scripting interface command">
<item>WriteCurves:
<itemize>
<item><ref id="impwav" name="Wavefront OBJ import/export option">,
<item><ref id="exprhino" name="3DM (Rhino) export option">
</itemize>
<item>WriteParametrics: <ref id="expx3dopt" name="X3D (Web3D) export option">
<item>WriteIdent: <ref id="prefrib" name="preference setting">
<item>WriteSelected:
<itemize>
<item><ref id="exprhino" name="3DM (Rhino) export option">,
<item><ref id="expwav" name="Wavefront OBJ export option">
</itemize>
<item>WriteViews: <ref id="expx3dopt" name="X3D (Web3D) export option">
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexx"><tt/<bf/X//
<list>
<item>X3D:
<itemize>
<item><ref id="impx3d" name="X3D (Web3D) Import">,
<item><ref id="expx3d" name="X3D (Web3D) Export">
</itemize>
</list>

<#if out=latex><x/phantomsection/</#if>

<label id="indexy"><tt/<bf/Y//
<list>
<item>.
</list>


<#if out=latex><x/phantomsection/</#if>

<label id="indexz"><tt/<bf/Z//
<list>
<item>Zap Ayam: <ref id="mmspecial" name="main menu entry">
<item>zap.tcl: <ref id="zaptcl" name="example/helper script">
<item>zdialog.tcl: <ref id="zdialogtcl" name="example/helper script">
<item>ZMin, ZMax:
<itemize>
<item><ref id="spattr" name="Sphere attribute">,
<item><ref id="dkp" name="Disk attribute">,
<item><ref id="cyp" name="Cylinder attribute">,
<item><ref id="pap" name="Paraboloid attribute">
</itemize>
<item>Zoom:
<itemize>
<item><ref id="camp" name="camera property">,
<item><ref id="vwsc" name="view action">
</itemize>
<item>Zoom to Object:
<itemize>
<item><ref id="vmconf" name="view menu entry">,
<item><ref id="vwsc" name="view action">
</itemize>
</list>

</article>

