<!doctype linuxdoc system>

<article>

<title>Ayam

<author>Randolf Schultz <tt>(randolf.schultz@gmail.com)</tt>

<date>1. Jun 2009

<abstract>
This is the documentation of Ayam 1.16 - a free 3D modelling environment
for the RenderMan interface.

Please note, that this document is intended to be a reference manual,
more detailed explanations of how to actually model with Ayam are
given in the tutorials.

This document has been written using the SGML-Tools formatting
system to generate files in a variety of text formats from one source file.
There are HTML and PDF versions of this document prepared for you.

In addition, you can use the provided SGML-source to generate other formats.
</abstract>

<toc>

<sect>Introduction
<p>
This section contains general information about Ayam and this document.

<sect1>About Ayam
<p>
Ayam is a free 3D modelling environment for the RenderMan Interface,
distributed under the BSD licence.
<p>
Ayam was formerly known as <tt>"The Mops"</tt>.
<p>
Here is a short summary of the Ayam feature set:
<itemize>
<item>RIB (RenderMan Interface Bytestream) export and import.
<item>Support for NURBS curves, interpolating curves, (trimmed)
NURBS surfaces, bilinear and bicubic patches and patch meshes,
Boxes, Quadrics (Sphere, Disk, Cylinder, Cone, Hyperboloid, Paraboloid
and Torus), MetaBalls, polygonal meshes, subdivision meshes and more.
<item>All primitives may be combined with the common
CSG-operations: Intersection, Difference, and Union.
<item>NURBS modelling includes extrude, revolve, sweep, birail, skin,
and gordon operations (with caps, holes, and bevels) realized as
Tool-Objects (see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).
<item>Wavefront OBJ export and import, Rhino 3DM export and import,
AutoCAD DXF export and import, Web3D X3D export and import, Apple
Quicktime 3D Metafile (3DMF) export and import.
<item>Custom objects that may freely implement their representations
(using OpenGL and RIB) and even small GUIs to edit their type specific
parameters may be written by the user and dynamically loaded at runtime.
<item>Scripting interface: Tcl.
<item>Script objects.
<item>Miscellaneous: (automatic) instancing, arbitrary number of modelling
views, object clipboard, independent property clipboard, console,
n-level undo.
</itemize>
<p>
Since Ayam 1.12, dynamic loading of custom objects and certain plugins
are also available on the Win32 platform (they were not available
before)!
<p>
Ayam is primarily aimed at the Linux, IRIX, and Win32 platforms.
On those platforms BMRT (Blue Moon Rendering Tools, a RenderMan
compliant renderer by Larry Gritz) is available.
Even though the distribution of BMRT is stopped it is still
the recommended renderer for Ayam.
Despite of this, Ayam may be used on many more platforms with any
RenderMan compliant renderer.
<p>
For platforms where BMRT is not available (e.g. FreeBSD or NetBSD), Ayam
may be compiled with code from the Affine Toolkit with limited
functionality (see also the file INSTALL).
In this case, no parsing of slc compiled shaders will be possible.
<p>
Since Ayam 1.6 it is also possible to completely replace the BMRT shader
parsing and RIB writing code with code from the Aqsis project, thus
completely eliminating the need for BMRT. Furthermore, shader parsing
plugins are available for all major RenderMan compliant renderers allowing
a tight integration of Ayam with any of those renderers.

<sect1>About this Manual
<p>
How should one read this manual?
<p>
Since this manual is intended to be a reference manual, it is
probably pointless to read it from the beginning to the end
(except maybe for the next section, explaining the basics).
Instead, just look up the documentation of the things you are interested
in via the table of contents or the index. Cross references will then
guide you to other important parts of the documentation.
Again: this manual has a rather large index, please use it
(see section <ref id="index" name="Index">)!
<p>
This manual is organized in the following way:
<p>
After this first section, the user interface of Ayam is introduced and
basic handling instructions for the application are given in the second
section.
In the third section all interactive modelling actions are documented.
The fourth section details all object types and object properties,
followed by documentation on all NURBS modelling tools in the fifth
section.
In the sixth section the Tcl scripting interface is explained and the
following seventh section has all information about the import and export
plugins. The eighth section is the dreaded miscellaneous section that
contains documentation not fitting elsewhere.
<p>
In this manual, the following typographic conventions are used:
<itemize>
<item>keyboard shortcuts: <tt/&lt;Ctrl+c&gt;/ (press control <em>and</em>
c key), for shortcuts like <tt/&lt;Ctrl+Shift+t&gt;/ an abbreviated
version: <tt/&lt;Ctrl+T&gt;/ will be used;
<item>names (of object types, menu entries, properties, or property elements):
<tt/"A Name"/;
<item>Tcl code examples:
<code>
set riopt(runtime) { a b }
</code>
<item>Object hierarchies:
<code>
+-Parent_Object(Type)
 | First_Child_Object(Type)
 | Second_Child_Object(Type)
 | [Third_Child_Object_may_be_present_or_not(Type)]
 | Empty_Level(Level)
 +-Sub_Level(Level)
 || First_Child_Object_of_Sub_Level(Type)
 |\ Last_Child_Object_of_Sub_Level(Type)
 \ Last_Child_Object(Type)
+-Next_Parent_Object(Type)
</code>
</itemize>

<sect>The Ayam GUI
<p>
This section describes the user interface of Ayam.
<p>
The user interface of Ayam is split into three types of windows:
a main window, a toolbox and an arbitrary number of view windows.
The main window displays the object hierarchy and allows to edit
object properties. The toolbox window is for easy creation of
objects and starting of modelling actions and tools. The modelling
actions are then carried out in view windows, where also the scene
is displayed.
<p>
The whole application with all open windows may be iconified (zapped) using
the shortcut <tt/&lt;Ctrl+Z&gt;/. If any of the windows iconified by zap
is de-iconified, all other windows iconified by zap will be de-iconified
as well.
<p>
<figure loc="ht">
<eps file="pics/swin.ps" height="12cm">
<img src="pics/swin.gif">
<caption>Single Window GUI Mode</caption>
</figure>
<p>
Until Ayam 1.14 all windows, main, toolbar, and views were always single
top level windows - a so called floating windows GUI mode. Since version
1.14, a new GUI mode is available where the main window, three view
windows and the toolbar are integrated in one top level window. This mode
is called single window GUI mode, see also the image above.
The new single window GUI mode is enabled by default. All sub windows are
in panes, the space occupied by a sub window may be adjusted by dragging
the mouse at the borderlines of the panes. The number of views is not
limited to three, albeit all extra views will become extra top level windows.
<p>
The next sections document the three types of windows, main, toolbar,
and views in detail.

<sect1>Anatomy of the Main Window
<p>
The main window is split into three large areas:
<enum>
<item>an area named <tt/"Objects:"/
<item>an area labeled <tt/"Properties:"/
<item>and a text widget (the so called "Console")
</enum>
<figure loc="ht">
<eps file="pics/main.ps" height="8cm">
<img src="pics/main.gif">
<caption>The Main Window</caption>
</figure>
<p>
The relative sizes of the three areas are managed by a so called paned
geometry management. To change the relative size of the console,
you may move your mouse pointer to the upper border of the console until
the pointer changes and then drag the border.
The same goes for the right border of the objects section.

<sect2>Objects<label id="obj">
<p>
The default representation of the object hierarchy is a tree view.
The second available representation is a simple listbox (as known from
<tt/"The Mops"/).
The label <tt/"Objects"/ may be used to switch between the two
representations of the object hierarchy quickly (using a double click).
It is also possible to switch between both representations
using the context menu.
<p>
The two representations have very different properties regarding
speed, use of resources, and versatility. The tree is, due to the
Drag-and-Drop operations, much more versatile but also slower.
<p>
Both representations manage a so called <tt/"current level"/.
This level is the level that is displayed in the object listbox.
In the tree view the current level is drawn in black while all
other levels are grayed out. Selection of objects
may only take place in the current level!
<p>
After the start-up of Ayam you will notice, that there is a first
object called <tt/"Root"/ in the top level of the scene, even though the
scene seems to be empty.
See section <ref id="rootobj" name="Root Object"> for more
information regarding this special object, and what it is good for.
Note that you can not delete or copy this object.

<bf/Object Tree View:/<label id="treeview">
<p>
<figure loc="ht">
<eps file="pics/treeview.ps" height="6cm">
<img src="pics/treeview.gif">
<caption>Object Tree View</caption>
</figure>
<p>

The object tree view is quite complex and may be slow on slow machines
(of the Pentium 90 class), especially when dealing with scenes
that contain many objects. This should not be a problem nowadays.
Nevertheless, Ayam tries to keep tree update delays as low as possible,
but this only works if the scene uses the hierarchy and changes
happen in sub levels (not the root level).
<p>
In the tree view, objects may be selected using the left mouse button.
Multiple selection of objects is possible by holding down the
<tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/ key while clicking on objects.
<p>
Double clicking on objects with child objects toggles display of the
child level.
The same may be accomplished using single clicks on the well known
plus/minus symbols in front of the name of those objects.
<p>
Drag-and-Drop operation is also possible to move objects in the
hierarchy and to initiate special actions like connecting materials
to objects. However, this last feature is documented in section
<ref id="obandprp" name="Objects, Properties, and Tags">
as it is object type specific.
<p>
<label id="treecontm">
The rightmost mouse button opens a context menu with basic tree and
clipboard operations:
<itemize>
<item><tt>"Tree/Rebuild"</tt> completely removes the tree nodes, rebuilds
the hierarchy, and selects the root object,

<item><tt>"Tree/Expand"</tt> opens all nodes with child nodes,

<item><tt>"Tree/Collapse"</tt> closes all nodes with child nodes,

<item><tt>"Switch to Listbox"</tt> removes the tree and replaces it
with the object listbox (see below).

<item><tt>"Deselect Object"</tt> deselects the currently selected
object(s).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="main menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>
<p>
Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object, since Ayam 1.7 holding down the <tt/&lt;Shift&gt;/ key
while pressing <tt/&lt;Up&gt;/ or <tt/&lt;Down&gt;/ will not move the
selection, but rather extend it in the respective direction,

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all objects in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

<item><tt/&lt;Space&gt;/ toggles display of the child objects of the
selected object(s).

<item><tt/&lt;Shift+Home&gt;/ and <tt/&lt;Shift+End&gt;/ are available
since Ayam 1.11 and extend the selection up to the first
or last object in the current level respectively.
The root object, however, will always be omitted.

</itemize>
<p>
If those shortcuts do not work you may need to move the keyboard
input focus away from (internal) view windows, the property GUI,
or the console using <tt/&lt;Tab&gt;/ or <tt/&lt;Shift+Tab&gt;/
first.
<p>
Another way of moving the focus (and cleaning up the application state)
is by using the <tt/&lt;Esc&gt;/ key:
In property GUIs and the console, pressing <tt/&lt;Esc&gt;/ moves the focus
away to the main window or object selection window.
Since Ayam 1.15, pressing <tt/&lt;Esc&gt;/ twice in a view window
will also reset the focus to the main window/object selection
window. Pressing <tt/&lt;Esc&gt;/ twice in the object selection
window will additionally clear the selection (this implies
removal of the currently displayed property GUI) and change the
current level to the root level.
<p>
Thus, if you feel lost anywhere in Ayam, just press <tt/&lt;Esc&gt;/
twice or thrice.


<bf/Object Listbox:/<label id="listbox">
<p>
<figure loc="ht">
<eps file="pics/listbox.ps" height="6cm">
<img src="pics/listbox.gif">
<caption>Object Listbox</caption>
</figure>
<p>
The object listbox displays the object hierarchy of the current scene.
Using this listbox you may browse through the hierarchy of the scene
with your mouse and you may select one or more objects.
<p>
Browsing and selecting should be very intuitive:
Use a double click to enter a level (or an object with child objects),
use a single click to select objects, multiple objects may be selected using
click and drag, or holding down the <tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/
key while clicking.
Keyboard operation is also possible if the listbox has the
input focus.
<p>
A <tt/".."/ is displayed as the first element of the current level
if you are "inside" a level or another object.
A double click on the <tt/".."/ takes you to the parent level.
The buttons below the listbox may be used to change the selection or
to quickly jump through the hierarchy. They should be self explanatory.
<p>
<label id="lbcontm">
The rightmost mouse button opens a small context menu:
<itemize>
<item><tt>"Switch to Tree"</tt> removes the listbox and replaces it
with the tree view (see above).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="main menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>

Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object, since Ayam 1.7 holding down the <tt/&lt;Shift&gt;/ key
while pressing <tt/&lt;Up&gt;/ or <tt/&lt;Down&gt;/ will not move the
selection, but rather extend it in the respective direction,

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all object in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

<item><tt/&lt;Shift+Home&gt;/ and <tt/&lt;Shift+End&gt;/ are available
since Ayam 1.11 and extend the selection up to the first
or last object in the current level respectively.
The root object, however, will always be omitted.

</itemize>
<p>
If those shortcuts do not work you may need to move the keyboard
input focus away from (internal) view windows, the property GUI,
or the console using <tt/&lt;Tab&gt;/ or <tt/&lt;Shift+Tab&gt;/
first.
<p>
Another way of moving the focus (and cleaning up the application state)
is by using the <tt/&lt;Esc&gt;/ key:
In property GUIs and the console, pressing <tt/&lt;Esc&gt;/ moves the focus
away to the main window or object selection window.
Since Ayam 1.15, pressing <tt/&lt;Esc&gt;/ twice in a view window
will also reset the focus to the main window/object selection
window. Pressing <tt/&lt;Esc&gt;/ twice in the object selection
window will additionally clear the selection (this implies
removal of the currently displayed property GUI) and change the
current level to the root level.
<p>
Thus, if you feel lost anywhere in Ayam, just press <tt/&lt;Esc&gt;/
twice or thrice.

<sect2>Properties<label id="propgui">
<p>
<figure loc="ht">
<eps file="pics/propgui.ps" height="6cm">
<img src="pics/propgui.gif">
<caption>Properties</caption>
</figure>
<p>
The listbox right next to the object hierarchy displays the properties
of the currently selected object.
<p>
If there are multiple selected objects, the properties listbox will
display no properties at all.
<p>
Unlike the object tree/listbox, where you can select multiple entries,
only one property may be selected.
If a property is selected, the associated GUI will be shown in the
appropriate area (on the right hand side).
<p>
Since Ayam 1.8 the keyboard may be used to select properties,
just press one of the <tt/&lt;0&gt;/-<tt/&lt;9&gt;/ keys (most comfortably
using the numeric keypad). <tt/&lt;0&gt;/ always selects the last and
often the only object type specific property, whereas <tt/&lt;1&gt;/
selects the first property, which often contains the standard
transformations.
<p>
All property GUIs use more or less standardized GUI elements that are
organized in list form. The lists may be scrolled if they get too long
to fit into the window.
<p>
If the elements of the property GUI do not fit into the screen space
that is defined by the current window size, Ayam will automatically
resize the main window when you select a property. You can control
this behaviour using the preference setting
<tt/"AutoResize"/ (see section <ref id="prefs" name="Preferences">).
<p>
If an object and a property are selected and a different object is selected,
the property GUI that has the same index as the previously selected
property in the properties listbox will be selected and shown. This is
not necessarily a property of the same type!
To avoid that or to clear the property GUI for fast browsing through the
scene you may either double click on the "Properties" label or use the
context menu of the properties listbox to de-select the current property.
<p>
What properties exactly will be shown, and how the GUIs look alike
depends on the selected object and the selected property.
This is documented comprehensively in section
<ref id="obandprp" name="Objects, Properties and Tags">.
<p>
Here are some general remarks about object properties:
<p>
The various things that may be changed using a property GUI
will normally not be applied to the selected object until the
<tt/"Apply"/-button is pressed!
<p>
Since Ayam 1.8.3 holding down the <tt/"Shift"/ button while
interacting with the property GUI or pressing <tt/"Return"/
when entry widgets have the keyboard input focus will lead
to an instant apply.
<p>
You can undo all changes to the arguments of a property that have been
made after the last <tt/"Apply"/ operation with the <tt/"Reset"/-button.
This does, however, not use the undo mechanism of Ayam.
<p>
Note also that property GUIs of custom objects may offer interactive
elements that do an instant "Apply" operation. Most GUIs of the core
objects of Ayam do not change anything until the <tt/"Apply"/-button
is used, however.
<p>
If a property GUI element has the keyboard input focus (it is then usually
displayed with a black rim around it), all the keyboard shortcuts for
the main menu and scene navigation will have no effect until the
keyboard input focus is moved away from the property GUI. You may
accomplish this easily using the <tt/&lt;Esc&gt;/ key.
<p>
A property may be copied and pasted to another object, see the
<tt/"Edit"/ menu. You can also paste property values to different types
of properties (e.g. pasting parameters from a surface shader to the
displacement shader) using <tt/"Paste to selected"/ in the
<tt>"Special/Clipboard"</tt> sub-menu.
<p>
Pasting a property to multiple selected objects does work too.
This is a great way to apply e.g. a surface shader to a big number
of material objects, without going the long way of setting a new
shader and entering parameters for it for every object.
<p>
Since you may not want to copy and paste whole properties all the time,
you may even mark single parameters with a double click on the
labels of the parameters. The marked parameters will then be preceded
by an exclamation mark (!) in the property GUI.
<p>
If you now copy this property, all marked parameters will be omitted.
<p>
It is also possible to copy just the parameters you marked using
<tt/"Copy Marked Prop"/.
<p>
A simple example for the property clipboard:
<p>
Our task is to give a big number of material objects the same color,
but they already have different opacity settings. Copying the complete
attribute property would destroy the opacity values. We can solve
this by copying just the color attribute, but leave all other
attributes as they are:
<enum>
<item>Change the color of a first material object using the
<tt/"Attributes"/ property GUI. (Do not forget the <tt/"Apply"/ button!)

<item>Mark the color parameter as to be copied using a double click
on the text <tt/"Color"/; it should read <tt/"!Color"/ now.

<item>Copy just the color parameter to the property clipboard,
using <tt/"Copy Marked Prop"/ in the <tt/"Edit"/ menu or the
hot key <tt/&lt;Ctrl+I&gt;/.

<item>Select all other material objects.

<item>Paste the property using <tt/"Paste Property"/ or <tt/&lt;Ctrl+V&gt;/.

<item>All done!
</enum>
<p>
Special care must be taken when pasting incomplete properties to objects
which do not have complete properties already. Do not paste an incomplete
shader property to an object which does not already have the same shader!

<sect2>The Console<label id="cons">
<p>
<figure loc="ht">
<eps file="pics/console.ps" height="2cm">
<img src="pics/console.gif">
<caption>Console</caption>
</figure>
<p>
The third part of the main window is the console. The console is mainly
for unobtrusive text output (informative, warning, and error messages).
If something does not work as advertised, the console may be worth
a look.
<p>
The console captures the stderr and stdout channels of the
Tcl-interpreter Ayam is running in. You can also redirect all internal
Tcl error messages, that would normally cause a Tcl error dialog window
to appear, to the console using the preference setting
<tt>"Misc/RedirectTcl"</tt>
(see section <ref id="prefmisc" name="Miscellaneous Preferences">).
<p>
You can also enter commands or even complete new Tcl procedures
into the console. However, this is a feature for an advanced
user that studied section <ref id="script" name="Scripting Interface">.
You need to explicitly click into the console to give it the input
focus and thus enable input.
<p>
An important thing to know is that the keyboard shortcuts for the
various main menu entries do not work if the console has the input
focus! Instead, other keyboard shortcuts (related to the console)
are in effect.
How do you get out of this? Simply press <tt/&lt;Shift+Tab&gt;/ or
<tt/&lt;Esc&gt;/ to move the focus away from the console and enable
the main menu shortcuts again.
<p>
Note that the <tt/&lt;Tab&gt;/ key alone does not move the focus away
from the console.
<tt/&lt;Tab&gt;/ instead completes names of files, commands (procedures),
variables, and widgets.
You may try this out by typing <tt/tip/ in the console,
then press <tt/&lt;Tab&gt;/.
The console automagically completes <tt/tip/ to <tt/tipoftheDay/
(the procedure that prints out the tip of the day, just try it).
<p>
Another simple demonstration of the consoles capabilities:
<itemize>
<item>Create ten box objects by clicking on the box icon ten times.
<item>Select all ten boxes.
<item>Go to the console by clicking into it.
<item>Enter the following:
<tt>forAll 0 &lcub;movOb &dollar;i 0 0; rotOb &lsqb;expr &dollar;i*10&rsqb; 0 0&rcub;</tt>
</itemize>
<p>
This example uses three procedures:
<itemize>
<item><tt/forAll/: allows to execute
a command for each of the selected objects, or for each object in the
current level if no objects are selected.
<item><tt/movOb/: moves the selected object(s).
<item><tt/rotOb/: rotates the selected object(s).
</itemize>
<p>
See section <ref id="script" name="Scripting Interface"> for a
listing of all the available commands.
<p>
Note that the example uses a side effect (the variable <tt/"i"/ that
holds the index of the currently processed object) to calculate
the amount of the movement and rotation.
<p>
For more information regarding the console, please refer to the
appropriate documentation by the original author Jeffrey Hobbs
(see the console context menu, that you may open with your right
mouse button).

<sect1>The Main Menu<label id="mm">
<p>
This section discusses the main menu bar. Note that many menu entries
have keyboard shortcuts that are displayed in each entry. You can adapt
the shortcuts using the file <tt>"ayamrc"</tt>
(see section <ref id="ayamrc" name="Ayamrc File">).
<p>
<label id="mmfile">
The <tt/"File"/ menu deals with standard file operations:<label id="filem">
<itemize>
<item><tt/"New"/, clears the current scene (deletes all objects) and reloads
the working environment (if the preference setting
<tt>"Main/NewLoadsEnv"</tt> is enabled).
This operation is not undoable!

<item><tt/"Open"/, clears the current scene and closes all views,
then loads a new scene from disk. All objects from the file
will be read. Depending on the setting of
<tt>"Preferences/Main/BakOnReplace"</tt>
a backup copy of the file that is read will be made before loading.
This operation is not undoable!
<p>
Since Ayam 1.13 also files supported by any of the import plugins
may be imported using this route. Note that this only works if the
selected file has a file name extension. The appropriate plugin will
be loaded automatically (from the list of plugin directories in the
preferences) if needed and the import options dialog of the plugin
will be opened, with the <tt/"FileName"/ option already set.
Mind that in this case, no backup copy of the file will be made.
See also section <ref id="impex" name="Import and Export">.

<item><tt/"Insert"/, inserts the objects and views of an Ayam scene file
into the current scene. All objects from the file will be read.
If the file to be inserted contains a Root or View objects, the new
objects will be created in the top level of the scene.
Otherwise, if just geometric objects are in the scene file (i.e. the file
was created using <tt>"Special/Save Selected"</tt>), the new objects
will be inserted in the current level of the scene.
<p>
This operation is not undoable!
<p>
Since Ayam 1.13 also files supported by any of the import plugins
may be imported using this route. See above (<tt/"Open"/).

<item><tt/"Save as"/, saves the current scene asking for a new file name.
<p>
Since Ayam 1.13 also files supported by any of the export plugins
may be exported using this route. See above (<tt/"Open"/).

<item><tt/"Save"/, saves the scene. If the scene has not been saved before
(read, you have not given it a file name) you will be asked for a file
name first.

<item><tt>"Import/"</tt>, since Ayam 1.13 this sub menu is initially
empty. You need to load a plugin first to gain to the menu entries
described here.

<item><tt>"Import/Apple 3DMF"</tt>, import a scene from the Apple
3DMF format, see section <ref id="imp3dmf" name="3DMF (Apple) Import">
for more information.

<item><tt>"Import/AutoCAD DXF"</tt>, import a scene from the AutoCAD
DXF format, see section <ref id="impdxf" name="AutoCAD DXF import">
for more information.

<item><tt>"Import/Mops"</tt>, import a scene from The Mops,
see section <ref id="impmops" name="Import of Mops Scenes">
for more information.

<item><tt>"Import/Rhino 3DM"</tt>, import a scene from the Rhino
3DM format, see section <ref id="imprhino" name="3DM (Rhino) Import">
for more information.

<item><tt>"Import/Wavefront OBJ"</tt>, import a scene from the Wavefront
OBJ format, see section <ref id="impwav" name="Wavefront OBJ Import">
for more information.

<item><tt>"Import/Web3D X3D"</tt>, import a scene from the XML
based X3D format published by the Web3D Consortium, see section
<ref id="impx3d" name="X3D (Web3D) Import">
for more information.

<item><tt>"Export/"</tt>, since Ayam 1.13 this sub menu initially
only contains the <tt>"RenderMan RIB"</tt> entry. You need to load a
plugin first to gain access to the other menu entries
described here.

<item><tt>"Export/RenderMan RIB"</tt>, exports the current scene to a RIB,
asking which camera (which view) to use.

<item><tt>"Export/Apple 3DMF"</tt>, export a scene to the Apple
3DMF format, see section <ref id="exp3dmf" name="3DMF (Apple) Export">
for more information.

<item><tt>"Export/Rhino 3DM"</tt>, export a scene to the Rhino
3DM format, see section <ref id="exprhino" name="3DM (Rhino) Export">
for more information.

<item><tt>"Export/Wavefront OBJ"</tt>, exports the current scene to a
Wavefront OBJ file, see also section
<ref id="expwav" name="Wavefront OBJ export">.

<item><tt>"Export/Web3D X3D"</tt>, export a scene to the XML
based X3D format published by the Web3D Consortium, see section
<ref id="expx3d" name="X3D (Web3D) Export">
for more information.

<item><tt/"Load Plugin"/, loads a file containing a custom object or a plugin.
Depending on the platform Ayam is running on, these are files with the
file name extension <tt/".so"/ or <tt/".dll"/.
There are currently two types of plugins for Ayam: custom objects and
import/export plugins.
See section <ref id="customobj" name="Custom Objects">
for more information about custom objects.
See section <ref id="impex" name="Import and Export">
for more information about import/export plugins.

<item><tt/"Save Prefs"/, save the current preference settings
to the ayamrc file after making a backup copy of this file (see section
<ref id="ayamrc" name="Ayamrc File"> for more information about this file).

<item><tt/"1."/, <tt/"2."/, <tt/"3."/, <tt/"4."/, immediately replace the
current scene with the one in the menu entry. The menu entries
are updated and rotated upon successful loading and saving of a scene
so that the first entry always contains the scene that was loaded
(or saved) last.

<item><tt/"Exit!"/, remove all temporary files, save preferences (if
the preference setting <tt>"Main/AutoSavePrefs"</tt> is turned on)
and quit the application.
</itemize>

<label id="mmedit">
The <tt/"Edit"/ menu contains object and property clipboard
operations, undo actions, and lets you open the preferences editor:
<itemize>
<item><tt/"Copy"/, copies the currently selected object(s) into the clipboard.
This operation is not undoable!

<item><tt/"Cut"/, moves the currently selected object(s) into the clipboard.
This operation is not undoable!

<item><tt/"Paste"/, copies the object(s) from the clipboard to the current
level of the scene. Note that the content of the clipboard remains intact
after this operation, this means that you can paste multiple times!
You can move objects out of the clipboard (clearing it) using the menu entry
<tt>"Special/Clipboard/Paste (Move)"</tt>.
Also note that referenced objects, when moved into the clipboard with
<tt/"Cut"/, can not be moved out of it using a simple <tt/"Paste"/, use
<tt>"Special/Clipboard/Paste (Move)"</tt> instead!
This operation is not undoable!

<item><tt/"Delete"/, removes the selected object(s) from the scene.
This operation is not undoable!

<item><tt/"Select All"/, selects all objects in the current level
(except for the root object).

<item><tt/"Select None"/, de-selects all currently selected objects.

<item><tt/"Copy Property"/, copies the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).
Marked parameters will be omitted!

<item><tt/"Copy Marked Prop"/, copies the currently marked parameters
of the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).

<item><tt/"Paste Property"/, copies all property data from the property
clipboard to the currently selected object(s). The data will get pasted
to the property type saved by the last copy operation. It will not get
pasted to the currently selected property; use
<tt>"Special/Clipboard/Paste Property to selected"</tt> for that.

<item><tt/"Undo"/, perform undo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Redo"/, perform redo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Material"/, searches for the material object currently
associated with the selected object and selects it for editing.
If the selected object has no material yet, a new material
will be created first.

<item><tt/"Master"/, searches for the master object of the
currently selected instance object and selects it for editing,
see also section <ref id="instanceobj" name="Instance Object">.

<item><tt/"Preferences"/, opens the preferences dialog (see section
<ref id="prefs" name="Preferences"> for more information).
</itemize>

<label id="mmcreate">
The <tt/"Create"/ menu entries let you create objects. In contrast
to the object creation via the toolbox some menu entries present you
with small requesters, where you may adjust parameters for the object
to be created. Here are the entries of the <tt/Create/ menu:
<itemize>
<item><tt/"NURBCurve"/, create a new NURBS curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="ncurveobj" name="NCurve Object">.

<item><tt/"ICurve"/, create a new interpolating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="icurveobj" name="ICurve Object">.

<item><tt/"ACurve"/, create a new approximating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="acurveobj" name="ACurve Object">.

<item><tt/"NCircle"/, create a new NURBS circle. See
also section <ref id="ncircleobj" name="NCircle Object">.

<item><tt/"NURBPatch"/, create a new NURBS patch. A small dialog box will
pop up, where you may specify the width and height of the new patch. See
also section <ref id="npatchobj" name="NPatch Object">.

<item><tt/"BPatch"/, create a new bilinear patch. See
also section <ref id="bpatchobj" name="BPatch Object">.

<item><tt/"PatchMesh"/, create a new patch mesh. See
also section <ref id="patchmeshobj" name="PatchMesh Object">.

<item><tt/"Solid"/, create a new solid primitive object, for use in CSG.
<tt/"Box"/, <tt/"Sphere"/, <tt/"Disk"/, <tt/"Cone"/, <tt/"Cylinder"/,
<tt/"Torus"/, <tt/"Hyperboloid"/ or <tt/"Paraboloid"/ may be selected.
See also section <ref id="qprim" name="Quadric Primitives">.

<item><tt/"Level"/, creates a new hierarchy object. <tt/"Level"/
just groups objects, <tt/"Union"/, <tt/"Intersection"/,
<tt/"Difference"/, and <tt/"Primitive"/ are CSG operations. See
also section <ref id="levelobj" name="Level Object">.

<item><tt/"Light"/, create a new light source. See
also section <ref id="lightobj" name="Light Object">.

<item><tt/"Custom Object"/, create a new custom object. If this sub-menu
is empty no custom object has been loaded yet. See
also section <ref id="customobj" name="Custom Object">.

<item><tt/"View"/, a new View window will be opened. See
also section <ref id="viewobj" name="View Object">.

<item><tt/"Instance"/, create an instance of the currently selected
object, see section <ref id="instanceobj" name="Instance Object">
for more information regarding instances.

<item><tt/"Clone"/, create a clone object, see
section <ref id="cloneobj" name="Clone Object">

<item><tt/"Mirror"/, create a clone object, that is immediately
configured as a mirror, see also
section <ref id="cloneobj" name="Clone Object">

<item><tt/"Material"/, create a new material. A small dialog box will
pop up, where you have to specify the name of the new material. See
also section <ref id="materialobj" name="Material Object">.

<item><tt/"Camera"/, create a new camera. Camera objects may be used
to temporarily save view camera settings, see
section <ref id="cameraobj" name="Camera Object">.

<item><tt/"RiInc"/, create a new RIB-include object. Those objects
may be used to include objects into your scenes
that just exist as a piece of RIB, see
also section <ref id="riincobj" name="RiInc Object">.

<item><tt/"RiProc"/, create a new procedural object, see
also section <ref id="riprocobj" name="RiProc Object">.

<item><tt/"Script"/, create a new script object, see
also section <ref id="scriptobj" name="Script Object">.

<item><tt/"Select"/, create a new select object, see
also section <ref id="selectobj" name="Select Object">.

<item><tt/"Text"/, create a new text object, see
also section <ref id="textobj" name="Text Object">.
</itemize>

<label id="mmtools">
The <tt/"Tools"/ menu:
<itemize>
<item><tt/"Last (None)"/, this menu entry is available since Ayam 1.13.
It allows quick access to the last used entry/tool in the <tt/"Tools"/
menu hierarchy. The label of the entry will be changed appropriately,
e.g. to <tt/"Last (Revert U)"/, when a tool was started.

<item><tt/"Create"/, <tt/"NURBCurve"/, and
<tt/"NURBPatch"/, are sub-menus with various NURBS based creation
and modelling tools, that are explained in depth in section
<ref id="nmtool" name="NURBS Modelling Tools">.

<item><tt/"PolyMesh"/: sub-menu for polygonal mesh related tools:
<itemize>
<item><tt/"Merge"/: merges all currently selected PolyMesh objects into
a single PolyMesh object, without checking for doubly used points,
loops, or faces. Normally, the currently selected PolyMesh objects will not
be changed by this tool. But you may let the merge-tool delete them
immediately after the merging operation, by enabling the
<tt/"RemoveMerged"/-option.
If the <tt/"OptimizeNew"/-option is enabled, the <tt/"Optimize"/-tool
(see below) will be started after the merge operation with the
newly created merged object as argument.

<item><tt/"Split"/: splits the faces from the selected PolyMesh objects
into a second PolyMesh object. The faces to be split off are selected
by selecting all their control points with the select points modelling
action (see also section <ref id="selac" name="Selecting Points">).
The original selected PolyMesh objects will be changed. The changes to
the original objects are undoable. Since the split operation does not
create optimized new objects, the <tt/"Optimize"/-tool (see below) may
be started immediately after splitting using the <tt/"OptimizeNew"/-option.

<item><tt/"Optimize"/: optimizes the selected PolyMesh object(s)
by removing all multiply used control points (if the option
<tt/"OptimizeCoords"/ is enabled) or multiply used faces (not implemented
yet). If the option <tt/"IgnoreNormals"/ is enabled, the optimize-tool will
consider points with equal coordinates but differing normals
to be equal (and optimize them).
Removing multiply used control points using the <tt/"Optimize"/-tool
may decrease the memory consumption of the control points
by a factor of about six, depending on the connectivity of the original
mesh.
</itemize>

<item><tt/"Points"/: sub-menu for tools that work on points:
<itemize>
<item><tt>"Select All Points"</tt>, selects all points of the currently
selected object(s).

<item><tt>"Invert Selection"</tt>, selects all points of the currently
selected object(s) that are not selected, and de-select all points that
are currently selected.

<item><tt>"Apply To All"</tt>, applies the transformations encoded in
the transformations property of the selected objects to all points of those
objects.
This will have the effect of resetting the transformations property
to the default values without (visibly) changing the points of the
selected objects.

<item><tt>"Apply To Selected"</tt>, applies the transformations
encoded in the transformations property of the selected objects to the
selected points.
This will reset the transformations property without (visibly)
changing the selected points. The points currently not selected
will be transformed, however!

<item><tt>"Center All Points (3D)"</tt>, moves all points of the
selected objects so that their common center (the center of gravity)
is the center of the respective objects coordinate system.
Note that, currently, this works on each of the selected objects
separately!
<item><tt>"Center All Points (2D-XY)"</tt>,
<tt>"Points/Center All Points (2D-YZ)"</tt>,
<tt>"Points/Center All Points (2D-XZ)"</tt>: work like the center
3D tool but just center in the designated plane.
</itemize>

<item><tt/"Show"/, <tt/"Hide"/ set and unset the <tt/"Hide"/
attribute of the selected object(s) thus making them invisible
or visible again.
Note that hidden objects may be excluded from RIB-Export, when
the preference setting <tt>"RIB-Export/ExcludeHidden"</tt> is
activated.

<item><tt/"Show All"/ and <tt/"Hide All"/ set and unset the <tt/"Hide"/
attribute of all objects in the scene (including the root object
and all views!) regardles of the currently selected objects (and
without changing the current selection). These operations are
not undoable.

<item><tt/"Convert"/, starts the convert action that has been
registered for the type of the selected object(s). The exact
behaviour depends on the type of the selected object(s):
a Revolve object will e.g. be converted to a level containing NURBS
patches that make up the surface of revolution and the caps.
This operation is not undoable, i.e. the newly created objects
will not be removed by using the undo system.

<item><tt/"Convert (In Place)"/, starts the convert action as
outlined above, but replaces the original objects with the
new converted ones. This operation, in contrast to the simple
conversion, is undoable.

<item><tt/"Force Notification"/, force the notification callbacks of
all selected objects (or all objects in the scene if no objects are
selected) to be called. The notification callbacks are used by objects
like e.g. Revolve to be informed about changes of their child
objects to properly adapt to those changes.

<item><tt/"Highlight Material"/, colours all objects of the same
material in red color in the tree view. This tool expects a selected
material object or a normal object that has a material attached.
It will not work for material objects that are not registered or
have no normal objects that refer to them. It will also not work
for objects that have no material assigned. If the reference counter
of a material object is not zero, but <tt/"Highlight Material"/
reports 0 objects found, the referring objects probably reside
in the object clipboard. You can clear the color from the tree view
with the keyboard shortcut <tt/&lt;Ctrl+l&gt;/.
</itemize>

<label id="mmcustom">
The <tt/"Custom"/ menu is initially empty. Custom objects and plugins,
may create entries here.

<label id="mmspecial">
The <tt/"Special"/ menu contains seldom used tools:
<itemize>
<item><tt/"Save Selected as"/, saves just the currently selected objects
to disk. Note that Ayam will not check, whether the objects are saved
with their materials. It is also possible to save instance objects
without their master objects. This will lead to errors while loading
such a scene later on.

<item><tt/"Save Environment"/, saves the root object and all
views to a so called environment scene file, which is read
on program startup and <tt>"File/New"</tt>.
Initially, the file requester that asks for the name
of the new environment uses the value of the preference
setting <tt>"Main/EnvFile"</tt>. Note that there will be no
check whether loading of that environment on next start up is
enabled in the preferences. Note also, that using <tt/"Save Environment"/
you can just save environment files that contain the root object
and all views. If you want to include geometric objects in your
environment or if you want to exclude the root object and just
save views you have to use <tt>"File/Save"</tt> or
<tt>"Special/Save Selected as"</tt> respectively.

<item><tt>"Clipboard/Paste (move)"</tt>, moves objects from the clipboard
back to the scene (clearing the clipboard). This is the only way to
get referenced objects out of the clipboard.

<item><tt>"Clipboard/Replace"</tt>, replaces the currently selected
object(s) with the object clipboard content, moving the replaced
objects into the clipboard. If multiple objects are selected
in non consecutive sequences, only the first consecutive sequence
or single object is replaced.

<item><tt>"Clipboard/Paste Property to selected"</tt> paste the property
from the property clipboard to the currently selected
property of the currently selected object. No type check of the
properties will take place! You may e.g. copy the settings from a
displacement shader to a surface shader (as long as the copied arguments
of both shaders have the same names and types).

<item><tt>"Instances/Resolve all Instances"</tt>, converts all instances
of the current level (and its child objects) to normal objects. Since
Ayam 1.14, if objects are selected, only the selected objects will be
processed.

<item><tt>"Instances/Automatic Instancing"</tt>, pops up a small dialog box,
where you may parameterise and start the automatic instantiation
algorithm (that automatically creates instances from
equal objects). See section <ref id="ai" name="Automatic Instancing">
for more information regarding automatic instancing.

<item><tt>"Tags/Add RiOption"</tt>, pops up a small dialog box, where you may
select and parameterise a RiOption tag to add as tag to the Root object
(see <ref id="riotag" name="RiOption Tag">). The Root object does
not have to be selected and the current selection will not be changed
by this action.

<item><tt>"Tags/Add RiAttribute"</tt>, pops up a small dialog box, where
you may select and parameterise a RiAttribute tag to add as tag to the
currently selected object(s) (see <ref id="riatag" name="RiAttribute Tag">).

<item><tt>"Tags/Edit TexCoords"</tt>, opens the texture coordinates editor.
(see also section <ref id="tctag" name="TC (Texture Coordinates) Tag">).

<item><tt>"RIB-Export/From Camera"</tt>, writes a complete RIB of
the current scene with the camera transformations taken from the
currently selected camera object. The size of the rendered image will
be taken from the RiOptions of the root object. If they are zero,
default values of 400 pixels width and 300 pixels height will be used.
The type of the projection written will be perspective.
Otherwise the RIB looks exactly the same as if exported via
main menu <tt>"File/Export/RenderMan RIB"</tt>.

<item><tt>"RIB-Export/Selected Objects"</tt>, exports only the
selected objects to a RIB. Note that instances will always be resolved,
hidden objects and objects with <tt>"NoExport"</tt> tags are treated
as on normal export operations, and light objects are simply ignored.
Note also that the created RIB, since it e.g. lacks camera transformation
and WorldBegin/End directives, may not be rendered directly by a
RenderMan compliant renderer (unless the renderer is really forgiving
about mis-structured RIBs).
The main use of this feature is to let you create RIBs that may be easily
included in other RIBs using e.g. the ReadArchive directive.

<item><tt>"RIB-Export/Create ShadowMap"</tt>, creates the shadow maps
from the currently selected light source.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt>"RIB-Export/Create All ShadowMaps"</tt>, creates all shadow maps
for the current scene (regardless of selection).
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Enable Scripts"/ enables all disabled script tags and
objects. Objects and tags in the object clipboard are not
affected!

<item><tt>"Select Renderer"</tt> opens a dialog where the renderer
for direct rendering from a view may be choosen.
The changes will have effect on all preference settings that control
direct rendering from a view, except whether RenderGUIs should
be used.
If the <tt>"ScanShaders"</tt> checkmark is activated, Ayam will
additionally try to load the corresponding shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">)
and rescan for compiled shaders. Note that in order for the
<tt>"ScanShaders"</tt> feature to work properly the <tt>"Main/Shaders"</tt>
and <tt>"Main/Plugins"</tt> preference settings have to be set correctly
(see also section <ref id="prefmain" name="The Main Preferences">).

<item><tt>"Scan Shaders"</tt> initiates the shader parsing with the
built in shader parser or the currently loaded shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">).

<item><tt>"Reset Preferences"</tt> removes the current ayamrc file,
where the preferences are saved; after a restart of Ayam, all
preferences will be reset to factory defaults. See also
section <ref id="ayamrc" name="Ayamrc File"> for more information
about the ayamrc file.

<item><tt/"Toggle Toolbox"/ closes or opens the toolbox window
(see <ref id="toolb" name="The Toolbox Window">). From version 1.3 on,
Ayam remembers the state of the toolbox in the saved preferences.

<item><tt/"Toggle TreeView"/ toggles object tree view and object listbox.
From version 1.3 on, Ayam remembers whether the tree view or the
object listbox is open in the saved preferences
(see also section <ref id="obj" name="Objects"> for more information
about both representations).

<item><tt>"Zap Ayam"</tt> iconifies all currently open windows of Ayam.
If one of the iconified windows is de-iconified later, all other zapped
windows will be de-iconified as well.
</itemize>

<label id="mmhelp">
The <tt/"Help"/ menu:
<itemize>
<item><tt/"Help"/, opens a web browser and displays the documentation,
the URL to display is taken from the <tt/"Docs"/ preference setting.

<item><tt/"Help on object"/, opens a web browser and displays
documentation about the currently selected type of object,
the URL to display is derived from the <tt/"Docs"/ preference setting,
this feature will not work with frame redirects e.g.
<tt>"http://www.ayam3d.org/"</tt>; use
<tt>"http://ayam.sourceforge.net/docs/"</tt> or a <tt>"file:"</tt>-URL
as base URL in the <tt/"Docs"/ preference setting instead!

<item><tt/"Show Shortcuts"/, displays some important shortcuts for modelling
actions, you may leave this window open when doing your first
steps in modelling with Ayam.

<item><tt/"About"/, displays some version, copyright,
and trademark information.

<item><tt/"Show Tooltips"/, enables tool tips (balloon help)
for various user interface elements (including the toolbox buttons).
</itemize>


<sect1>Anatomy of a View<label id="viewwin">
<p>
<figure loc="ht">
<eps file="pics/view.ps" height="7cm">
<img src="pics/view.gif">
<caption>A View Window</caption>
</figure>
<p>
The view window is split into a menu bar and a
OpenGL-widget, where interaction and drawing takes place.
The title of the view window gives information about
name, current type, and the currently active modelling
action of the view.
<p>
Since Ayam 1.14 the current modelling action is also displayed in
the view menu bar as an icon.

<sect1>The View Menu<label id="vm">
<p>
This section discusses the view menu bar. Note that many menu entries
have keyboard shortcuts that are displayed in each entry. You can adapt
the shortcuts using the file <tt>"ayamrc"</tt>
(see section <ref id="ayamrc" name="Ayamrc File">).
Note that the view menu keyboard shortcuts only work if the view window
has the keyboard input focus.

<label id="vmview">
Here are all meny entries of the <tt/"View"/ menu:
<itemize>
<item><tt/"Quick Render"/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"QRender"/ command
(see the preferences) will be called. Note that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Render"/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"Render"/ command
(see the preferences) will be called. Note that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Redraw"/: forces the OpenGL-widget to be drawn, this is
particularly useful if automatic redrawing of the view has been disabled.

<item><tt/"Export RIB"/ exports the scene to a RIB. This does exactly the
same as the main menu entry <tt>"File/Export/RenderMan RIB"</tt>, except that
the current view will already be selected in the dialog box.

<item><tt/"Open PPrev"/, <tt/"Close PPrev"/: those menu entries are just
available, if the compile time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
Permanent preview (PPrev) continuously writes a RIB stream to
a (fast) RenderMan renderer, a frame for each redraw operation
of the view window that was used to open the preview. This way, the
RenderMan renderer immediately displays all changes in the scene.
This is a great way to test many different camera or light settings without
the need to manually start a rendering process and close the preview window
for each different setting.
As the RIB client library usually is not able to handle multiple open
RIB streams simultaneously, RIB-Export and direct rendering from view
windows are not available until the permanent preview window is closed.

<item><tt>"Create ShadowMap"</tt>: creates the shadow maps
for the currently selected light source.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Create All ShadowMaps"/: creates all shadow maps for the
current scene (regardless of selection).
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Close"/: the View window will be removed. This entry is not
available for the internal views of Ayam in single window GUI mode.
</itemize>

<label id="vmtype">
The <tt/"Type"/ menu entries:
<itemize>
<item><tt/"Front"/

<item><tt/"Side"/

<item><tt/"Top"/

<item><tt/"Perspective"/

<item><tt/"Trim"/
</itemize>
may be used to change the type of the view, which restrains the scope
of certain modelling actions. See sections
<ref id="viewobj" name="View Object">,
<ref id="vwsc" name="View Window Shortcuts and Actions">, and
<ref id="iac" name="Interactive Actions (Modelling)">
for more information.

<label id="vmconf">
The <tt/"Configure"/ menu may be used to change preferences of the view.
Some preferences are outlined in greater detail in section
<ref id="vat" name="ViewAttrib">.
<itemize>
<item><tt/"Automatic Redraw"/, toggles whether the view should
be redrawn, whenever the scene changes. If this is disabled,
you can force a redraw using <tt>"View/Redraw"</tt>.

<item><tt/"Drawing Mode"/ determines whether the view should draw a wireframe
representation (<tt>"Drawing Mode/Draw"</tt>) or a shaded one
(<tt>"Drawing Mode/Shade"</tt>) or, new in Ayam 1.6, a representation
where the curves of the draw mode are drawn over the shaded
representation (<tt>"Drawing Mode/ShadeAndDraw"</tt>).

<item><tt/"Draw Selection only"/, if this is enabled, just the
currently selected objects (and their children) will be drawn.

<item><tt/"Draw Level only"/, if this is enabled, just the
objects of the current level (and their children) will be drawn.

<item><tt/"Draw Object CS"/, if this is enabled, small coordinate
systems (three colored lines) will be drawn at the base of each
objects coordinate system.

<item><tt/"AntiAlias Lines"/, if this is enabled, all lines will
be anti-aliased (smoothed).

<item><tt/"Draw BGImage"/, if this is enabled, the background
image will be drawn.

<item><tt/"Set BGImage"/, may be used to set the current background
image of the view, which should be a TIFF file.
You can also set this image using the view attribute <tt/BGImage/.

<item><tt/"Draw Grid"/, if this is enabled the grid will be drawn.

<item><tt/"Use Grid"/, if this is enabled the grid will be used to
constrain modelling actions to grid coordinates.

<item><tt/"Set Gridsize"/, may be used to change the size of the grid
associated with this view. Another way to change the grid size is
to use the grid menu on the rightmost side, see below.

<item><tt/"Half Size"/, change width and height to the half of the
current values.

<item><tt/"Double Size"/, change width and height to the double of the
current values.

<item><tt/"From Camera"/, copy camera settings from the currently
selected camera object to the view.

<item><tt/"To Camera"/, copy camera settings to the currently
selected camera object from the view.

<item><tt/"Set FOV"/, lets you specify a field of view value
for the view, and adapts the zoom accordingly. This is just
working for perspective views, of course.

<item><tt/"Zoom to Object"/, adapt the camera settings, so that
the currently selected objects are centered in the view.

<item><tt/"Align to Object"/, align the view to the coordinate
system of the currently selected object or to the parent
object of the current level if no object is currently selected.

<item><tt/"Edit Local"/, if this is enabled modelling will take place
in local object space and not in world space. The grid will be
changed accordingly (interpreted as if defined in the local coordinate space).
See also section <ref id="editlocal" name="Editing in Local Space">.
</itemize>

The <tt/"Modelling mode"/ icon menu may be used to quickly change the current
modelling mode (local, or global, see also section
<ref id="editlocal" name="Editing in Local Space">)
<p>

The <tt/"Drawing mode"/ icon menu may be used to quickly change the current
drawing mode, drawing, shading, or drawing and shading.
<p>

The <tt/"Grid"/ icon menu may be used to quickly change the current grid
size:
<p>
On the right hand side in the view menu bar there is a little icon
that displays the current grid size. You may click on the icon to
display a menu with predefined grid size values.
Choosing one of the values 0.1, 0.25, 0.5, or 1.0 will set the
grid size of the view to the choosen value and will additionally
switch on drawing of the grid and snapping to the grid.
The entry <tt/"X"/ allows to set a custom grid value.
The last entry will set the grid size to 0.0 and switch off drawing of
and snapping to the grid.
If a gridsize other than 0.1, 0.25, 0.5, or 1.0 is in effect for the view,
a different icon (with an X) will be displayed in the icon menu instead.

<sect1>View Window Shortcuts and Actions<label id="vwsc">
<p>
Important keyboard commands of a view window (aside from the view
menu shortcuts) are discussed in this section.
Note that the view keyboard shortcuts only work if the view window
has the keyboard input focus.
<p>
Keyboard shortcuts directly modifying the camera, that is associated
with the view window, are:
<itemize>
<item><tt/&lt;Left&gt;/, <tt/&lt;Up&gt;/, <tt/&lt;Right&gt;/,
<tt/&lt;Down&gt;/ rotate viewer around origin.

<item><tt/&lt;Add&gt;/, <tt/&lt;Sub&gt;/ (on the numeric keypad) zoom view.
</itemize>

Interactive actions modifying the camera, that is associated with the
view window, are:
<itemize>
<item>Using <tt/&lt;v&gt;/ you may move the view with your mouse.

<item>Using <tt/&lt;V&gt;/ you move the camera in the direction it is
looking. Note that this affects both, from and to setting of the
virtual camera. Furthermore, this movement will have no visible effect in
parallel views.

<item><tt/&lt;R&gt;/ (note the case!) starts rotating the virtual
camera around the point it is looking to.
<item>Rotating the view is also possible in any
modelling mode, by holding down the <tt/&lt;Alt&gt;/-key.

<item><tt/&lt;o&gt;/ starts zooming the view. Moving the mouse up
zooms in and moving the mouse down zooms out.

<item>Since Ayam 1.7 zooming the view into a rectangular region
defined through a mouse drag is also possible in any
modelling mode, when holding down the <tt/&lt;Shift&gt;/-key.
</itemize>
<p>
You may also move the view by dragging with the rightmost mouse
button and zoom the view with the middle mouse button.
<p>
If you have a wheel mouse and it is configured to send
Mouse4 and Mouse5 button events, Ayam will zoom the view
when you turn the wheel.
<p>
Using the menu entry <tt/"Zoom to Object"/ or the shortcut
<tt/&lt;Ctrl+o&gt;/ you can change the views from to and zoom
settings so that the selected objects will be displayed centered
in the view window. This is handy if you are e.g. searching for
objects or if you are simply lost in space.
<p>
Using the menu entry <tt/"Align to Parent"/ or the shortcut
<tt/&lt;Ctrl+a&gt;/ you can change the views camera settings so
that it is aligned to the coordinate system of the currently
selected object.
This is handy for modelling in local coordinate systems
(e.g. editing the points of a 2D curve defined in the
XY-plane that has been rotated around the Y-axis).
See also section <ref id="editlocal" name="Editing in Local Space">.

<sect1>Selecting Objects within a View<label id="objsel">
<p>
When the view windows action is <tt/"Pick"/ you can pick (select) objects
that appear within this view.
You can invoke this action by pressing <tt/&lt;Shift+p&gt;/
or make this action the default action using the preference
setting <tt>"Modelling/DefaultAction"</tt>.
This section describes techniques that you can use for selecting
one or more objects within a view.

<sect2>Selecting Individual Objects<label id="oneobjsel">
<p>
Selecting objects within a view is a straightforward operation that uses
standard methods. You will use the following two selection operations most
frequently:

<itemize>
<item>To select a single object within a view, move the cursor to the object
and click mouse button 1 (the leftmost one).
Once you select an object, any objects previously
selected are unselected automatically.

<item>To select an additional object, move the cursor to the object and
<tt/&lt;Control&gt;/+Click (again with the leftmost mouse button).
Previously selected objects remain selected, and
the newly picked object is added to the selection. Notice that the picked item
must belong to the same level as the previously selected objects. An
alternative method for selecting multiple objects is to drag a rectangle
around them. For more information see
<ref id="mulobjsel" name="Drag-selecting Multiple Objects">
</itemize>

<sect2>Drag-selecting Multiple Objects<label id="mulobjsel">
<p>
You can select multiple objects using the <tt/&lt;Control&gt;/+Click method
described in section <ref id="oneobjsel" name="Selecting Individual Objects">.
An additional method for selecting multiple objects is to drag a rectangle
around those objects. However only objects that belong to the current level
can be picked within a drag-selection. If you want to select multiple objects
that belong to another level you must change the current level by either
selecting it in the tree/listbox or by picking one object from that level
on a view.
<p>
The procedure for drag-selecting multiple objects also uses a standard method:

<enum>
<item>Imagine a rectangle that encloses only the objects you want to select.

<item>Click at one corner of the rectangle and, while continuing to press the
mouse button, drag until you have enclosed all the objects.

<item>Release the mouse button. All the valid objects inside or crossing the
rectangle are selected and any objects previously selected are unselected
automatically.
</enum>

<p>
Note that if you press <tt/&lt;Control&gt;/ during the drag-selection, objects
that are enclosed by the rectangle will be added to the current selection
instead of replacing it.

<sect2>Ambiguous Picking<label id="ambobjsel">
<p>
In some cases Ayam is unable to differentiate between the objects you have
selected and other nearby or related objects. This ambiguity can arise as
follows:

<itemize>
<item>Imagine a small square surrounding the cursor. When you click an object,
any other valid objects that fall inside this square are also considered to
be possible selections. For example, if you select an item that is positioned
very close to another one, Ayam may consider both items to be possible
selections.

<item>If your model is three-dimensional (which is likely to happen),
imagine a line that is perpendicular to the screen and that passes through
the cursor and into the model. When you pick an object, any objects that
intersect this line are considered to be possible candidates for selection.
</itemize>

<p>
<figure loc="ht">
<eps file="pics/ampick.ps" height="3cm">
<img src="pics/ampick.gif">
<caption>List of Ambiguous Candidates</caption>
</figure>

<p>
If your selection is ambiguous Ayam displays a window that contains a list of
the possible candidates for selection. When you click a name in the list,
the corresponding object is highlighted. Click <tt/"Ok"/ when you have
determined which object to select or <tt/"Cancel"/ to close the list and keep
the previous selection unchanged.
Since Ayam 1.11 you can also use a double click in the list of selection
candidates to select an object and close the dialog.
<p>
Notes:
<itemize>
<item>While the list of ambiguous candidates is opened you can not pick other
objects within the views.

<item>It is possible to use the <tt/"Zoom to Object"/ action (shortcut
<tt/&lt;Ctrl+o&gt;/) while the ambiguous select listbox is open to get
a better view of the temporarily selected object.

<item>The tolerance used to determine whether an object should be picked
or not can be adjusted (see <tt/"PickTolerance"/ in <ref id="hidprefs"
name="Hidden Preference Settings">).
</itemize>

<sect1>The Toolbox Window<label id="toolb">
<p>
<figure loc="ht">
<eps file="pics/tools.ps" height="8cm">
<img src="pics/tools.gif">
<caption>The Toolbox</caption>
</figure>
<p>
The toolbox window displays some buttons that start interactive
modelling actions, modelling tools, or create objects.
You can open and close it using the main menu entry
<tt>"Special/Toggle Toolbox"</tt>.
<p>
Note that in contrast to the keyboard shortcuts of the
view windows the buttons in the toolbox switch to the modelling
actions for all available views. For more information about
the actions see section <ref id="iac" name="Interactive Actions">.
<p>
The toolbox window may be configured by the user using the
hidden preference setting <tt/"toolBoxList"/ in the ayamrc file.
Using this setting you may select from certain groups of buttons
and change the order in which they appear in the toolbox window.
See section <ref id="hidprefs" name="Hidden Preference Settings"> for
more information.
<p>
The toolbox is also open for extension by scripts, see section
<ref id="scextoolbox" name="Script Examples (Toolbox Buttons)"> for
examples.
<p>
You may also resize the window to change from the vertical standard
layout to a horizontal one, optimizing the use of precious screen
space. After resizing, the toolbox will re-layout the buttons,
warning you if the space is too small for all buttons to display.
If the window is too big for the desired layout and the
preference setting <tt>"Misc/ToolBoxShrink"</tt> is switched on, the
toolbox will shrink wrap the window to match the space occupied by
the buttons.
Furthermore, using the preference setting <tt>"Misc/ToolBoxTrans"</tt>
the toolbox window can be made transient.
It will then (depending on the window manager or its configuration)
get a different or no decoration, no icon, and will always be iconified
when the main window gets iconified.

<sect1>Preferences<label id="prefs">
<p>

<figure loc="ht">
<eps file="pics/prefs.ps" height="8cm">
<img src="pics/prefs.gif">
<caption>Preferences Dialog</caption>
</figure><p>
The preferences dialog may be opened using the main menu entry
<tt>"Edit/Preferences"</tt> or the shortcut <tt/&lt;Ctrl+p&gt;/.
<p>
Use
<itemize>
<item><tt/"Ok"/ to close the preference editor and
apply all changes,

<item><tt/"Apply"/ to apply the changes, but leave the editor open,

<item><tt/"Revert"/ to reset to the settings that have been loaded on
program startup (these are not the factory defaults, to get back to
the factory defaults, restart Ayam with the command line option
<tt/"-failsafe"/ or use the main menu entry
<tt>"Special/Reset Preferences"</tt>!),

<item><tt/"Cancel"/ to close the dialog without applying any changes.
All changes done after the last press of <tt/"Apply"/ will be lost.
</itemize>

Note that while the preference editor is open, AutoFocus is temporarily
turned off and changes to the <tt/"AutoFocus"/ preference setting will
only be realized after the editor is closed.
<p>
The preferences are divided into five sections as follows.

<sect2>The Main Preferences<label id="prefmain">
<p>
The <tt/"Main"/ section contains the most important application setup
related preference settings.
<p>
Since Ayam 1.14, unused settings will not be shown anymore, e.g. on the
Win32 platform, the <tt/"TwmCompat"/ setting will be hidden.

<itemize>
<item><tt/"Shaders"/ contains a number of paths (separated by a colon
<tt/":"/ on Unix and by a semicolon <tt/";"/ on Win32) where Ayam looks
for compiled shaders (e.g. files with the extension <tt/".slc"/ that
have been compiled with slc from BMRT). Using the <tt/"Add"/ button,
you may easily add another path, simply press the button and select a
file from the directory you want to add. Note that currently the
filename of a compiled shader may contain just two <tt/"."/ at maximum.
The environment variable SHADERS will be adapted to match the contents
of this preference setting, so that renderers started by Ayam see
exactly the same shaders as Ayam through the <tt/"Shaders"/ preference
setting.
Note that this does of course not affect any renderers that are started
outside the Ayam context.

<item><tt/"Scan for Shaders!"/ initiates a rebuild of the internal
shader database. All shaders in the directories specified by
the <tt/"Shaders"/ preference setting will be scanned and entered in
that database.
Watch the console for error messages that may appear while scanning.
See also section <ref id="parseshd" name="Shader Parsing"> for more
information on scanning shaders.
</itemize>

The next sub-section contains GUI (user interface) related
settings.<label id="prefgui">
<itemize>
<item><tt/"Locale"/, sets a language for the balloon help texts,
the default value menu shows all currently available locales.

The value will have no effect until Ayam is restarted!

<item><tt/"SingleWindow"/ toggles, whether Ayam should create just
one main window with internal views and toolbox or use the old
floating windows style GUI. The new single window GUI mode is enabled
by default.

<item><tt/"AutoResize"/ toggles, whether the main window
should be resized horizontally according to the property GUI whenever
a new GUI is displayed.

This option is not available in the SingleWindow GUI mode.

<item><tt/"AutoFocus"/ controls whether Ayam should automatically
move the focus to a view or the main window, when the mouse pointer
enters it. Note that this may only work correctly, when a window
of Ayam already has the focus. Notice also, that moving the focus
to a window might also raise it (depending on your operating system
or window manager).

Note that while the preference editor is open, AutoFocus is temporarily
turned off and changes to the <tt/"AutoFocus"/ preference setting will
only be realized after the editor is closed.

This option is not available in the SingleWindow GUI mode.

<item><tt/"TwmCompat"/ changes, how Ayam tells the window manager
new geometries of windows. This option has to be toggled if Ayam
fails to correctly remember the geometry of the main window between
two invocations or if the main window jumps downward when properties
are selected.

This option is not available on the Win32 platform and on MacOSX Aqua.

<item><tt/"AutoSavePrefs"/, if this is switched on, Ayam will write
the preferences settings to the file ayamrc when the program quits.

<item><tt/"BakOnReplace"/, if this is switched on, Ayam will make
a backup copy of each scene file it loads via the main menu entry
<tt>"File/Open"</tt> or via the most recently used list.
The backup file will be placed right next to the loaded file
and get an additional file name extension according to the hidden
preference setting <tt/"BackupExt"/.

<item><tt/"AddExtensions"/, this option may be used to let Ayam
automatically add file name extensions to saved files (if they
do not have already a proper extension).

<item><tt/"EnvFile"/; This file typically contains some view
objects to create a standard 2-, 3-, or 4-view working environment
and is automatically loaded upon startup of Ayam (if the hidden
preference option <tt/"LoadEnv"/ is switched on) and upon clearing
the scene using <tt>"File/New"</tt> (if the hidden preference option
<tt/"NewLoadsEnv"/ is switched on).
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"Scripts"/ is a list of Tcl scripts that will
be executed on startup. The scripts have to be specified with full
path and filename. If non absolute paths are used they are relative
to the current directory of Ayam on application startup (which is typically
the directory where the Ayam executable resides).
Multiple entries have to be separated by a colon (<tt/":"/) on Unix and by
a semicolon (<tt/";"/) on Win32.

<item><tt/"Plugins"/ is a list of directories that contain custom
objects or plugins. Those directories will e.g. be searched for
custom objects when unknown object types are encountered while reading
Ayam scene files. If a matching custom object is found, it will be
automatically loaded into Ayam, so that scene loading may proceed without
an error. If non absolute paths are used they are relative
to the directory where the Ayam executable resides.
Multiple entries have to be separated by a colon (<tt/":"/) on Unix and
by a semicolon (<tt/";"/) on Win32.

<item><tt/"Docs"/ is an URL that points to the documentation in
HTML format.

<item><tt/"TmpDir"/ is the directory, where temporary RIB files are
created, e.g. when rendering directly from view windows.
</itemize>

The preference settings <tt/"ListTypes"/, <tt/"MarkHidden"/,
<tt/"LoadEnv"/, and <tt/"NewLoadsEnv"/ are hidden preference
settings since Ayam 1.14, see section
<ref id="hidprefs" name="Hidden Preference Settings">.


<sect2>Modelling Preferences<label id="prefmodel"><label id="prefmodeling">
<p>
The next section of the preferences, <tt/"Modelling"/,
contains modelling related settings:
<itemize>
<item><tt/"PickEpsilon"/ is used by the single point editing actions
(see section <ref id="editac" name="Editing Points">)
to determine which point (vertice) of an object has been selected.
A smaller <tt/"PickEpsilon"/ means more exact picking.
The value of <tt/"PickEpsilon"/ should be positive. In older versions
of Ayam (prior to 1.8), a value of 0.0 was allowed. This is no longer the
case.

<item><tt/"LazyNotify"/ determines whether notification shall
occur on all mouse movements or just on release of the mouse button,
for the interactive modelling actions.

Notification is the mechanism used to inform objects that rely
on certain child objects (e.g. the Revolve tool object) about
changes of their child objects, so that the parent can adapt
to the child objects automagically
(see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).

<item><tt/"CompleteNotify"/ determines when notification of all objects
depending on references of changed objects takes place:
<itemize>
<item><tt/"Never"/, for manual control of complete notification
(manual complete notification can be carried out using the main
menu entry <tt>"Tools/Force Notification"</tt>);
<item><tt/"Always"/, a complete notification is done whenever the
normal notification is carried out;
<item><tt/"Lazy"/, the complete notification runs
only after a modelling action finished (when the mouse button is
released).
</itemize>
Note that complete notify also updates objects that implicitly depend on
updated objects via instances.

<item><tt/"EditSnaps"/ determines, whether points
should be snapped to the grid when a grid is defined and
in use for the single point modelling actions.

<item><tt/"Snap3D"/ controls, whether points that are snapped to
grid coordinates (in single point editing actions and when grids are active)
should be influenced in all three dimensions, or just the two dimensions
determined by the type of the view.

<item><tt/"FlashPoints"/ controls flashing of editable points in
the single point modelling actions when they would be modified by
a click and drag action.
Note that a change of this preference option takes effect after the
current modelling action has been switched off and the single point
editing has been activated (again).

<item><tt/"DefaultAction"/ determines the modelling action
that should be active after a press of the <tt/&lt;Esc&gt;/ key.

<item><tt/"UndoLevels"/ determines the number of modelling steps
that should be saved in the undo buffer. Useful values range
from 2 to 50 (depending on how much memory you like to spend).
If you set <tt/"UndoLevels"/ to -1, the undo system will be disabled
completely.
For more information, see also the section
<ref id="undos" name="The Undo System">.
</itemize>

<sect2>Drawing Preferences<label id="prefdraw"><label id="prefdrawing">
<p>
The preferences in the <tt/"Drawing"/ section let you specify
how objects are being drawn:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a NURBS curve
or NURBS patch using GLU.
Smaller tolerance settings lead to higher quality. Useful values
range from 1 to 100.
This setting has no effect for objects that override it
using a local tolerance setting different from 0.

<item><tt/"NPDisplayMode"/ sets the display mode for NURBS patches.
Either the control hull (or control polygon) is drawn (ControlHull), or
just the outlines of the polygons created by the tesselation
(OutlinePoly), or just the outlines of the patch (OutlinePatch).
Note that this setting just affects the drawing of patches if
the view is not in shaded mode.
Note also, that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<item><tt/"NCDisplayMode"/ sets the display mode for NURBS curves,
The control hull (control polygon) or the curve or a
combination of both may be displayed.
Note that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<item><tt/"UseMatColor"/ determines, whether the shaded representation
uses the color defined by the material of an object for
rendering.

<item><tt/"Background"/, <tt/"Object"/, <tt/"Selection"/, <tt/"Grid"/,
<tt/"Tag"/, <tt/"Shade"/, and <tt/"Light"/ let you set colors that
will be used when drawing or shading.
</itemize>

<sect2>The RIB-Export Preferences<label id="prefrib"><label id="prefrib-export">
<p>
The <tt/"RIB-Export"/ section of the preferences contains settings that
affect how RIBs are created.
<itemize>
<item><tt/"RIBFile"/ allows to set the file Ayam is exporting
RenderMan Interface Bytestreams (RIBs) to. Note that some
filenames have special meaning:
<p>
If you set <tt/"RIBFile"/ to <tt/"Scene"/ (this is the default)
the RIB file name will be derived from the name of
the currently loaded scene with the last extension replaced by
<tt/".rib"/. If you set <tt/"RIBFile"/ to <tt/"Scenefile"/, the leading
path will be stripped from the scene name additionally.
Use <tt/"Scenefile"/, if you render with shadow maps.
This way the scene will use relative paths to
load the shadow maps and you may move
the RIBs around more easily.
<p>
<tt/"Ask"/ is another special setting, that allows
to select a different filename each time you export a RIB file.
A file selection dialog will pop up, after the selection of the
view to export.
The same effect may be achieved by leaving <tt/"RIBFile"/ totally
empty!
<p>
If you set <tt/"RIBFile"/ to <tt/"rendrib"/,
libribout.a does not create a RIB file at all, but immediately pipes the
resulting byte stream into rendrib (the BMRT renderer) for rendering.
The same goes for <tt/"rgl"/.
Moreover, filenames that start with a pipe symbol <tt/"|"/ will
cause the program behind the pipe symbol to be started by libribout
and the written RIB to be piped into. This works e.g.
with Photorealistic RenderMan, try it out with <tt/"|render"/.
In the latter cases of direct rendering, you will probably want to set
up the RIB to render to the display (read leave the <tt/"Image"/
preference setting empty.
However, when you use these options of direct rendering, be warned, that
for the time of the rendering Ayam will be frozen (it will neither
respond to mouseclicks nor will it update any windows), until the
rendering is finished and the display window of the renderer is closed.

<item><tt/"Image"/ specifies the image file that will be created,
when you render the exported RIB file.
You may set it to <tt/"RIB"/, this will create image
files that are named as the exported RIB file (with the last
file extension replaced by <tt/".tif"/). Again, setting
it to <tt/"Ask"/ will cause a dialog box to appear,
each time you export to a RIB file.
<p>
Note that in contrast to the <tt/"RIBFile"/ option leaving the field
totally empty is not equal to entering <tt/"Ask"/ but generates
RIB files that will be set up to render to the display.

<item><tt/"ResInstances"/, if this is enabled all instance
objects are resolved (temporarily) before being written to the RIB file.

<item><tt/"CheckLights"/, if this is enabled Ayam will
check the current scene for lights before RIB export. If no lights or
no lights that are actually switched on are to be found in
the scene, a distant headlight will be added to the scene
automatically for RIB export.

<item><tt/"DefaultMat"/ determines a default material setting
that should be written in the top level of the RIB, so that it
is in effect for all objects, that are not connected to a material
object. Many RenderMan compliant renderers will not render the
objects at all, if no material is defined.
The default <tt/"matte"/, writes just a simple
<tt>RiSurface "matte"</tt> (without parameters) to the RIB.
The setting <tt/"default"/ looks for a material object named
<tt/"default"/ and writes it's complete shaders and attributes,
if it does not find such a material it falls back to <tt/"matte"/.
The setting <tt/"none"/ does not write any default material setting.

<item><tt/"RIStandard"/ determines whether Ayam
should omit all non standard RenderMan interface options and
attributes on RIB export.

<item><tt/"WriteIdent"/ determines, whether Ayam should
write special RiAttributes
(<tt>RiAttribute "identifier" &lsqb;"name"&rsqb;</tt>)
with the names of the objects to the RIB to aid in RIB file debugging.

<item><tt/"ShadowMaps"/ determines, whether shadow maps should
be used, when writing light sources. It is not sufficient
to switch this on to render using shadow maps, light sources
that shall use shadow maps have to be parameterised
as well, see section <ref id="shadowmaps" name="Using ShadowMaps">.
If <tt/"ShadowMaps"/ is set to <tt/"Automatic"/, the
exported RIBs will automatically render and use all shadow maps;
if it is set to <tt/"Manual"/, the shadow maps will be rendered on
user request only (e.g. using the view menu entry:
<tt>"View/Create All ShadowMaps"</tt>). <tt/"Manual"/ should be used,
when rendering directly from view windows with shadow maps.

<item><tt/"ExcludeHidden"/ causes hidden objects not to be
exported to RIB files.

<item><tt/"RenderMode"/ allows to switch between two different methods
of forcing a renderer to render to the screen (via a RiDisplay statement
in the exported RIB, necessary for e.g. PRMan and RDC;
or via a command line argument, e.g. <tt>-d</tt> for rendrib from BMRT).

<item><tt/"QRender"/ determines the command that should be executed,
upon quick rendering a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"QRenderUI"/, enables the Rendering GUI for quick rendering,
see discussion of <tt/"RenderUI"/ below.

<item><tt/"QRenderPT"/, progress template for quick rendering,
see discussion of <tt/"RenderPT"/ below.

<item><tt/"Render"/ determines the command that should be executed,
upon normal rendering of a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"RenderUI"/ enables the renderer user interface (Rendering GUI),
which consists of a simple progress bar, a label that displays the
estimated or elapsed rendering time, a checkbutton to control
ringing the bell when the rendering is finished,
and a cancel button. This GUI is displayed
when a renderer is invoked directly from a view window
using the <tt/"Render"/ view menu entry (or the equivalent keyboard shortcut).
Proper work of this GUI depends on the existence of
two external programs: <tt/"cat"/ and <tt/"kill"/ (those programs
should be available on every Unix platform). If you do not have
those programs in your path, do not enable the RenderUI option.
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"RenderPT"/ is a string that contains a progress output
template used by Ayam to determine the current percentage of completion
of the rendering for display in the Rendering GUI. The special symbol <tt/"%d"/
denotes the position of the percentage number in the output of the renderer.
For rendrib from BMRT2.6 this should be set to <tt/"R90000 %d"/ and
the special command line option <tt/"-Progress"/ should be used.
For rendrib from BMRT2.5 it should be set to <tt/"Done computing %d"/
and no special option has to be given to the renderer.
If the output of the renderer contains variable strings before
the progress number, a second variant of parsing the output using
regular expressions is available since Ayam 1.6. In this case, the
progress template should be a complete regexp command for Tcl
that parses the string contained in the variable named <tt/"string"/
and puts the parsed progress number into a variable named <tt/"progress"/.
Here is an example that works with Pixie-1.2.1, which outputs
strings like <tt/"fish.rib (222):  - 10.00 percent"/:
<code>
regexp -- {^.* - (\[0-9\]+)} string dummy percent
</code>

<item><tt/"SMRender"/, renderer to use for the rendering of shadow maps
(e.g. view menu entry <tt>"View/Create All ShadowMaps"</tt>),
see also section <ref id="shadowmaps" name="Using ShadowMaps">.
<tt>%s</tt> denotes the name of the RIB file.

<item><tt/"SMRenderUI"/, enables the Rendering GUI for the rendering
of shadow maps, see discussion of <tt/"RenderUI"/ above.

<item><tt/"SMRenderPT"/, progress template for the rendering
of shadow maps, see discussion of <tt/"RenderPT"/ above.

<item><tt/"SMFileFormat"/, designates the file format of the shadow maps,
use <tt/"zfile"/ for RenderMan and <tt/"shadow"/ for Gelato.

<item><tt/"SMFileType"/, type of shadow maps to be created, currently
available types are <tt/"z"/ - normal shadow maps (for RenderMan
renderers and Gelato), <tt/"avgz"/ - Woo shadow maps (for Gelato only!),
and <tt/"volz"/ - volume shadow maps (for Gelato only!).

<item><tt/"SMChangeShaders"/, toggles, whether Ayam should automatically
prepend a "shader" to light shader names for lights that use shadow maps
upon RIB export. Not changing the shader names is necessary for Gelato.

<item><tt/"PPRender"/ is the name of the renderer to use for the
permanent preview feature (see also section <ref id="vm" name="View Menu">).
This setting is just available, if the compile
time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
</itemize>

Note that you can set many renderer related preferences at once using the
select renderer tool via the main menu <tt>Special/Select Renderer</tt>
(see also section <ref id="mmspecial" name="Special Menu">). In fact,
using <tt>Special/Select Renderer</tt> first, then fine tuning your
renderer setup using the preferences editor is the suggested way to
switch Ayam to a certain RenderMan renderer.

<sect2>Miscellaneous Preferences<label id="prefmisc">
<p>
The (<tt/"Misc"/) section of the preferences contains the dreaded
miscellaneous settings.

The first sub-section deals with error message handling:
<itemize>
<item><tt/"RedirectTcl"/ controls, whether error messages
stemming from Tcl/Tk should be redirected to the console,
rather than be handled by Tcls sometimes annoying error
handling dialog box. However, this dialog box with the built in
stack trace can also become very handy, if you write and debug
Tcl scripts.

<item><tt/"Logging"/ determines, whether error messages should
be written to the file specified by <tt/"LogFile"/.
If this is enabled, you should clear the log manually from time
to time, as Ayam will always append to <tt/"LogFile"/.

<item><tt/"LogFile"/; see above.
</itemize>

The last sub-section contains miscellaneous user interface
related preferences:
<itemize>
<item><tt/"SaveAddsMRU"/; if this is switched on, saving to a file
will add that file to the most recently used files list in the
main menu for quick access.

<item><tt/"ToolBoxTrans"/; controls whether the toolbox window
should be declared as a transient window of the main window.
It will then, depending on the window manager or its configuration,
get a different or no decoration, no icon (or no entry in the
task bar on Windows), and will always be iconified
when the main window gets iconified.

<item><tt/"ToolBoxShrink"/; controls whether the toolbox window
should automatically shrink-wrap around the calculated layout
of the buttons after a resize operation.

<item><tt/"RGTrans"/; controls whether the RenderUI-windows
should be declared as a transient window of the main window.
See the discussion of <tt/"ToolBoxTrans"/ above for more information
about transient windows.

<item><tt/"HideTmpTags"/ may be used to hide tags that are marked
temporary (internal tag types do so) from the tag property GUI.

<item><tt/"TclPrecision"/; this is the precision Tcl handles floating
point numbers with. You may want to decrease this number to about 5
if any numbers in the entry fields are represented in an exact, but also
too lengthy and hard to read fashion, like 0.4999999 instead of 0.5.
Note that you may lose information in doing so. The default value used
by Tcl is 12 and results in no loss of information. The default value
used by Ayam is 6 and should result in a good balance between precision
and readability.

<item><tt/"SavePrefsGeom"/ controls when the geometry of the preferences
editor should be remembered by Ayam, <tt/"Never"/: the window is always
opened in standard size, centered on the screen; <tt/"WhileRunning"/:
the window width and position will be remembered as long as Ayam is
running; <tt/"Always"/: the window width and position will be remembered
in the saved preferences, thus, also surviving a restart of Ayam.
Note that the height of the preferences window will always be adapted
to the currently open preferences section, no matter how <tt/"SavePrefsGeom"/
is set.

<item><tt/"SMethod"/; is the sampling method used by the NURBS to PolyMesh
(tesselation) facility (based on GLU V1.3+). Five methods are available:
<tt/"DomainDistance"/ (the default) simply tesselates the NURBS into equally
sized pieces with regard to parametric space; <tt/"SParamU"/ and
<tt/"SParamV"/ control the number of sampling points in U and V direction
respectively per unit length.
This leads to different numbers of samples for knot vectors
of different length in parameter space!
The tesselation method <tt/"PathLength"/ ensures that no edge of a
polygon generated by the tesselation is longer than the value specified
by <tt/"SParamU"/ and the tesselation method <tt/"ParametricError"/
ensures that the distance between the tesselated surface and the original
surface is no point bigger than the value specified by <tt/"SParamU"/.
Note that <tt/"SParamU"/ is expressed in object space units for the
<tt/"PathLength"/ and <tt/"ParametricError"/ tesselation methods.
To overcome the limitations of the <tt/"DomainDistance"/ tesselation
method, Ayam 1.9 supports two new modes <tt/"NormalizedDomainDistance"/
and <tt/"AdaptiveDomainDistance"/, where <tt/"NormalizedDomainDistance"/
ensures that the tesselation creates the same number of sample
points (as given via <tt/"SParamU"/ and <tt/"SParamV"/) for any
knot vector and <tt/"AdaptiveDomainDistance"/ additionally adds
sample points dependend on the number of control points (width or
height of the patch) to provide a better adaptation to complex patches.

<item><tt/"SParamU"/; is a parameter for the sampling method above.
The default value for the sampling method <tt/"DomainDistance"/ is 10. Higher
values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"PathLength"/ is 30.
Smaller values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"ParametricError"/ is 0.5.
Smaller values lead to better quality and more tesselated polygons.

<item><tt/"SParamV"/; is just available for the tesselation modes
<tt/"DomainDistance"/, <tt/"NormalizedDomainDistance"/, and
<tt/"AdaptiveDomainDistance"/.
</itemize>

<sect>Interactive Actions (Modelling)<label id="iac">
<p>
Before invoking any modelling action you should select one or more
objects using the object hierarchy in the main window or using the
pick action!
<p>
Every action can be started with a key press (a shortcut) when
the keyboard focus is in a view window or by clicking on the associated
button in the toolbox window.
Using a keyboard shortcut starts that action in the current view only,
the other views are not affected. Starting an action from the
toolbox window will cause the action to be started in all
view windows that are currently open simultaneously.
<p>
It is perfectly ok to start and work with many different actions at
the same time in different views: you can have e.g. a view, where you move
objects, a second where you rotate objects and a third, where you pick
objects. The layout, drawing style, and grids may also differ between
the different views. Together with the feature, that you may change
the selection while actions are active and even pan and zoom views
(using the rightmost and middle mouse buttons respectively) while
actions are active and without breaking them, this is the key to
unsurpassed flexibility in modelling using Ayam.
<p>
To break an action, the <tt/&lt;Esc&gt;/ key may be used.
<p>
The default action for all views, which is also in effect after
use of the <tt/&lt;Esc&gt;/ key, is <tt/"None"/ or <tt/"Pick"/
(depending on the preference setting <tt>"Modelling/DefaultAction"</tt>).
See section
<ref id="objsel" name="Selecting Objects within a View">
for more information about picking objects.
<p>
Note that the modelling actions are not available in perspective views.
<p>
If an action is in effect for a view, the views title will be changed
appropriately.
<p>
A modelling action is performed by clicking into the view with the
leftmost mouse button to mark a point in space or to pick a vertex
and then by dragging the mouse.
<p>
You may undo/redo the effects of a modelling action using <tt/&lt;Ctrl+z&gt;/
and <tt/&lt;Ctrl+y&gt;/ (see section
<ref id="undos" name="The Undo System"> for more information).
<p>
Grids are available to restrict the modelling actions to certain
points and help in exact modelling.
<p>
Also note that you may use the middle and rightmost mouse button
to zoom and move the view while modelling actions are active.
<p>
For actions that modify the camera of a view
please see section <ref id="vwsc" name="View Window Shortcuts and Actions">.

<sect1>Moving Objects or Selected Points
<p>
Using the modelling action <tt/"Move"/ (shortcut: <tt/&lt;m&gt;/)
you may move selected objects or the selected (tagged) points
of the selected objects.
<p>
Note that the objects/points will be moved in the XY-plane for
Front-views, the ZY-plane for Side-views, and the XZ-plane
for Top-views only, no matter how the view is rotated.

<sect1>Rotating Objects or Selected Points<label id="rotac">
<p>
Using the modelling action <tt/"Rotate"/ (shortcut: <tt/&lt;r&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects.
<p>
The axis of rotation is always parallel to the Z-axis in Front-views, the
Y-axis in Top-views, and the X-axis in Side-views of the local
object coordinate system. The orientation of the object coordinate system
may change in respect to the world coordinate system if a sequence of
rotate modelling actions is applied.
<p>
Note that if multiple objects are selected, each object is rotated
around the center of its own local coordinate system.

<sect1>Rotating Objects or Selected Points around a Point
<p>
Using the modelling action <tt/"Rotate about"/ (shortcut: <tt/&lt;a&gt;/)
you may interactively rotate objects or the selected (tagged) points
of the selected objects around a specified point in space.
The action requires a point to be specified using a single
click after the action has been started.
The point will then be marked by a little red cross.
If you want to rotate about a different point, you need to restart the
action (simply press <tt/&lt;a&gt;/ again).
<p>
After the first click, the action works the same way as
the Rotate action, except that it rotates the selected object(s)
around the specified point.
This, consequently, also works with multiple selected objects.
Note that this action does not only change the Rotate_X(_Y,_Z)
properties of the selected objects, but also the Translate_X(_Y,_Z)
properties.
<p>
To avoid degenerated coordinates due to roundoff errors
it is highly suggested to use grids with this action.

<sect1>Scaling Objects or Selected Points<label id="scalac">
<p>
There are several different actions available to interactively scale
objects or the selected (tagged) points of the selected objects:
<p>
The modelling action <tt/"Scale 3D"/ (shortcut: <tt/&lt;S&gt;/, note the
big S!) scales all three axes of the selected objects or
the selected (tagged) points of the selected objects
by the same factor.
<p>
The modelling action <tt/"Scale 2D"/ (shortcut: <tt/&lt;s&gt;/)
scales just two axes of the selected objects or
the selected (tagged) points of the selected objects. Those axes are
XY in a Front-view, ZY in a Side-view, and XZ in a Top-view.
<p>
The modelling actions <tt/"Scale X"/ (shortcut: <tt/&lt;x&gt;/),
<tt/"Scale Y"/ (shortcut: <tt/&lt;y&gt;/), and
<tt/"Scale Z"/ (shortcut: <tt/&lt;z&gt;/) scale only one axis
of the selected objects or
the selected (tagged) points of the selected objects.
<p>
The modelling action <tt/"Stretch 2D"/ (shortcut: <tt/&lt;Alt+s&gt;/)
works much like <tt/"Scale 2D"/ but the scale factor for each
axis may be different. Never start this action by a click
near one of the axes to be changed, as this will cause
very big scale factors for the other axis. Try it first with
a centered box by starting from one of the vertices,
then try it once starting on the X-axis.

<sect1>Selecting Points<label id="selac">
<p>
The modelling action <tt/"Select Points"/
(shortcut: <tt/&lt;t&gt;/; for <em>t</em>ag points)
may be applied to a NURBS curve, NURBS patch, or objects
that support single point editing only. Objects usually draw their
selectable points using small white rectangular handles (when a
modelling action is active).
<p>
Selected points will be drawn in dark red when a modelling action is active.
<p>
The selected points may be modified subsequently using the modelling actions
Move, Rotate, and Scale as discussed above.
Selected points always take precedence for those modelling actions.
<p>
After the pick (the selection of a point), the picked point
will be added to the list of selected points for the selected object.
If the selected point is already in that list it will be removed from
the list instead. Note that the list of selected points will not be
deleted from the object until an explicit deselection is performed
using the shortcut <tt/&lt;D&gt;/. Unfortunately, undo, redo, and
certain modelling actions like inserting or deleting control points
will also destroy the list of selected points.
<p>
Note that the list of selected points is not copied, if the object
is copied using the clipboard.
<p>
It is perfectly legal to select some points, move them using
the move action, then switch to single point editing, edit
some other or even one of the selected points, switch back
to the selection action, add other points to the selection or delete some
points from the selection, switch to rotate, rotate the selected
points and so on.
<p>
You may also add a bigger number of points to the selection using a
click and drag operation. All points that are inside the rectangular
region defined by the click and drag will be added to the selection.
In fact, this approach is the only way to safely add points to the
selection that occlude each other.

<sect1>Editing Points<label id="editac">
<p>
To edit the points of an object three actions (<tt/"Edit"/,
<tt/"Edit Weights"/, and <tt/"Direct Point Edit"/) are available.
All those actions may be applied to objects that support single point
editing only.
Objects mark themselves editable by drawing the editable points using
small white rectangular handles if one of the single point editing actions
is activated and the object is selected.
<itemize>
<item>The modelling action <tt/"Edit"/ (shortcut: <tt/&lt;e&gt;/)
works much like the move action, but it moves single points instead of
objects. In contrast to the move action, you need to directly pick on
the handle of the point you want to move. Furthermore, it is not possible
to move points of multiple selected objects, only the first selected
object is considered.
<p>
If a multiple point is edited, this action modifies all single
points that make up the multiple point, i.e. you can not move
single points apart from a multiple point using the point
edit action.

<item>The modelling action <tt/"Edit Weights"/ (shortcut: <tt/&lt;w&gt;/)
changes the w coordinate of a single point by dragging the mouse left
or right. The weights may be reset for all points
using the shortcut: <tt/&lt;W&gt;/. Furthermore, it is
not possible to edit the weights of multiple selected objects, only
the first selected object is considered.
<p>
If a NURBS curve has multiple points, this action modifies all
single points that make up the multiple point.

<item>The modelling action <tt/"Direct Point Edit"/ (shortcut:
<tt/&lt;p&gt;/)
opens a small window where you may change the coordinates of the
selected point directly by entering numbers.
Note that the w coordinate setting will be ignored if the
picked point does not have weight information (is not homogenous).
Using the small menu on top of the coordinate window you may
determine whether editing takes place in local object or global
world space. This modelling action also only affects the points
of the first of multiple selected objects.
<p>
If a multiple point is edited, this action modifies all single
points that make up the multiple point, i.e. you can not move
single points apart from a multiple point using the direct point
edit action.
<p>
Notice that since Ayam 1.4 the direct point editing dialog may stay
open all the time. Furthermore, it is not necessary that the original
object stays selected while working with the direct point edit dialog,
you may select other objects to e.g. infer new point coordinates from
their properties and apply them to the original object.
However, certain actions like deleting objects, will also delete the
reference to the selected points. In this case you will have to select
the object and then a point to edit again. Furthermore notice that
the coordinate values displayed in the direct point editing window
will not update when the point is modified by another modelling
action. Simply click on the point again in a view where the
direct point editing action is active, to update the coordinate
values in the direct point editing dialog.
<p>
Even though the dialog may display point coordinates in degraded
accuracy (due to floating point to string conversion, see also
the discussion of the <tt/"TclPrecision"/ preference option in
section <ref id="prefmisc" name="Miscellaneous Preferences">),
the original point data is unchanged and its accuracy is not affected
as long as the new data is not applied.
</itemize>

<sect1>Snapping Points to the Grid<label id="snapac">
<p>
Since Ayam 1.11 there are two actions available that let
you snap points to the current grid of a view.
The actions are initiated using the shortcuts <tt/&lt;g&gt;/
and <tt/&lt;G&gt;/. If an object has selected (tagged)
points, only those points will be snapped to the grid,
otherwise all points of the object will be snapped to the grid.
If <tt/&lt;g&gt;/ is used, the snapping only occurs in
the modelling plane associated with the view (i.e. in 2D).
To snap all three coordinate values to the grid use <tt/&lt;G&gt;/.
Note that the snapping also occurs, if the view has the preference
option <tt/"Use Grid"/ turned off.

<sect1>Inserting or Deleting Points<label id="insdelac">
<p>
The modelling action <tt/"Insert Point"/ (shortcut: <tt/&lt;i&gt;/)
may be applied to NURBS, interpolating, and approximating curves
(objects of type NCurve, ICurve, and ACurve) only.
A new control point will be inserted in the curve right
after the picked point. The new point will be inserted in the
middle between the selected point and the next point, changing
the shape of the curve. (It is also possible to insert control
points into certain types of NURBS curves without changing
their shape using knot insertion;
see also the insert knot tool section
<ref id="insknt" name="The Insert Knot Tool">.)
<p>
The modelling action <tt/"Delete Point"/ (shortcut: <tt/&lt;d&gt;/)
may be applied to NURBS, interpolating, and approximating curves
(objects of type NCurve, ICurve, and ACurve) only.
The selected control point will be deleted from the curve.
Deleting points from a curve with knot type <tt/"Custom"/
may currently lead to an incorrect knot sequence, please
check and correct the new sequence manually.

<sect1>Miscellaneous Actions<label id="miscac">
<p>
This section documents some special modelling actions.
<itemize>
<item>The modelling action <tt/"FindU"/ (shortcut: <tt/&lt;u&gt;/)
may be applied to NURBS curves (objects of type NCurve) only.
This action may be used to get the corresponding parametric
value u from a point on a curve. Pick a point on the curve
(not a control point!). If this
is done, the appropriate value for u is calculated, stored
in the global variable u, and additionally written to the console.
A small cross is drawn at the position of the picked point.
Remember to exactly pick a point on the curve or nearby, otherwise
the calculation may fail and no value will be written to the console.

<item>The modelling action <tt/"Split Curve"/ (shortcut <tt/&lt;c&gt;/)
may be applied to NURBS curves (objects of type NCurve) only.
Using this action you may split a NURBS curve into two new curves
at a point on the curve that may be specified by picking a point
on the curve.
Remember to exactly pick a point on the curve or nearby otherwise
the calculation of the parametric value for the split will fail.
The selected curve will be changed by this action, and
a new curve will be created. It is currently not possible to undo
the changes of a split!
</itemize>

<sect1>Editing in Local Space<label id="editlocal">
<p>
Normally, all editing takes place in world space and the input
plane of all modelling actions is constrained to the world
XY-, ZY-, or XZ-plane (depending on the type of view used).
<p>
However, if a view is aligned and switched to local, you can also
edit in local object space. This means you can e.g. edit a
two-dimensional parameter curve of a skin object where both objects
(curve and skin) are rotated and scaled arbitrarily
and make sure that the curve remains two-dimensional all the time.
<p>
All you need to do is to first select the curve and then press
<tt/&lt;Ctrl+a&gt;/ to align the view and then <tt/&lt;Ctrl+l&gt;/ to
make it local.
In practice, this means that the input plane of an aligned local view
will match the XY-, ZY-, or XZ-plane of the local object space,
depending on the type of the view (<tt/"Front"/, <tt/"Side"/, or <tt/"Top"/).
<p>
Furthermore, grids will also act as if defined in local object space.
Note that in contrast to their normal behaviour, grids can also be scaled
differently in X-window and Y-window coordinates in aligned local views
(if the local object space is deformed this way).

<sect>Objects, Properties, and Tags<label id="obandprp">
<p>
This section informs you about the different object types of Ayam and
about the property GUIs that appear in the properties section of the
main window if a single object and a property have been selected.
<p>
Documentation on the standard properties (Transformations, Attributes,
Material, Shader, and Tags) can be found in
section <ref id="stdprop" name="Standard Properties">.
<p>
Furthermore, this section contains information about all tag types,
see section <ref id="tags" name="Tags">.
<p>
In the next sections general object capabilities will be briefly
documented in tables like this:
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Object Type|No/Object Type+/*|Yes/No|N/A&thinsp;/&thinsp;Children&thinsp;/&thinsp;Object Type+/*|Yes/No@<hline>
</tabular>
<caption>Object Capabilities Example</caption>
</table>
The capabilities are:
<itemize>
<item><bf/Parent of/: the object is a parent object (can have child
objects of the designated type), + - multiple child objects may be present,
* - multiple child objects must be present, note that the type of the
child object must not directly match, the child must rather provide an object
of the appropriate type (see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">);
<item><bf/Material/: the object can be associated with a material;
<item><bf>Converts to/Provides</bf>: type of converted/provided objects
(Children means, the provided objects of the children are delivered upstream),
+ - multiple objects may be provided, * - multiple objects will be provided;
<item><bf/Point Edit/: the object has editable points.
</itemize>

<#if out=latex><x/newpage/</#if>

<sect1>Object Types Overview
<p>
This section provides an overview on the object types available in
Ayam (since there are so many).
The object types are grouped by application in the following sections.

<sect2>Scene Organization
<p>
These objects help to organize the scene apart from
geometric objects:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Root|No|No|N/A|No@<hline>
Level|Any (+)|Yes|N/A&thinsp;/&thinsp;Children (+)|No@<hline>
Clone|Any (+)|No|Children (+)|No@<hline>
Instance|No|No|Master|No@<hline>
Select|Any (+)|No|N/A&thinsp;/&thinsp;Children (+)|No@<hline>
View|No|No|N/A|Yes@<hline>
Camera|No|No|N/A|Yes@<hline>
Material|No|N/A|N/A|No@<hline>
Light|No|No|N/A|Yes@<hline>
RiInc|No|No|N/A|No@<hline>
RiProc|No|No|N/A|No@<hline>
</tabular>
<caption>Scene Organization</caption>
</table>

<sect2>CSG/Solid Primitives
<p>
These objects serve as geometric primitives in CSG hierarchies:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Box|No|Yes|NPatch*|No@<hline>
Sphere|No|Yes|NPatch+|No@<hline>
Disk|No|Yes|NPatch|No@<hline>
Cone|No|Yes|NPatch+|No@<hline>
Cylinder|No|Yes|NPatch+|No@<hline>
Torus|No|Yes|NPatch+|No@<hline>
Paraboloid|No|Yes|NPatch+|No@<hline>
Hyperboloid|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>CSG/Solid Primitives</caption>
</table>


<sect2>Freeform Curves
<p>
These objects are mainly used as child objects for the surface
generating tool objects:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCurve|No|No|N/A|Yes@<hline>
ICurve|No|No|NCurve|Yes@<hline>
ACurve|No|No|NCurve|Yes@<hline>
NCircle|No|No|NCurve|No@<hline>
</tabular>
<caption>Freeform Curves</caption>
</table>


<sect2>Freeform Surfaces
<p>
These objects enable direct manipulation of freeform surfaces:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NPatch|NCurve+/Level+|Yes|PolyMesh|Yes@<hline>
BPatch|No|Yes|NPatch|Yes@<hline>
PatchMesh|No|Yes|NPatch|Yes@<hline>
</tabular>
<caption>Freeform Surfaces</caption>
</table>


<sect2>Curve Tool Objects
<p>
These objects modify existing curves or create new curves:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNC|NCurve*|No|NCurve|No@<hline>
ExtrNC|NPatch|No|NCurve|No@<hline>
OffsetNC|NCurve|No|NCurve|No@<hline>
</tabular>
<caption>Curve Tool Objects</caption>
</table>

<#if out=latex><x/newpage/</#if>

<sect2>Surface Tool Objects
<p>
These objects mainly create freeform surfaces from curves:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Revolve|NCurve|Yes|NPatch+|No@<hline>
Extrude|NCurve+|Yes|NPatch+|No@<hline>
Swing|NCurve*|Yes|NPatch+|No@<hline>
Sweep|NCurve*|Yes|NPatch+|No@<hline>
Birail1|NCurve*|Yes|NPatch+|No@<hline>
Birail2|NCurve*|Yes|NPatch+|No@<hline>
Skin|NCurve*|Yes|NPatch+|No@<hline>
Gordon|NCurve*/Level|Yes|NPatch+|No@<hline>
Bevel|NCurve|Yes|NPatch|No@<hline>
Cap|NCurve+|Yes|NPatch|No@<hline>
Text|No|Yes|NPatch+|No@<hline>
Trim|NPatch/NCurve+/Level+|Yes|NPatch|No@<hline>
ConcatNP|NPatch*|Yes|NPatch|No@<hline>
ExtrNP|NPatch|Yes|NPatch|No@<hline>
</tabular>
<caption>Surface Tool Objects</caption>
</table>


<sect2>Polygonal and Subdivision Objects
<p>
These objects complement the Ayam feature set and allow
objects modelled in the polygonal or subdivision modelling
paradigms to be included in Ayam scenes:
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PolyMesh|No|Yes|SDMesh|Yes@<hline>
SDMesh|No|Yes|PolyMesh|Yes@<hline>
</tabular>
<caption>Polygonal and Subdivision Objects</caption>
</table>


<sect2>Scripts and Plugins
<p>
These objects create/modify arbitrary other objects from scripts
or define new object types via the custom object plugin
mechanism.
<table loc="!ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Script|Any+|No|Any|No@<hline>
MetaObj|MetaComp+|Yes|PolyMesh|No@<hline>
MetaComp|No|No|N/A|No@<hline>
</tabular>
<caption>Scripts and Plugins</caption>
</table>

<sect1>Root Object<label id="rootobj">
<p>
There is always exactly one Root object in the scene.
This object is something special in that it can not be deleted
or copied.
The Root object holds options global to the scene like RiOptions,
atmosphere and imager shaders. Furthermore, all currently open
view windows are represented as child objects of the Root object.
<p>
If you hide the Root object, the little red/green/blue coordinate system
will not be drawn in any view.
<p>
The global scene options are documented in the following sections.

<sect2>RiOptions Property<label id="rio"><label id="rioptionsprop">
<p>
The RiOptions property carries RenderMan Interface options.
Both, standard and BMRT specific options may be set using this
property. For the sake of brevity only a short description of
the available options will be given here.
Please refer to the documentation of the RenderMan Interface
and the documentation of BMRT for more detailed information about the
options.
<p>
The RiOptions property consists of the following elements:
<itemize>
<item><tt/"Width"/, <tt/"Height"/, if greater than zero this value
will be used for the image size instead of the corresponding
dimension of the view window, but only for real RIB export operations,
not for the QuickRender and not for the Render actions in view windows.
QuickRender and Render actions will always use the dimensions of the
view window instead.

<item><tt/"StdDisplay"/, if this is enabled, a standard display
statement will be written to the RIB, which looks like this:

<code>Display "unnamed.tif" "file" "rgba"</code>

If you disable this option, be sure to add atleast one
RiDisplay tag to the root object (see also section
<ref id="ridtag" name="RiDisplay Tag">), otherwise your RIB will
not contain a Display statement. This option has no effect on
RIBs created by the QuickRender and Render actions in view windows.

<item><tt/"Variance"/, maximum allowed variance of two pixel values.
The default 0.0 causes no setting in the RIB. If the variance is > 0.0
no pixel samples setting will be written to the RIB. Various
sources discourage the use of variance based sampling, because
e.g. the number of samples actually taken (and therefore the rendering
time) might not easily be predicted anymore.

<item><tt/"Samples_X"/, <tt/"Samples_Y"/ number of samples taken per
pixel.

<item><tt/"FilterFunc"/, function used to filter final pixel values.

<item><tt/"FilterWidth"/, <tt/"FilterWidth"/ size of the filter.

<item><tt/"ExpGain"/, Exposure

<item><tt/"ExpGamma"/, Exposure Gamma

<item><tt/"RGBA_ONE"/, <tt/"RGBA_MIN"/, <tt/"RGBA_MAX"/,
<tt/"RGBA_Dither"/, specify quantisation and dithering

<item><tt/"MinSamples"/, <tt/"MaxSamples"/, minimum and maximum number
of samples per pixels.

<item><tt/"MaxRayLevel"/, maximum number of recursive rays.

<item><tt/"ShadowBias"/, minimum distance that one object has to
be in order to shadow another object.

<item><tt/"PRManSpec"/, toggles behaviour of BMRT's specular() function
between PRMan compatible (default) and RiStandard compatible.

<item><tt/"RadSteps"/, number of radiosity steps, the default 0 leads
to no radiosity calculations to be performed.

<item><tt/"PatchSamples"/, minimum number of samples per patch to
calculate the radiosity form factors for this patch.

<item><tt/"Textures"/, <tt/"Shaders"/, <tt/"Archives"/ and <tt/"Procedurals"/
are search paths for the renderer.

<item><tt/"TextureMem"/ and <tt/"GeomMem"/ determine how much
memory rendrib (from BMRT) should use at maximum to cache textures and
tesselated geometry.
</itemize>

<sect2>Imager, Atmosphere Property<label id="imager">
<p>
The Imager and Atmosphere properties let you define shaders for the
Root object, please refer to section
<ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Imager shaders are executed once for every rendered pixel,
they may e.g. be used to set a specific background color.
<p>
Atmosphere shaders are volume shaders that
may be used to implement global atmospheric
optical effects like fog.

<sect1>View Object<label id="viewobj">
<p>
Every view window (see also section
<ref id="viewwin" name="Anatomy of a View">)
has a corresponding view object as a child object of the root object.
You can change camera settings, the type of the view,
and other things related to the view using the properties of the view object.
Note that deleting the object that represents a view, will not
close the view window. You will just lose a way to configure it.
Please, do not mess with the objects in other ways (e.g. copy them),
you are asking for trouble otherwise!
<p>
Each view is associated with a virtual camera.
The type of the view determines the Up-vector of that camera.
If the type is "Top" the Up-vector corresponds to the world
Z-axis, else the world Y-axis.
The type of the view, additionally, determines the so called input plane
of the view. Interactive modelling actions in a view are limited to that
input plane (unless the view is switched to local modelling; available since
Ayam 1.4; see also section <ref id="editlocal" name="Editing in Local Space">).
The standard input planes are as following: Front - XY-plane,
Side - ZY-plane, Top - XZ-plane, Trim - XY-plane.
<p>
In perspective views no interactive modelling actions are possible,
but you may position the camera, pick objects, and select points.
<p>
Views of type <tt/"Trim"/ are very special. They are used to edit
trim curves of NPatch objects only. They display <em>only</em>
those trim curves as normal NURBS curves when the current level is
inside a NPatch.
The extensions of the patch in parameter-space are drawn as a rectangle.
The trim curves should completely lie inside this rectangle.
Note that picking of objects currently does not work in views of type
<tt/"Trim"/.
<p>
View objects act in special ways, when certain objects are dropped
onto them in the tree view:
<p>
When a camera object is dropped onto a view object using Drag-and-Drop
in the tree view the camera settings of the camera object will be copied
to the views camera.
<p>
When a light object of type <tt/"Spot"/ is dropped onto a view object
using Drag-and-Drop in the tree view the views camera will be changed,
so that the user looks along the light to see what objects of the scene
are lighted by the light object (this works best with perspective views
that have equal width and height).
<p>
Since Ayam 1.8 it is possible, to directly drag objects from the
tree view to a view window, for geometric objects, the view then
performs a zoom to object operation, for cameras and light sources
the views camera will be changed as if the object was dropped
onto a view object in the tree view (see the above description).
<p>
The following table briefly lists some capabilities of the View object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
View|No|No|N/A|Yes@<hline>
</tabular>
<caption>View Object Capabilities</caption>
</table>
<p>
The next sections detail the properties of the view object.

<sect2>Camera Property<label id="camp"><label id="cameraprop">
<p>
This section describes all elements of the <tt/"Camera"/ property:
<itemize>
<item><tt/"From"/ is the point where the camera (that is attached
to the view) is situated.
<item><tt/"To"/ is the point the camera is looking to.
<item><tt/"Up"/ is the up vector of the camera.
<item><tt/"Near"/ defines the near clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Near should always be positive for perspective views, and
smaller than far.
<item><tt/"Far"/ defines the far clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Far should always be bigger than near.
<item><tt/"Roll"/ defines an angle by which the camera is rotated
around the axis that is defined by the points from and to.
<item><tt/"Zoom"/ is a zoom factor.
</itemize>

Note that the up vector is not checked for erroneous values
(e.g. pointing in the direction of from-to) when applying the changes
of the <tt/"Camera"/ property.

<sect2>ViewAttrib Property<label id="vat"><label id="viewattribprop">
<p>
This section describes the elements of the <tt/"ViewAttrib"/ property:
<itemize>
<item><tt/"Type"/ specifies the type of the view. Front, Side, Top (all
parallel), Perspective and Trim (again parallel) may be selected.
<item><tt/"Width"/ and <tt/"Height"/ control the size of the view
window.
<item><tt/"Redraw"/ toggles automatic redrawing of the view.
If this is disabled, no drawing takes place in the view until an
explicit redraw is requested (using the view menu, or the shortcut
<tt>&lt;Ctrl+d&gt;</tt>).
<item><tt/"Shade"/ toggles shading of surfaces.
Note that the lighting is in no way an exact (or even similar)
representation of the light information you specified with Light objects!
Instead, a single light source, located at the camera origin
(a headlight), will be used!

<item><tt/"DrawSel"/ toggles drawing of selected objects. If this is
enabled, only the current selected objects will be drawn.
<item><tt/"DrawLevel"/ toggles drawing of the objects of the current
level only. If this is enabled, only the objects of the current
level will be drawn.
<item><tt/"Grid"/ is the grid size, 0.0 means no grid.
<item><tt/"DrawGrid"/ toggles drawing of the current grid.
<item><tt/"UseGrid"/ toggles, whether the current grid should be
used by the interactive modelling actions.
<item><tt/"Local"/ enables editing in local object space.
See also section <ref id="editlocal" name ="Editing in Local Space">.

<item><tt/"DrawBG"/ controls whether the background image should
be drawn.
<item><tt/"BGImage"/ is the name of a TIFF file, that will
be used as texture for the background image. Ayam will read
this image once when you apply the changes to the
<tt/"ViewAttrib"/ property
but reread
the image file if the notification callback of the view object
is invoked (e.g. using the main menu entry
<tt>"Tools/Force Notification"</tt>).
</itemize>

<sect1>Camera Object<label id="cameraobj">
<p>
Camera objects are used to temporarily save camera settings
of views.
Therefore, they has just have two properties
explained above, see sections <ref id="camp" name="Camera"> and
<ref id="attrs" name="Attributes Property">.
<p>
When a view object is dropped onto a camera object using Drag-and-Drop
in the tree view, the camera settings from the view will be copied
to the camera object.
<p>
The following table briefly lists some capabilities of the Camera object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Camera|No|No|N/A|Yes@<hline>
</tabular>
<caption>Camera Object Capabilities</caption>
</table>

<sect1>Box Object<label id="boxobj">
<p>
A solid box, centered at the origin of the object coordinate system.
This object will always be exported as solid primitive in RIBs;
consisting of six bilinear patches.
<p>
Since Ayam 1.8.2, a box object may be converted to three NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Box object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Box|No|Yes|NPatch*|No@<hline>
</tabular>
<caption>Box Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a box:

<sect2>BoxAttrib Property<label id="bxp"><label id="boxattribprop">
<p>
<itemize>
<item><tt/"Width"/ is the width of the box (size of the box in
direction of the X axis of the objects coordinate system).
<item><tt/"Length"/ is the length of the box (size of the box in
direction of the Z axis of the objects coordinate system).
<item><tt/"Height"/ is the height of the box (size of the box in
direction of the Y axis of the objects coordinate system).
</itemize>

<sect1>Quadric Primitives<label id="qprim">
<p>
<figure loc="ht">
<eps file="pics/primitives.ps" height="7cm">
<img src="pics/primitives.gif">
<caption>Box, and Quadric Primitives</caption>
</figure>
<p>

<sect2>Sphere Object<label id="sphereobj">
<p>
A sphere, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple sphere (depending on the <tt/"Closed"/ parameter
of the SphereAttrib property) in RIBs.
<p>
Since Ayam 1.8.2, a sphere object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the sphere.
<p>
The following table briefly lists some capabilities of the Sphere object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Sphere|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Sphere Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a sphere:

<sect3>SphereAttr Property<label id="spattr"><label id="sphereattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and <tt/"ZMin"/, <tt/"ZMax"/ or
<tt/"ThetaMax"/ have other than the default values,
a single sphere will be written (in the worst case) as a
CSG hierarchy of two spheres, two cylinders and eight disks!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the sphere, default is 1.
<item><tt/"ZMin"/ may be used to chop the sphere off at a certain
place at Z.
<item><tt/"ZMax"/ may be used to chop the off at a certain
place at Z.
<item><tt/"ThetaMax"/ is the sweeping angle of the sphere (the default value
is 360).
</itemize>

<sect2>Disk Object<label id="diskobj">
<p>
A disk, centered at the origin of the object coordinate system.
This object will always be exported as simple disk in RIBs.
<p>
Since Ayam 1.8.2, a disk object may be converted to a NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the disk.
<p>
The following table briefly lists some capabilities of the Disk object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Disk|No|Yes|NPatch|No@<hline>
</tabular>
<caption>Disk Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a disk:

<sect3>DiskAttr Property<label id="dkp"><label id="diskattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the disk, default is 1.
<item><tt/"ZMin"/ displaces the disk along the Z axis, default is 0.
<item><tt/"ThetaMax"/ is the sweeping angle of the disk, default is 360.
</itemize>

<sect2>Cone Object<label id="coneobj">
<p>
A cone, centered at the origin of the object coordinate system,
with the base at the XY plane.
This object will be exported as solid primitive or as
simple cone (depending on the <tt/"Closed"/ parameter
of the ConeAttrib property) in RIBs.
<p>
Since Ayam 1.8.2, a cone object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cone.
<p>
The following table briefly lists some capabilities of the Cone object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cone|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Cone Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a cone:

<sect3>ConeAttr Property<label id="cnp"><label id="coneattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cone will be written (in the worst case) as a
CSG hierarchy of a cone, a disk and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cone at the base, default is 1.
<item><tt/"Height"/ is the height of the cone, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cone, default is 360.
</itemize>

<sect2>Cylinder Object<label id="cylinderobj">
<p>
A cylinder, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple cylinder (depending on the <tt/"Closed"/ parameter
of the RiCylinderAttr property) in RIBs.
<p>
Since Ayam 1.8.2, a cylinder object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cylinder.
<p>
The following table briefly lists some capabilities of the Cylinder object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cylinder|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Cylinder Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a cylinder:

<sect3>CylinderAttr Property<label id="cyp"><label id="cylinderattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cylinder will be written (in the worst case) as a
CSG hierarchy of a cylinder, two disks and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cylinder, default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cylinder, default is 360.
</itemize>

<sect2>Torus Object<label id="torusobj">
<p>
A torus, centered at the origin of the object coordinate system.
A torus is a donut like shape, that results from sweeping
a small circle ( that has been displaced along X sufficiently )
around the Z axis.
This object will be exported as solid primitive or as
simple torus (depending on the <tt/"Closed"/ parameter
of the RiTorusAttr property) in RIBs.
<p>
Since Ayam 1.8.2, a torus object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the torus.
<p>
The following table briefly lists some capabilities of the Torus object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Torus|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Torus Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a torus:

<sect3>TorusAttr Property<label id="top"><label id="torusattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"PhiMin"/, <tt/"PhiMax"/ or <tt/"ThetaMax"/ have different than the
default values,
a single torus will be written (in the worst case) as a
CSG hierarchy of a torus, two disks and two hyperboloids!
But it may be used in CSG operations, safely.
<item><tt/"MajorRad"/ is the radius of the torus, measured
from the Z axis to the center of the swept smaller circle, default is 0.75.
<item><tt/"MinorRad"/ is the radius of the swept circle, default is 0.25.
<item><tt/"PhiMin"/ determines an angle to limit the swept circle,
default is -180.
<item><tt/"PhiMax"/ determines an angle to limit the swept circle,
default is 180.
<item><tt/"ThetaMax"/ is the sweeping angle of the torus, default is 360.
</itemize>

<sect2>Paraboloid Object<label id="paraboloidobj">
<p>
A paraboloid, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple paraboloid (depending on the <tt/"Closed"/ parameter
of the RiParaboloidAttr property) in RIBs.
<p>
Since Ayam 1.8.2, a paraboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the paraboloid.
<p>
The following table briefly lists some capabilities of the Paraboloid object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Paraboloid|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Paraboloid Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a paraboloid:

<sect3>ParaboloidAttr Property<label id="pap"><label id="paraboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ZMin"/, <tt/"ZMax"/ or <tt/"ThetaMax"/ have different
than the default values,
a single paraboloid will be written (in the worst case) as a
CSG hierarchy of a paraboloid, two disks and two bicubic patches!
But it may be used in CSG operations, safely.
<item><tt/"RMax"/ is the radius of the paraboloid at a Z of <tt/"ZMax"/,
default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the paraboloid, default is 360.
</itemize>

<sect2>Hyperboloid Object<label id="hyperboloidobj">
<p>
A hyperboloid, centered at the origin of the object coordinate system.
This shape will be created by sweeping a line specified by two
points in space around the Z axis.
This object will be exported as solid primitive or as
simple hyperboloid (depending on the <tt/"Closed"/ parameter
of the RiHyperbAttr property) in RIBs.
<p>
Since Ayam 1.8.2, a hyperboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the hyperboloid.
<p>
The following table briefly lists some capabilities of the Hyperboloid object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Hyperboloid|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Hyperboloid Object Capabilities</caption>
</table>
<p>
The following parameters further control the shape of a hyperboloid:

<sect3>HyperboloidAttr Property<label id="hyp"><label id="hyperboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that due to a bug in BMRT that is still present in V2.3.6
this option does not work properly when
<tt/"ThetaMax"/ has a different than the default value and the
hyperboloid has no displacement shader. In fact, using a displacement
shader with a km (amount of displacement) of 0.0 is a work-around
for this bug (found by T. E. Burge).
Also note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single hyperboloid will be written (in the worst case) as a
CSG hierarchy of a hyperboloid, two disks and two bilinear patches!
<item><tt/"P1_X"/, <tt/"P1_Y"/ and <tt/"P1_Z"/, define point one,
default is (0, 1, -0.5).
<item><tt/"P2_X"/, <tt/"P2_Y"/ and <tt/"P2_Z"/, define point two,
default is (1, 0, 0.5).
<item><tt/"ThetaMax"/ is the sweeping angle of the hyperboloid, default is 360.
</itemize>

<sect1>Level Object<label id="levelobj">
<p>
Level objects may be used to build object hierarchies and perform CSG
operations.
<p>
Ayam does not offer a layer concept, but by grouping objects using
levels and the hide/show tools, layer functionality may be emulated
to a certain extent.
<p>
Organizing the scene and working in levels also increases the speed
of object tree updates, as only the current level and its sub-levels
are subject to a tree update if the object hierarchy changes.
<p>
Note that child objects of a level inherit the levels transformations
attributes and shaders. Inheritance of e.g. transformations means:
If you have a NURBS patch in a level that is translated to (10,0,0),
the origin of the local coordinate system of the NURBS patch
will be situated at (10,0,0). If you decide to move the patch by a
value of 5 in X direction by setting a corresponding value in the
Transformations property of the patch object, the local coordinate
system of the patch will be placed at (15,0,0) in world coordinates.
<p>
Note also that since Ayam 1.12, Level objects provide their child
objects to their parent objects as a list. This means the following
hierarchy is now valid:
<code>
+-Skin
 +-Level
  | NCurve
  | NCurve
  | ICurve
  \ NCurve
</code>
All NURBS curves and objects that may be converted to NURBS curves
(in this example: the ICurve) will be provided to the Skin by the
Level object. Transformation attributes of the Level will be added
to the provided objects. Objects that do not provide the wanted
type will be silently ignored.
<p>
The following table briefly lists some capabilities of the Level object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Level|Any+|Yes|N/A&thinsp;/&thinsp;Children (+)|No@<hline>
</tabular>
<caption>Level Object Capabilities</caption>
</table>
<p>

<sect2>LevelAttr Property<label id="lep"><label id="levelattrprop">
<p>
Levels do not have many object type specific properties, you may just
modify the type of the level using the attribute <tt/"Type"/.
<p>
Levels of type <tt/"Level"/ just group objects and inherit attributes.
<p>
Levels of type <tt/"Union"/, <tt/"Intersection"/, and <tt/"Difference"/
are used to build CSG hierarchies. Additionally, they inherit attributes.
Note that Ayam is currently not able to correctly display the results
of CSG operations, all objects are always drawn completely, even though
a CSG operation would cut parts away.
<p>
However, since Ayam 1.8 there is a plugin available that is able to
preview the results of CSG operations, see also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">.
<p>
The object hierarchy to cut away a part of a box using a sphere
looks like this:
<code>
+-Level_of_Type_Difference(Level)
 | Box
 \ Sphere
</code>
More than two objects may be arguments of a CSG operation:
<code>
+-Level_of_Type_Difference(Level)
 | Box
 | Sphere
 \ Sphere
</code>
In this example, the two spheres would cut away parts of the box.
<p>
New solid primitives may be created with levels of type <tt/"Primitive"/.
<code>
+-Level_of_Type_Difference(Level)
 +-Level_of_Type_Primitive(Level)
 | | Sphere_blue
 | \ Disk_red
 \ Box_grey
</code>
In this example an open sphere with <tt/"ThetaMax"/ 180.0 (a hemisphere)
is manually capped by a disk object. The two objects need to be placed
into a level of type <tt/"Primitive"/ because each object alone is an
open surface and therefore not a valid CSG primitive. Both objects that
form the new primitive use a different material. In addition, a grey box
cuts away a part from the multi colored hemisphere.
The above CSG hierarchy is available as example scene file
<tt/"multicolcsg.ay"/.
<p>
See also this image:
<figure loc="ht">
<eps file="pics/multicolcsg.ps" height="4cm">
<img src="pics/multicolcsg.gif">
<caption>Multicolor CSG Example</caption>
</figure>
<p>
Note that Ayam is not able to check, whether your new primitive obeys
the rule of total closeness. For instance, if the disk in the above
example would not totally cap the sphere (this happens if the disk
<tt/"ThetaMax"/ is not 360.0 or if it is not placed exactly at the
sphere) Ayam would not complain upon RIB export.
The rendered image would expose serious errors, however.
<p>
Furthermore, it is not necessary to enclose normal child objects
(e.g. quadrics with the <tt/"Closed"/ attribute set to on) of
CSG levels in primitive levels for RIB export. This is done by Ayam
automatically where needed.

<sect1>Material Object<label id="materialobj">
<p>
Material objects are used to attach RiAttributes and shaders to
geometric objects.
<p>
When geometric objects are dropped onto a material object using
Drag-and-Drop in the tree view they will be connected to this
material object.
<p>
While geometric objects are connected to a material object this material
object may not be deleted.
<p>
The following table briefly lists some capabilities of the Material object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Material|No|N/A|N/A|No@<hline>
</tabular>
<caption>Material Object Capabilities</caption>
</table>
<p>

<sect2>RiAttributes Property<label id="riattrs"><label id="riattributesprop">
<p>
Using this property standard and BMRT specific attributes may be set.
Please refer to the documentation of the RenderMan interface
and the documentation of BMRT for more detailed information about the
RenderMan specific attributes.

<itemize>
<item><tt/"Color"/, the color of the object. If you set one of the
entries to a negative value (e.g. -1), the color will not be set at all
for this object.
<item><tt/"Opacity"/, the opacity of the object, the default
255 255 255 means the object is totally opaque. If you set one of the
entries to a negative value (e.g. -1), the opacity will not be set at all
for this object.
<item><tt/"ShadingRate"/, determines how often shaders are evaluated for
a sample.
<item><tt/"Interpolation"/, determines how return values computed
by the shaders are interpolated across a geometric primitive.
<item><tt/"Sides"/, determines how many sides of the surface of a
geometric primitive should be shaded.
<item><tt/"BoundCoord"/, sets the coordinate system in which the
displacement bound is expressed.
<item><tt/"BoundVal"/, displacement bound value.
<item><tt/"TrueDisp"/, toggles true displacements on or off. Default off.
<item><tt/"CastShadows"/, determines how the object casts shadows:
the default <tt/"Os"/ means the object casts shadows according to it's
opacity; <tt/"None"/ object does not cast any shadows; <tt/"Opaque"/
the object is completely opaque and casts shadows; <tt/"Shade"/
the object has a complex opacity pattern determined by it's surface
shader, that is used in shadow calculations.
<item><tt/"Camera"/, <tt/"Reflection"/, and <tt/"Shadow"/ toggle
visibility attributes.
</itemize>

<sect2>Surface, Displacement, Interior, Exterior Property<label id="matshader">
<p>
These properties let you define shaders for the material object, please
refer to section <ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Surface shaders may be used to procedurally encode lighting models and
textures. Displacement shaders may procedurally deform the object while
rendering. Interior and Exterior shaders are so called volume shaders
that may be used to capture special optical effects, encoding how light
is affected while passing through an object.

<sect2>MaterialAttr Property<label id="matattr"><label id="materialattrprop">
<p>
The MaterialAttr property contains attributes related to the
management of material objects:
<itemize>
<item><tt/"Materialname"/ denotes the name of the material. Note
that material names have to be unique in a scene. If two
materials with the same name exist, only the first material
created with this name is "registered" and thus may be connected
to geometric objects.
<item><tt/"Refcount"/ shows how many geometric objects are connected to
(are of) this material. Note that connected or referring geometric objects
not necessarily have to live in the scene, they may as well temporarily
reside in the object clipboard.
<item><tt/"Registered"/ displays whether this material may be
connected to geometric objects, see the discussion about material names above.
</itemize>

<sect1>Light Object<label id="lightobj">
<p>
Light objects let you bring light into your scenes.
<p>
In contrast to the light sources as defined in the RenderMan
interface, normal Ayam light sources are always global. This
means, regardless of the place of a light source in the scene
hierarchy, it will always light all other objects.
<p>
Note that you can not preview the effect of a light source in
shaded Ayam views, currently. However it is possible to estimate
the effect of a spot light source by simply dropping it into
a perspective view window, the view will then show you the objects
lighted by the spot.
<p>
The behaviour of a light source object depends heavily on the type
of the light source.
There are four different light types available in Ayam:
<tt/"custom"/, <tt/"point"/, <tt/"distant"/ and <tt/"spot"/.
<p>
Custom Lights:<label id="cul">
<p>
Light sources of type custom use the attached light shader.
<p>
Note that Ayam is trying to guess from the names of the light shader
arguments to draw the light.
The names <tt/"from"/ and <tt/"to"/ denote location and destination
of the lightsource. Those names should not be used for other things
in the light shaders!
<p>
Point-, Distant-, and Spotlights:<label id="pdsl">
<p>
These (standard) light sources have well defined parameters that
will be displayed in the <tt/"LightAttr"/ property.
Please refer to the RenderMan documentation for more information
about the standard light sources (see section
<ref id="secref" name="references">).
<p>
The following table briefly lists some capabilities of the Light object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Light|Yes|No|N/A|Yes@<hline>
</tabular>
<caption>Light Object Capabilities</caption>
</table>
<p>

<sect2>LightAttr Property<label id="lip"><label id="lightattrprop">
<p>
Depending on the type of the light source, the light attribute
property contains different parameters. Parameters that
are not displayed will not be used on RIB export, consequently.
<p>
Using <tt/"Type"/ you can change the type of the light source.
When you change the type of a light source, the property GUI will
be adapted to show only the options available for the new light
source type, but only after you used the <tt/"Apply"/-button.
<p>
<tt/"IsOn"/ allows you to switch the light off or on. The default
value is on.
<p>
<tt/"IsLocal"/ controls whether the light source should light
just local objects (objects, that are defined in the same level
in the scene hierarchy as the light source object or below it) or
all objects in the scene.
The default is off, all objects in the scene are lighted!
The <tt/"IsLocal"/ attribute is ignored for lights that are
defined in the root level of the scene. Mind also that shadow maps
will always contain shadows from all objects in the scene,
regardless of local lights.
<p>
Using the light attribute <tt/"Shadows"/ you may determine
whether the lightsource should cast shadows.
The default is off, no shadows! Note that this option will not
magically enable shadows on renderers that create shadows by
shadow maps. It will merely be interpreted by raytracing
renderers like BMRT.
<p>
The attribute <tt/"Samples"/ determines the number of times to sample
an area light source, independent of pixel samples, the default value
is 1. This attribute is available for custom lights only!
<p>
<tt/"UseSM"/ determines, whether shadow maps should be created
and used for this light source. The resolution of the
shadow map may be determined by the attribute <tt/"SMRes"/. If
<tt/"SMRes"/ is 0, a default of 256 by 256 pixels will be used.
These options are for renderers that do not support raytraced
shadows like PRMan or Aqsis only.
<p>
For lights of type <tt/"Distant"/ the <tt/"Scale"/ attributes
of the <tt/"Transformations"/ property of the light
object may be used to scale the camera transformation
used for the creation of the corresponding shadow map.
Values of 1 for <tt/"Scale_X"/ and <tt/"Scale_Y"/ create
a shadow map that is sized 1 by 1 units in world space.
<p>
All other parameters that may appear in the <tt/"LightAttr"/
property are the standard parameters for the standard RenderMan
light sources: distant, point, and spot:
<itemize>
<item><tt/"From"/ and <tt/"To"/ denote position and target of the light
source as point in space. You may edit both points using standard
point editing actions (see also section
<ref id="iac" name="interactive actions">).
<item><tt/"Color"/ is the color of the light emitted by the light source.
<item><tt/"Intensity"/ is the intensity of the light emitted by the
light source. Note that the standard point and spot lights have
a quadratic falloff (with distance), that requires the intensity
to be set to quite high values in order to achieve some
illumination effect (e.g. around 30 for the standard distance of
<tt/"From"/ and <tt/"To"/ of a spot light).
<item><tt/"ConeAngle"/ is the angle of the beam of a spot light.
<item><tt/"ConeDAngle"/ (cone delta angle) is the angle that determines a
falloff area at the edge of the beam of a spot light.
<item><tt/"BeamDistrib"/ (beam distribution) determines, how the light
falls off in the beam of the spot light. Larger values result in narrower
lighted areas.
</itemize>

In order to ease the parameterisation of spot lights, you may drop the
light source object onto a view object or into a view window
(preferably one with a perspective viewing transformation and with equal
width and height) to see what objects of the scene are actually lighted
by the light object.

<sect2>Using ShadowMaps<label id="shadowmaps">
<p>
Using shadow maps requires the global preference setting
<tt>"RIB-Export/ShadowMaps"</tt> to be switched on.
Furthermore, for each light source for which a shadow map should be
created, the attributes <tt/"IsOn"/ and <tt/"UseSM"/ have to be
switched on.
<p>
<bf>Automatic Creation of ShadowMaps</bf>
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Automatic"</tt>,
Ayam will create a special version of the RIB on export, that creates
all shadow maps automatically upon rendering. This is done by rendering
depth images from the position of every light source that casts shadows.
Special light source shaders later pick up these depth images
and calculate shadows.
This approach implies, that the scene is rendered multiple times.
To reduce the size of the RIB, the objects to be rendered
are written to a second RIB file named <tt>"&lt;scene&gt;.obj.rib"</tt>.
This file is read from the main RIB several times via
<tt>"ReadArchive"</tt>. The RIB contains multiple frames which may
also be rendered separately if the frame number is known.
To help you picking the right frame number for the image (e.g.
to re-render just the final image, when only a material setting was
changed, and no shadow casting lights were moved and no shadow casting
geometry was changed),
a comment with the frame number of the last frame (the image) will be
written as last statement to the RIB.
<p>
Because multiple files (RIBs and shadow maps) are used, it is suggested
to change the preference setting <tt>"RIB-Export/RIBFile"</tt> to
<tt>"Scenefile"</tt>. This will strip the leading absolute path component
from the filenames so that you may move the exported scene from one
system to another more easily.
<p>
Do not render directly from a view window to the display when the
<tt/"ShadowMaps"/ <tt/"RIB-Export"/ preference option is set to
<tt>"Automatic"</tt>.
Your renderer may not write image files when the command line option
to render directly to the display (-d for rendrib, or -fb for Aqsis) is
in use. Consequently, this may also inhibit writing of the shadow maps,
so that the resulting image will look wrong, or the renderer will render
the shadow map to the display and simply stop.
<p>
<bf>Manual Creation of ShadowMaps</bf>
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Manual"</tt>,
the exported scene will not render the shadow maps but rather
expects them to be present already. You can create them manually
(hence the name <tt>"Manual"</tt>) using the view menu entries
<tt>"View/Create ShadowMap"</tt>, <tt>"View/Create All ShadowMaps"</tt>
or the main menu entries
<tt>"Special/RIB-Export/Create ShadowMap"</tt>,
<tt>"Special/RIB-Export/Create All ShadowMaps"</tt>.
The manual approach has the advantage, that the shadow maps will not
be re-created each time you render the scene.
<p>
<bf>ShadowMap Types</bf>
<p>
Ayam supports three different methods for the creation of shadow maps
for certain types of light sources: point, distant, and spot:
<p>
The point method is used with
lights of type <tt>"Point"</tt> and custom lights that have a light
shader argument named "from".
Six shadow maps pointing in all possible axis aligned
directions and named <tt>"&lt;rib&gt;.point&lt;num&gt;_&lt;dir&gt;.shd"</tt>
(where <tt>"&lt;rib&gt;"</tt> is the name of the RIB,
<tt>"&lt;num&gt;"</tt> is the number of the light source that makes
use of shadow maps and <tt>"&lt;dir&gt;"</tt> is one of
<tt/"x+"/, <tt/"x-"/, <tt/"y+"/, <tt/"y-"/, <tt/"z+"/, or <tt/"z-"/)
will be created.
<p>
The distant method is used with lights of type <tt>"Distant"</tt>
and custom lights that have a light
shader argument named "from" and a light
shader argument named "to".
One shadow map is created and named
<tt>"&lt;rib&gt;.dist&lt;num&gt;.shd"</tt>.
By default, the size of the shadow map is 1 by 1 units in world space,
but this may be adapted using the scale transformation attributes of
the light object.
<p>
The spot method is used with lights of type <tt>"Spot"</tt>
and custom lights that have a light
shader argument named "from", a light
shader argument named "to", and a light shader argument named "coneangle".
One shadow map is created and named
<tt>"&lt;rib&gt;.spot&lt;num&gt;.shd"</tt>.
The spot method uses the cone angle (and additionally the delta cone
angle, if present) argument to determine the size of the shadow map
in world space.
<p>
If a light object of type <tt>"Spot"</tt>, <tt>"Distant"</tt> or
<tt>"Point"</tt> is used, Ayam automatically changes the name of the
exported light shader to <tt>"shadowspot"</tt>, <tt>"shadowdistant"</tt>,
and <tt>"shadowpoint"</tt> respectively. Additionally, the shader
will be parameterised to use the created shadow maps.
If the light source is of type <tt>"Custom"</tt>, no automatic renaming
and adjusting of the shader takes place. This means, you have
to make sure that the shader really uses the shadow maps, by
selecting the right shader and parameterising it accordingly.
See the discussion above for the names of the shadow map files.
Those file names, most probably, will have to be entered as parameter
to the light shader.
<p>
For example, you will not get any shadows if you use a light source of
type <tt/"Custom"/ with the normal <tt/"distantlight"/ shader attached,
even though Ayam is able to create the necessary shadow maps. The
normal <tt/"distantlight"/ shader just makes no use of the shadow maps.
You have to manually switch to a shader that
makes use of the shadow maps (<tt/"shadowdistant"/ in this case) to get
shadows.
<p>
<bf>ShadowMap Mini Tutorial</bf>
<p>
Here is a short example for a scene using a shadow map:
<enum>
<item>Go to the preferences (section <tt/"RIB-Export"/) and set
<tt/"ShadowMaps"/ to <tt>"Automatic"</tt>.
<item>Create two boxes.
<item>Open the <tt/"Transformations"/ property of the second box.
<item>Translate it by X: 0.0, Y: -1.0, Z: 0.0.
<item>Scale it by X: 4.0, Y:1.0, Z:4.0.
<item>Create a light source.
<item>Open the <tt/"LightAttr"/ property.
<item>Change the type to <tt/"Spot"/. Press <tt/"Apply"/.
<item>Now change the parameters of the spot light to <tt/"IsOn"/: Yes,
<tt/"Intensity"/: 18.0,
<tt/"UseSM"/: Yes, <tt/"ConeAngle"/: 45.0, <tt/"BeamDistrib"/: 3.0,
<tt/"From"/: -2, 2, 2, <tt/"To"/: 1, 0, -1;
leave all other parameters at their default values.
<item>Create a new view and make it perspective (Menu:
<tt>"Type/Perspective"</tt>).
<item>Export a RIB from that perspective view (Menu:
<tt>"View/Export RIB"</tt>).
<item>Render the RIB with a RenderMan compliant renderer, that uses
shadow maps, e.g. Photorealistic RenderMan (prman) or Aqsis.
</enum>

This scene is distributed with Ayam as an example scene named
<tt>"shadowmaps.ay"</tt>.
<p>
Note that for Aqsis you should add a RiHider hidden,depthfilter,s,midpoint
tag to your root object if shadow maps are in use. Other renderers might
require additional tweaking using shadow bias RiOption tags.
Please consult the documentation of your renderer on how to achieve
the best results using shadow maps.

<sect2>Using AreaLights<label id="alob">
<p>
The common idealized standard light sources <tt/"Point"/, <tt/"Distant"/
and <tt/"Spot"/ have no own geometric extension in space.
This means, shadows resulting from such light sources will have sharp
borders which does not look too natural.
Good looking soft shadows may be generated using area lights.
<p>
Area lights may be created by simply placing a single object as child
object of a <tt/"Custom"/ light object that has the <tt>"arealight"</tt>
shader attached:
<code>
+-AreaLight(Light)
 \ AreaLightGeometry(Sphere)
</code>
This child object determines the geometry, place <em>and</em> extension,
of the lightsource.
According to L. Gritz, Spheres and Cylinders work best as area light
geometry for BMRT, because of special sampling code.
<p>
An example:
<itemize>
<item>Create a custom light object.
<item>Assign the arealight light shader to it.
<item>Create a sphere.
<item>Drag-and-Drop the sphere onto the Light object so that it becomes
a child of the light object.
<item>Transform the sphere object to your hearts content; the position
and size of the object determines the position and size of the lightsource!
</itemize>

There is an example scene named <tt>"arealight.ay"</tt> distributed with
Ayam.

<sect1>NCurve (NURBS Curve) Object<label id="ncurveobj">
<p>
<figure loc="ht">
<eps file="pics/ncurve.ps" height="5cm">
<img src="pics/ncurve.gif">
<caption>A simple NURBS Curve</caption>
</figure>
<p>
The NCurve object is the most used basic object for NURBS modelling
in Ayam because NURBS curves are used to build more complex smoothly
shaped surfaces using operations like extrude, revolve, sweep or skin.
NURBS curves can be open or closed and used to emulate Bezier and
B-Spline curves easily. In addition, for easier modelling, they
support multiple points, as explained in section
<ref id="ncurvemp" name="Multiple Points">).
<p>
The following table briefly lists some capabilities of the NCurve object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCurve|No|No|N/A|Yes@<hline>
</tabular>
<caption>NCurve Object Capabilities</caption>
</table>
<p>
The next section details the NCurve object property.

<sect2>NCurveAttr Property<label id="ncattr"><label id="ncurveattrprop">
<p>
The first section of the NCurveAttr property contains curve specific
settings:<p>
<itemize>
<item><tt/"Type"/: This attribute replaces the <tt/"Closed"/
attribute since Ayam 1.9.

<p>
The type <tt/"Open"/ is for the standard open NURBS curve.

<p>
If the type is <tt/"Closed"/, the first and last control point of
the curve will be made identical. This will close the curve but
without any guaranteed continuity.
Such a closed curve will e.g. be created by the NURBS circle tool.
It is important to know, that identical start/end control points
alone can not guarantee that the curve is closed if the knot vector
is not clamped. If in doubt, use the clamp tool or a knot vector
of type <tt/"NURB"/, <tt/"Chordal"/, or <tt/"Centripetal"/.

<p>
If the type is <tt/"Periodic"/, the last p control points of the curve
will be made identical to the first p where p is the degree of the
curve (read order-1). This will close the curve with guaranteed continuity.
Note that for a cubic spline (order 4) you will need atleast 6 control
points to make it periodic. It is important to know, that the multiple control
points alone can not guarantee that the curve is closed if the knot vector
has no periodic extensions. If in doubt, switch the curve to
knot type <tt/"B-Spline"/, <tt/"Chordal"/, or <tt/"Centripetal"/.

<p>
You may also want to enable the creation of multiple points using the
<tt/"CreateMP"/ attribute (see below) for closed and periodic curves so that
single point editing actions modify all multiple control points.

<item><tt/"Length"/ is the number of control points of the curve.

<item><tt/"Order"/ is the order of the curve.
<item><tt/"Knot-Type"/: Using <tt/"Knot-Type"/ you may select from
<tt/"NURB"/, <tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Custom"/, <tt/"Chordal"/,
and <tt/"Centripetal"/ knot types.

<p>
The knot type <tt/"NURB"/ will generate uniformly distributed knot values
ranging from 0.0 to 1.0, where the multiplicity of the knots at the
ends will be of order of the curve (the knot vector will be clamped).
This guarantees that the curve will touch the control points at the ends
of the curve.
An example <tt/"NURB"/ knot vector for a curve of length 5 and order 4
would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.5 1.0 1.0 1.0 1.0 }</tt>.

<p>
The knot type <tt/"Bezier"/ will generate just 0.0 and 1.0 values. Note that
the order of the curve has to be equal to the length of the curve if
<tt/"Bezier"/ knots are generated. Otherwise, the generated knot sequence is
illegal. The resulting curve looks and behaves exactly like a real
Bezier curve, interpolating the control points at the ends and so on.
An example <tt/"Bezier"/ knot vector for a curve of length 5 and order 5
would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 }</tt>.

<p>
The knot type <tt/"B-Spline"/ will generate uniformly distributed knot values
(without any multiple knots). The resulting curve looks and behaves like a
B-Spline curve. It is <em>not</em> interpolating the control end points.
An example <tt/"B-Spline"/ knot vector for a curve of length 5 and order 4
would be:

<p>
<tt>{ 0.0 0.125 0.25 0.375 0.5 0.625 0.75 0.875 1.0 }</tt>.

<p>
The knot types <tt/"Chordal"/ and <tt/"Centripetal"/ will generate knot values
whose distribution reflect the distances of the control points.
For open curves, the generated knot vector will be clamped, for periodic
curves, proper periodic extensions will be created.
Those knot types are mainly useful for curves with unevenly distributed
control points that will be sampled uniformly (in parametric space) later
on and where it is expected, that the uniform sampling in parameter space
results in evenly distributed sample points in coordinate space, e.g. if
the curves are used as Sweep, Birail, or Clone trajectory, or surfaces
are created from them that use implicit texture coordinates or a uniform
tesselation strategy.
The <tt/"Chordal"/ and <tt/"Centripetal"/ knots will ensure a more uniform
distribution of the sample points on the curve in such cases (see also the
example image below).
An example <tt/"Chordal"/ knot vector for an open curve of length 5 and
order 4 would be:

<p>
<tt>{ 0.0 0.0 0.0 0.0 0.388889 1.0 1.0 1.0 1.0 }</tt>.

The image below illustrates the use of two curves with uniform (NURB) vs.
chordal knot vectors as Sweep trajectories.
The upper Sweep with the uniform knot vector has much more unevenly
distributed/sized sections and exhibits more severe self intersection
problems.
Please note that the shapes of the curves differ slightly.

<figure loc="ht">
<eps file="pics/chordalex.ps" height="6cm">
<img src="pics/chordalex.gif">
<caption>Sweeps Created From Curves With Uniform (upper) And
Chordal (lower) Knot Vectors</caption>
</figure>

<item><tt/"Knots"/ allows to enter own custom knot sequences.
Note that <tt/"Knots"/ are not in use if <tt/"Knot-Type"/ (above)
is of type <tt/"NURB"/, <tt/"B-Spline"/, <tt/"Bezier"/, <tt/"Chordal"/,
or <tt/"Centripetal"/! Note also, that the content of this parameter
will be overwritten, if the knot type is switched to any of the
aforementioned types.

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this curve. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.

<item><tt/"IsRat"/ informs you since Ayam 1.9, whether the curve
is rational (uses weight values different from 1.0).
</itemize>

The GLU-parameters control the appearance of the curve when
curve/surface display is enabled.
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a curve.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ determines how the curve should
be drawn. The control hull (control polygon) or the curve or a
combination of both may be displayed. The setting <tt/"Global"/
means, that the global preference setting
<tt>"Drawing/NCDisplayMode"</tt> should be used.

</itemize>

When changing more than one of the above values the changes will be
applied in the order of the values in the property. The
sum of the changed values should describe a valid NURBS curve.
It is perfectly legal to change the length of the curve,
it's order, and switch to a custom knot vector (be sure to actually
enter a valid new knot vector) at once. Ayam will check your changes
and fall back to certain default values if e.g. your knot sequence is wrong.
Check the console for any messages after pressing the <tt/"Apply"/ button!
<p>
When the curve type is changed using the NCurveAttr property
Ayam may also have to change the position of some control points
as follows:
<itemize>
<item>When the type is changed from open to closed, the last control
point is moved to be identical to the first one. In addition, if the
current knot type of the curve is <tt/"B-Spline"/, it will be reset to
knot type <tt/"NURB"/.
<item>When the type is changed from open or closed to periodic, the last
p control points will be moved to be identical to the first p, where
p is the degree of the curve (order-1). For a cubic curve (order 4),
consequently, the last three control points will be moved. In addition,
if the current knot type of the curve is <tt/"NURB"/ or <tt/"Bezier"/
it will be changed to <tt/"B-Spline"/ automatically.
</itemize>

<sect2>Multiple Points<label id="ncurvemp">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A NURBS Curve with Multiple Points (big handles)</caption>
</figure>
<p>
The NURBS curves of Ayam support so called multiple points.
A multiple point is made of a number of different control points that have
the same coordinates.
Modelling actions will always modify all the control points that
make up a multiple point.
Multiple points will be drawn with a bigger handle than normal points
(see image above).
They may e.g. be used to create closed curves. Note that the control
points that make up a multiple point do not have to be consecutive
(in the control point vector of the NURBS curve).
Multiple points may be created using the collapse tool,
and split up again using the explode tool (see sections
<ref id="collt" name="The Collapse Tool"> and
<ref id="explt" name="The Explode Tool"> for more information regarding
those tools).
Note that even though you might have exploded some multiple points
Ayam will re-create them automatically on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
property if they still have identical coordinate values.
In other words, you should immediately edit the control
points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again!
You may also totally inhibit creation of multiple points for a
NURBS curve using the attribute <tt/"CreateMP"/.

<sect1>NPatch (NURBS Patch) Object<label id="npatchobj">
<p>
The NPatch object allows to model NURBS surfaces in a direct way, e.g. by
modifying control points. Note that using NPatch objects should be seen as
last resort, only to be used when the flexibility of all the NURBS
surface creating tool objects is not high enough to achieve a certain shape.
<p>
Since Ayam 1.10, NPatch objects also support the concept
of multiple points, see section
<ref id="ncurvemp" name="Multiple Points">
for more information regarding this.
<p>
The following table briefly lists some capabilities of the NPatch object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NPatch|NCurve+/Level+|Yes|PolyMesh|Yes@<hline>
</tabular>
<caption>NPatch Object Capabilities</caption>
</table>
<p>

<sect2>NPatchAttr Property<label id="npattr"><label id="npatchattrprop">
<p>
The first section of the NPatchAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
Similar to the <tt/"Length"/ parameter of the NCurve object, changes to
<tt/"Width"/ or <tt/"Height"/ add or remove internal control points
(i.e. to double the resolution of a 4 by 4 NURBS patch in U direction,
change the <tt/"Width"/ from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).

<item><tt/"Order_U"/ and <tt/"Order_V"/ set the orders of the patch.

<item><tt/"Knot-Type_U"//<tt/"Knot-Type_V"/ and
<tt/"Knots_U"//<tt/"Knots_V"/: For a discussion of the
<tt/"Knot-Type"/ and <tt/"Knots"/ parameters,
please see section <ref id="ncattr" name="NCurveAttr">.

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this surface. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.
This option is available since Ayam 1.10.

<item><tt/"IsRat"/ informs you since Ayam 1.9, whether the patch
is rational (uses weight values different from 1.0).
</itemize>

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn (<tt/"ControlHull"/), or just the outlines of the polygons
created by the tesselation (<tt/"OutlinePolygon"/), or just the
outlines of the patch (<tt/"OutlinePatch"/). The default setting
(<tt/"Global"/) means, that the value of the global preference setting
<tt>"Drawing/NPDisplayMode"</tt> should be used instead.
</itemize>

<sect2>Trim Curves<label id="trim">
<p>
Trim curves may be used to cut out certain parts of a NURBS patch.
They are simple 2D NURBS curves defined in the parametric space
of the associated NURBS patch. Trim curves have to be defined as child
objects of the NURBS patch object they belong to. In contrast to other
child objects, however, they do not inherit the transformation attributes
of the parent object. Trim curve editing should take place in views
of type <tt>Trim</tt>, that draw the boundaries of the parametric
space of the corresponding NURBS patch as rectangle, but otherwise
act as normal <tt>Front</tt> views.
<p>
Note that the direction of the trim curve determines which part of
the NURBS patch should be cut out. You can use the <tt/Revert/ tool
(<tt>Tools/NURBCurve</tt> menu) to easily change the direction
of a trim curve.
<p>
Some special restrictions apply to trim curves:
<itemize>
<item>All trim curves should entirely lie in the (u,v) parameter
space of the NURBS patch (remember the rectangle in the <tt>Trim</tt> view).
Note that this restriction does not apply to the control points,
but the curves! It is ok to have control points outside the
rectangle if the defined curve is inside the rectangle.

<item>The last point of a trim curve must be identical
to the first point.

<item>Trim loops (multiple trim curves that form loops) are possible too;
the last point of each curve in the loop must be identical to the first
point of the next curve in the loop and the first point of the first curve
of a loop must be identical to the last point of the last curve of that
loop.

<item>To mark a set of curves to be a loop, they must be placed in a level
object. The order of the curves in this level is the order of the loop.
The transformation attributes of this level object are fully ignored for
trimming.

<item>Drawing trimmed NURBS patches with certain implementations of
OpenGL may require a special trim curve (a rectangular piecewise linear
curve that encloses the whole NURBS patch) to be present. Such a curve
may be generated with the <tt/TrimRect/ tool. You can find this tool in
the <tt>"Tools/Create"</tt> menu. This curve is needed if you want to cut
out a hole with a single trim curve. This curve is generally not needed
if you want to render the patch with BMRT but it should not hurt if it
is present.

<item>If there are nested trim curves, their direction must alternate.

<item>Trim curves may not intersect each other or themself.
</itemize>
Note that Ayam is not checking whether your trim curves
follow these rules!
<p>
Warning: Certain OpenGL implementations may be easily crashed
drawing trimmed NURBS patches with trims that do not follow the
aforementioned rules! When in doubt or while heavy modelling,
switch to wireframe drawing and switch off shading temporarily
and you will be on the safe side.
<p>
Since Ayam 1.5 also NURBS curve providing objects are supported
as trim curves.

<sect1>BPatch (Bilinear Patch) Object<label id="bpatchobj">
<p>
A BPatch is a simple bilinear patch defined by four control
points. BPatch objects are e.g. used to build box objects, see
<ref id="boxobj" name="Box Object">).
<p>
You may convert the current BPatch object to an ordinary NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the BPatch object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
BPatch|No|Yes|NPatch|Yes@<hline>
</tabular>
<caption>BPatch Object Capabilities</caption>
</table>
<p>

<sect2>BPatchAttr Property<label id=bpattr><label id="bpatchattrprop">
<p>
The BPatchAttr property allows you to set the
four points defining the geometry of the patch:<p>
<itemize>
<item><tt/"P1_X"/, <tt/"P1_Y"/, <tt/"P1_Z"/, first point.
<item><tt/"P2_X"/, <tt/"P2_Y"/, <tt/"P2_Z"/, second point.
<item><tt/"P3_X"/, <tt/"P3_Y"/, <tt/"P3_Z"/, third point.
<item><tt/"P4_X"/, <tt/"P4_Y"/, <tt/"P4_Z"/, fourth point.
</itemize>

<sect1>PatchMesh Object<label id="patchmeshobj">
<p>
The PatchMesh object may be used to model with bilinear and
bicubic patch meshes.
The PatchMesh object may be converted to a NURBS patch
representation using the main menu entry <tt>"Tools/Convert"</tt>.
However, this does not work for all possible types of patch meshes
(e.g. patch meshes with the basis types Catmull-Rom, Hermite, or
Custom can not be converted, currently).
An internal NURBS patch representation is also in use when drawing
the patch mesh (if the <tt/"DisplayMode"/ is not <tt/"ControlHull"/)
and when shading the patch mesh.
Consequently, there is currently no shaded representation of patch meshes
of basis type Catmull-Rom, Hermite or Custom.
<p>
The following table briefly lists some capabilities of the PatchMesh object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PatchMesh|No|Yes|NPatch|Yes@<hline>
</tabular>
<caption>PatchMesh Object Capabilities</caption>
</table>
<p>

<sect2>PatchMeshAttr Property<label id="pmattr"><label id="patchmeshattrprop">
<p>
The first section of the PatchMeshAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Type"/ may be set to <tt/"Bilinear"/ or <tt/"Bicubic"/.
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
<item><tt/"Close_U"/ and <tt/"Close_V"/ determine, whether the patch
mesh should be closed in U and V direction respectively.
<item><tt/"BType_U"/ and <tt/"BType_V"/ control the basis type
for bicubic patches. You may choose between the basis types:
<tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Catmull-Rom"/,
<tt/"Hermite"/, and <tt/"Custom"/.
In the latter case (<tt/"Custom"/), additional parameters may be set.
Those are <tt/"Step_U"//<tt/"Step_V"/ (the stepsize of the basis) and
<tt/"Basis_U"//<tt/"Basis_V"/ the basis itself
(please see the RenderMan Companion for a discussion of basis types).
</itemize>
The parameters <tt/"BType_U"/ and <tt/"BType_V"/ and consequently
<tt/"Step_U"//<tt/"Step_V"/ and <tt/"Basis_U"//<tt/"Basis_V"/ are
only available to bicubic patch meshes.

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<tt>"Drawing/DisplayMode"</tt> should be used.
</itemize>

<sect1>PolyMesh Object<label id="polymeshobj">
<p>
The PolyMesh object may be used to include objects that
have been modeled using the polygonal modelling paradigm
in Ayam scenes.
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The PolyMesh object is equivalent to the general points polygons
primitive of the RenderMan interface. This means, each PolyMesh
object may contain multiple general (convex or concave) polygons,
which in turn may consist of an outer loop and an arbitrary number
of inner loops that describe holes in the polygon. The loops use a point
indexing scheme to efficiently reuse coordinate values.
This general approach requires a so called tesselation to be carried
out, in order for the PolyMesh object to be shaded.
For the tesselation, Ayam uses routines of the GLU library.
<p>
Ayam is able to automatically create face normals for PolyMeshes.
They will be calculated while tesselating the PolyMesh and be
perpendicular to the plane determined by the first three vertices
of the outer loop of a polygon.
Furthermore, Ayam supports vertex normals (normals stored for every
control point).
<p>
Note that storing a bunch of triangles each in its own PolyMesh
object will lead to a real waste of memory. You may use the
merge tool (main menu <tt>"Tools/PolyMesh/Merge"</tt>) to merge
many PolyMesh objects into a single PolyMesh object.
<p>
Since Ayam 1.11, PolyMesh objects may be converted to SDMesh
objects. Note that no verification of the usability of the
mesh as base mesh for a subdivision surface is carried out.
Usually, such meshes have to be manifold and may not contain
T-junctions.
<p>
The following table briefly lists some capabilities of the PolyMesh object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
PolyMesh|No|Yes|SDMesh|Yes@<hline>
</tabular>
<caption>PolyMesh Object Capabilities</caption>
</table>
<p>

<sect2>PolyMeshAttr Property<label id="pomattr"><label id="polymeshattrprop">
<p>
The PolyMeshAttr GUI just displays some information about the
PolyMesh object:
<itemize>
<item><tt/"NPolys"/ the number of polygons.
<item><tt/"NControls"/ the total number of control points
defined.
<item><tt/"HasNormals"/ is 1 if the object uses vertex normals,
else it is 0.
</itemize>

<sect1>SDMesh Object<label id="sdmeshobj">
<p>
The SDMesh object may be used to include objects that
have been modeled using the subdivision modelling paradigm
in Ayam scenes.
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The SDMesh object is equivalent to the Subdivision Mesh
primitive of the RenderMan interface. This means, each SDMesh
object may contain multiple faces with arbitrary number
of vertices that form a polygonal mesh. This polygonal mesh is
then successively refined using a subdivision scheme and, depending
on the number of refinement (or subdivision) steps, results in
a more or less smooth surface. There are several different
subdivision schemes, but the scheme currently supported
by most RenderMan compliant renderers is named "Catmull-Clark".
<p>
Tags may be specified for faces, edges, or vertices
to control the subdivision process (e.g. to create sharp corners or edges
in the resulting surface). All tags known from the RenderMan interface
(hole, crease, corner, and interpolateboundary) are supported by Ayam,
but they may currently not be changed by the user.
<p>
Furthermore, Ayam is currently not able to do the subdivision and
show the resulting smooth surface. All that is shown in wireframe and
shaded views is the original polygonal mesh.
<p>
Since Ayam 1.11, SDMesh objects may be converted to PolyMesh
objects. Note however that only the original unrefined control
polygon will be converted.
<p>
The following table briefly lists some capabilities of the SDMesh object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
SDMesh|No|Yes|PolyMesh|Yes@<hline>
</tabular>
<caption>SDMesh Object Capabilities</caption>
</table>
<p>

<sect2>SDMeshAttr Property<label id="sdmattr"><label id="sdmeshattrprop">
<p>
The SDMeshAttr GUI just displays some information about the
SDMesh object:
<itemize>
<item><tt/"Scheme"/, subdivision scheme, since Ayam 1.11 you
may choose between Catmull-Clark and Loop.
<item><tt/"NFaces"/, the number of faces.
<item><tt/"NControls"/, the total number of control points
defined.
</itemize>

<sect1>Instance Object<label id="instanceobj">
<p>
Instance objects help to save memory consumption in scenes with many
similar or repeating objects.
<p>
The term instance is unfortunately misleading (and can be very confusing
if you are accustomed to the terminology of object oriented programming),
but it is the term that seems to be used and understood by most
computer graphic artists. A better term would be link, as an instance
object has the same basic properties as a link in a Unix file system.
A link is just a pointer to an original file, the same goes for
an instance object: it is just a pointer to an original object (here
also called master object).
A link can be placed anywhere on the file system,
an instance object can be placed anywhere in the scene hierarchy, and
additionally, it can be transformed (otherwise it would be pretty
useless).
<p>
Normally, the sole purpose of instance objects is to save storage space,
in memory and on the disk. But in the tool object context, instances
also serve as a means to transport geometric data across the scene
hierarchy to make tool objects depend on each other (see also section
<ref id="toolobj" name="The Modelling Concept Tool-Objects">).
Note that in the tool object context, instance objects are the only
objects, that are subject to a second round of provision.
<p>
The amount of saved space can be very high, depending heavily on the
actual scene and at what levels in the hierarchy instances are used.
If there are no similar objects in the scene, however, one can hardly
utilise instancing. Similar means "the same except for
the transformation property" in this context.
<p>
Some simple rules for instancing:

<itemize>
<item>No instances may be created of objects of the following types:
Root, View, Instance, Material, Light. Do not try to fool
Ayam and create instances of levels that contain aforementioned
types of objects, things will go awry!
<item>You may, however, put some instances
into a level object and create instances of this level
(this is sometimes called hierarchical instancing).
<item>But you may not put instances of a level into the very same
level (this would be recursive instancing, which is not supported by Ayam).
<item>The original object may not be deleted from the scene
as long as there are instances of that object in the scene or in the
object clipboard.
</itemize>

If you can not delete an object, and the error message tells
you something about a reference counter, then you were about
to violate the second rule. Clean the clipboard using
the menu <tt>"Special/Clipboard/Paste (Move)"</tt> and delete
or resolve all references.
<p>
Note that it is not possible to copy a master object and some instances
of it, so that the new instances point to the newly created master.
All copies of instance objects always point to the same master object.
<code>
--NCurve   <-----
                 |
--Instance  -----
</code>
For example, when the above two objects are copied and pasted back to the
scene, the following scene hierarchy results:
<code>
--NCurve   <-------
                 | |
--Instance  -----  |
                   | !
--NCurve           |
                   |
--Instance  -------
</code>
The new instance still points to the original master and <em>not</em>
to the copy of the master.
<p>
It is possible to move masters and instances through the scene hierarchy
using Drag-and-Drop in the tree view or using the clipboard with
<tt>"Edit/Cut"</tt> and then <tt>"Special/Clipboard/Paste (Move)"</tt>.
<p>
You can resolve an instance object at any time using
the converter registered for objects of type <tt>Instance</tt> (simply
select the instance object and use the menu entry
<tt>"Tools/Convert"</tt>). To resolve all instance objects in a scene
to normal objects, you may use the main menu entry:
<tt>"Special/Instances/Resolve all Instances"</tt>.
<p>
The RIB export of instances does not use the RiInstance facility
of the RenderMan interface, but the ReadArchive mechanism.
This means, every original object in the scene will be written
in a separate archive (RIB file) on disk, and every instance will
cause that archive file to be read. You can change this behaviour
using the preference setting <tt/"ResInstances"/:
If <tt/"ResInstances"/ is enabled, all instances will be resolved
(temporarily) before being exported to RIB.
<p>
Ayam can also create instances for complete scenes or just parts
of scenes automatically
(see section <ref id="ai" name="Automatic Instancing">).
<p>
To easily find the master object of an instance, just select the
instance, then use the main menu entry: <tt>"Edit/Master"</tt>.
<!--
To find out, where in the scene instances of a master object
exist, select the master object and use the main menu entry
<tt>"Edit/Master"</tt>.
-->
<p>
The following table briefly lists some capabilities of the Instance object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Instance|No|No|Master|No@<hline>
</tabular>
<caption>Instance Object Capabilities</caption>
</table>
<p>


<sect1>Clone Object<label id="cloneobj">
<p>
<figure loc="ht">
<eps file="pics/clone.ps" height="5cm">
<img src="pics/clone.gif">
<caption>Clone Object (blue) with Trajectory Curve (white)</caption>
</figure>
<p>
The Clone object allows you to easily create and control an arbitrary
number of instances of a single object, hereafter called the cloned
object.
The instances can be transformed (each by a certain amount expressed
as difference between two instances) or placed on a trajectory curve.
<p>
The Clone object may also be used for symmetric (mirrored) modelling;
in this case multiple child objects are accepted and multiple clones
with a negative scale value (and in reverse order!) will be created.
<p>
If a second object is present as child of the Clone object (and mirroring
is not enabled) it is treated as trajectory (or path) curve,
similar to the Sweep object
(see also section <ref id="sweepobj" name="Sweep Object">).
<p>
Thus, the default object hierarchy of a Clone object looks like this:
<code>
+-Clone
 | Cloned-Object
 \ [Trajectory(NCurve)]
</code>
If you use a trajectory curve to place the clones, you may want
to hide the cloned object and also add a <tt/"NoExport"/ tag to it.
Otherwise the original object will appear twice, on the trajectory and
on its normal, untransformed, position. Note that the transformation
attributes of the cloned object will be completely overwritten when
placing the clones on the trajectory curve. If the cloned object has
distinct scale or rotation attributes it should be put inside a level
object like this:
<code>
+-Clone
 +-Level
 |\ Cloned-Object with non-standard Scale/Rotation
 \ Trajectory(NCurve)
</code>
<p>
It is not possible to create clones from objects that may not
be master objects of instance objects (e.g. light objects or
material objects). However, (since Ayam 1.7) it is possible to use
instances as parameter objects.
<p>
If an instance object is used as cloned object it should be placed
in a level and the <tt/"NoExport"/ tag should be added to the
level object (as you can not add tags to instance objects), see the
following example hierarchy:
<code>
+-Clone
 +-Level with NoExport tag
 |\ Instance
 \ Trajectory(NCurve)
</code>
<p>
The following table briefly lists some capabilities of the Clone object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Clone|Any+|No|Children (+)|No@<hline>
</tabular>
<caption>Clone Object Capabilities</caption>
</table>
<p>
The following attributes further control the cloning process:

<sect2>CloneAttr Property<label id="cloneattr"><label id="cloneattrprop">
<p>
<itemize>
<item><tt/"NumClones"/ is the number of clones to create, it is not in use
when the mirror mode (see below) is enabled.
<item><tt/"Rotate"/ is only used, if a trajectory curve is present.
If it is enabled all clones will be aligned according to the normal of
the trajectory curve.
<item><tt/"Mirror"/ allows to choose between three different mirror
modes (mirroring about the YZ-, XZ-, or XY-plane). If mirroring is
enabled, for each child of the Clone object, a mirrored counterpart will
be created by cloning the child object and setting a negative scale value.
All other parameters of the Clone object will be ignored. Since Ayam 1.9,
the original object(s) <em>and</em> their mirrored counterparts will be
provided by the Clone object to their respective parent (normally, tool
objects do not provide their unmodified children).
Additionally, the order of the mirrored objects will be reversed so that
it is possible to use a single Clone object in mirror mode (with one or
multiple NURBS curves as children) as parameter object of e.g. a Skin object:
<code>
+-Skin
 +-Mirror(Clone)
  \ NCurve
+-Skin
 +-Mirror(Clone)
  | NCurve_1(NCurve)
  | NCurve_2(NCurve)
  \ NCurve_3(NCurve)
</code>
The first Skin object in the above example can only work, because also
the unmodified NCurve is provided by the Clone object. The second Skin
object can only work properly, because the order of the provided objects
is reversed, so that it gets to see the curves in the following sequence:
<tt/"NCurve_1"/, <tt/"NCurve_2"/, <tt/"NCurve_3"/, <tt/"Mirrored_NCurve_3"/,
<tt/"Mirrored_NCurve_2"/, <tt/"Mirrored_NCurve_1"/.

<item><tt/"Translate_X"/, <tt/"Translate_Y"/, <tt/"Translate_Z"/,
<tt/"Rotate_X"/, <tt/"Rotate_Y"/, <tt/"Rotate_Z"/,
<tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/,
those attributes control the transformation of the instances created by
the Clone object. Note that the attributes specify difference values
between two instances: the clone <tt/"n+1"/ is offset by <tt/"Translate_X"/,
<tt/"Translate_Y"/, and <tt/"Translate_Z"/ from the previous clone <tt/"n"/.
It is also rotated by <tt/"Rotate_X"/, <tt/"Rotate_Y"/, and <tt/"Rotate_Z"/
and scaled by <tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/ in relation
to the previous clone. However, the transformation attributes do not affect
the first clone.
<p>
Since Ayam 1.13 the transformation attributes are also used if a trajectory
curve is present. But they are never in use when the mirror mode is activated.
</itemize>
The following table summarizes which transformation attributes are used
in the respective clone modes.

<table loc="ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/Mode/|<bf/Use Child Transform/|<bf/Use CloneAttrib Transform/|<bf/Use Clone Transform/@<hline>
Clone|No|Yes|Yes@<hline>
Trajectory|Yes|Yes|Yes@<hline>
Mirror|Yes|No|Yes@<hline>
</tabular>
<caption>Clone Parameterisation Examples</caption>
</table>

<sect1>Revolve Object<label id="revolveobj">
<p>
<figure loc="ht">
<eps file="pics/revolve.ps" height="5cm">
<img src="pics/revolve.gif">
<caption>Revolve Object (left: Curve, right: Surface of Revolution)</caption>
</figure>
<p>
The Revolve object forms a surface of revolution from a NURBS curve.
<p>
The Revolve object has the generating NURBS curve as child object
and watches its changes and adapts to it automagically.
<p>
The axis of revolution is always the Y axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Y axis of the revolve
object itself). The generating curve should lie in the XY plane of this
coordinate system. If not, it will be squashed down to this plane!
<p>
The following simple experiment should make the last
statements more clear, during all steps watch the movements
of the revolution:

<itemize>
<item>Create a NURBS curve object and select it.
<item>Create a Revolve tool object using the menu entry
(<tt>"Tools/Create/Revolve"</tt>).
<item>Select the Revolve object, and rotate it around Z. (The axis
of the revolution changes. The generating NURBS curve, as child object,
will also be rotated.)
<item>Now enter the Revolve object, select the child curve and
edit the control points (note how the surface of revolution changes).
<item>Rotate the curve around Z (note how the surface of revolution changes).
<item>Switch to a Side view, edit the generating curve here in Z
direction only (the surface of revolution does not change).
</itemize>

You may convert the current surface of revolution, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Revolve object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Revolve|NCurve|Yes|NPatch+|No@<hline>
</tabular>
<caption>Revolve Object Capabilities</caption>
</table>
<p>

<sect2>RevolveAttr Property<label id="rep"><label id="revolveattrprop">
<p>
Using the parameter <tt/"ThetaMax"/ you can specify the
sweeping angle of the revolution just like with an ordinary
RenderMan quadric.
<p>
Since Ayam 1.8 the Revolve object supports a B-Spline mode,
that may be enabled by setting the new parameter <tt/"Sections"/
to a value higher than 2. In this mode, a circular B-Spline is
used as basis for the surface of revolution, instead of the
standard NURBS circle. Depending on the number of sections
choosen, the surface of revolution does not exactly interpolate
the parameter curve, but the surface may be edited more easily
after a possible conversion to an ordinary NURBS patch object,
because the control points will not be rational.
In addition to the number of sections, in B-Spline mode it is
possible to control the order of the surface of revolution
using the new parameter <tt/"Order"/. If <tt/"Order"/ is 0,
a standard value of 3 will be used.
Note that the B-Spline mode is currently only available for
full revolutions (<tt/"ThetaMax"/ should be 360.0).
<p>
The revolve object can automatically generate caps,
which are trimmed NURBS patches. Using the parameters
<tt/"UpperCap"/, <tt/"LowerCap"/, <tt/"StartCap"/, and <tt/"EndCap"/,
you determine whether such caps should be
generated, default is off (no caps).
<p>
If the side caps of a surface of revolution of an open
curve are not created correctly, (GLU complains about
"intersecting or misoriented trim curves"),
try to revert the revolved curve.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Extrude Object<label id="extrudeobj">
<p>
<figure loc="ht">
<eps file="pics/extrude.ps" height="4cm">
<img src="pics/extrude.gif">
<caption>Extrude Object (left: Curve, middle: normal Extrusion,
right: Extrusion with Caps)</caption>
</figure>
<p>
The extrude object forms an extrusion from a number of planar NURBS curves.
<p>
The first curve determines the outline and the other curves determine
holes in the extrusion object. Holes may be used by objects that form
e.g. letters.
<p>
The object has the generating NURBS curves as child objects,
watches them and adapts to them automagically.
<p>
Consequently, the object hierarchy of an Extrude object may look like this:
<code>
+-Extrude
 | Outline(NCurve)
 | [Hole_1(NCurve)
 | ...
 \ Hole_n(NCurve)]
</code>
<p>
The extrude object can generate caps, if the generating
curves are closed. Cap generation may fail, if the outer
curve has weights and the curve itself leaves the convex
hull of the control polygon. Be careful when using curves
with weights!
<p>
The sharp corners between caps and extrusion may be beveled.
<p>
The axis of the extrusion is always the Z axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Z axis of the extrude
object itself). The generating curves should lie in the XY plane of this
coordinate system. If not, they will be squashed down to this plane!
See section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve curves in the XY plane.
<p>
You may convert the current surface of extrusion, the caps, and bevels,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Extrude object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Extrude|NCurve+|Yes|NPatch+|No@<hline>
</tabular>
<caption>Extrude Object Capabilities</caption>
</table>
<p>

<sect2>ExtrudeAttr Property<label id="extrattr"><label id="extrudeattrprop">
<p>
Using the parameter <tt/"Height"/ you determine how
big in Z direction the extrusion should be. Note that
the height of the bevels will not be taken into account here,
if you have an extrusion with height 1.0 and you switch on
beveling (upper and lower) with radius 0.1 you end up
with an object that extends 1.2 units in Z direction.
<p>
The extrude object can automatically generate caps,
that are trimmed NURBS patches. Using <tt/"StartCap"/ and
<tt/"EndCap"/ you determine whether such caps should be generated,
default is off (no caps). Note that this feature does only work
properly, if the generating NURBS curves are closed and not self
intersecting, this is because the generating curves themselves are
used as trim curves for the caps. Warning, Ayam will not check whether
your curves conform to this criteria. Ayam, however, automatically
detects the correct orientation of the curves (and reverts them if
necessary).
<p>
Since Ayam 1.10 the bevel parameters of the extrude object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, and <tt/"BevelRadius"/ are no
longer available. They were replaced with new dynamic tag creating
bevel property GUI sections that are accessible through the new
command entries <tt/"Add Start Bevel!"/ and <tt/"Add End Bevel!"/
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Using Holes and Bevels<label id="handb">
<p>
All curves forming holes in the extruded object must be defined inside
(geometrically) the first curve (the outline curve). Additionally,
they may not intersect each other or themself and you can not have hole
curves inside hole curves. If there are bevels and caps, allow extra
spacing between the curves (for the bevels).
Ayam will not check whether your curves conform to these criteria!
<p>
With the direction of the curve you decide the direction of the
bevel as well (should it round outwards or inwards?).
If the bevels of the holes look wrong try to revert the generating
curves of the holes.
Note that beveling does not work well with open curves. You should always
use closed curves for beveling!
Beveling may lead to self intersecting trim curves in sharp corners of an
extrusion. Decrease the bevel radius or round the corners of the extruded
curve (using insertion of additional control points) if cap generation
fails due to self intersecting bevels.
<p>
Another special issue shall be noted: If there are holes, the
corresponding bevels will be scaled with the hole curve object
transformation values. Thus, to achieve equally sized bevels for outline
and holes, possible scale transformations should be carried out on the
hole curve control points, rather than on the hole curve object
transformation attributes.

<sect1>Swing Object<label id="swingobj">
<p>
<figure loc="ht">
<eps file="pics/swing.ps" height="5cm">
<img src="pics/swing.gif">
<caption>Swing Object (left: Curves, right: Resulting Swung Surface)</caption>
</figure>
<p>
The Swing object, available since Ayam 1.14, forms a surface that results
from rotating a NURBS curve (cross section or profile) around an axis while
scaling it according to a second NURBS curve (trajectory or path).
This is sometimes called rotational sweep.
<p>
The swing object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory.
<p>
The object hierarchy of a Swing object, thus, looks like this:
<code>
+-Swing
 | Cross_Section(NCurve)
 \ Trajectory(NCurve)
</code>
<p>
The swing operation will occur around the Y-axis.
<p>
The base plane for the swing operation is the YZ-plane. The cross section
curve should be defined in this plane and the trajectory should start here.
<p>
The dimensions and orders of the swung surface will be taken from the
respective parameter curves as follows: width and order in U direction
from the trajectory, height and order in V direction from the cross
section.
<p>
You may convert the current swung surface and the caps, if there
are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Swing object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Swing|NCurve*|Yes|NPatch+|No@<hline>
</tabular>
<caption>Swing Object Capabilities</caption>
</table>
<p>

<sect2>SwingAttr Property<label id="swingattrprop">
<p>
The attributes <tt/"UpperCap"/, <tt/"LowerCap"/, <tt/"StartCap"/, and
<tt/"EndCap"/ may be used to automatically create cap surfaces, that
close the Swing on the respective ends.
Note that this works properly only if the corresponding parameter
curve is closed and planar.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the Swing, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.


<sect1>Sweep Object<label id="sweepobj">
<p>
<figure loc="ht">
<eps file="pics/sweep.ps" height="6cm">
<img src="pics/sweep.gif">
<caption>Sweep Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Sweep object forms a surface that results from moving a NURBS curve
(cross section or profile) along a second NURBS curve (trajectory or path).
The cross section may be scaled while sweeping using a third curve, the
scaling function. Swept surfaces may be closed in the direction of the
trajectory and, since Ayam 1.10, they may even be periodic.
<p>
The Sweep object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory,
and the third curve represents the scaling function.
<p>
The object hierarchy of a Sweep object, thus, looks like this:
<code>
+-Sweep
 | Cross_Section(NCurve)
 | Trajectory(NCurve)
 \ [Scaling_Function(NCurve)]
</code>
<p>
Note that the <tt/"Translate"/ attributes of the cross section curve
will be fully ignored. All other transformation attributes
(of cross section and trajectory!) will be used to determine
place, orientation, and size of the Sweep object!
<p>
The cross section curve has to be defined in the YZ-plane of the
Sweep objects coordinate system but it also has to be defined in the
XY-plane of its own coordinate system. This means that a simple circular
curve as e.g. created with the toolbox has to be rotated by 90 degrees
around the Y-axis using its transformation attributes to follow these
rules. Later editing of this curve has to be done in a Side view (or
in an aligned local Front view, if the Sweep object itself is transformed
somehow).
<p>
The scaling function is sampled for each section and the Y-component
of the coordinates of the current curve point will be used as
scale factor that is applied to the cross section in Y-direction.
Since Ayam 1.13, the Z-component will be used to independently scale the
cross section in Z-direction. In earlier versions the Y-component
was used to scale both directions.
This implies, that e.g. a scaling function that does nothing should be
a linear curve from (0,1,1) to (1,1,1).
Scale components that are less than or equal zero will be silently ignored.
<p>
<figure loc="ht">
<eps file="pics/ssweep.ps" height="5cm">
<img src="pics/ssweep.gif">
<caption>Sweep Object (blue) with Scaling Function (white)</caption>
</figure>
<p>
Here is a short example for the creation of a sweep:
<itemize>
<item>Create a circular B-Spline curve using the toolbox. (This will be our
cross section.)
<item>Rotate the curve by 90 degrees around the Y-axis. (Use the
<tt/"Transformations"/ property for that.)
<item>Create a simple NURBS curve using the toolbox. (This will be our
trajectory.)
<item>Select both curves. (Select the first curve, hold down
the <tt/"Shift"/ key and select the other curve.)
<item>Create the Sweep object using the toolbox.
<item>Now you may enter the Sweep object and modify
e.g. the second curve, the trajectory. (Press <tt/"e"/,
then drag some control points around.)
<item>To modify the cross section you would need to switch to a
view of type <tt/"Side"/. (Use the <tt/&lt;Ctrl+s&gt;/ shortcut while
the view has the input focus.)
</itemize>

Section <ref id="scexsweep" name="Easy Sweep"> has an example
script that automates creation and parameterisation of
a suitable cross section curve.
<p>
You may convert the current sweep, the bevels, and the caps, if there
are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Sweep object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Sweep|NCurve*|Yes|NPatch+|No@<hline>
</tabular>
<caption>Sweep Object Capabilities</caption>
</table>
<p>

<sect2>SweepAttr Property<label id="swp"><label id="sweepattrprop">
<p>
Since Ayam 1.10 the <tt/"Type"/ attribute controls, whether the
swept surface should be open, closed, or periodic in the direction
of the trajectory curve.
<p>
If <tt/"Interpolation"/ is enabled, an additional interpolation
will be run on the swept surface in U direction so that all section
curves will be interpolated by the swept surface. Instead of a
NURBS knot vector, the swept surface will then get a
Chordal knot vector (calculated by knot averaging) and the
swept surface will follow the trajectory more closely.
See the image below for an example.
<figure loc="ht">
<eps file="pics/sweepinterp.ps" height="5cm">
<img src="pics/sweepinterp.gif">
<caption>Sweep Along a Quarter Circle without (left) and with (right) Interpolation Enabled</caption>
</figure>
<p>
The third parameter, <tt/"Sections"/, determines how many
sections (in U direction) should be used, when generating the
sweep NURBS patch. The sweep NURBS patch has sections+1 control
points in U direction for open and closed sweep types, and sections+order
control points for periodic sweep types.
Since Ayam 1.13, also zero is a valid setting for the <tt/"Sections"/
parameter and used as new default value. If <tt/"Sections"/ is zero
the number of sections is directly derived from the length of the
trajectory curve plus one (except for trajectory curves of length 2,
where it is 1). See the table below for examples.
<p>
Consequently, if <tt/"Sections"/ is zero, for a standard NURBS curve of
length 4, the number of sections used is 5 and the width of the created
NURBS patch is 6, for a curve with just 2 control points, the number of
sections used is 1 and the width of the resulting patch is 2.
<p>
If <tt/"Sections"/ is zero, the order of the sweep in U direction
is taken from the trajectory curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
If <tt/"Rotate"/ is enabled, the cross sections will be
rotated so that they are always perpendicular to the trajectory,
this is the default.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
Sweep on both ends.
Note that this works properly only if the cross section
curve is closed and planar (defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for sweeps.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the sweep, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.
<p>
The following table shows some example parameter configurations for
the Sweep object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Trajectory Length/|<bf/Trajectory Order/|<bf/Sweep Length/|<bf/Sweep Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4@<hline>
</tabular>
<caption>Sweep Parameterisation Examples</caption>
</table>

<sect1>Birail1 Object<label id="birail1obj">
<p>
<figure loc="ht">
<eps file="pics/birail1.ps" height="5cm">
<img src="pics/birail1.gif">
<caption>Birail1 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail1 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves.
The object hierarchy of a Birail1 object, thus, looks like this:
<code>
+-Birail1
 | Cross_Section(NCurve)
 | Rail1(NCurve)
 \ Rail2(NCurve)
</code>
<p>
When the cross section touches the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curve will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curve and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail1vc.ps" height="5cm">
<img src="pics/birail1vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail1 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail1 object. Mind the direction of the rail curves (R1 and R2)
with regard to the cross section curve (CS) and the fact that the
cross section curve touches the starting points of the rail curves.
<p>
Note that the cross section curve does not have to be two dimensional, and,
in contrast to the normal Sweep object, it also does not have to be
defined in a special plane. Also note that the precision with which the
resulting surface will interpolate the rail curves depends on the
number of sections choosen.
<p>
The Birail1 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current birailed surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Birail1 object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Birail1|NCurve*|Yes|NPatch+|No@<hline>
</tabular>
<caption>Birail1 Object Capabilities</caption>
</table>
<p>
The following parameters further control the birailing process:

<sect2>Birail1Attr Property<label id="birail1p"><label id="birail1attrprop">
<p>
The parameter <tt/"Sections"/ determines how many
sections (in U direction) should be used, when generating the
birailed NURBS patch. The birailed NURBS patch always has sections+1 control
points in U direction. Since Ayam 1.13, also zero is a valid setting for
the <tt/"Sections"/ parameter and used as new default value.
If <tt/"Sections"/ is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.
<p>
If <tt/"Sections"/ is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g. defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the birail, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.
<p>
The following table shows some example parameter configurations for
the birail object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Rail1 Length/|<bf/Rail1 Order/|<bf/Birail1 Length/|<bf/Birail1 Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4@<hline>
</tabular>
<caption>Birail1 Parameterisation Examples</caption>
</table>

<sect1>Birail2 Object<label id="birail2obj">
<p>
<figure loc="ht">
<eps file="pics/birail2.ps" height="5cm">
<img src="pics/birail2.gif">
<caption>Birail2 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail2 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves, while morphing it
into a second cross section (or profile) curve. The morphing process
may be controlled by a fifth parameter curve.
The object hierarchy of a Birail2 object, thus, looks like this:
<code>
+-Birail2
 | Cross_Section1(NCurve)
 | Rail1(NCurve)
 | Rail2(NCurve)
 | Cross_Section2(NCurve)
 \ [Interpolation_Control(NCurve)]
</code>
<p>
When the cross sections touch the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curves will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curves and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail2vc.ps" height="5cm">
<img src="pics/birail2vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail2 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail2 object. Mind the direction of the rail curves (R1 and R2)
with regard to the two cross section curves (CS1 and CS2) and the
fact, that all curves touch at their respective end points.
<p>
Note that the cross section curves do not have to be two dimensional, and,
in contrast to the normal Sweep object, they also do not have to be
defined in a special plane. Furthermore, they do not have to be compatible
in terms of length, order, and knots. Incompatible curves will be made
compatible before birailing automatically; the height of the resulting
surface, however, is not easily predictable anymore in this case.
Also note that the precision with which the resulting surface will
interpolate the rail curves depends on the number of sections choosen.
<p>
If a fifth curve is present as parameter object, this curve will
control the morphing (interpolation) process. The y coordinate
of this curve at a specific point, which should have a value between
0 and 1, determines the ratio of control of the first cross section
(0) and the second cross section (1) over the interpolated curve.
Thus, a straight line running from point (0,0) to (1,1) will mimic
the standard linear interpolation that would be carried out if no
interpolation control curve were present. Note, however, that the
interpolation control curve has no influence on the first and last
copy of the respective cross section curve, unless the <tt/"InterpolCtrl"/
option is used (which is available since Ayam 1.10).
<p>
The Birail2 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current birailed surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Birail2 object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Birail2|NCurve*|Yes|NPatch+|No@<hline>
</tabular>
<caption>Birail2 Object Capabilities</caption>
</table>
<p>
The following parameters control the birailing process:

<sect2>Birail2Attr Property<label id="birail2p"><label id="birail2attrprop">
<p>
The parameter <tt/"Sections"/ determines how many sections (in U direction)
should be used, when generating the birailed NURBS patch. The birailed
NURBS patch always has sections+1 control points in U direction.
Since Ayam 1.13, also zero is a valid setting for
the <tt/"Sections"/ parameter and used as new default value.
If <tt/"Sections"/ is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.
<p>
If <tt/"Sections"/ is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.
<p>
The parameter <tt/"InterpolCtrl"/ allows the interpolation controlling
curve full influence on the birailed surface.
If <tt/"InterpolCtrl"/ is disabled, the first and last border of the
resulting surface will always exactly match the parameter curves (CS1 and
CS2 respectively), regardless of the interpolation control curve.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g. defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the birail, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.
<p>
The following table shows some example parameter configurations for
the birail object.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Sections/|<bf/Rail1 Length/|<bf/Rail1 Order/|<bf/Birail2 Length/|<bf/Birail2 Order/@<hline>
0|2|2|2|2@<hline>
0|5|4|6|4@<hline>
0|6|5|7|5@<hline>
4|6|5|5|4@<hline>
10|6|5|11|4@<hline>
</tabular>
<caption>Birail2 Parameterisation Examples</caption>
</table>

<sect1>Skin Object<label id="skinobj">
<p>
<figure loc="ht">
<eps file="pics/skin.ps" height="6cm">
<img src="pics/skin.gif">
<caption>Skin Object (left: Curves, right: Resulting Skinned Surface)</caption>
</figure>
<p>
The skin object forms a surface defined by a set of cross section curves,
where the first and last curve will always be interpolated by the surface
(this process is sometimes also called lofting). When only two parameter
curves are used the skin forms a so called ruled surface.
<p>
The complete template for the Skin object hierarchy, consequently,
looks like this:
<code>
+-Skin
 | C_1(NCurve)
 | C_2(NCurve)
 | [...
 \ C_n(NCurve)]
</code>
<p>
Note that in contrast to the build from curves tool,
the curves may be of arbitrary length and order. You may e.g.
easily skin a curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points.
If the curves are of different length or order, they will all be
converted internally until they are compatible. Be warned, that
this process may consume a considerable amount of time
because all unclamped curves have to be converted to
clamped ones; then, for every curve with low order degree elevation
has to be done; then a uniform knot vector has to be found; then all
curves have to be refined using this new knot vector; interpolation
adds another dimension of complexity... If you experience
lags when editing the child curves of a skin object try to switch
to lazy notification.
Since Ayam 1.9, a skin object will also use all the curves of a
tool object, that provides multiple curves, e.g. a clone object
in mirror mode.
<p>
The direction of the parameter curves will be parallel to the v
dimension (height) of the skinned surface. The number of the parameter
curves will define the u dimension (width) of the skinned surface.
<p>
Also note that the resulting patch may be quite complex, even though
the curves are not, if the orders or knot vectors of the curves do not
match.
For example, a skinned patch from two curves of length 4 but one with
order 4 and the other with order 2 will result in a patch with
a width of 2 and a height of 10!
<p>
The skin object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
<p>
You may convert the current skinned surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Skin object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Skin|NCurve*|Yes|NPatch+|No@<hline>
</tabular>
<caption>Skin Object Capabilities</caption>
</table>
<p>
The following parameters control the skinning process:

<sect2>SkinAttr Property<label id="skp"><label id="skinattrprop">
<p>
The first parameter <tt/"Interpolation"/ controls,
whether the inner curves should also be interpolated by the
skinning surface.
<p>
The second parameter <tt/"Order_U"/ determines the order
of the resulting surface in U direction (the order in V direction is
determined by the curves). The order may not be higher than the
number of curves used. If the specified value is higher than the number
of curves, the order of the generated surface will be silently
set to the number of curves.
If <tt/"Order_U"/ is 0, a default value of 4 will be used.
<p>
Using the next parameter <tt/"Knot-Type_U"/, you can adapt the
type of the knot vector that should be used in the U direction of the
skinned surface. Note that this setting will have no effect if
interpolation is switched on because then a chord length parameterisation
will be used. If the knot type is Bezier and the specified
order (see above) does not exactly match the number of skinned curves,
then the order will be silently adapted to the number of skinned curves.
New in Ayam 1.7 is support for the knot type Custom, which creates
a chord length parameterisation, even if interpolation is not enabled.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be used
to automatically create cap surfaces to close the skinned surface
on both ends.
Note that this works only if the respective curves are closed and
planar (e.g. defined in the XY plane).
Furthermore, if the skin is not interpolating the respective parameter
curves (this may be the case if the <tt/"Knot-Type_U"/ parameter is set
to <tt/"B-Spline"/) the cap(s) will not be created in the right place.
The cap(s) will always be created in the position of the first (last)
parameter curve.
<p>
Since Ayam 1.10 bevels are available for skins.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the skin, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect1>Gordon Object<label id="gordonobj">
<p>
<figure loc="ht">
<eps file="pics/gordon-hood.ps" height="6cm">
<img src="pics/gordon-hood.gif">
<caption>Gordon Object (left: Curves, right: Resulting Gordon
Surface)</caption>
</figure>
<p>
The Gordon object forms a surface defined by two sets of intersecting
curves (a network of curves), where all curves will always be interpolated
by the surface (see image above). The image below shows the simplest
configuration of such a network, consisting of four parameter curves.
Note the arrangement and the direction of the curves.
Also note that this configuration is in fact equivalent to a Coons patch.
<p>
<figure loc="ht">
<eps file="pics/sgordon.ps" height="6cm">
<img src="pics/sgordon.gif">
<caption>Gordon Surface with Parameter Curves (white)</caption>
</figure>
<p>
The curves may be of arbitrary length and order. You may e.g.
use a curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points for the U parametric dimension. Note, however,
that in the general case only non-rational curves can be used
as parameter curves for a Gordon surface.
If the parameter curves are rational, the weight information
of the curves will simply be ignored.
However, since Ayam 1.13 there is a special case allowed: if
exactly four parameter curves are present, their weight
information will be used properly. Mind that for a correct
surface interpolation the curves weights have to match in the
respective end points.
<p>
The Gordon object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
Separation of the two sets of curves has to be done using an
empty level object. The first set of curves determines the u
direction and the second set of curves the V direction of the
Gordon surface. For the example surface in the image above, the
child objects of the Gordon object would have to look like this
in the Ayam object tree view:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 \ V2(NCurve)
</code>
<p>
The creation of a Gordon surface is computationally
expensive. It involves (interpolated) skinning of the two sets of
parameter curves, finding the intersection points of the two sets
of parameter curves, interpolating the matrix of intersection points,
making the three resulting surfaces compatible, and finally combining
the three surfaces into the resulting Gordon surface. If you experience lags
while editing the parameter curves of a Gordon surface, consider
switching to lazy notification.
<p>
In order to ease the computationally intensive intersection
detection for Ayam you may specify a third argument (separated
from the two sets of parameter curves by a second empty level object).
This third argument should be a NURBS patch object that describes
all intersection points (by its control points).
If present, this intersection patch always takes precedence over the
intersection points calculated internally.
You may want to add a <tt>"NoExport"</tt> tag to this patch. The object
hierarchy of a Gordon object using such a patch may look
like this:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | Level
 \ Intersections(NPatch)
</code>
<p>
The complete template for the Gordon object hierarchy, consequently,
is as follows:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | [...
 | Un(NCurve)]
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | [...
 | Vn(NCurve)]
 | [Level
 \ Intersections(NPatch)]
</code>
<p>
The Gordon object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current Gordon surface to an ordinary NURBS
patch using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Gordon object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Gordon|NCurve*/Level|Yes|NPatch+|No@<hline>
</tabular>
<caption>Gordon Object Capabilities</caption>
</table>
<p>
The following parameters of the Gordon object further control
the creation of the Gordon surface:

<sect2>GordonAttr Property<label id="gop"><label id="gordonattrprop">
<p>
If the parameter <tt/"WatchCurves"/ is switched on, Ayam will
check for all four outer parameter curves, whether they touch in their
endpoints. If not, the endpoints will be corrected. Note that this
works only properly with clamped curves and objects that directly
contain editable control points (i.e. it works with NCurve and ICurve
objects, but not with Instance or ConcatNC objects). If Ayam can
determine which curve was modified last, the other curve that should
meet at the endpoint in question will be modified by <tt/"WatchCurves"/.
If Ayam finds no information on modifications, the U curves take
precedence (i.e. the V curves will be modified).
<p>
The parameters <tt/"Order_U"/ and <tt/"Order_V"/ determine the
desired order of the resulting surface in U and V direction.
However, depending on the number and configuration of curves used
in the U or V direction, it may not be possible to create a Gordon
surface of the desired order.
If <tt/"Order_U"/ or <tt/"Order_V"/ are 0, a default value
of 4 will be used.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.
<p>
To help in the exact configuration of the Gordon surface, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect1>Bevel Object<label id="bevelobj">
<p>
<figure loc="!ht">
<eps file="pics/bevel.ps" height="5cm">
<img src="pics/bevel.gif">
<caption>Bevel Object (left: Curve, right: Resulting Bevelled Surface)</caption>
</figure>
<p>
The bevel object forms a bevelled surface from a single parameter
curve.
Consequently, the template for the object hierarchy of a Bevel object
looks like this:
<code>
+-Bevel
 \ NCurve
</code>
<p>
Bevels are also available as properties of different tool objects
(e.g. Extrude or Sweep). In fact, Bevel objects use the same creation
algorithm as bevel properties but offer increased flexibility in terms of
e.g. material settings. Surfaces created from bevel properties always
share the material settings of the tool object. In contrast, Bevel
objects may have their own material settings. Bevel objects are
available in Ayam since version 1.10.
<p>
Note that the parameter curve of a Bevel object should be closed and
planar to achieve best results;
see section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve this. If the curve is closed or periodic,
the appropriate curve type should be set in the curve object,
otherwise the bevelled surface may expose defects.
<p>
The Bevel object watches the child object and adapts to it automatically
via the notification mechanism.
<p>
You may convert the current bevelled surface to an ordinary NURBS patch
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Bevel object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Bevel|NCurve|Yes|NPatch|No@<hline>
</tabular>
<caption>Bevel Object Capabilities</caption>
</table>
<p>
The following parameters of the Bevel object further control
the creation of the bevelled surface:

<sect2>BevelAttr Property<label id="bevelp"><label id="bevelattrprop">
<p>
<itemize>
<item><tt/"BevelType"/ lets you choose between different shapes of bevels:
 <itemize>
 <item><tt/"Round"/ a quarter circle,

 <item><tt/"Linear"/ a straight bevel,

 <item><tt/"Ridge"/ a more complex ridged surface,

 <item><tt/"RoundCapped"/ a quarter circle followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point,

 <item><tt/"LinearCapped"/ a straight bevel followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point.
 </itemize>

Note that the bevel types <tt/"RoundCapped"/ and <tt/"LinearCapped"/
lead to degenerated NURBS surfaces. If applied shaders or textures
look wrong, consider creation of real cap surfaces instead.

<item><tt/"BevelRadius"/ controls the size of the bevelled surface when seen
from the top of the parameter curve. Note that the size of the bevel is
expressed in units defined by the object coordinate system of the
controlling object. Scale values of the controlling object affect the
bevel size.

<item><tt/"BevelRevert"/ allows to revert the sense of the bevelled surface,
should it round inwards or outwards? The sense may also be controlled
using the direction of the parameter curve and, additionally, the sense
in a different dimension may also be affected by using negative values
for the bevel radius.
</itemize>
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"BevelAttr"/ property.
<p>
To help in the exact configuration of the bevel, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect1>Cap Object<label id="capobj">
<p>
<figure loc="!ht">
<eps file="pics/cap.ps" height="6cm">
<img src="pics/cap.gif">
<caption>Cap Object (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
The cap object forms a surface that fills a closed planar NURBS curve.
If multiple curves are present as child objects, the curves following
the first curve define holes in the cap surface similar to the
parameter curves of an extruded surface (see also section
<ref id="handb" name="Using Holes and Bevels">).
<p>
<figure loc="!ht">
<eps file="pics/gordoncap.ps" height="5cm">
<img src="pics/gordoncap.gif">
<caption>Cap from Non-Planar Curve (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
Since Ayam 1.13 the cap object also supports the so called Gordon mode.
Here, only a single parameter curve may be present but, in contrast
to the standard mode of operation (Trim), in the Gordon mode the parameter
curve may be non-planar. Internally the cap object will split the
parameter curve into four sections and build a Gordon surface from
the four sections (see the image above for an example).
<p>
Consequently, the template for the object hierarchy of a Cap object
looks like this:
<code>
+-Cap
 | Outline(NCurve)
 | [Hole1(NCurve)]
 +-[Hole2(Level)
  | Part1(NCurve)
  \ Part2(NCurve)]
</code>
<p>
Note that, in Trim mode, the curves have to be planar and defined in
the XY plane; see section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve this.
Furthermore, cap generation may fail, if the control points of the
first curve have weights and the curve leaves the convex hull of the
control polygon. Be careful when using weights!
<p>
The Cap object watches the child objects and adapts to them automatically
via the notification mechanism.
<p>
You may convert the current cap surface to an ordinary NURBS patch object
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Cap object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Cap|NCurve+|Yes|NPatch|No@<hline>
</tabular>
<caption>Cap Object Capabilities</caption>
</table>
<p>
The following parameters control the cap creation process:

<sect2>CapAttr Property<label id="capp"><label id="capattrprop">
<p>
The attribute <tt/"Type"/ determines whether a trimmed NURBS surface
should be created (type <tt/"Trim"/), or an untrimmed Gordon surface
(type <tt/"Gordon"/), see also the general discussion about the cap
object above.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"CapAttr"/ property.
<p>
To help in the exact configuration of the cap, the <tt/"NPInfo"/
field always displays the parameters of the created NURBS patch.

<sect1>ICurve (Interpolating Curve) Object<label id="icurveobj">
<p>
The ICurve object creates a global interpolating NURBS curve from n
3D non-rational data points.
The curve may be closed, the order of the curve may be configured,
the parameterisation may be adapted, and end derivatives may be specified.
The open versions use n+2 NURBS control points, and the closed ones n+3.
<figure loc="!ht">
<eps file="pics/icurves.ps" height="7cm">
<img src="pics/icurves.gif">
<caption>Different ICurves resulting from identical data point configurations
(Upper Left: Open, Order 3; Upper Right: Open, Order 4; Lower Left: Closed, Order 3; Lower Right: Closed, Order 4)</caption>
</figure>
<p>
The image above shows some interpolating curves, the left ones
are of order 3 (quadratic curves), the right ones are of order 4 (cubic
curves), the upper open, and the lower closed ones. The interpolation
fidelity for the closed curves was tuned by adjusting the <tt/"SDLen"/
and <tt/"EDLen"/ parameters (all set to 0.2), see also the discussion
of the parameters below.
<p>
In all parameterisation modes, knot averaging will be used
to determine the knot vector of the interpolating curve.
<p>
Note that the axis of symmetry for closed interpolating curves
crosses the first data point (in contrast to open interpolating
or closed approximating curves, where it crosses between the last
and first data point).
For example, the closed interpolating curves in the above example
image are indeed both symmetric, but the axis of symmetry is crossing
the first and third data point and is, thus, rotated by 45 degrees.
<p>
This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g. revolve, sweep, extrude, and skin) are
able to work with an ICurve object instead of an object
of type NCurve.
<p>
You may convert the current ICurve to an ordinary NURBS curve
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ICurve object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ICurve|No|No|NCurve|Yes@<hline>
</tabular>
<caption>ICurve Object Capabilities</caption>
</table>
<p>
The following parameters control the interpolation process:

<sect2>ICurveAttr Property<label id="icp"><label id="icurveattrprop">
<p>
<itemize>
<item>The <tt/"Type"/ parameter controls whether the interpolated
curve should be open or closed.

<item><tt/"Length"/ is the number of data points to interpolate.

<item>The next parameter <tt/"Order"/ determines the desired order of the
interpolating curve. If the specified order is bigger than the number of
control points used by the interpolating NURBS curve, then the order is
silently changed to match the number of control points.

<item>The parameter <tt/"ParamType"/ switches the parameterisation
between <tt/"Chordal"/ and <tt/"Centripetal"/, the latter generating
a better parameterisation if the input data contains sharp turns.

<item>The parameters <tt/"SDLen"/ and <tt/"EDLen"/ are used to control
the length of the first and last derivative (if automatically
generated from the data points, i.e. when <tt/"Derivatives"/ below is
switched off).

<item>If the parameter <tt/"Derivatives"/ is switched on, two more
editable points appear in the single point editing modes. Those
additional points directly control the derivatives in the
endpoints of the interpolating curve. The parameters <tt/"SDLen"/ and
<tt/"EDLen"/ do not influence those derivatives.
If this parameter is switched off, the direction of the derivatives
will be determined from the first, second, second to last, and last
data points automatically.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

The parameters <tt/"Mode"/, <tt/"Closed"/, and <tt/"IParam"/ are gone
since Ayam 1.16. <tt/"Closed"/ was replaced by <tt/"Type"/, <tt/"IParam"/
by <tt/"SDLen"/ and <tt/"EDLen"/, and the <tt/"Mode"/ is now determined
automatically from the desired order.

<sect1>ACurve (Approximating Curve) Object<label id="acurveobj">
<p>
<figure loc="!ht">
<eps file="pics/acurves.ps" height="7cm">
<img src="pics/acurves.gif">
<caption>Different ACurves (Upper Left: ALength 3, Order 3; Upper Right: ALength 4, Order 4; Lower Left: ALength 4, Order 4; Lower Right: ALength 6, Order 3)</caption>
</figure>
<p>
The ACurve object, available since Ayam 1.15, creates an approximating
NURBS curve with m control points from n 3D non-rational data points
(see image above).
The number of data points must be higher than or equal to the number of
control points used. The approximation algorithm used is a least
squares approach. If the number of control points approach the number
of data points, undesired wiggles in the output curve may occur.
<p>
This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g. revolve, sweep, extrude, and skin) are
able to work with an ACurve object instead of an object
of type NCurve.
<p>
You may convert the current ACurve to an ordinary NURBS curve
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ACurve object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ACurve|No|No|NCurve|Yes@<hline>
</tabular>
<caption>ACurve Object Capabilities</caption>
</table>
<p>
The following parameters control the approximation process:

<sect2>ACurveAttr Property<label id="acp"><label id="acurveattrprop">
<p>
<itemize>
<item>Using <tt/"Length"/ you determine the number of data points to
approximate.

<item>Using <tt/"ALength"/ you determine the number of (distinct)
control points to use for the approximating NURBS curve.
The total number of distinct control points must be smaller than or equal
to the number of data points.

<item>The curve can be closed with the parameter <tt/"Closed"/.
For closed approximations, the total number of control points will
be <tt/"ALength + Order - 1"/.
The following table illustrates this relationship.

<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Length/|<bf/ALength/|<bf/Order/|<bf/Closed/|<bf/Output Length/@<hline>
10|5|3|No|5@<hline>
10|5|3|Yes|8@<hline>
10|4|4|Yes|8@<hline>
5|4|3|No|4@<hline>
5|4|3|Yes|7@<hline>
</tabular>
<caption>ACurve Parameterisation Examples</caption>
</table>

<item>For symmetric data point configurations, the approximating curve
is not necessarily symmetric. With the parameter <tt/"Symmetric"/
this can be enforced (see image below), albeit at the cost of about
double runtime and a slightly worse parameterisation.
<figure loc="!ht">
<eps file="pics/acurve-sym.ps" height="4cm">
<img src="pics/acurve-sym.gif">
<caption>Left: asymmetric ACurve, Right: symmetric ACurve</caption>
</figure>

<item>The parameter <tt/"Order"/ specifies the desired order
of the approximating NURBS curve. Currently, only orders higher than
2 are supported.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect1>ConcatNC (Concatenate NURBS Curves) Object<label id="concatncobj">
<p>
<figure loc="ht">
<eps file="pics/concatnc.ps" height="5cm">
<img src="pics/concatnc.gif">
<caption>ConcatNC Object (blue) from a Linear Curve and 3 Instances (white)</caption>
</figure>
<p>
The ConcatNC object concatenates all child objects (which should be
NURBS curves or provide NURBS curves) to a single NURBS curve. Since
the ConcatNC object also provides a NURBS curve, it is possible to
use it as child object for another ConcatNC object (with possibly
different parameters) or as a parameter object for a tool object that
works with NURBS curves such as Revolve or Extrude.
<p>
How does the concatenation process work?
<p>
First, the orders of all parameter curves will be elevated to the maximum
order of all the parameter curves (see section
<ref id="elevt" name="elevate tool"> for more information on elevation)
and all curves will be clamped (see section
<ref id="clat" name="clamp tool"> for more information on clamping).
If <tt/"FillGaps"/ is enabled (see below), fillet curves will be
created for every gap between the parameter curves of the ConcatNC object.
If <tt/"Closed"/ and <tt/"FillGaps"/ are enabled, an additional fillet
is created to close the curve.
Then, the control points of all parameter curves and fillets are simply
copied into a new big control point vector, without checking for double
points. This means that for parameter curves that touch at their
respective ends, atleast double control points in the new concatenated
curve will result.
<p>
The knot sequence of the new concatenated curve will be of type
<tt/"NURBS"/ or a custom knot vector will be computed (depending
on the setting of <tt/"Knot-Type"/).
If <tt/"Knot-Type"/ is <tt/"NURBS"/, the shape of the concatenated curve
will differ from the parameter curves if any of the parameter curves has
a custom knot vector with non equidistant knots. If <tt/"Knot-Type"/ is
<tt/"Custom"/, the shape of the parameter curves will be preserved.
<p>
Attributes like display mode and tolerance for the new concatenated curve
are simply taken from the first parameter curve.
<p>
You may convert the current ConcatNC object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ConcatNC object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNC|NCurve*|No|NCurve|No@<hline>
</tabular>
<caption>ConcatNC Object Capabilities</caption>
</table>
<p>
The following parameters further control the concatenation process:

<sect2>ConcatNCAttr Property<label id="concatncp"><label id="concatncattrprop">
<p>
<itemize>
<item>Using <tt/"Closed"/ you may create a closed concatenated curve.
If <tt/"FillGaps"/ (below) is enabled, an additional fillet will
be created for the last and the first child curve to close
the concatenated curve. If <tt/"FillGaps"/ (below) is not enabled,
the concatenated curve will be closed with the same algorithm
that is also used by the close curve tool (possibly changing
the shape again!).

<item><tt/"FillGaps"/, creates fillet curves for all gaps between
the child curves of the ConcatNC object. The fillet curves will be
cubic Bezier curves. The direction of the tangents in the endpoints of
the fillets and the gap enclosing curves will match, so that the
transition should be G1 continuous.

<item>If <tt/"Revert"/ is enabled, the orientation of the concatenated
curve will be reversed.

<item><tt/"FTLength"/ determines a scale factor for the tangent vectors
of the fillets. A value of 1.0 leads to vectors that are as long as
the matching vectors in the control point arrays of the original curves.
A value of 0.3 is the default value. You may need to tweak this, if
you experience discontinuities in the transitions between original
curves and fillets, especially, if <tt/"Knot-Type"/ (see below) is set to
<tt/"Custom"/.

<item><tt/"Knot-Type"/ in fact toggles between two different modes
of concatenation. If <tt/"Knot-Type"/ is <tt/"NURB"/ a simple knot vector
with equidistant knots is generated, which leads to a concatenated curve,
that does not exactly preserve the shape of the original curves.
If <tt/"Knot-Type"/ is <tt/"Custom"/, the knot vector is composed from
the knot vectors of the original curves, and thus, their
shape may be preserved completely.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect1>ExtrNC (Extract NURBS Curve) Object<label id="extrncobj">
<p>
The ExtrNC object extracts a NURBS curve from a NURBS patch object,
for use as parameter object for other tool objects, like e.g.
Revolve. It also works with NURBS patch providing objects, so that
the following example hierarchy is valid:
<code>
--NPatch
+-Skin
 +-ExtrNC
 |\ Instance_of_NPatch(Instance)
 \ NCurve
</code>
Depending on the parameters of the ExtrNC object, the Skin object
above will have one boundary in common with a boundary or an iso-curve
of the NPatch object.
Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNC object. Therefore, the main menu entry
<tt>"Tools/Create/ExtrNC"</tt>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNC object.
<p>
Note that the extraction of any curves currently completely ignores
potentially present trimming information of the NPatch object.
<p>
You may convert the current ExtrNC object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ExtrNC object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ExtrNC|NPatch|No|NCurve|No@<hline>
</tabular>
<caption>ExtrNC Object Capabilities</caption>
</table>
<p>
The extraction process is controlled by the following attributes:

<sect2>ExtrNCAttr Property<label id="extrncp"><label id="extrncattrprop">
<p>
<itemize>
<item><tt/"Side"/ controls, which curve should be extracted.
Available values are <tt/"U0"/, <tt/"Un"/: extract boundary curve along
width; <tt/"V0"/, <tt/"Vn"/: extract boundary curve along
height; <tt/"U"/, <tt/"V"/ (available since Ayam 1.8.1) extract curve
along width and height respectively at specified parametric value (see below).
<p>
Since Ayam 1.13 it is also possible to extract the complete boundary
curve of the patch (<tt/"Boundary"/).
<p>
Since Ayam 1.15 it is also possible to create a curve from the patch
data that is the "middle axis" (<tt/"Middle_U"/, <tt/"Middle_V"/)
(simply the medium of all control points of a patch in the designated
dimension). This option is useful to re-engineer swept surfaces, delivered
as simple patches.

<item><tt/"Parameter"/ controls the parametric value in U or V
direction in the parameter space of the NURBS patch object where the
curve should be extracted. This parameter is only used when <tt/"Side"/
is <tt/"U"/ or <tt/"V"/. The valid range of parameter values depends
on the knot vectors of the NURBS patch.

<item><tt/"Relative"/ controls whether the parametric value should
be interpreted in a relative way. If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector, regardless of the
actual knot values, and the valid range for <tt/"Parameter"/ is
then consequently 0.0-1.0.
This option is available since Ayam 1.15.

<item><tt/"Revert"/ immediately reverts the extracted curve.

<item><tt/"PatchNum"/ allows to select a patch from a list of
patches delivered e.g. by a beveled extrude object as child
of the ExtrNC object.
This way it is possible to extract a curve from a bevel or cap
surface of e.g. a Revolve object.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the extracted NURBS curve.
</itemize>
<p>
See section <ref id="ncattr" name="NCurveAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>NCircle (NURBS Circle) Object<label id="ncircleobj">
<p>
The NCircle object is available since Ayam 1.12 and creates a
circular NURBS curve or a circular arc in the XY plane
centered at the origin with designated radius and start/end angles.
<p>
In order to revert the created NURBS curve, since Ayam 1.15,
the start/end angles may be used, e.g. <tt/"TMin"/ 0.0,
<tt/"TMax"/ -360.0 for a reverse full circle.
<p>
You may convert the current NCircle object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the NCircle object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
NCircle|No|No|NCurve|No@<hline>
</tabular>
<caption>NCircle Object Capabilities</caption>
</table>
<p>
The following section describes the parameters of the circle or
arc.

<sect2>NCircleAttr Property<label id="ncircleattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the circle.

<item><tt/"TMin"/ (ThetaMin) controls the starting angle of the circle
or arc to be created. Negative values are allowed.

<item><tt/"TMax"/ (ThetaMax) controls the end angle of the circle
or arc to be created. Negative values are allowed.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect1>OffsetNC (Offset NURBS Curves) Object<label id="offsetncobj">
<p>
<figure loc="ht">
<eps file="pics/offnc.ps" height="5cm">
<img src="pics/offnc.gif">
<caption>Offset Curves (white) from NURBS Curves (blue) with Offset 0.2, -0.2, and 0.3</caption>
</figure>
<p>
The OffsetNC object, available since Ayam 1.14, creates offset curves from
planar NURBS curves using two simple algorithms; one derived from the bevel
creation algorithm and the other simply offsetting control polygon sections.
The offset curve will always match the original curve in type, length, order,
and knots. See also the image above.
<p>
Since Ayam 1.15 there is a third offsetting algorithm available, that creates
offsets from non planar curves.
<p>
You may convert the current OffsetNC object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the OffsetNC object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
OffsetNC|NCurve|No|NCurve|No@<hline>
</tabular>
<caption>OffsetNC Object Capabilities</caption>
</table>
<p>
The following parameters further control the offsetting process:

<sect2>OffsetNCAttr Property<label id="offsetncp"><label id="offsetncattrprop">
<p>
<itemize>
<item>The first parameter <tt/"Mode"/ determines, which algorithm
to use for the offsetting process.

<item>Using <tt/"Revert"/ you may revert the direction of the
offset curve.

<item><tt/"Offset"/ determines the distance between original curve and
offset curve. Negative values are allowed.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the parameters: <tt/"Tolerance"/ and <tt/"DisplayMode"/.

<item>Finally, a <tt/"NCInfo"/ field informs about the actual configuration
of the created NURBS curve.
</itemize>

<sect1>ConcatNP (Concatenate NURBS Patches) Object<label id="concatnpobj">
<p>
<figure loc="ht">
<eps file="pics/concatnp.ps" height="5cm">
<img src="pics/concatnp.gif">
<caption>ConcatNP Object (white) From Two NURBS Patches (blue)</caption>
</figure>
<p>
The ConcatNP object, available since Ayam 1.16, concatenates all child
objects (which should be NURBS patches or provide NURBS patches) to
a single NURBS patch (see image abovee). Since the ConcatNP object also
provides a NURBS patch, it is possible to use it as child object for
another ConcatNP object (with possibly different parameters).
<p>
Attributes like display mode and tolerance for the new concatenated patch
are simply taken from the first parameter patch. Eventually present
trim curves will currently <em>not</em> be honored properly.
<p>
You may convert the current ConcatNP object to an ordinary NURBS patch
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ConcatNP object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ConcatNP|NPatch*|Yes|NPatch|No@<hline>
</tabular>
<caption>ConcatNP Object Capabilities</caption>
</table>
The following parameters further control the concatenation process:

<sect2>ConcatNPAttr Property<label id="concatnpp"><label id="concatnpattrprop">
<p>
<itemize>
<item>Using <tt/"Type"/, open, closed, or periodic concatenated patches may
be created.

<item>If <tt/"Revert"/ is enabled, the orientation of the concatenated
surface will be reversed (in U direction).

<item>The <tt/"Knot-Type"/ parameter allows to choose between NURB
and B-Spline knot vectors for the concatenated surface (in U direction).

<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the created NURBS patch.
</itemize>

<sect1>ExtrNP (Extract NURBS Patch) Object<label id="extrnpobj">
<p>
The ExtrNP object, available since Ayam 1.14, extracts a NURBS patch from
another NURBS patch object, for use as parameter object for other tool
objects.
<p>
It also works with NURBS patch providing objects, so that the following
example hierarchy is valid:
<code>
--NPatch
+-ExtrNP
 \ Instance_of_NPatch(Instance)
</code>
Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNP object. Therefore, the main menu entry
<tt>"Tools/Create/ExtrNP"</tt>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNP object.
<p>
Also note that eventually present trim curves will <em>not</em> be honored
properly.
<p>
You may convert the current ExtrNP object to an ordinary NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the ExtrNP object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
ExtrNP|NPatch|Yes|NPatch|No@<hline>
</tabular>
<caption>ExtrNP Object Capabilities</caption>
</table>
<p>
The extraction process is controlled by the following attributes:

<sect2>ExtrNPAttr Property<label id="extrnpp"><label id="extrnpattrprop">
<p>
<itemize>
<item><tt/"UMin"/, <tt/"UMax"/, <tt/"VMin"/, and <tt/"VMax"/ are
parametric values that control which part of the original surface
is to be extracted. The valid range of parameter values depends
on the knot vectors of the original surface.

<item><tt/"Relative"/ controls whether the parametric values should
be interpreted in a relative way. If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector, regardless of the
actual knot values, and the valid range for the parametric values is
then consequently 0.0-1.0. This option is available since Ayam 1.15.

<item><tt/"PatchNum"/ allows to select a patch from a list of
patches delivered e.g. by a beveled extrude object as child
of the ExtrNP object.
This way it is possible to extract a patch from a bevel or cap
surface of e.g. a Revolve object.

<item>See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<item>Finally, a <tt/"NPInfo"/ field informs about the actual configuration
of the extracted NURBS surface.
</itemize>

<sect1>Text Object<label id="textobj">
<p>
<figure loc="!ht">
<eps file="pics/text-ayam.ps" height="4cm">
<img src="pics/text-ayam.gif">
<caption>Text Object set in Verdana</caption>
</figure>
<p>
Text objects may be used to easily create objects that form letters or
even whole words in very high quality. For that, they parse TrueType font
description files, extract the Bezier curves from the font description,
sort the curves, connect them properly and finally extrude them.
As with the Extrude objects, caps and bevels may be created automatically.
<p>
Parsing of TrueType font descriptions is quite tricky. For the sake
of brevity and ease of the implementation, Ayam does not support elaborate
TrueType features like kerning tables, that e.g. control distances between
certain letters (You are not going to typeset a book with Ayam anyway,
aren't you?). Therefore you might experience wrong letter distances
from time to time. If this happens, just create a Text object for each
letter, and arrange the objects as you like.
<p>
You may convert the current Text object to ordinary NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following table briefly lists some capabilities of the Text object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Text|No|Yes|NPatch+|No@<hline>
</tabular>
<caption>Text Object Capabilities</caption>
</table>
<p>
The following attributes control the creation of the text objects.

<sect2>TextAttr Property<label id="textattr"><label id="textattrprop">
<p>
<itemize>
<item>Using <tt/"FontName"/ you specify a TrueType font description file.
Those files usually have the file name extension <tt/".ttf"/.
Only real TrueType font files, containing Bezier curve font descriptions,
are supported. There are also rastered, bitmap containing TrueType
font description files, those will not work.

<item>Using <tt/"String"/ you specify the letters to be created.
This entry (and the corresponding data structures) are Unicode clean.
This means you can put any Unicode letters into this entry. You should
of course make sure, that the specified letters are included in the
selected font file.

<item><tt/"Height"/ controls the height of the extruded object.

<item><tt/"Revert"/ reverts the sense of inside-outside detection
mechanism for the cap generation. Depending on the actual font description
file (or even letter) you may need to toggle this to get caps.

<item><tt/"UpperCap"/, <tt/"LowerCap"/, work like for the Extrude object
(see section <ref id="extrattr" name="ExtrudeAttr Property"> for a more
exhaustive description of those parameters).

<item><tt/"Add Start Bevel!"/, <tt/"Add End Bevel!"/:
Since Ayam 1.10 the bevel parameters of the text object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, <tt/"BevelRadius"/, and
<tt/"RevertBevels"/ are no longer available. They were replaced with
new dynamic tag creating bevel property GUI sections that are accessible
through the new command entries <tt/"Add Start Bevel!"/ and
<tt/"Add End Bevel!"/
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
Just one note: for some fonts, the bevel radius has to be set to really
small values (about 0.0008) to get proper bevels and caps. This is
because of sharp corners in some letters that lead to self overlapping
borders of the bevel surfaces with high values for the bevel radius.
</itemize>

See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>RiInc Object<label id="riincobj">
<p>
RiInc objects may be used to include objects or whole scene parts into your
scenes that, for some reason, are just available as a piece of RIB.
<p>
The following table briefly lists some capabilities of the RiInc object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
RiInc|No|No|N/A|No@<hline>
</tabular>
<caption>RiInc Object Capabilities</caption>
</table>
<p>
The following attributes control the inclusion:

<sect2>RiIncAttr Property<label id="riincp"><label id="riincattrprop">
<p>
<itemize>
<item>Using <tt/"File"/ you specify the filename of the RIB to be included.
<item><tt/"Width"/, <tt/"Height"/, and <tt/"Length"/ specify
the size of a box, that will be drawn as a geometric representation of
the RIB.
</itemize>

<sect1>RiProc Object<label id="riprocobj">
<p>
RiProc objects may be used to include procedural objects or external
archives into your scenes.
<p>
The following table briefly lists some capabilities of the RiProc object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
RiProc|No|No|N/A|No@<hline>
</tabular>
<caption>RiProc Object Capabilities</caption>
</table>
<p>
The following attributes control the RiProc object:

<sect2>RiProcAttr Property<label id="riprocp"><label id="riprocattrprop">
<p>
<itemize>
<item><tt/"Type"/ defines the type of the procedural object which is
one of <tt/"DelayedReadArchive"/, <tt/"RunProgram"/, or
<tt/"DynamicLoad"/.
<item>Using <tt/"File"/ you specify the filename of the RIB archive,
program, or dynamic shared object (depending on the type of the
procedural object).
<item>Using <tt/"Data"/ additional arguments may be supplied to
procedural objects of type <tt/"RunProgram"/ and <tt/"DynamicLoad"/.
<item><tt/"MinX"/, <tt/"MaxX"/, <tt/"MinY"/, <tt/"MaxY"/, <tt/"MinZ"/,
and <tt/"MaxZ"/ specify the size of the bounding box of the objects that
the procedural will create or the archive contains.
</itemize>

<sect1>Script Object<label id="scriptobj">
<p>
Script objects are the most flexible object type of Ayam.
They may be used to create new objects, modify existing objects,
or realise mechanisms like constraints using small scripts.
<p>
Those small scripts may employ functionality from Tcl and
the Tcl scripting interface of Ayam to calculate data which
is then used to create or modify objects of the scene
(see also section <ref id="script" name="Scripting Interface">).

<sect2>Safe Interpreter<label id="safeinterp">
<p>
In Ayam versions prior to 1.16 Script object scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
Script objects scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state. Direct access
to Tk is also completely blocked but Script objects still can have their
own property GUIs (see examples below).
<p>
In particular, the following Tcl commands are not available in the
safe interpreter:
cd, encoding, exec, exit, fconfigure, file, glob, load, open, pwd, socket,
source, unload; auto_exec_ok, auto_import, auto_load, auto_load_index,
auto_qualify, unknown (the missing unknown and autoloading facilities
lead to further unavailability of commands normally available via
autoloading, like e.g. parray, history).
Ayam scripting interface commands that directly manipulate the user
interface are also not available (uS, rV etc.). Please refer to the
documentation of the scripting interface commands about their availability
in the safe interpreter
(see section
<ref id="sccomm" name="Index of Procedures and Commands">).
<p>
In addition, access to global variables like env, ay, ayprefs
is not allowed. In fact, the safe interpreter has a completely
separate set of variables. Transfer of data between both interpreters
must be arranged manually from the Ayam interpreter (e.g. scripts that
run in the Ayam console).
<p>
With the help of scripts, that run in the Ayam interpreter, more commands
may be transfered to or made available in the safe interpreter.
But this may, of course, open security holes again.
<p>
You can also still re-enable full access from script objects to the
complete scripting interface by recompiling Ayam.
If you do so, for security reasons, if scene files containing script
objects are loaded, Ayam will raise a warning dialog, offering to
temporarily disable all script objects that will be read. The script
objects will be disabled using the <tt/"Active"/ script object property
and may be enabled after careful inspection of the script code manually
or using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>Script Object Usage
<p>
The script of a script object will be run each time the script is
modified and each time the notification callback of the script object
is called (e.g. because one of the children of the script object changed).
As long as the script of a script object is executed, Ayam will
not process any events except for checking whether the script emergency
hotkey <tt/&lt;Ctrl+Shift+c&gt;/, that may also be used to
escape from infinite loops in the Ayam console, is pressed.
Calling commands and procedures that lead to the processing of
events or that are slow because they manipulate or update the
GUI of Ayam should be avoided. In particular, the following
procedures and commands should <em>not</em> be used: uS, uCR, uCL,
selOb, plb_update, cutOb, copOb, delOb, undo!
<p>
Since Ayam 1.8.2 script objects may also create their own property
GUIs for e.g. script parameters. This may be accomplished by adding
tags of type <tt>"NP"</tt> with the name of the new property as
value to the script object. The script itself is responsible for data
management and property GUI creation.
<p>
Since Ayam 1.9 the parameters set via a new property GUI may be
comfortably saved with scene files by just adding the following
comment as first line to the script:
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
where arrayname designates the name of the global Tcl array
the property GUI elements operate with.
Note that with the introduction of individual parameters in Ayam
1.15 not all members of the arrays will be saved. Only members
from the <tt>"SP"</tt> list (see below) will be considered, which gives
script object developers fine grained control over what actually goes
to the Ayam scene file.
<p>
Since Ayam 1.12 there is also a tag type to remove properties
(<tt>"RP"</tt>). Using this tag, one can e.g. hide the actual script
code and block users from unintentionally changing it.
<p>
Since Ayam 1.15 script objects can have individual sets of parameters,
so that multiple copies of a script object can be used (without individual
parameters all copies would share the same parameter values).
For this, the new variable <tt>"SP"</tt> in the script data array
contains a list of parameter names in that array that are individual
(not shared by all copies of the script object).
<p>
The binary and source distributions of Ayam contain several example
scripts for script objects in the <tt>"ayam/bin/scripts"</tt> and
<tt>"ayam/src/scripts"</tt> directories, respectively. In addition,
there are example scene files using script objects in the
<tt>"ayam/scn/scripts"</tt> directory.
<p>
The following table briefly lists some capabilities of the Script object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Script|Any (+)|No|Any (+)|No@<hline>
</tabular>
<caption>Script Object Capabilities</caption>
</table>
<p>
The next section discusses the available script object types and
additional controlling parameters.

<sect2>ScriptAttr Property<label id="scriptattr"><label id="scriptattrprop">
<p>
<itemize>
<item>If <tt/"Active"/ is disabled, the script will not be run.

<item><tt/"Type"/ is the type of the script object.
Three types of script objects are currently available:
 <itemize>
 <item><tt/"Run"/, the script will be run and no special action will
take place.

 <item><tt/"Create"/, the script will be run and will create and
parameterise a single new object. After running the script, the newly
created object will automatically be moved into the internal data
structure of the script object. The script object will look like
and act as an object of the type that the script created.
If the script creates e.g. a NCurve object, the script object may
be used as parameter object of a tool object that needs a NCurve,
e.g. a Sweep:
<code>
+-Sweep
 | Cross_Section(Script)
 \ Path(NCurve)
</code>
The newly created object has to be selected by the script code
for parameterisation and moving. The selection should be done
using the new scripting interface command <tt/"hSL"/ (hidden select
last).
Consequently, the most simple example script for a script object
of type <tt/"Create"/ looks like this:
<code>
crtOb NCurve
hSL
</code>

 <item><tt/"Modify"/, if the script object has child objects,
these child objects will be copied into the internal data
structure of the script object. A selection of the copied objects
will be established, then the script will be run. Usually, the
script modifies one of the selected objects (moves control points,
adds tags, or does something similar). Note that the original
child objects will not be modified.
If certain actions in the script shall be restricted to
one of the child objects of the script object, the
<tt/"withOb"/ command may be used to accomplish this easily.
The script object will look like and act as an object of the type
of the first child object of the script object.
If the script object has e.g. a NCurve object as first child, the
script object may be used as parameter object of a tool object that
needs a NCurve, e.g. a Sweep:
<code>
+-Sweep
 +-Cross_Section(Script)
 |\ NCurve
 \ Path(NCurve)
</code>
A simple example script for a script object of type <tt/"Modify"/ that
needs a single NURBS curve as child object may look
like this:
<code>
revertC
</code>
Note: In order to make this work for objects providing NURBS curves
(interpolating curves or instances of NURBS curves) the code has to
look like this:
<code>
convOb -inplace; revertC
</code>
</itemize>

<item><tt/"Script"/ is the script code. The corresponding widget
is a standard Tcl text widget that allows to directly edit the code.
It is also possible to edit the code in an external editor and
copy it to the script object using the operating system clipboard
and the <tt/"Paste (Replace)"/ context menu entry of the text widget.
If the first line of the script is a comment like
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
then the global Tcl array <tt>&lt;arrayname&gt;</tt> will be saved with
the script object to Ayam scene files.
The array must contain an entry <tt/"SP"/ that lists all individual
parameters of the script object. Note that only parameters from this
list will be saved to Ayam scene files.
Note also, that <tt/"SP"/ must <em/never/ contain <tt/"SP"/. All copies
of a script object must share the same set of individual vs. shared
parameters. If objects need to store differing/individual amounts of
parameter data, lists can be used as individual parameters.
</itemize>

<sect2>Script Object Example<label id="scriptobjex">
<p>
This section illustrates the development of a script object for parametric
lines, otherwise unavailable in Ayam.
<p>
We start with a simple version, that first creates a NURBS curve object with
two control points and then places the control points each at +/- half the
desired line length on the x axis. Just copy the following code to the
Script property of a script object of type <tt/"Create"/, and activate it.
<code>
set length 1
crtOb NCurve -length 2; hSL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</code>
<p>
<figure loc="ht">
<eps file="pics/scriptex1.ps" height="4cm">
<img src="pics/scriptex1.gif">
<caption>Simple Script for Parametric Line Primitive</caption>
</figure>
<p>
This code works, but if lines of a different length than 1 are needed,
the user must edit the script which is not very convenient and error
prone.
A complete, easy to use, and safe GUI for the length parameter
can be added by changing the script code
(<tt>&quot;&num; &circ;&circ;&circ;&quot;</tt> lines designate changed
or added code):
<code>
# Ayam, save array: LineAttrData
if { ![info exists ::LineAttrData] } {
    array set ::LineAttrData {
	Length 1
	SP {Length}
    }
    set w [addPropertyGUI LineAttr]
    addParam $w LineAttrData Length
}
set length $::LineAttrData(Length)
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
crtOb NCurve -length 2; hSL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</code>
and by adding a <tt>"NP"</tt> (new property) tag to the script object
with the value <tt>"LineAttr"</tt>, resulting in a new clickable
graphical user interface as can be seen in the following image:
<p>
<figure loc="ht">
<eps file="pics/scriptex2.ps" height="4cm">
<img src="pics/scriptex2.gif">
<caption>Parametric Line Primitive with Parameter GUI</caption>
</figure>
<p>
The GUI setup code creates a Tcl array essential to manage the
data of an Ayam object property (LineAttrData). Then, the LineAttr
property GUI is created
and a GUI element is added to the GUI using <tt>"addParam"</tt>.
Note that the <tt>"addPropertyGUI"</tt> command expects for a property
named <tt>"SomePropertyName"</tt> a corresponding property data array
named <tt>"SomePropertyNameData"</tt> to exist.
The GUI setup code should just run once, therefore it checks for the
presence of the array LineAttrData first.
See also section
<ref id="ayproparr" name="Global Property Management and Data Arrays">
for more information about property GUIs and the Ayam scripting interface.
<p>
Finally, to enable saving of the parameter value in the new property
<tt>"LineAttr"</tt> to scene files, a comment must be prepended to the
script (<tt>"Ayam, save array: LineAttrData"</tt>), and to enable
multiple and individually parameterised copies of this
script object, a <tt/"SP"/ entry needs to be added to the
<tt>"LineAttrData"</tt> array as well.
<p>
The complete script is also available as example script file
<tt>"scripts/crtlinegui.tcl"</tt> in the Ayam distribution.

<sect1>Select Object<label id="selectobj">
<p>
The Select object, available since Ayam 1.14, may be used in hierarchies
of tool objects to select one object from a list of provided objects.
Since Ayam 1.16, also multiple objects and ranges (even decreasing
ranges that lead to reversed orders) may be selected.
<p>
In the following example hierarchy, a single patch from multiple provided
patches of the Sweep object (the swept surface, a bevel, or a cap)
could be selected by the Select object and delivered upstream to
the ExtrNC object.
<code>
+-Sweep
+-Revolve
 +-ExtrNC
  +-Select
   \ Instance_of_Sweep(Instance)
</code>
Note that this example just serves illustrative purposes; the hierarchy
presented is not exactly useful, as the ExtrNC object has a selector
facility built in. Consequently, the Select object should be used in
scenarios, where a selector facility does not exist or is hard to
implement, as e.g. in Script object scripts.
<p>
The following table briefly lists some capabilities of the Select object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Select|Any (+)|No|N/A&thinsp;/&thinsp;Children (+)|No@<hline>
</tabular>
<caption>Select Object Capabilities</caption>
</table>

<sect2>SelectAttrib Property<label id="selectp"><label id="selectattribprop">
<p>
<itemize>
<item><tt/"Indices"/ designates the object(s) to select. The index values
are zero based. Multiple indices must be separated by <tt/","/, ranges
can be specified like this <tt/"1-4"/, reversed ranges are allowed
(<tt/"4-1"/) and will create an object list of reversed order. The special
index <tt/"end"/ (or abbreviated <tt/"e"/) designates the last of all
the provided objects.
An index may appear multiple times, leading to multiple copies of the
selected object to be delivered upstream.
The index space spans over all provided objects of the desired type
from all child objects. This means one can mix provided objects from
multiple child objects of the Select object. Syntactically incorrect
ranges and indices are silently ignored.
<p>
Examples:
 <itemize>
  <item><tt/"0,2"/ - delivers the first and third provided objects upstream;
  <item><tt/"end-0"/ - delivers all provided objects in reversed order
upstream;
  <item><tt/"0,0,0"/ - delivers three copies of the first provided object
upstream;
  <item><tt/"0,4-end,1"/ - delivers the first, the fifth (if there are so many)
up to the last, and the second object upstream.
 </itemize>
</itemize>


<sect1>Trim Object<label id="trimobj">
<p>
The Trim object, available since Ayam 1.16, may be used in hierarchies
of tool objects to trim NURBS patch providing objects otherwise
unavailable to trimming like e.g. a Revolve object.
The first child of the Trim object is the NURBS patch providing object
and the second object is the trim curve (defined in the parametric
space of the NURBS surface). More curves and loops may follow.
All curves must obey the rules for trimming as outlined in section
<ref id="trim" name="Trim Curves">).
The surface may already be trimmed and there may be multiple provided
patches, however only one of them will be trimmed by the Trim object.
<p>
The object hierarchy of a Trim object, thus, looks like this:
<code>
+-Trim
 | Surface(Revolve)
 | Trim_1(NCurve)
 +-[Trim_2(Level)
 | | NCurve
 | \ NCurve
 | ...
 \ Trim_n(ICurve)]
</code>
<p>
The following table briefly lists some capabilities of the Trim object.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
Trim|NPatch/NCurve+/Level+|Yes|NPatch|No@<hline>
</tabular>
<caption>Trim Object Capabilities</caption>
</table>
<p>
The following parameters further control the trimming process:

<sect2>TrimAttrib Property<label id="trimp"><label id="trimattribprop">
<p>
<itemize>
<item><tt/"PatchNum"/ allows to select a patch, should the NURBS
patch providing object deliver a list. This way, a bevel of an
extrusion might be trimmed.
</itemize>

<sect1>Custom Objects<label id="customobj">
<p>
Custom objects are plugins that extend the Ayam capabilities by
defining totally new types of e.g. geometric objects. This may
be done easily, because the Ayam core is written in a modelling
paradigm independent way.
<p>
A simple example of a custom object is the CSphere, which implements
a simple sphere and has a new property named <tt/"CSphereAttr"/.
This property contains all parameters of a simple RenderMan Interface
quadric sphere. A more complex example would be the MetaObj custom
object. It is possible, but not planned for now, to integrate
the T-Spline modelling paradigm into Ayam this way.
<p>
Since a custom object has total control over properties and representations,
you should refer to the documentation of the respective custom object for
more information regarding its properties.
<p>
One custom object is already distributed with Ayam. This Metaball
custom object is documented in the next section:

<sect1>Metaball Object<label id="metaobjobj"><label id="metacompobj">
<p>
<figure loc="ht">
<eps file="pics/meta.ps" height="5cm">
<img src="pics/meta.gif">
<caption>A Metaball Object from Six Meta Components</caption>
</figure>
<p>
A metaball object is a custom object (see also section
<ref id="customobj" name="Custom Object">).
It allows you to model with implicit surfaces in realtime.
<p>
To start modelling you should first create a <tt>"MetaObj"</tt> object
using the menu entry
<tt>"Create/Custom Object/MetaObj"</tt> (if this menu entry is not
available, you have to load the <tt>"metaobj"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<tt>"Create/Custom Object/MetaObj"</tt> creates a so called meta world with a
single meta component (a sphere) in it. The meta world is represented
by a <tt>"MetaObj"</tt> object and the component by a <tt>"MetaComp"</tt>
object which is a child of the <tt>"MetaObj"</tt> object.
<p>
The complete template for the MetaObj object hierarchy, consequently,
looks like this:
<code>
+-MetaWorld(MetaObj)
 | C1(MetaComp)
 | [...
 \ Cn(MetaComp)]
</code>
<p>
The following table briefly lists some capabilities of the MetaObj and
MetaComp objects.
<table loc="ht">
<tabular ca="|c|c|c|c|c|"><hline>
<bf/Type/|<bf/Parent of/|<bf/Material/|<bf>Converts to&thinsp;/&thinsp;Provides</bf>|<bf/Point Edit/@<hline>
MetaObj|MetaComp+|Yes|PolyMesh|No@<hline>
MetaComp|No|No|N/A|No@<hline>
</tabular>
<caption>MetaObj/MetaComp Object Capabilities</caption>
</table>
<p>
Meta components live only in a meta world, therefore it makes no sense
to create <tt>"MetaComp"</tt> objects in other places except as a
child of a <tt>"MetaObj"</tt> object. Type, parameters, and
transformation attributes of the meta components define the function
of an implicit surface. The <tt>"MetaObj"</tt> object, that represents
the meta world, evaluates this function on a regular three-dimensional
grid and creates a polygonal representation for a specific function
value (the so called threshold value).
<p>
This process may be further parameterised using the <tt/"MetaObjAttr"/
property:

<sect2>MetaObjAttr Property<label id="moattr"><label id="metaobjattrprop">
<p>
<itemize>
<item>With the parameter <tt/"NumSamples"/ you specify the resolution of the
three-dimensional regular grid, on which the implicit function is
evaluated, in each dimension.
A higher number of samples results in better quality but more polygons
are created and more CPU power and memory are needed. For modelling
you should set this to a lower value of about 40. For final rendering
you may increase this to about 160.

<item><tt/"IsoLevel"/, defines the threshold value for that a polygonal
representation of the implicit function should be created. Normally, you
should not need to change this value.

<item>To show the actual bounds of the meta world, you may enable
the <tt>"ShowWorld"</tt> parameter.
</itemize>

New in Ayam 1.5 is an adaptive calculation mode of the implicit
surface. It may be switched on using the new attribute
<tt>"Adaptive"</tt>. In the adaptive calculation mode, Ayam tries
to vary the resolution of the resulting polygonal mesh according to
the features of the implicit surface in order
to capture fine details, even though a coarse grid is used.
This is not done using a successively refined grid but by a
refinement of the triangles created by the original algorithm
(see also XXXX).
You may control the adaptation process using three parameters:
<tt>"Flatness"</tt>, <tt>"Epsilon"</tt>, and <tt>"StepSize"</tt>.
If <tt>"Adaptive"</tt> is set to <tt>"automatic"</tt>, Ayam will
not use the adaptive calculation while a modelling action is in
progress. This mode has been introduced, because the adaptive mode
may consume a considerable amount of CPU resources.
<p>
While modelling with meta balls you may add other <tt/"MetaComp"/ objects
to the <tt/"MetaObj"/ object and parameterise them.
A <tt/"MetaComp"/ object has the following properties.

<sect2>MetaCompAttr Property<label id="mcattr"><label id="metacompattrprop">
<p>
<itemize>
<item><tt/"Formula"/ specifies the type of the meta component.
The following types are available: Metaball, Torus, Cube, Heart, and
Custom. The latter gives you the possibility to use your own formulas.

<item>With the parameter <tt/"Negative"/ you define a component with a
negative effect on the implicit function value.
Negative components are not visible on their own but they are useful
for modelling holes. Just try it.
</itemize>

The other parameter are specific to the type of the component:

<sect2>Metaball<label id="mbcp">
<p>
<itemize>
<item><tt/"Radius"/ sets the radius of the metaball
<item><tt/"EnergyCoeffA"/, <tt/"EnergyCoeffB"/, and <tt/"EnergyCoeffC"/
are some parameters for the metaball formula.
Usually you can leave those parameters at their default values.
If you change them, be careful.
</itemize>

<sect2>Torus<label id="mtcp">
<p>
<itemize>
<item><tt/"Ri"/ the inner radius of the torus
<item><tt/"Ro"/ the outer radius if the torus
<item><tt/"Rotate"/ rotates the torus about 90 degree
</itemize>

<sect2>Cube<label id="mucp">
<p>
<itemize>
<item><tt/"EdgeX"/, <tt/"EdgeY"/, and <tt/"EdgeZ"/, let you define the
sharpness of the edges of the cube
</itemize>

<sect2>Custom<label id="cucp">
<p>
<itemize>
<item><tt/"Expression"/ is a piece of Tcl script, that represents your
own custom formula for a meta component. The expression may call any
Tcl commands to calculate a field value from the current grid position,
which is given in the global variables <tt>"x"</tt>, <tt>"y"</tt>, and
<tt>"z"</tt>.
The expression has to return the field value in the global variable
<tt>"f"</tt>.
Here is an example for a custom expression:
<code>
set f [expr {pow($x,4)+pow($y,4)+pow($z,4)}]
</code>
Note that those expressions are called many times
and since they are programmed in Tcl, this can be quite slow.
You should use any tricks (like the curly braces
in the expr-statement above) to speed up the expression.
</itemize>

<sect1>Standard Properties<label id="stdprop">
<p>
Most Ayam objects have standard properties. They are used
to control transformations and common attributes of objects.
The following sections describe the standard properties
<tt/"Transformations"/, <tt/"Attributes"/, <tt/"Material"/, <tt/"Shaders"/,
and <tt/"Tags"/.

<sect2>Transformations Property<label id="trap"><label id="transformationsprop">
<p>
Use the <tt/"Transformations"/ property to edit the location, orientation,
and size of an object.
<p>
The corresponding property GUI contains the following elements:
<itemize>
<item><tt/"Reset All!"/ immediately resets all transformation
attributes to the default values.

<item><tt/"Translation_X (_Y, _Z)"/ is the displacement of the
object from the world origin in X (Y, Z) direction.

<item><tt/"Rotation_X (_Y, _Z)"/ is the angle (in degrees)
of the rotation of the object around the X (Y, Z) axis.
Read the next section for more information on how to use these
entries. Read it!

<item><tt/"Scale_X (_Y, _Z)"/ determines a scale factor that will be
applied to the object in the direction of the local X (Y, Z) axis.

<item><tt/"Quat0 (1, 2, 3)"/ the quaternion that is used to determine
the orientation of the object in space. This quaternion is not here
to be edited directly! The sole purpose of its appearance here
is to allow copying and pasting of rotations.
</itemize>

The transformations are applied to the object in the following order:
Scale, Rotation, Translation.
<p>
How to use the rotation attributes?<label id="gimb">
<p>
The orientation of an object in space may be expressed using
so called Euler angles. This notation (simply three angles
determining a rotation about the axes of the coordinate system)
suffers from a phenomenon called gimbal lock.
<p>
To avoid gimbal locks, Ayam internally holds the orientation
of an object in a quaternion.
This quaternion not only holds information about the angles
but also about the order in which partial rotations occured.
<p>
It is important to know, that the values of the angles of
the rotation property must not be read in a way that
the object will first be rotated around X by x-angle degrees
then around Y y-angle degrees then around Z z-angle degrees.
In fact, no information about the order in which partial
rotations occured may be derived from that three values.
This implies, that e.g. the values 0 0 45 may denote
a different orientation than the very same values
0 0 45 (no joke)!
<p>
But how do you get the three entries to do what you want?
You either want to rotate the object around an axis by a given
amount or you want to undo a rotation or undo all rotations.
<p>
Rotating an object is easy, simply add the amount about
which you want to rotate the object to the value currently
displayed in the appropriate entry. If you want to rotate
about 45 degrees about X and the x-angle entry displays a 30,
enter 75.
Then press the apply button.
If you change multiple entries the rotations made will be
in the order X (if changed) then Y (if changed) then Z (if changed).
Do not change more than one entry at once until you exactly
know what you are doing.
<p>
Undoing a single rotation works in the same way, just use a subtraction
instead of an addition.
<p>
Undoing all rotations (resetting the object to its original state)
is simple too: enter 0 for all three entries at once,
then press apply.
<p>
If you want to copy the orientation of an object to other objects
using the property clipboard, make sure that you select all Rotation and
Quat property elements.

<sect2>Attributes Property<label id="attrs"><label id="attributesprop">
<p>
The <tt/"Attributes"/ property of an object contains currently:
<itemize>
<item><tt/"Objectname"/, the name of the object. It is also displayed
in the object listbox or tree and may be written to RIB streams.

<item><tt/"Hide"/, if this attribute is set this object is not drawn.
It may also be excluded from RIB export.

<item><tt/"HideChildren"/, if this attribute is set, the child objects
of this object are not drawn. This attribute is e.g. used by
<tt/"NPatch"/ objects to prevent the trim curves from being drawn
in normal views.

<item><tt/"RefCount"/, just displays how many objects point to this
object e.g. through master-instance or object-material relationships.
Objects with a reference count higher than zero may not be deleted.
</itemize>

<sect2>Material Property<label id="matprop"><label id="materialprop">
<p>
The <tt/"Material"/ property allows you to connect geometric objects
to material objects (see also section
<ref id="materialobj" name="Material Object">).
The material property GUI consist of the following elements:
<itemize>
<item><tt/"Clear Material!"/ immediately clears any connection
of the current object to its material.

<item><tt>"Add/Edit Material!"</tt> adds a material to the
current object (if it has none) and immediately selects
the new material object for editing. If the current object
already has a material, this material object is searched for
and selected for editing.

<item><tt/"Materialname"/ is the name of the material of this object.
If you change the name, the object will be disconnected from the
old material and connected to the new material.
An easier way to connect geometric objects to material objects is to simply
drop the geometric objects onto the material object using Drag-and-Drop
in the tree view.
</itemize>

<sect2>Shader Properties<label id="shd"><label id="atmosphereprop">
<label id="imagerprop"><label id="surfaceprop"><label id="displacementprop">
<label id="interiorprop"><label id="exteriorprop"><label id="lightshaderprop">
<p>
Shader properties are used to attach shaders of a certain type to objects.
The name of the property contains the type of the shader, e.g.
light shaders may be attached using a property named <tt/"LightShader"/ only.
Other types of shaders or shader properties available are: <tt/"Surface"/,
<tt/"Displacement"/, <tt/"Interior"/, <tt/"Exterior"/, <tt/"Atmosphere"/,
and <tt/"Imager"/.
<p>
Each shader property GUI, even if no shader is attached to an object,
starts with the <tt/"Set new shader."/-button. This button allows
to select a new shader of the appropriate type.
If you press the <tt/"Set new shader."/-button, a dialog with a
list of shaders pops up. If this list is empty, Ayam
is probably not set up properly (or you simply do not have
shaders of the appropriate type). Check the preference setting
<tt>"Main/Shaders"</tt>.
After a new shader has been set, the arguments of the shader will be
parsed and a GUI will be generated to allow the arguments of the shader
to be filled with values.
<p>
The <tt/"Delete shader."/-button may be used to
delete the current shader from the selected object.
<p>
The <tt/"Default Values."/-button resets all arguments
of the shader to the default values.
See also section <ref id="workshd" name="Working with Shaders"> below.
<p>
All other elements of the shader property GUI depend on the currently
attached shader.
<p>
<bf>Shader Parsing</bf><label id="parseshd">
<p>
If no plugin is loaded, the official Ayam binaries use libslcargs
(from BMRT) to parse shaders that have been compiled with slc (the
shader compiler from BMRT). Parsing incorporates detecting the
type of the shader and detecting the names, types, and default values of
all shader arguments.
<p>
Note that currently, Ayam only works properly with shaders
that have at most two dots in their file name and that Ayam will simply
skip all array arguments (and emit a warning message) while parsing
a shader. Those array arguments consequently never appear in the
shader property GUIs and RIBs exported by Ayam. Also note that
default values for shader arguments of type color will be silently
clamped to the range 0-255.
<p>
Many shaders use array arguments to define transformation matrices.
If this is the case and you have access to the shader source code
you may want to modify those shaders to enable working with the
transformation matrix carrying shader arguments. To do this, just
change all definitions of transformation matrix carrying floating
point arrays to real matrices. If the shader contains a
<p>
<tt>"float a_matrix_parameter[16]"</tt>
<p>
change this to
<p>
<tt>"matrix a_matrix_parameter"</tt>.
<p>
Note that these changes of the shader argument definitions probably
also require changes of the shader source code that uses those arguments.
Ayam is able to deal with matrices because of their fixed size of 16
float values, and because libslcargs is able to deliver the default
values for a matrix (but not for an array!).
<p>
If Ayam has been compiled without a shader parsing library
(e.g. without libslcargs), Ayam will parse XML files created
by <tt/"sl2xml"/ from the K-3D project
(see <tt>"http://www.k-3d.org/"</tt>)
instead of compiled shaders.
The <tt/"Set new shader."/-button will in this case always
open a file requester, allowing you to select a XML file,
that has been created by sl2xml.
Furthermore, the <tt/"Default Values."/-button will not be available;
you have to use <tt/"Set new shader."/ instead.
<p>
From version 1.3 on, Ayam also supports shader parsing plugins to allow
parsing of shaders compiled with different shader compilers, see also
section <ref id="spplugins" name="Shader Parsing Plugins">.
<p>
<bf>Working with Shaders</bf><label id="workshd">
<p>
The <tt/"Default Values."/-button resets all arguments of the shader
to the default values.
Additionally, the compiled shader will be parsed again and the property GUI
will be adapted (new shader arguments will appear, removed shader arguments
will disappear).
Therefore, this button is quite handy if you have to deal with
changing shaders: just edit the shader, recompile it, then back
in Ayam just hit the <tt/"Default Values."/-button. Note that
this destroys your possibly carefully adjusted shader argument values.
<p>
If you want to keep the old shader argument values when a shader
changes, simply copy the shader property using the property clipboard
(main menu: <tt>"Edit/Copy Property"</tt>) before
you load the new default values and paste the property
back using <tt>"Edit/Paste Property"</tt> after loading of the
new default values.
Beware! This works properly only, if you do not change the type of
existing shader arguments and if no shader arguments are removed in
the new version of the shader!
<p>
You can also just copy certain parameter values (shader arguments
whose types do not change) by selecting them using double-clicks
on the parameter names in the shader property GUI and then use e.g.
<tt>"Edit/Copy Marked Prop"</tt>
(see also the description of the property clipboard in section
<ref id="propgui" name="Properties">).

<sect2>Tags Property<label id="tagsprop">
<p>
Use the <tt/"Tags"/ property to edit the tags of an object.
<p>
Tags provide an easy way to attach arbitrary information (e.g. additional
RenderMan interface attributes, special attributes for plugins or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.
<p>
The tags property GUI consists of the following standard
elements:
<itemize>
<item><tt/"Remove all Tags!"/ immediately removes all tags
from the object.

<item><tt/"Remove Tag!"/ is a menu, that allows you
to select and remove a single tag from the object.

<item><tt/"Add Tag!"/ opens a small dialog box, where you
may enter a new tag type and value. Once you press the <tt/"Ok"/
button, a new entry will be added to the tags property, displaying
the new tag. Just click on the entry to get back to the dialog,
to remove the tag using <tt/"Clear"/ then <tt/"Ok"/, or to change
the type or value of the tag.
</itemize>
<p>
The next sub-sections describe the tag types currently available in Ayam
and the plugins distributed with Ayam.
Note that extensions and plugins may define their own types.

<sect1>Tags<label id="tags">
<p>
Tags provide an easy way to attach arbitrary information (e.g. additional
RenderMan interface attributes, special attributes for plugins or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.
<p>
This section documents all currently known tag types.

<sect2>RiAttribute Tag<label id="riatag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiAttribute"/ can be used to attach
arbitrary RenderMan interface attributes to objects.
This is handy if you use a renderer with lots of RiAttributes
that differ from the standard RiAttributes.
<p>
<tt/"RiAttribute"/ tags attached to a geometric object override
<tt/"RiAttribute"/ tags possibly attached to the material object of this
geometric object.
<p>
In order to create a tag of type RiAttribute, the type string must be
<tt/"RiAttribute"/. The syntax of the value string is as following:
<p>
<tt/&lt;attrname&gt;,&lt;paramname&gt;,&lt;paramtype&gt;,&lt;param&gt;/
<p>
where attrname is the name of the attribute (e.g. "render") paramname
is the name of the parameter (e.g. "displacementbound") paramtype is a
single character defining the type of the parameter (it may be one of
<tt/f/ - float, <tt/g/ - float pair, <tt/i/ - integer, <tt/j/ - integer
pair, <tt/s/ - string, <tt/c/ - color, <tt/p/ - point) and finally
param is the value of the parameter itself (e.g. a float: "1.2", an
integer value: "3", a string: "on", a color: "1,1,1" or a point:
"0.4,0.5,1.0").
<p>
<bf/Example/
<p>
Some examples for valid RiAttribute tags:
<code>
RiAttribute render,truedisplacement,i,1
RiAttribute dice,numprobes,j,3,3
RiAttribute radiosity,specularcolor,c,0.5,0.5,0.5
</code>
<p>
<bf/Notes/
<p>
The <tt/"RiAttribute"/ tag handles just a single parameter at once.
Also note that <tt/"RiAttribute"/ tags may be created much more easily
using the menu entry <tt>"Special/Tags/Add RiAttribute"</tt>.
The database of RiAttributes for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>RiOption Tag<label id="riotag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiOption"/ can be used to attach arbitrary RenderMan
interface options to objects. This is handy if you use a renderer with
lots of RiOptions that differ from the standard RiOptions.
However, they will be only used by the RIB exporter if they are attached
to the <tt/"Root"/ object!
The syntax is similar to the <tt/"RiAttribute"/ tag type, see above.
<p>
<bf/Notes/
<p>
RiOption tags may be created easily using the menu entry
<tt>"Special/Tags/Add RiOption"</tt>.
Tags created with this GUI will always be added to the <tt/"Root"/ object.
It does not have to be selected when the GUI is used.
Furthermore, the database of RiOptions for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>TC (Texture Coordinates) Tag<label id="tctag">
<p>
<bf/Description/
<p>
The tag type <tt/"TC"/ can be used to attach texture coordinates to
objects or materials.
<p>
The <tt/"TC"/ tag always contains a list of eight comma separated
float values, that specify a mapping for four 2D points (a quadrilateral)
in texture space from the default values (0,0), (1,0), (0,1), and (1,1)
to the new specified values.
<p>
<bf/Example/
<p>
<code>TC 0,0,10,0,0,10,10,10</code>
Changes the texture coordinate space so that more and smaller tiles
of a texture would be displayed on a primitive.

<code>TC 0,0,0,1,1,0,1,1</code>
Flips the texture coordinate space over two corners.
A shader normally generating vertical stripes will create
horizontal stripes now.

<code>TC 0,1,0,0,1,1,1,0</code>
Turns the texture coordinate space by 90 degrees.
A shader normally generating vertical stripes will create
horizontal stripes now.
<p>
<bf/Notes/
<p>
<tt/"TC"/ tags attached to a geometric object override
<tt/"TC"/ tags possibly attached to the material object of this
geometric object.
<p>
The exact behaviour of an object equipped with a <tt/"TC"/ tag
depends heavily on the shader and its use of the texture coordinates!
<p>
Note also that using <tt/"TC"/ tags you change the texture coordinates
of entire primitives only, if you want to change the texture coordinates
of sub-primitives (e.g. of single control points of a NURBS patch)
you would need to use a <tt/"PV"/ (Primitive Variable) tag instead.
<p>
To ease setting of <tt/"TC"/ tag values Ayam provides a special graphical
editor as outlined below.
<p>
The texture coordinate editor<label id="tce"> may be opened using the
main menu entry <tt>"Special/Tags/Edit TexCoords"</tt> and
lets you edit texture coordinate tags in an intuitive way.
<p>
For that, the current texture coordinates are displayed as a black
polygon in a canvas with regard to the original (default) values,
that are displayed in gray.
Small arrows point to positive s and t direction respectively.

<figure loc="ht">
<eps file="pics/tce.ps" height="6cm">
<img src="pics/tce.gif">
<caption>Texture Coordinate Editor</caption>
</figure>
<p>

The <tt/"RotateR"/ and <tt/"RotateL"/ buttons shift the coordinate
values between the four points. This results in a 90 degree
rotation of the texture space.
<p>
The <tt/"FlipS"/ and <tt/"FlipT"/ buttons flip the texture
coordinate values in s and t direction respectively. This is
useful, if you, for example, want to correct a texture mapping for
an image that appears upside down.
<p>
The next buttons allow to move (using <tt/"MoveS"/ and <tt/"MoveT"/)
and scale (using <tt/"ScaleS"/ and <tt/"ScaleT"/) the texture coordinates
by a specific amount that is given in the first entry field.
<p>
The <tt/"Load"/ and <tt/"Save"/ menu buttons allow you to:
<itemize>
<item>load the default texture coordinate values ((0,0), (1,0), (0,1), (1,1)),

<item>load texture coordinates from a selected BPatch object:
The xy coordinates of the four points of the selected BPatch
will be interpreted as st coordinates.
This allows for more complex transformations of the texture coordinates
e.g. rotations about an angle of 45 degrees. For that just create a
BPatch object, rotate it accordingly, then load the coordinates into
the texture coordinate editor.

<item>load TC tags from the selected object,

<item>save the texture coordinates to a BPatch object,

<item>save TC tags to a selected object. Note that it is not
possible to directly save the TC tag to multiple selected objects.
But you can use the property clipboard to copy the tag after saving
to a single object.
</itemize>
Note that the tag numbers in the menu entries count TC tags only.
<p>
The texture coordinate dialog is modeless, it may stay open
while you model. The <tt/"Dismiss"/ button closes the dialog.

<sect2>PV (Primitive Variable) Tag<label id="pvtag">
<p>
<bf/Description/
<p>
The tag type <tt/"PV"/ can be used to attach arbitrary data
to geometric primitives and even sub-primitives.
With the help of primitive variables you can e.g. attach your
own texture coordinates to a NURBS patch primitive or attach distinct
colors to the faces or even to single vertices of a polygonal mesh.
In the latter case, the data is properly interpolated by the RenderMan
renderer before it is handed over to the surface shader.
<p>
When rendering, all data defined in a <tt/"PV"/ tag is handed over
to the surface shader that is attached to the respective geometric primitive
using additional shader parameters.
For RIB export, proper <tt/"RiDeclare"/ statements will be created
automatically by Ayam.
<p>
However, Ayam does not check, whether your shaders actually use the data
from the <tt/"PV"/ tag!
<p>
The syntax of the value string of a PV tag is as following:
<p>
<tt/&lt;name&gt;,&lt;detail&gt;,&lt;type&gt;,&lt;ndata&gt;,&lt;data&gt;/
<p>
where
<tt/"&lt;name&gt;"/ is the name of the primitive variable;
<tt/"&lt;detail&gt;"/ or storage class should be one of
<tt/"uniform"/, <tt/"varying"/, <tt/"vertex"/, or <tt/"constant"/;
<tt/"&lt;type&gt;"/ is a single character describing the type of the
data (see also the documentation of the <tt/"RiAttribute"/ tag above);
<tt/"&lt;ndata&gt;"/ is an integer number describing how many data
elements will follow; and
<tt/"&lt;data&gt;"/ is a comma separated list
consisting of a <tt/"&lt;ndata&gt;"/ elements of type <tt/"&lt;type&gt;"/.
<p>
<bf/Example/
<p>
<code>PV mycolor,constant,c,1,0,1,0</code>
adds a single color value (0,1,0), which is the same all over the primitive,
the respective surface shader should have a parameter <tt/"color mycolor"/;
<code>PV mys,varying,f,4,0.1,0.2,0.3,0.4</code>
could be used to add a distinct float value to each corner point of a
four point NURBS patch (of order, width, and height 2),
the respective surface shader should have a parameter
<tt/"varying float mys"/;.
<p>
<bf/Notes/
<p>
Not all geometric objects currently honour PV tags
on RIB export. The geometric objects currently supporting PV tags
are: SDMesh, PolyMesh, PatchMesh, NPatch, and BPatch.
<p>
Furthermore, the number of data elements, which depends on the
detail or storage class, the type of geometric primitive, and the
configuration of the geometric primitive is <em>not</em> checked by Ayam.
Some RIB writing libraries, however, check the number and silently
omit the primitive variable if there are mismatches. Check your
RIB for the presence of the primitive variable after export,
especially, if you are adding or editing PV tags manually!

<sect2>RiHider Tag<label id="rihtag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiHider"/ can be used to choose and parameterise
different algorithms for hidden surface removal when rendering
the exported scene with a RenderMan compliant renderer.
RiHider tags have to be attached to the root object in order to be used.
The syntax of a RiHider tag is quite similar to a RiAttribute tag:
<tt/"&lt;type&gt;,&lt;parameterlist&gt;"/
where <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
<p>
<bf/Example/
<p>
A RiHider tag could look like this:
<p>
<code>RiHider hidden,depthfilter,s,midpoint</code>

<sect2>RiDisplay Tag<label id="ridtag">
<p>
<bf/Description/
<p>
The tag type <tt/"RiDisplay"/ can be used to add output files of
different type (e.g. containing depth-buffer information)
to the scene or to directly control the output format when rendering
the exported scene with a RenderMan compliant renderer.
RiDisplay tags have to be attached to the root object in order to be used.
The syntax of a RiDisplay tag is as follows:
<tt/"&lt;name&gt;,&lt;type&gt;,&lt;mode&gt;,&lt;parameterlist&gt;"/,
where name is e.g. a file or device name, type specifies the
destination of the image data (e.g. screen or file), mode
specifies which information should be stored or displayed
(e.g. color values: rgb, or depth values: z),
and <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
<p>
<bf/Example/
<p>
A RiDisplay tag to add output of the depth-buffer information to the
file <tt/"imagez.tif"/ could look like this:
<code>RiDisplay imagez.tif,file,z</code>
<p>
<bf/Notes/
<p>
The name will be automatically changed to <tt/"+name"/ on RIB export
if it does not already start with a plus.

<sect2>NoExport Tag<label id="noexporttag">
<p>
<bf/Description/
<p>
The tag type <tt/"NoExport"/ can be used to exclude certain objects
from exported RIBs. The value string of this tag is ignored. All
that counts is the presence of the tag. Child objects of objects
with the <tt/"NoExport"/ tag will also be excluded from the RIB.
Since Ayam 1.6, light objects also honour the <tt/"NoExport"/ tag.
Note that regardless of potentially present <tt/"NoExport"/ tags,
RIB archives will be created for all referenced objects all the
time (even if <tt/"NoExport"/ tags are added to all instances).

<sect2>SaveMainGeom Tag<label id="savemaingeomtag">
<p>
<bf/Description/
<p>
The tag type <tt/"SaveMainGeom"/ can be used to save the geometry
of the main window and the toolbox window (if open) to a scene
file. For that the scene saving code checks for the presence of
a <tt/"SaveMainGeom"/ tag for the root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <tt/"SaveMainGeom"/ tag for the root object
after replacing a scene and re-establishes the geometries of
main and toolbox window.

<sect2>SavePaneLayout Tag<label id="savepanelayouttag">
<p>
<bf/Description/
<p>
The tag type <tt/"SavePaneLayout"/ can be used to save the relative
sizes of the internal windows of the main window when Ayam runs in
the single window GUI mode to a scene file.
For that the scene saving code checks for the presence of
a <tt/"SavePaneLayout"/ tag for the root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <tt/"SavePaneLayout"/ tag for the root object
after replacing a scene and re-establishes the geometries of the
internal windows.

<sect2>TP (Tesselation Parameter) Tag<label id="tptag">
<p>
<bf/Description/
<p>
The tag type <tt/"TP"/ can be used to save tesselation parameters
to objects of type <tt/"NPatch"/ (and objects that may be converted
to <tt/"NPatch"/ objects). Those tesselation parameters
will be used when the NPatch object is tesselated for e.g. a
conversion to a PolyMesh object. The syntax of the TP tag is:
<tt>"&lt;tmethod&gt;,&lt;tparamu&gt;,&lt;tparamv&gt;"</tt>
where <tt/"&lt;tmethod&gt;"/ is an integer value between 1 and 3, describing
which tesselation method to use (1 - ParametricError,
2 - PathLength, and 3 - DomainDistance) and <tt/"&lt;tparamu&gt;"/ and
<tt/"&lt;tparamv&gt;"/ are float values describing the respective parameter
value for the chosen tesselation method. The second parameter value
is ignored for the tesselation methods 1 and 2.
<p>
Note that the syntax of the <tt/"TP"/ tag changed in Ayam 1.9,
the old syntax only allowed one parameter.
<p>
TP tags may be easily created using the tesselation GUI, that can
be started with the main menu entry <tt>"Tools/NURBPatch/Tesselate"</tt>
(see also section <ref id="tesst" name="The Tesselation Tool">).
<p>
<bf/Example/
<p>
A TP tag could look like this:
<code>TP 1,0.5,0.6</code>

<sect2>DC (Depth Complexity) Tag<label id="dctag">
<p>
<bf/Description/
<p>
The tag type <tt/"DC"/ is only used by the AyCSG CSG preview plugin
to store the depth complexity of CSG primitives.
The syntax of the DC tag is:
<tt>"&lt;dcval&gt;"</tt>
where <tt/"&lt;dcval&gt;"/ is a positive integer value describing the
depth complexity of the CSG primitive. See also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">
for more information regarding the depth complexity value.
<p>
<bf/Example/
<p>
A DC tag (valid for e.g. a torus) could look like this:
<code>DC 2</code>

<sect2>NP (New Property) Tag<label id="nptag">
<p>
<bf/Description/
<p>
The tag type <tt/"NP"/ (new property) may be used to add new property
GUIs to single objects. The value of the tag is the name of a new
property. The necessary code to manage the property data and the
windows that make up the property GUI itself have to be present in
the Tcl context of Ayam before the user clicks on the new property in the
property list box.
<p>
<bf/Example/
<p>
<code>NP Transformations</code>

<sect2>RP (Remove Property) Tag<label id="rptag">
<p>
<bf/Description/
<p>
The tag type <tt/"RP"/ (remove property) may be used to remove GUI access
to a property from single objects. The value of the tag is the name of the
property to be removed. The GUI access will be blocked by simply omitting
the property from the property listbox.
Note well: the property is still present and active in the objects themselves
and values may still be set using the scripting interface.
<p>
<bf/Example/
<p>
<code>RP Script</code>
removes direct access to the Script property of a Script object.
Ideally, the Script object also has a <tt/"NP"/ tag, to allow
direct control of script parameters. This way, the user does not
see the script (code), just a clean parameter GUI.

<sect2>BNS (Before Notify Script) Tag<label id="bnstag">
<p>
<bf/Description/
<p>
The tag type <tt/"BNS"/ (before notify script) may be used to add scripts
to an object, that will be run <em/before/ the notification callback of
that object completed.
The notification, in turn, will be executed because e.g. one of the children
of the object changed.
<p>
<bf/Example/
<p>
A simple BNS tag could look like this:
<code>BNS puts "notify callback about to fire"</code>
<p>
<bf/Notes/
<p>
In Ayam versions prior to 1.16 BNS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
BNS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<ref id="safeinterp" name="Safe Interpreter">.
Consequently, the warning dialog that appeared when files with
BNS tags were loaded is also gone.
<p>
You can still re-enable the old functionality by recompiling Ayam.
If you do so, for security reasons, if scene files containing BNS
tags are loaded, Ayam will again raise the warning offering to
temporarily disable all such tags that will be read.
To disable a BNS tag, Ayam simply changes its type from <tt/"BNS"/
to <tt/"DBNS"/ (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <tt/"BNS"/
or by using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>ANS (After Notify Script) Tag<label id="anstag">
<p>
<bf/Description/
<p>
The tag type <tt/"ANS"/ (after notify script) may be used to add scripts
to an object, that will be run <em/after/ the notification callback of
that object completed.
The notification, in turn, will be executed because e.g. one of the children
of the object changed.
<p>
<bf/Example/
<p>
A simple ANS tag could look like this:
<code>ANS puts "notify callback completed"</code>
<p>
<bf/Notes/
<p>
In Ayam versions prior to 1.16 ANS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
ANS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<ref id="safeinterp" name="Safe Interpreter">.
Consequently, the warning dialog that appeared when files with
ANS tags were loaded is also gone.
<p>
You can still re-enable the old functionality by recompiling Ayam.
If you do so, for security reasons, if scene files containing ANS
tags are loaded, Ayam will again raise the warning offering to
temporarily disable all such tags that will be read.
To disable a ANS tag, Ayam simply changes its type from <tt/"ANS"/
to <tt/"DANS"/ (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <tt/"ANS"/
or by using the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>UMM/VMM (U/V Min Max) Tag<label id="ummtag">
<p>
<bf/Description/
<p>
The tag types <tt/"UMM"/ (u min max) and <tt/"VMM"/ (v min max) may
be used to store additional parametric domain trimming values to
NURBS curve and NURBS patch objects. Note that the GLU NURBS display
modes do not honor those tags, but the RIB export does.
<p>
<bf/Example/
<p>
An UMM tag could look like this:
<code>UMM 0.4,0.6</code>

<sect2>BP (Bevel Parameters) Tag<label id="bptag">
<p>
<bf/Description/
<p>
The tag type <tt/"BP"/ (bevel parameters) is used by all bevel
supporting tool objects to store their bevel information.
The syntax of the BP tag is:
<tt>"&lt;side&gt;,&lt;type&gt;,&lt;radius&gt;,&lt;revert&gt;"</tt>
where <tt/"&lt;side&gt;"/ is an integer value from 0 - 3
defining the side of the surface, where the bevel should be applied
to, <tt/"&lt;type&gt;"/ is an integer value from 0 - 4 defining
the type of the bevel, <tt/"&lt;radius&gt;"/ is a floating point
value defining the radius of the bevel, and <tt/"&lt;revert&gt;"/
is either 0 or 1 and may be used to revert the bevel.
<p>
<bf/Example/
<p>
A BP tag could look like this:
<code>BP 0,0,0.1,0</code>

<sect2>Internal Tags
<p>
The following tags are of no general use. They are used
by Ayam internally only.
<itemize>
<item>OI (Object ID) Tag<label id="oitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between instance objects and
the original objects they are pointing to.
<p>
The tag type <tt/OI/ is not meant to be used by the end user.
Furthermore, changing the IDs manually avails to nothing as the
tags are rebuilt before every export/save operation.
<item>MI (Material ID) Tag<label id="mitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between material objects and
the objects they are assigned to.
<p>
The tag type <tt/MI/ is not meant to be used by the end user.
Furthermore, changing the IDs manually avails to nothing as the
tags are rebuilt before every export/save operation.
</itemize>

<sect2>List of Known Tags
<p>
This section contains a comprehensive list of tag names, that are
known since Ayam 1.10 and in all accompanying extensions (plugins).
<p>
<tt>"RiAttribute", "RiOption", "RiHider", "RiDisplay", "NoExport", "TC",
"PV", "SaveMainGeom", "SavePaneLayout", "TP", "MI", "OI", "DC", "TM", "NP",
"RP", "BNS", "DBNS", "ANS", "DANS",
"UMM", "VMM", "BP", "IDR", "IIDR", "RIDR", "R3IDR", "CIDR", "CCIDR"</tt>
<p>
The following tags are temporary (they will not be displayed in the
Tags property of an object, if the preference option <tt>"HideTmpTags"</tt>
is enabled):
<tt>"MI", "OI"</tt>
<p>
Documentation on all those tags can be found in the sections above.

<sect>NURBS Modelling Tools<label id="nmtool">
<p>
This section describes NURBS curve and surface related modelling
tools. All tools are accessible via the <tt/"Tools"/ menu of the
main window. In addition, there are also corresponding scripting
interface commands.

<sect1>The Closed BSpline Tool<label id="cbspt">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A Closed B-Spline</caption>
</figure>
<itemize>
<item>Arguments: Number of control points (i).
<item>Operation: This tool creates a closed cubic B-Spline curve with
i+3 control points in the XY plane. The control points are arranged
in a circle of radius 1 centered around the origin. This gives the curve
a circular appearance (see image above) but it is <em>not</em> a true circle:
If few control points are used, the radius of the circular curve
is clearly smaller than 1. Furthermore, shape, parameterisation, and
curvature of the closed B-Spline are not exactly as one would expect
from a circle.
However, you can use the NURBCircle tool (see below) to create a true
circle instead.
<item>Note: i must be atleast 3. The first three control points of the
new curve will be identical to the last three. Additionally, the curve
will be marked as periodic and the generation of multiple points will
be enabled, so that point edit actions know that they may need to move
two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

<sect1>The NURBCircle Tool<label id="ncirct">
<p>
<figure loc="ht">
<eps file="pics/ncircle.ps" height="5cm">
<img src="pics/ncircle.gif">
<caption>A NURBS Circle</caption>
</figure>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBCircle tool creates a full circular NURBS curve
of radius 1 in the XY plane located at the origin.
<item>Note: The NURBS curve created by the NURBCircle tool is rational
(uses weights). This means, editing the curve (e.g. moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished). Use a closed B-Spline
created with the Closed BSpline Tool (see above) if you want to edit
the curve further.
You can use this circle to easily create a NURBS-torus by moving
the circle along X and then revolving it. The amount of movement
determines the radius of the torus, whereas the radius of the circle
determines the thickness.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

<sect1>The NURBCircleArc Tool<label id="ncircat">
<p>
<itemize>
<item>Arguments: angle of the arc in degrees
<item>Operation: The NURBCircle tool creates a circular NURBS curve
arc of radius 1, with the specified angle, in the XY plane,
located at the origin.
<item>Note: The NURBS curve created by the NURBCircleArc tool is rational
(uses weights). This means, editing the curve (e.g. moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished).
</itemize>

<sect1>The TrimRect Tool<label id="trrt">
<p>
<itemize>
<item>Arguments: None
<item>Operation: The TrimRect tool creates a two-dimensional piecewise
linear NURBS curve of rectangular shape in the XY plane, that fits in
the (u,v) parameter space of a NURBS patch, for use as trim curve.
<item>Note: To fit the curve to the parameter space of a NURBS patch,
the NURBS patch object should be selected or the current level should be
inside the NURBS patch.
If no NURBS patch object is selected and the current level is not inside
a NURBS patch, a curve with the coordinates (-1,-1), (-1,1), (1,1),
and (1,-1) will be created instead.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
See section <ref id="trim" name="Trim Curves"> for a more detailed
discussion of trim curves and how to use the rectangular curve created
by the TrimRect tool.
</itemize>

<sect1>The NURBSphere Tool<label id="nspt">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a half circle NURBS curve
and revolves it about the Y axis thus forming a sphere of radius 1.
<item>Note: The NURBS curve is deleted afterwards.
</itemize>

<sect1>The NURBSphere2 Tool<label id="nsp2t">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a Cobb-NURBSphere,
consisting of six NURBS patches.
<item>Note: The NURBS patches are of high order (5).
</itemize>

<sect1>The Revolve Tool<label id="revt">
<p>
<itemize>
<item>Arguments: The revolve tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Revolve object, and moves
the selected objects to it.
<item>Note: See section <ref id="revolveobj" name="Revolve Object">
for more information regarding the revolve object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Extrude Tool<label id="extt">
<p>
<itemize>
<item>Arguments: The extrude tool takes the selected objects from
the selection.
<item>Operation: The tool creates an Extrude object, and moves
the selected objects to it.
<item>Note: See section <ref id="extrudeobj" name="Extrude Object">
for more information regarding the extrude object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Sweep Tool<label id="swpt">
<p>
<itemize>
<item>Arguments: The sweep tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Sweep object, and moves
the selected objects to it.
<item>Note: See section <ref id="sweepobj" name="Sweep Object">
for more information regarding the Sweep object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Cap Tool<label id="capt">
<p>
<itemize>
<item>Arguments: The cap tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Cap object, and moves
the selected objects to it.
<item>Note: See section <ref id="capobj" name="Cap Object">
for more information regarding the Cap object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Birail1 Tool<label id="bi1t">
<p>
<itemize>
<item>Arguments: The birail1 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail1 object, and moves
the selected objects to it.
<item>Note: See section <ref id="birail1obj" name="Birail1 Object">
for more information regarding the Birail1 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Birail2 Tool<label id="bi2t">
<p>
<itemize>
<item>Arguments: The birail2 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail2 object, and moves
the selected objects to it.
<item>Note: See section <ref id="birail2obj" name="Birail2 Object">
for more information regarding the Birail2 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Gordon Tool<label id="gort">
<p>
<itemize>
<item>Arguments: The gordon tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Gordon object, and moves
the selected objects to it.
<item>Note: See section <ref id="gordonobj" name="Gordon Object">
for more information regarding the Gordon object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Skin Tool<label id="skit">
<p>
<itemize>
<item>Arguments: The skin tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Skin object, and moves
the selected objects to it.
<item>Note: See section <ref id="skinobj" name="Skin Object">
for more information regarding the Skin object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Revert Tool<label id="revertt">
<p>
<itemize>
<item>Arguments: The revert tool takes all NURBS curves and
ICurves from the selection.
<item>Operation: The direction of the selected curves will be
reversed.
<item>Note: The direction of a curve is shown as
a small arrow at the end of the curve.
Eventually selected points will still be selected after this
operation.
See also the documentation of the corresponding
<ref id="screvert" name="scripting interface command">.
</itemize>

<sect1>The Concat Tool<label id="conct">
<p>
<itemize>
<item>Arguments: The concat tool takes two NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be concatenated
and a new third curve will be created.
<item>Note: If one of the curves has weights, the resulting curve
will have weights too. If the knot type of the first curve
is <tt/"Custom"/, it will be converted to <tt/"NURB"/, otherwise the
knot type of the new curve will be that of the first selected curve.
Due to those changes of the knot values, the resulting curve might
differ from the original curves.
See also section <ref id="concatncobj" name="ConcatNC Object">.
The original NURBS curves will not be deleted by this tool.
</itemize>

<sect1>The Split Tool<label id="splitt">
<p>
<figure loc="ht">
<eps file="pics/splitnc.ps" height="4cm">
<img src="pics/splitnc.gif">
<caption>Split Tool (left: original curve, right: resulting split curves for t=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The split curves tool takes a single NURBS curve from
the selection and additionally requests a parametric value.
<item>Operation: The selected NURBS curve will be split into two
new NURBS curves at the designated parametric value. The splitting process
involves application of knot insertion, so that both new curves will
get a custom knot vector.
<item>Note: The original selected NURBS curve will be changed and
form the first of the two new curves, so you may want to keep a copy
of it somewhere.
See also the documentation of the corresponding
<ref id="scsplitnc" name="scripting interface command">.
</itemize>

<sect1>The Trim Tool<label id="trimt">
<p>
<figure loc="ht">
<eps file="pics/trimnc.ps" height="4cm">
<img src="pics/trimnc.gif">
<caption>Trim Tool (left: original curve, right: resulting trimmed curve for umin=0.1, umax=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The trim curves tool takes all selected NURBS curves from
the selection and additionally requests two parametric values, umin and umax.
<item>Operation: The selected NURBS curves will be trimmed to the
designated parametric range (umin, umax).
<item>Note: The trimming process involves the application of knot insertion
so that the curves will get a custom knot vector.
See also the documentation of the corresponding
<ref id="sctrimnc" name="scripting interface command">.
</itemize>

<sect1>The Elevate Tool<label id="elevt">
<p>
<figure loc="ht">
<eps file="pics/elevate.ps" height="4cm">
<img src="pics/elevate.gif">
<caption>Successive Application of Elevate Tool (Order 3 (left), 4 (middle),
5 (right))</caption>
</figure>
<itemize>
<item>Arguments: The elevate tool takes a number of NURBS curves from
the selection and additionally requests an integer value.
<item>Operation: The order of the selected NURBS curves will be raised
by the specified integer value without changing the shape of the curve.
<item>Note: If the knot vector of the curve is not clamped, it
will be clamped automatically. The knot type of the curve will
be changed to custom. New control points will be added and the position
of old control points may be changed in the progress.
See also the documentation of the corresponding
<ref id="scelevatenc" name="scripting interface command">.
</itemize>

<sect1>The Refine Tool<label id="refit">
<p>
<figure loc="ht">
<eps file="pics/refine.ps" height="4cm">
<img src="pics/refine.gif">
<caption>Successive Application of Refine Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
refined by inserting a knot in the middle of each inner knot interval
without changing the shape of the curve.
<item>Note: Because a new knot is inserted in the middle of
each interval, knot vectors of type NURB and B-Spline will
not change in type. See the image above for an example of a
successive refinement of a simple NURBS curve. Note that the shape
of the curve does not change, but the position of
certain control points does.
If you want to refine a curve with new control points and not
change the position of existing control points, use the NCAttribute
property GUI instead (simply increase the length of the curve
by oldlength-1).
Also note that for periodic curves the refine tool just inserts
control points into all control point intervals except for the
first (last) p intervals (where p is the degree of the curve).
The shape of the curve will be changed in this case.
See also the documentation of the corresponding
<ref id="screfinenc" name="scripting interface command">.
</itemize>

<sect1>The Coarsen Tool<label id="coart">
<p>
<figure loc="ht">
<eps file="pics/coarsen.ps" height="4cm">
<img src="pics/coarsen.gif">
<caption>Successive Application of Coarsen Tool</caption>
</figure>
<itemize>
<item>Arguments: The coarsen tool takes a number of NURBS curves from
the selection.
<item>Operation: Every second control point in the control vectors of
the selected NURBS curves will be deleted.
<item>Note: For periodic curves the coarsen tool will not remove
control points from the first (last) p intervals (where p is the degree
of the curve).
For closed curves, the coarsen tool will not remove the last point.
The coarsen tool will also remove knot values from curves with
custom knot vectors.
See also the documentation of the corresponding
<ref id="sccoarsennc" name="scripting interface command">.
</itemize>

<sect1>The Clamp Tool<label id="clat">
<p>
<figure loc="ht">
<eps file="pics/clampnc.ps" height="4cm">
<img src="pics/clampnc.gif">
<caption>Clamp Tool (left: original curve, right: clamped curve)</caption>
</figure>
<itemize>
<item>Arguments: The clamp tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
changed using knot insertion so that the first and the last knot
have a multiplicity equal to the order of the curve,
without changing the shape of the curve. The curve will
interpolate the first and the last control point afterwards.
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
<ref id="scclampnc" name="scripting interface command">.
</itemize>

<sect1>The Insert Knot Tool<label id="insknt">
<p>
<figure loc="ht">
<eps file="pics/inskn.ps" height="4cm">
<img src="pics/inskn.gif">
<caption>Left: original curve, Right: a knot has been inserted 1 time at t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS curves from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected curves, without changing the
shape of the curve(s).
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
<ref id="scinsknnc" name="scripting interface command">.
</itemize>

<sect1>The Remove Knot Tool<label id="remknt">
<p>
<figure loc="ht">
<eps file="pics/remkn.ps" height="4cm">
<img src="pics/remkn.gif">
<caption>Remove Knot Tool (left: original curve, right: the knot at t=0.5 has been removed 1 time)</caption>
</figure>
<itemize>
<item>Arguments: The remove knot tool takes a number of NURBS curves from
the selection and requests three additional values, a parametric value t,
an integer value i, and a tolerance tol.
<item>Operation: The specified knot (t) will be removed i
times from the knot vector of the selected curves if the shape of the
resulting curve does not deviate more than tol from the original curve
in any point.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original curve is left unchanged.
<item>Note: If tol is <tt/"Inf"/ (infinity) the tool tries to work without
changing the shape of the curves, however, this is not guaranteed.
The point selection will be removed from the original objects.
See also the documentation of the corresponding
<ref id="scremknnc" name="scripting interface command">.
</itemize>

<sect1>The Plot Curvature Tool<label id="plotcurt">
<p>
<figure loc="ht">
<eps file="pics/plotcur.ps" height="4cm">
<img src="pics/plotcur.gif">
<caption>Curvature Plot (top) of simple NURBS curve (bottom)</caption>
</figure>
<itemize>
<item>Arguments: The plot curvature tool takes a number of NURBS curves from
the selection and requests three additional values: the number of data
points, the width value and the height value.
<item>Operation: A new NURBS curve, depicting the curvature of the selected
NURBS curve, will be created for each of the selected
NURBS curves. The curvature plots will have a length defined by the
number of data points and will be scaled to the specified width
and by the specified height value. See also the image above.
</itemize>

<sect1>The Shift Closed B-Spline Tool<label id="shiftclbspt">
<p>
<figure loc="ht">
<eps file="pics/shiftclsbsp.ps" height="4cm">
<img src="pics/shiftclsbsp.gif">
<caption>Shift Closed B-Spline Tool (left: Closed B-Spline Curve, right: Shifted Curve)</caption>
</figure>
<itemize>
<item>Arguments: The shift closed B-Spline tool takes a number of
NURBS curves, that should be closed B-Splines, from the selection and
requests one additional integer parameter.
<item>Operation: The control points of the curve(s) will be shifted, so that
the second control point will be the first after this operation.
The shifting process will be repeated according to the integer parameter i
given.
<item>Note: Eventually selected points will still be selected after this
operation. See also the image above.
</itemize>

<sect1>The To XY Tool<label id="toxyt">
<p>
<figure loc="ht">
<eps file="pics/toxy.ps" height="5cm">
<img src="pics/toxy.gif">
<caption>To XY Tool (left: original curve, right: modified curve)</caption>
</figure>
<itemize>
<item>Arguments: The To XY tool takes a number of
NURBS curves from the selection. The NURBS curves should be planar.
<item>Operation: The control points of the curve(s) will be rotated,
so that they are in the XY plane of the respective object space defined by
the NURBS curve object(s). Additionally, the rotation attributes of
the NURBS curve object(s) will be changed so that the curve does not
change its orientation with regard to other objects or the world space.
See also the image above, where the left curve, planar but not defined
in the XY plane will be changed, so that it is defined in the XY plane
(mind the two different object coordinate systems in conjunction with
the world coordinate system in the middle).
<item>Note: A reverse operation, apart from undo, would be to apply the
current transformation attributes to the control points of the curves.
</itemize>

<sect1>The Make Compatible Tool<label id="makecompt">
<p>
<figure loc="ht">
<eps file="pics/makecomp.ps" height="4cm">
<img src="pics/makecomp.gif">
<caption>Make Compatible Tool (left: Original Curves, right: Compatible Curves)</caption>
</figure>
<itemize>
<item>Arguments: The Make Compatible tool takes a number of
NURBS curves from the selection.
<item>Operation: The curves will be made compatible, so that they
are of the same order and defined on the same knot vector.
<item>Note: This tool does not change the geometry of the curves.
However, since clamping, degree elevation, and knot insertion may be
used on the curves, their order, knot vectors, and control points
may be changed.
The point selection will be removed from the original objects.
</itemize>

<sect1>The Rescale Knots to Range Tool<label id="resckrt">
<p>
<itemize>
<item>Arguments: The rescale knots to range tool takes a number of
NURBS curves from the selection and requests a range (two float values).
<item>Operation: The knot vectors of the curves will be scaled, so that
their first and last values match the given range.
<item>Note: The knot type of the curve has to be <tt/"Custom"/!
This tool does not change the geometry of the curves.
</itemize>

<sect1>The Rescale Knots to Mindist Tool<label id="resckmt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS curves from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the curves will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots).
<item>Note: The knot type of the curve has to be <tt/"Custom"/!
This tool does not change the geometry of the curves.
</itemize>

<sect1>The Collapse Points Tool<label id="collt">
<p>
<itemize>
<item>Arguments: The collapse tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) control points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The selected control points will be made a
single multiple point, all points will get the coordinate values
of the last tagged point.
</itemize>

<sect1>The Explode Points Tool<label id="explt">
<p>
<itemize>
<item>Arguments: The explode tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) multiple points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The points forming the selected multiple points will
be made to simple points again and may be edited separately.
<item>Note: Even though you might have exploded some multiple points
Ayam will re-create them on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
or NPatchAttr property if all single control points of the multiple
point(s) still have identical coordinate values (and the <tt/"CreateMP"/
option of the curve or patch object is activated). You should immediately
edit the control points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again!
</itemize>

<sect1>The Swap UV Tool<label id="swapuvt">
<p>
<itemize>
<item>Arguments: The swap uv tool takes a number of NURBS patches,
BPatch, or PatchMesh objects from the selection.
<item>Operation: The u and v dimension of the selected objects will
be swapped (width and height will be exchanged) without altering the
shape of the patches.
</itemize>

<sect1>The Elevate UV Tool<label id="elevuvt">
<p>
<itemize>
<item>Arguments: The elevate uv tool takes a number of NURBS patches from
the selection and additionally requests two integer values.
<item>Operation: The order of the selected NURBS patches will be raised
by the specified integer values without changing the shape of the patches.
<item>Note: If the knot vector of the patch is not clamped, it
will be clamped automatically. The knot type of the patch will
be changed to <tt/"Custom"/. New control points will be added and the position
of old control points may be changed in the progress.
The point selection will be removed from the original object.
</itemize>

<sect1>The Revert U Tool<label id="revertut">
<p>
<itemize>
<item>Arguments: The revert u tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the u dimension (width).
<item>Note: See also the documentation of the corresponding
<ref id="screvertus" name="scripting interface command">.
</itemize>

<sect1>The Revert V Tool<label id="revertvt">
<p>
<itemize>
<item>Arguments: The revert v tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the v dimension (height).
<item>Note: See also the documentation of the corresponding
<ref id="screvertvs" name="scripting interface command">.
</itemize>

<sect1>The Patch Clamp Tool<label id="clanpt">
<p>
<figure loc="ht">
<eps file="pics/clampnp.ps" height="4cm">
<img src="pics/clampnp.gif">
<caption>Patch Clamp Tool (left: Original Patch with B-Spline Knot Vectors, right: Clamped Patch)</caption>
</figure>
<itemize>
<item>Arguments: The patch clamp tool takes a number of NURBS patches from
the selection.
<item>Operation: The knot vectors of a selected NURBS patch will be
changed using knot insertion so that the first and the last knot
(in each direction) have a multiplicity equal to the order of the patch
(in the respective direction).
<item>Note: The shape of the patch will not change but the position of some
control points will. The patch interpolates the first and the last control
point afterwards. The knot types of the patch will be changed to type
<tt/"Custom"/.
The point selection will be removed from the original object.
There are also tools available that clamp a patch in U or
V direction only.
See also the documentation of the corresponding scripting interface commands
<ref id="scclampunp" name="clampuNP">, and
<ref id="scclampvnp" name="clampvNP">.
</itemize>

<sect1>The Patch Rescale Knots to Range Tool<label id="resckrnpt">
<p>
<itemize>
<item>Arguments: The patch rescale knots to range tool takes a number of
NURBS patches from the selection and requests a range.
<item>Operation: The knot vectors of the patches will be scaled, so that
their first and last values match the given range. Trim curves, if
present, will also be scaled to match the new range.
<item>Note: The knot types of the patch have to be <tt/"Custom"/!
This tool does not change the geometry of the patches.
See also the documentation of the corresponding
<ref id="screscaleknnp" name="scripting interface command">.
</itemize>

<sect1>The Patch Rescale Knots to Mindist Tool<label id="resckmnpt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS patches from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the patches will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots). Trim curves, if present, will also be scaled
to match the new range.
<item>Note: The knot types of the patch have to be <tt/"Custom"/!
This tool does not change the geometry of the patches.
See also the documentation of the corresponding
<ref id="screscaleknnp" name="scripting interface command">.
</itemize>

<sect1>The Patch Insert Knot Tool<label id="insknnpt">
<p>
<figure loc="ht">
<eps file="pics/insknnp.ps" height="5cm">
<img src="pics/insknnp.gif">
<caption>Left: original patch, Right: a knot has been inserted 1 time at t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS patches from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected patches, without changing the
shape of the patches.
<item>Note: The knot type of the patch will be changed to <tt/"Custom"/.
This tool does not change the geometry of the patches.
The point selection will be removed from the original object.
See also the documentation of the corresponding scripting interface commands
<ref id="scinsknunp" name="insknuNP">, and
<ref id="scinsknvnp" name="insknvNP">.
</itemize>

<sect1>The Patch Split Tools<label id="splitnpt">
<p>
<itemize>
<item>Arguments: The patch split tools take a number of NURBS patches from
the selection and request a parametric value t (in u or v dimension,
respectively).
<item>Operation: The patches will be split at the parametric value t
into two patches (in u or v dimension, respectively) using knot insertion.
<item>Note: The original patch will be modified and a new patch will be
created.
The point selection will be removed from the original object.
Trim curves will not be honored properly.
See also the documentation of the corresponding scripting interface commands
<ref id="scsplitunp" name="splituNP">, and
<ref id="scsplitvnp" name="splitvNP">.
</itemize>

<sect1>The Extract Curve Tool<label id="extnct">
<p>
<itemize>
<item>Arguments: The extract curve tool takes the selected objects from
the selection.
<item>Operation: The tool creates instances from all selected objects
then creates an ExtrNC object and moves the instances to it.
<item>Note: This tool uses the object clipboard to move the objects
around so that the original clipboard contents are lost when this tool
finishes.
Eventually present trim curves will <em>not</em> be honored properly.
See section <ref id="extrncobj" name="ExtrNC Object">
for more information regarding the ExtrNC object.
</itemize>

<sect1>The Extract Patch Tool<label id="extrnpt">
<p>
<itemize>
<item>Arguments: The extract patch tool takes the selected objects from
the selection.
<item>Operation: The tool creates instances from all selected objects
then creates an ExtrNP object and moves the instances to it.
<item>Note: This tool uses the object clipboard to move the objects
around so that the original clipboard contents are lost when this tool
finishes.
Eventually present trim curves will <em>not</em> be honored properly.
See section <ref id="extrnpobj" name="ExtrNP object">
for more information regarding the ExtrNP object.
See also the documentation of the corresponding
<ref id="scextrnp" name="scripting interface command">.
</itemize>

<sect1>The Split to Curves Tool<label id="sptct">
<p>
<itemize>
<item>Arguments: The split to curves tool takes a single NURBS patch from
the selection.
<item>Operation: The selected NURBS patch will be split into NURBS curves,
along direction U or V.
<item>Note: The original NURBS patch object is not deleted.
See also the documentation of the corresponding
<ref id="scsplitnp" name="scripting interface command">.
</itemize>

<sect1>The Build from Curves Tool<label id="bfct">
<p>
<itemize>
<item>Arguments: The build from curves tool takes a number of NURBS
curves from the selection.
<item>Operation: The selected NURBS curves will be parsed, all curves
that are of equal length or longer than the first selected curve
will be used to form a new NURBS patch of the following dimensions:
Width: length of the first selected curve,
Height: number of used curves.
The order in U direction (Order_U) will be equal to the number of used curves
for numbers of two to four and four for bigger numbers of used curves.
The knot type in U direction (Knot-Type_U) will always be NURB.
Other parameters (Order_V, Knot-Type_V, Knots_V) are taken from
the first curve.
<item>Note: The original NURBS curves objects are not deleted.
See also the documentation of the corresponding
<ref id="scbuildnp" name="scripting interface command">.
</itemize>

<sect1>The Tesselation Tool<label id="tesst">
<p>
<figure loc="ht">
<eps file="pics/tgui.ps" height="3cm">
<img src="pics/tgui.gif">
<caption>GUI of Tesselation Tool</caption>
</figure>
<itemize>
<item>Arguments: The tesselation tool takes all NURBS patches and
NURBS patch providing objects from the selection.
<item>Operation: A modal dialog box (see image above) will pop up,
that allows to select a tesselation method via a drop-down menu
and to tune the corresponding tesselation parameter(s) using a slider and
an entry widget. The initial method and parameter values will be derived
from the TP tag of the first of the selected objects (if it has such a tag).
<p>
The selected or provided NURBS patches will be tesselated with the
chosen method and parameters.
The PolyMesh objects created by the tesselation will immediately be
displayed in all view windows instead of the original objects.
Whenever tesselation method or parameters are changed, the tesselation
will be recomputed and displayed, thus, allowing an immediate estimation
of the tesselation quality.
<p>
If the preference option <tt>"Modelling/LazyNotify"</tt> is enabled,
updates of the tesselation that normally occur while dragging the
slider(s) will be deferred until the mouse button is released.
<p>
If the <tt/"Ok"/ button is pressed to close the tesselation tool, all
selected objects will be replaced by their tesselated
counterparts; if <tt/"Cancel"/ is used, all selected objects remain
unchanged.
<p>
If the check box <tt/"SaveToTag"/ is activated, closing the tesselation
tool using <tt/"Cancel"/ will also add a <tt/"TP"/ tag containing
the currently selected method and parameter value to all selected
objects. This tag will be evaluated later, when the respective
objects will be converted to PolyMesh objects. Since Ayam 1.11 the
conversion mechanism of objects keeps the <tt/"TP"/ tags, so that you
may e.g. save tesselation parameters for a sphere or a revolve object.
<item>Note: The tesselation tool will block most other parts of Ayam
while it is running. It is, however, possible to adjust view parameters
while the tesselation tool is open, to examine the tesselation result
more closely or from different viewing angles. The initial values of the
parameter slider bounds may be changed by simply entering values
that are out of bounds into the entry widget, then pressing the
<tt/&lt;Tab&gt;/ key. The resolution of the slider is calculated
automatically from the resolution of the value entered in the entry
widget.
</itemize>

See section
<ref id="prefmisc" name="Miscellaneous Preferences">
for a more extensive discussion of the tesselation methods
and their parameter(s).

<sect>Scripting Interface<label id="script">
<p>
The Ayam scripting interface is mainly a number of Tcl procedures
and Tcl commands that are also used internally by the application, e.g.
the main menu entry <tt>"File/New"</tt> calls the
scripting interface command <tt/"newScene"/ (among other commands).
Using the scripting interface means to call these commands on
your own possibly in a mix with standard Tcl script code.
<p>
Furthermore, using Tcl and its introspection facilities, you could
easily modify the code Ayam consists of. This is, however, not
recommended for good reasons (unless you read the Ayam source code
and really know, what you are doing).
So watch out for already existing procedures and commands when
implementing your own!
Using procedures and commands not listed in this documentation
is dangerous too. Implementation and interfaces of those
procedures and commands may change in future versions without
notice.
<p>
In Tcl, all variables, procedures, and commands are case sensitive,
it really is <tt/"sL"/ and <em>not</em> <tt/"sl"/ and <em>not</em>
<tt/"SL"/.
<p>
The scripting interface may be used directly from the console
of Ayam. You can, of course, also write scripts in your own
Tcl script files, that may be loaded at any time into Ayam using
the console and the Tcl command <tt/"source"/.
You can also arrange for a script file to be executed automatically
on every application startup using the preference setting
<tt>"Main/Scripts"</tt>.
Moreover, on the X11 and Aqua window systems, Ayam is able to execute
script code sent via the Tk <tt/"send"/ command or the AppleScript
<tt/"tell"/ command from external applications.
<p>
In contrast to other modelling environments, in Ayam there is
another way to run scripts. In Ayam, scripts may also be attached
to script objects and run when the notification mechanism updates
the scene. See also section
<ref id="scriptobj" name="Script object">.
Even normal objects can trigger scripts upon notification using
BNS or ANS tags. See also sections
<ref id="bnstag" name="Before Notify Script"> and
<ref id="anstag" name="After Notify Script">.
<p>
Note that most of the scripting interface commands listed in this
documentation work in the background, without changing anything to
the Ayam GUI and Ayam view windows, for the sake of execution speed.
If you want your changes to become visible you have to update the
various parts of the GUI (property GUIs, view windows) explicitly
(see also section <ref id="sciupd" name="Updating the GUI">).
However, since Ayam 1.13 it is also possible to automatically run GUI
updating commands in the console by using <tt/&lt;Shift+Return&gt;/
instead of <tt/&lt;Return&gt;/ when issuing scripting interface commands.
<p>
If you want your changes to be undoable, you have to arrange for
this manually too (see the documentation of the undo command:
<ref id="scundo" name="Undo">).
<p>
From scripts it may be necessary to check wether an error occured
during the execution of a command. All commands return
TCL_OK in <em>any</em> case, so checking their return value avails
to nothing, but they set the global Tcl variable <tt>"ay_error"</tt>
to a value higher than 1 if an error occured. You need to set it to
zero before and check it after the operation in question to see whether
the operation performed successfully:
<code>
proc myProc { } {
  set ::ay_error 0
  copOb
  if { $::ay_error > 1 } {
    ayError 2 "myProc" "Error copying object!"
  }
}
</code>

<sect1>Global Variables and Arrays
<p>
Several global variables and arrays exist in the Ayam Tcl context, that
may be useful for scripts.

<sect2>Global Variables
<p>
<itemize>
<item> The <tt/"ay_error"/ variable holds the current error state.
See also section <ref id="scierr" name="Reporting Errors">.
<item> The variable <tt/"i"/ is used by all <tt/"forAll"/
command variants. See also section
<ref id="scifall" name="Applying Commands to a Number of Objects">.
</itemize>

<sect2>The Global Array ay<label id="ayarray">
<p>
The global array <tt/"ay"/ holds application state variables.
Furthermore, you can find the paths to important widgets
(e.g. the tree widget for the object hierarchy or the currently
active view) in this array.
Use <tt/"parray ay"/ in the console to see what is there.
More documentation to come.

<sect2>The Global Array ayprefs<label id="ayprefs">
<p>
The global array <tt/"ayprefs"/ holds preferences data.
The <em>complete</em> array is saved in the <tt/"ayamrc"/ file upon exit,
so be careful when adding new entries.
You can reset your <tt/"ayamrc"/ file anytime using the command line
option <tt/"-failsafe"/.
See also section <ref id="ayamrc" name="Ayamrc File">.
Use <tt/"parray ayprefs"/ in the console to see what is there.
More documentation to come.

<sect2>The Global Property Management and Data Arrays<label id="ayproparr">
<p>
For every property, a corresponding global array exists, where the data
of the property is saved.
This global array only holds useful data when the respective
property GUI is active, or when it has been filled explicitly by
the so called get-property callback.
The data may be transferred back to the selected object using
the so called set-property callback.
The names of the array and the callbacks may be inferred from another global
array that is always named like the property itself, e.g. for the tags
property the following global array <tt/"Tags"/ is defined:
<code>
Tags {
arr   tagsPropData
sproc setTagsp
gproc getTagsp
w     fTagsAttr
}
</code>
The entry arr designates the name of the global property data array
(thus, tags data is stored in an array called <tt/"tagsPropData"/).
If sproc or gproc are empty (<tt/""/), a standard callback
named <tt/"setProp"/ or <tt/"getProp"/ should be used to get
or set the property values. Otherwise sproc and gproc designate
the set-property and get-property callbacks respectively.
But for the tags property, the procedures <tt/"setTagsp"/ and
<tt/"getTagsp"/ should be used.
The last entry, <tt/"w"/, is the path and name of the main property
GUI window.
<p>
Since Ayam 1.16, the global property management array may be created
easily using the new scripting interface command <tt/"addPropertyGUI"/.
<p>
The following global arrays and callbacks to get or set the data
exist:
<table loc="ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/property/|<bf/array/|<bf/get-property callback/|<bf/set-property callback/@<hline>
Transformations|transfPropData|getTrafo|setTrafo@<hline>
Attributes|attrPropData|getAttr|setAttrp@<hline>
Material|matPropData|getMat|setMat@<hline>
Tags|tagsPropData|getTagsp|setTagsp@<hline>
</tabular>
<caption>Property Arrays and Callbacks</caption>
</table>
Note that this list is pretty much incomplete, however you can always
infer such information using commands like <tt/"parray Tags"/ in the Ayam
console!
<p>
See also section
<ref id="sciprop" name="Manipulating Properties">
for more information on how to edit property values from the
scripting interface.

<sect1>Index of Procedures and Commands<label id="sccomm">
<p>
This section provides documentation on the most important
scripting interface commands and procedures of Ayam sorted
by category.
<p>
All commands are documented in the following scheme:
<itemize>
 <item>Synopsis: <tt/"command parameters"/ (how are the command and its
parameters actually called),
 <item>Background: does the command run in the background,
Undo: is the result of the command undoable, Safe: is the command available
in the safe interpreter (for Script objects and notify script tags),
 <item>Description: Detailed description of the command and its
parameters,
 <item>Notes: Additional information completing the detailed description,
 <item>Example: <tt/"command 1"/ (example application of the command
with explanation).
</itemize>

<sect2>Getting Help on Scripting Interface Commands<label id="schelp">
<p>
Since Ayam 1.8.2 a scripting interface command named <tt/"help"/ is available,
that displays the help of scripting interface commands using a web
browser (similar to the <tt/"Help on Object"/ feature):
<itemize>
 <item>Synopsis: <tt/"help command"/
 <item>Background: N/A, Undo: No, Safe: No
 <item>Description: Fire up a web browser and display the help for
the designated Ayam scripting interface command.
 <item>Example: <tt/"help help"/ displays the help of the help command.
</itemize>

<sect2>Creating Objects<label id="crtob">
<p><label id="sccrtob">
To create new objects the <tt/"crtOb"/ command can be used.
<itemize>
 <item>Synopsis: <tt/"crtOb type [args]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: New objects may be created with the command <tt/"crtOb"/,
type may be derived from the type name, as displayed in the tree view.<p>

Depending on the type, further arguments may (or have to) be given,
some object types expect other objects to be selected:<p>
  <itemize>
  <item><tt/"NCurve"/: NURBS curves accept a single integer as length of
the new curve, the length defaults to 4. Example:
<tt/"crtOb NCurve -length 10; uS; rV"/
  <item><tt/"NPatch"/: NURBS patches accept two integers as width and
height of the new patch, width and height both default to 4. Example:
<tt/"crtOb NPatch -width 2 -height 2; uS; rV"/
  <item><tt/"Level"/: Levels must be given an additional argument
determining the type of the new level, this argument may be one of:
<tt/"0"/ (level), <tt/"1"/ (union), <tt/"2"/ (intersection),
<tt/"3"/ (difference), <tt/"4"/ (primitive).
 <item><tt/"Material"/: Materials must be given an additional
argument giving the name of the new material. Example:
<tt/"crtOb Material default; uS; rV"/
 <item><tt/"Instance"/: creates an instance of the selected object.
 <item>...
 </itemize>
 <item>Example: Create a sphere and update the GUI:
<tt/"crtOb Sphere; uS; rV"/.
</itemize>

<sect2>Manipulating the Selection<label id="selob">
<p>
These commands are probably the most important ones, because many other
scripting interface commands operate on selected objects only:
<p><label id="scselob">
selOb - select object(s):
<itemize>
 <item>Synopsis: <tt/"selOb [index]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Use this command to set or clear the current
selection, index may be an ordered list of indizes, a single index or empty.
If no index is given, the current selection will be cleared.
 <item>Examples: <tt/"selOb"/ clears the current selection, <tt/"selOb 0"/
selects the first object in the current level, <tt/"selOb 0 1"/ selects
the first two objects in the current level.
</itemize>

<p><label id="scwithob">
withOb - execute a command on certain selected object(s):
<itemize>
 <item>Synopsis: <tt/"withOb index [do] command"/
 <item>Background: depends on command, Undo: depends on command, Safe: Yes
 <item>Description: Use this command to execute command on a
single object (designated by index) from a multiple selection
without changing the selection state of any objects.
 <item>Example: <tt>"withOb 2 {movOb 0 1 0}"</tt> moves the third
object from multiple selected objects. All objects stay selected.
</itemize>

<p><label id="scsl">
sL - select last object:
<itemize>
 <item>Synopsis: <tt/"sL"/
 <item>Background: No, Undo: No, Safe: Yes
 <item>Description: Select the last object in the current level
and, if run in the Ayam interpreter, update the GUI.
If run in the safe interpreter (e.g. from a Script objects script)
this command will create a hidden selection.
This command is often called in a sequence
after creating a new object like this:
<code>
# create object
crtOb NCurve
# update tree
uCR
# select new object
sL
</code>
</itemize>

<p><label id="schsl">
hSL - hidden select last object:
<itemize>
 <item>Synopsis: <tt/"hSL"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Select the last object in the current level
but do not update the GUI. This command is mainly for use in Script
objects script code.
</itemize>

<sect2>Manipulating Properties<label id="sciprop">
<p>
Since Ayam 1.9 two new commands are implemented that ease
the manipulation of property values from the scripting interface:

<p><label id="scgetproperty">
getProperty - get single property value
<itemize>
 <item>Synopsis: <tt/"getProperty propname(elemname) varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command gets a single property element
named elemname from the property named propname of the currently
selected object and writes the result into the variable named varname.
 <item>Notes: In contrast to many other helper commands, the variable
varname does not have to be global.
This command runs more slowly than accessing the data array
that is associated with a property and calling the appropriate get-procedure
directly. See below for more information regarding direct access of
property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be retrieved in the variable <tt/"r"/ easily using the command
<tt/"getProperty SphereAttr(Radius) r"/
</itemize>

<p><label id="scsetproperty">
setProperty - set single property value
<itemize>
 <item>Synopsis: <tt/"setProperty propname(elemname) value"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: This command sets a single property element
named elemname of the property named propname for the currently
selected object to the new value given in value.
 <item>Notes: This command runs more slowly than accessing the data array
that is associated with a property and calling the appropriate set-procedure
directly. See below for more information regarding direct access of
property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be set to the new value <tt/"3.0"/ easily using the command
<tt/"setProperty SphereAttr(Radius) 3.0"/
</itemize>
<p>
In contrast to <tt/"setProperty"/, here is an equivalent example for the
direct (fast) access of property values:
<code>
getProp
set SphereAttrData(Radius) 3.0
setProp
</code>
See also section
<ref id="ayproparr" name="Global Property Management and Data Arrays">.

<sect2>Clipboard Operations<label id="sciclip">
<p>
These commands operate the object clipboard:
<p><label id="sccopob">
copOb - copy object:
<itemize>
 <item>Synopsis: <tt/"copOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Copy the selected object(s) to the object clipboard.
</itemize>
<p><label id="sccutob">
cutOb - cut object:
<itemize>
 <item>Synopsis: <tt/"cutOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Move the selected object(s) into the object clipboard.
</itemize>
<p><label id="scpasob">
pasOb - paste object:
<itemize>
 <item>Synopsis: <tt/"pasOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Copy the selected object(s) from the object
clipboard to the current level.
</itemize>
<p><label id="scdelob">
delOb - delete object:
<itemize>
 <item>Synopsis: <tt/"delOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Delete the selected object(s) from the scene.
</itemize>
<p><label id="sccmovob"><label id="scpasmovob">
pasmovOb - paste (move) object:
<itemize>
 <item>Synopsis: <tt/"pasmovOb"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Move the objects from the object
clipboard to the current level.
</itemize>

<p>
The following commands operate the property clipboard,
which is totally independent from the object clipboard.
<p><label id="scpclip_copy"><label id="sccopyprop">
pclip_copy/copyProp - copy a property to the property clipboard
<itemize>
 <item>Synopsis: <tt/"pclip_copy mode"/ or <tt/"copyProp mode"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Copy the currently selected
property from the currently selected
object to the property clipboard.
If mode is 0, omit all marked entries, if mode is 1 copy just
marked entries.
Note that you may call this procedure also using the shortcut
<tt/"copyProp"/.
</itemize>

<p><label id="scpclip_paste"><label id="scpasteprop">
pclip_paste/pasteProp - paste a property
<itemize>
 <item>Synopsis: <tt/"pclip_paste"/ or <tt/"pasteProp"/
 <item>Background: Yes, Undo: Yes, Safe: No
 <item>Description: Copy the property from the property clipboard
to the currently selected object.
Note that you may call this procedure also using the shortcut
<tt/"pasteProp"/.
</itemize>

<sect2>Hierarchy Operations<label id="scihier">
<p>
These commands manipulate the current level of Ayam:
<p><label id="scgodown">
goDown:
<itemize>
 <item>Synopsis: <tt/"goDown index"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Enter the object determined by index. If index is 0
and the current level is inside some other object (not the root)
the parent level will be entered instead.
</itemize>

<p><label id="scgoup">
goUp:
<itemize>
 <item>Synopsis: <tt/"goUp"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Go one level up in the object hierarchy.
</itemize>

<p><label id="scgotop">
goTop:
<itemize>
 <item>Synopsis: <tt/"goTop"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Go to the top level of the object hierarchy.
</itemize>

<sect2>Transformations<label id="scitrafo">
<p>
These commands transform objects or selected points of objects:
<p><label id="scmovob">
movOb - move objects:
<itemize>
 <item>Synopsis: <tt/"movOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Move the selected object(s) by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p><label id="scrotob">
rotOb - rotate objects:
<itemize>
 <item>Synopsis: <tt/"rotOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rotate the selected object(s) by dx degrees around the
objects X axis, then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

<p><label id="scscalob">
scalOb - scale objects:
<itemize>
 <item>Synopsis: <tt/"scalOb dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Scale the selected object(s) by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

<p><label id="scmovsel"><label id="scmovpnts">
movPnts - move selected points:
<itemize>
 <item>Synopsis: <tt/"movPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Move the selected points by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p><label id="scrotsel"><label id="scrotpnts">
rotPnts - rotate selected points:
<itemize>
 <item>Synopsis: <tt/"rotPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rotate the selected points by dx degrees around the
objects X axis then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

<p><label id="scscalsel"><label id="scscalpnts">
scalPnts - scale selected points:
<itemize>
 <item>Synopsis: <tt/"scalPnts dx dy dz"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Scale the selected points by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

<p><label id="scdelegtrafo">
delegTrafo - delegate transformations:
<itemize>
 <item>Synopsis: <tt/"delegTrafo"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: delegates the transformations associated
with the selected objects to their child objects. Additionally,
the transformations of the selected objects will be reset to the
default values.
</itemize>

<p><label id="scapplytrafo">
applyTrafo - apply transformations:
<itemize>
 <item>Synopsis: <tt/"applyTrafo sel&verbar;all"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: applies the transformations encoded in the
transformation attributes of the selected objects to the points
(either all points, or just the selected ones if there are any)
of those objects.
Additionally, the transformations of the selected objects will
be reset to the default values.
</itemize>

<sect2>Manipulating Shaders<label id="scishaders">
<p>
These commands operate the shader properties:
<p><label id="scshaderset">
shaderSet:
<itemize>
 <item>Synopsis: <tt/"shaderSet shadertype [varname]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Set the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. If varname is not given, the shader in question
is deleted from the object instead.
</itemize>

<p><label id="scshaderget">
shaderGet:
<itemize>
 <item>Synopsis: <tt/"shaderGet shadertype varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. The shader will be written to an array
pointed to by varname.
</itemize>

<sect2>Manipulating Tags<label id="scitags">
<p>
These commands may be used to modify the tags of an object:
<p><label id="scaddtag">
addTag:
<itemize>
 <item>Synopsis: <tt/"addTag type value"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Add a tag with type-string type and value-string
value to the currently selected objects(s).
It is legal to deliver <tt>""</tt> as value parameter. This is e.g.
needed for the <tt/"NoExport"/ tag.
</itemize>

<p><label id="scdeltags">
delTags:
<itemize>
 <item>Synopsis: <tt/"delTags type"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Delete all tags of type-string type from
the currently selected objects(s).
If type is <tt/"all"/, all tags are deleted from the
currently selected objects(s).
</itemize>

<p><label id="scgettags">
getTags:
<itemize>
 <item>Synopsis: <tt/"getTags tvname vvname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get all tags from
the currently selected objects and put them as lists into two
variables named tvname for the tag type-strings and vvname for the tag
value-strings.
</itemize>

<p><label id="scsettags">
setTags:
<itemize>
 <item>Synopsis: <tt/"setTags tags"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clear all tags from the currently selected object
and set new tags. The tag type-strings are taken from the list elements
with even index numbers
and the tag value-strings from the list elements with odd index numbers.
</itemize>

<sect2>Manipulating NURBS Curves and Surfaces<label id="scinurbs">
<p>
These are more specialized commands to change NURBS curve and surface
properties:
<p><label id="scclampnc">
clampNC - clamp NURBS curve:
<itemize>
 <item>Synopsis: <tt/"clampNC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve will be changed to <tt/"Custom"/ and
the knots will have o equal values at start and end (where o is the
order of the curve).
See also section <ref id="clat" name="The Clamp Tool">.
</itemize>

<p><label id="scelevatenc">
elevateNC - elevate NURBS curve:
<itemize>
 <item>Synopsis: <tt/"elevateNC n"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Elevate the order of the selected NURBS curves
without changing the shape of the curves by n.
The knot type of the elevated curves will be changed to <tt/"Custom"/.
See also section <ref id="elevt" name="The Elevate Tool">.
</itemize>

<p><label id="scinsknnc">
insknNC - insert knot into NURBS curve:
<itemize>
 <item>Synopsis: <tt/"insknNC u r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curves) r times. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the curve and n is the length of the curve.
The knot type of the curves will always be changed to custom but
the shape of the curves will not change!
See also section <ref id="insknt" name="The Insert Knot Tool">.
</itemize>

<p><label id="scremknnc">
remknNC - remove knot from NURBS curve:
<itemize>
 <item>Synopsis: <tt/"remknNC u r [tol]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove a knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curve) r times from the curve. Note that the
shape of the curve may be changed by this tool unless the parameter
tol is specified. If tol is specified the new curve does not deviate
from the original curve more than tol in any point on the curve.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original curve is left unchanged.
See also section <ref id="remknt" name="The Remove Knot Tool">.
</itemize>

<p><label id="screfinenc">
refineNC - refine NURBS curve:
<itemize>
 <item>Synopsis: <tt/"refineNC [{u1 u2 un}]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Refine the knot vector of the selected NURBS curve
without changing the shape of the curve with n new knots {u1 u2 un}.
Or, if no list of new knots is given: add a new knot into each interval
in the old knot vector.
The knot type of the refined curve may be changed to <tt/"Custom"/.
See also section <ref id="refit" name="The Refine Tool">.
</itemize>

<p><label id="sccoarsennc">
coarsenNC - coarsen NURBS curve:
<itemize>
 <item>Synopsis: <tt/"coarsenNC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Remove every second control point from the
selected NURBS curves.
See also section <ref id="coart" name="The Coarsen Tool">.
</itemize>

<p><label id="screvert"><label id="screvertc">
revertC - revert curves:
<itemize>
 <item>Synopsis: <tt/"revertC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected NURBS curves
and interpolating curves.
See also section <ref id="revertt" name="The Revert Tool">.
</itemize>

<p><label id="screvertu"><label id="screvertus">
revertuS - revert surfaces:
<itemize>
 <item>Synopsis: <tt/"revertuS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected surfaces in
the u parametric dimension.
See also section <ref id="revertut" name="The Revert U Tool">.
</itemize>

<p><label id="screvertv"><label id="screvertvs">
revertvS - revert surfaces:
<itemize>
 <item>Synopsis: <tt/"revertvS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Revert the direction of the selected surfaces in
the v parametric dimension.
See also section <ref id="revertvt" name="The Revert V Tool">.
</itemize>

<p><label id="scswapuvs">
swapuvS - swap dimensions of surfaces:
<itemize>
 <item>Synopsis: <tt/"swapuvS"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Swap the dimensions of the selected surfaces, thus
exchanging width and height (without altering the shape of the surfaces).
See also section <ref id="swapuvt" name="The Swap UV Tool">.
</itemize>

<p><label id="screscaleknnc">
rescaleknNC - rescale knots of NURBS curves:
<itemize>
 <item>Synopsis: <tt/"rescaleknNC [-r rmin rmax|-d mindist]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rescale the knot vector(s) of the selected NURBS curve(s)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. Scaling to a minimum
distance ensures that all knots (except for multiple knots) have a distance
bigger than mindist afterwards. The knot type of the curve has to be
<tt/"Custom"/!
This operation does not change the shape of the curve.
See also section <ref id="resckrt" name="The Rescale Knots to Range Tool">.
</itemize>

<p><label id="scsplitnc">
splitNC - split NURBS curve
<itemize>
 <item>Synopsis: <tt/"splitNC u"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: splits the selected NURBS curve at designated parametric
value into two curves, creating one new curve and modifying the original
selected curve.
See also section <ref id="splitt" name="The Split Tool">.
</itemize>

<p><label id="sctoxync">
toXYNC - move NURBS curve to XY plane
<itemize>
 <item>Synopsis: <tt/"toXYNC"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: moves the control points of the selected NURBS curve
objects to its XY plane.
See also section <ref id="toxyt" name="The To XY Tool">.
</itemize>

<p><label id="sctrimnc">
trimNC - trim NURBS curve
<itemize>
 <item>Synopsis: <tt/"trimNC umin umax"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: trims the selected NURBS curve to the designated
parametric range (umin-umax), modifying the original selected curve.
See also section <ref id="trimt" name="The Trim Tool">.
</itemize>

<p><label id="scestlennc">
estlenNC - estimate length of NURBS curve:
<itemize>
 <item>Synopsis: <tt/"estlenNC varname"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: estimate the length of the currently selected curve
and put the result into the designated variable.
</itemize>

<p><label id="screparamnc">
reparamNC - reparameterise a NURBS curve:
<itemize>
 <item>Synopsis: <tt/"reparamNC type"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: reparameterise all selected NURBS curves to have
chordal knots (type: 0), or centripetal knots (type: 1). The knot type
of the curve will be changed to <tt/"Custom"/.
</itemize>

<p><label id="scclampnpu"><label id="scclampunp">
clampuNP - clamp NURBS patch in U direction:
<itemize>
 <item>Synopsis: <tt/"clampuNP"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the U direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
U direction).
See also section <ref id="clanpt" name="The Patch Clamp Tool">.
</itemize>

<p><label id="scclampnpv"><label id="scclampvnp">
clampvNP - clamp NURBS patch in V direction:
<itemize>
 <item>Synopsis: <tt/"clampvNP"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Clamp the V direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
V direction).
See also section <ref id="clanpt" name="The Patch Clamp Tool">.
</itemize>

<p><label id="screscaleknnp">
rescaleknNP - rescale knots of NURBS patches:
<itemize>
 <item>Synopsis: <tt/"rescaleknNP [-r[u|v] rmin rmax|-d[u|v] mindist]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Rescale the knot vector(s) of the selected NURBS patch(es)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. The <tt/"-ru"/, <tt/"-rv"/,
<tt/"-du"/, and <tt/"-dv"/ variants scale only the designated dimension.
Scaling to a minimum distance ensures that all knots (except for multiple
knots) have a distance bigger than mindist afterwards. Trim curves, if
present, will also be scaled to match the new range.
The knot types of the patch have to be <tt/"Custom"/!
This operation does not change the shape of the patch.
See also sections
<ref id="resckrnpt" name="The Patch Rescale Knots to Range Tool">
and
<ref id="resckmnpt" name="The Patch Rescale Knots to Mindist Tool">.
 <item>Example: <tt/"rescaleknNP -ru 0.2 0.3"/ scales the u knot vector
of the selected NURBS patch objects to the new range (0.2, 0.3).
</itemize>

<p><label id="scinsknnpu"><label id="scinsknunp">
insknuNP - insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknuNP u r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot in U direction at the position
specified by u, r times. u must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the patch in U direction and n is the
width of the patch.
The u knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change!
See also section <ref id="insknnpt" name="The Patch Insert Knot Tool">.
</itemize>

<p><label id="scinsknnpv"><label id="scinsknvnp">
insknvNP - insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknvNP v r"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Insert a new knot in V direction at the position
specified by v, r times. v must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector V as follows: <tt/V[p] <= v <= V[n]/, where
p is the degree (order-1) of the patch in V direction and n is the
height of the patch.
The v knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change!
See also section <ref id="insknnpt" name="The Patch Insert Knot Tool">.
</itemize>

<p><label id="scsplitnpu"><label id="scsplitunp">
splituNP - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splituNP u"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Splits the selected NPatch objects into two patches
at parametric value u.
See also section <ref id="splitnpt" name="The Patch Split Tools">.
</itemize>

<p><label id="scsplitnpv"><label id="scsplitvnp">
splitvNP - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitvNP v"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Splits the selected NPatch objects into two patches
at parametric value v.
See also section <ref id="splitnpt" name="The Patch Split Tools">.
</itemize>

<p><label id="scextrnp">
extrNP - extract NURBS patch:
<itemize>
 <item>Synopsis: <tt/"extrNP umin umax vmin vmax"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Extracts a sub-patch from the selected NPatch
objects. The sub-patch is specified by the parametric values umin, umax,
vmin, and vmax which have to be in the respective valid knot range.
See also section <ref id="extrnpt" name="The Extract Patch Tool">.
</itemize>

<p><label id="scsplitnp">
splitNP - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitNP (u|v)"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Splits the selected NPatch objects into NURBS curves,
along parametric dimension u or v.
See also section <ref id="splitnpt" name="The Patch Split Tools">.
</itemize>

<p><label id="scbuildnp">
buildNP - build NURBS patch:
<itemize>
 <item>Synopsis: <tt/"buildNPatch"/
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: Builds a NURBS patch from the selected NURBS curves.
See also section <ref id="bfct" name="The Build from Curves Tool">.
</itemize>


<sect2>Manipulating Points<label id="scipoints">
<p>
Use these two commands to read or manipulate single points of arbitrary
objects.
Note that the exact arguments needed depend on the type of the selected
object, e.g. a NURBS curve requires just one index parameter (indexu),
whereas a NURBS patch requires two index parameters (indexu and indexv).

<p><label id="scgetpnt">
getPnt:
<itemize>
 <item>Synopsis: <tt/"getPnt [-trafo|-p] indexu [indexv] varx vary varz [varw]"/
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: Get a control point of the currently selected object
and write the coordinate values into the variables varx, vary, varz, and
varw.
If the special argument <tt/"-trafo"/ is given, the coordinates
will additionally be transformed by the values given in the objects
Transformation property.
If the argument <tt/"-p"/ is given, the <tt/"indexu"/ and <tt/"indexv"/
values are interpreted as parametric values of a NURBS curve or surface
and the corresponding point on the curve or surface is delivered in
varx, vary, and varz.
<item>Examples: <tt/"getPnt 1 x y z w"/ gets the coordinate
values of the second point of the selected NURBS curve and writes
the values to the variables <tt/"x y z w"/. <tt/"getPnt -p 0.5 x y z w"/
gets the curve point at parametric value <tt/"0.5"/ and writes
the values to the variables <tt/"x y z w"/.
</itemize>

<p><label id="scsetpnt">
setPnt:
<itemize>
 <item>Synopsis: <tt/"setPnt indexu [indexv] x y z [w]"/
 <item>Background: Yes, Undo: Yes, Safe: Yes
 <item>Description: Set a control point of the
currently selected object to the coordinates x, y, z, and w.
 <item>Example: <tt/"setPnt 1 0.0 0.2 0.3 1.0"/ sets the coordinate
values of the second point of the selected NURBS curve object to
<tt/"0.0 0.2 0.3 1.0"/.
</itemize>


<sect2>Updating the GUI<label id="sciupd">
<p>
These commands update various parts of the Ayam user interface:
<p><label id="scrv">
rV - redraw all views:
<itemize>
 <item>Synopsis: <tt/"rV"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Redraws all currently open views, except for
iconified views and views where automatic redraw has been turned off.
</itemize>

<p><label id="scus">
uS - update select:
<itemize>
 <item>Synopsis: <tt/"uS [update_prop maintain_selection]"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update the object listbox or tree view after a change
to the object hierarchy.
<p>
If update_prop is 0 no update of the property GUIs will take place.
If maintain_selection is 1 the old selection will be established again.
If both arguments are omitted update_prop defaults
to 1 and maintain_selection to 0.
 <item>Deficiencies: uS completely removes the object tree from
the tree widget and rebuilds it, which can be a very time consuming
operation (depending on the complexity of the scene). There are some
options to speed this process up:
 <itemize>
 <item>If there were just changes to the current level (and below)
the global array entry <tt/"ay(ul)"/ (UpdateLevel) may be set
to the current level before calling <tt/"uS"/. This will not remove
and update the complete scene but just the part below <tt/"ay(ul)"/.
Example:
<code>global ay; set ay(ul) $ay(CurrentLevel); uS;</code>.
 <item>If objects have been created and thus just need to be
added to the current level of the object tree view, the command
<tt/"uCR"/ may be used instead of <tt/"uS"/.
 <item>If just names or types of objects of the current level changed,
the command <tt/"uCL cl"/ may be used instead of <tt/"uS"/.
 </itemize>
</itemize>

<p><label id="scucl">
uCL - update current level:
<itemize>
 <item>Synopsis: <tt/"uCL mode [args]"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update only the current level of the object listbox
or tree view after changes. See also the discussion of <tt/"uS"/ above.
The parameter <tt/"mode"/ may be "cl" or "cs", where "cl" is the normal
operation mode, and "cs" just clears the selection.
</itemize>

<p><label id="scucr">
uCR - update current level after create:
<itemize>
 <item>Synopsis: <tt/"uCR"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Update only the current level of the object listbox
or tree view after objects have been created and need to be added to
the current level. See also the discussion of <tt/"uS"/ above.
</itemize>

<p><label id="scplb_update">
plb_update - property listbox update:
<itemize>
 <item>Synopsis: <tt/"plb_update"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Clear the current property GUI, ask the currently
selected object for a list of properties and insert them in the
property listbox, then rebuild the property GUI of the property
with the same index in the property listbox
as the property selected before plb_update was started (this is not
necessarily a property of the same type).
</itemize>

Since Ayam 1.13 it is also possible to automatically run GUI updating
commands in the console by using <tt/&lt;Shift+Return&gt;/ instead
of <tt/&lt;Return&gt;/. The commands from the hidden preference setting
<tt/"AUCommands"/ will be executed after the commands from the command
line, if the <tt/&lt;Shift&gt;/ key is held down. <tt/&lt;Shift+Return&gt;/
may also be used without commands on the command line.
By default, the <tt/"AUCommands"/ are <tt/"uS; rV;"/, leading to
updated object tree, property GUI, and views.

<sect2>Custom Objects<label id="scicust">
<p>
This command manages custom objects (plugins):
<p><label id="scio_lc">
io_lc - load custom:
<itemize>
 <item>Synopsis: <tt/"io_lc filename"/
 <item>Background: No, Undo: No, Safe: No
 <item>Description: Load the custom object (plugin) from file filename.
Note that it is currently not possible to unload a custom object from
Ayam.
</itemize>

<sect2>Applying Commands to a Number of Objects<label id="scifall">
<p>
There are two commands that help to apply arbitrary commands
to a number of objects, forAll and forAllT:
<p><label id="scforall">
forAll:
<itemize>
 <item>Synopsis: <tt>"forAll recursive command"</tt>
 <item>Background: depends, Undo: depends, Safe: No
 <item>Description: The forAll command executes command for all
objects that have been selected currently, or for every object
of the current level if nothing has been selected. If recursive
is 1 then forAll will recurse into every object (if it has child objects)
before the execution of command. Note that forAll will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu first.
 <item>Deficiencies:
 <itemize>
  <item>A recursive forAll will
e.g. also descend into NURBS patches (if they have trim curves) and apply
the command to the trim curves, which might not exactly be what you
want. Use <tt>"forAllT"</tt> in this case.
  <item>The command will not have access to global arrays unless
e.g. one of the following constructs is in use:<p>

<tt>"forAll 0 &lcub; uplevel &num;0 &lcub; commands &rcub; &rcub;"</tt><p>
<tt>"forAll 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAll"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<p><label id="scforallt">
forAllT:
<itemize>
 <item>Synopsis: <tt>"forAllT type recursive command"</tt>
 <item>Background: depends, Undo: depends, Safe: No
 <item>Description: forAllT works the same way as forAll, with an
additional type check. The command will not be executed if the type of the
current object does not match the argument type. Note that forAllT will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu first.<p>

Note that the type strings will be converted to lowercase before
comparison, so that it is legal to use forAllT e.g. this way:
<p><tt>"forAllT ncurve 0 &lcub;puts $i&rcub;"</tt><p>
 <item>Deficiencies:
 <itemize>
  <item>The command will not have access to global arrays unless
e.g. one of the following constructs is in use:<p>
<tt>"forAllT ncurve 0 &lcub;uplevel &num;0 &lcub;commands&rcub; &rcub;"</tt><p>
<tt>"forAllT ncurve 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAllT"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<sect2>Scene IO<label id="scio">
<p>
These commands help to load scenes from and save them to Ayam scene
files:
<p><label id="scnewscene">
newScene:
<itemize>
 <item>Synopsis: <tt>"newScene"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: clears the current scene.
</itemize>

<p><label id="screplacescene">
replaceScene:
<itemize>
 <item>Synopsis: <tt>"replaceScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: clears the current scene, then loads a new scene
from filename.
</itemize>

<p><label id="scinsertscene">
insertScene:
<itemize>
 <item>Synopsis: <tt>"insertScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: inserts a scene from filename.
</itemize>

<p><label id="scsavescene">
saveScene:
<itemize>
 <item>Synopsis: <tt>"saveScene filename"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: saves the current scene to filename.
</itemize>

<sect2>RIB Export<label id="scribex">
<p>
This command allows to export the current scene to a RenderMan
Interface Bytestream (RIB):

<p><label id="scwrib">
wrib - RIB export:
<itemize>
 <item>Synopsis:
<tt>"wrib filename [-image imagename] [-smonly|-selonly|-objonly]"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: exports the current scene to a RIB file designated
by <tt/"filename"/. If the argument <tt/"-image"/ is given, the RIB file
will create an image file named <tt/"imagename"/ upon rendering. The export
will use the camera transformation from the currently selected Camera
object.
If the argument <tt/"-smonly"/ is provided, a RIB to render shadow maps
will be created and the argument of <tt/"-image"/ will be ignored.
If the argument <tt/"-selonly"/ is given, only the selected (geometric)
objects will be exported, which will result in a RIB file not
suitable for rendering (no setup, camera transformation, or lights
are in it) but for inclusion into other scenes via RiArchive.
Likewise <tt/"-objonly"/ leads to a RIB file containing all objects in the
scene but not suitable for rendering.
The <tt>"wrib"</tt> command always needs a selected camera object
(unless the <tt/"-selonly"/ or <tt/"-objonly"/ options are given); if
there is none or if the camera transformations of the camera associated
with a view window shall be used, the corresponding Togl callback for
the view might be used like this instead:
<code>
.view1.f3D.togl wrib -file filename.rib
</code>
The Togl callback understands the same options as the <tt>"wrib"</tt>
command.
<item>Notes: In Ayam versions prior to 1.15, the filename had to be prepended
by a <tt/"-filename "/, this is no longer the case.
</itemize>

<sect2>Reporting Errors<label id="scierr">
<p>
This command is for error reporting from scripts:

<p><label id="scayerror">
ayError:
<itemize>
 <item>Synopsis: <tt>"ayError code place detail"</tt>
 <item>Background: No, Undo: No, Safe: No
 <item>Description: This command reports errors or warnings.
You should always use ayError instead of puts because the error
reporting mechanism of Ayam features compression of repeated
messages and logging to files. Code should be one of: 1: warning, 2:
error, 3: flush messages, 4: unspecified output.
There are more codes defined (see ayam.h, look for Return/Error Codes)
but they are not needed in the Tcl script context.
Place should describe the procedure where the error occured.
Detail is the string to be output.
</itemize>

<sect2>Miscellaneous<label id="scimisc">
<p>
Miscellaneous commands:

<p><label id="scgettype">
getType:
<itemize>
 <item>Synopsis: <tt>"getType varname"</tt>
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command writes the type of the
selected object into the variable varname. The types are
the well known strings that are displayed in the hierarchy list box
if the objects are not named (NPatch, NCurve, Sphere, etc.).
</itemize>

<p><label id="sctmpget">
tmpGet:
<itemize>
 <item>Synopsis: <tt>"tmpGet tmpdir varname"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command calculates a name for a temporary
file in tmpdir and puts the complete name into varname.
</itemize>

<p><label id="schaschild">
hasChild:
<itemize>
 <item>Synopsis: <tt>"hasChild"</tt>
 <item>Background: Yes, Undo: No, Safe: Yes
 <item>Description: This command returns 1 if the selected object
has child objects, otherwise it returns 0.
</itemize>

<p><label id="scundo">
undo:
<itemize>
 <item>Synopsis: <tt>"undo [redo|save opname [0|1]|clear|rewind]"</tt>
 <item>Background: Yes, Undo: Yes, Safe: No
 <item>Description:
 <itemize>
  <item>If called without arguments, this command performs the undo
  operation.
  <item>If the argument is <tt/"redo"/, this command performs the redo
  operation.
  <item>If the argument is <tt/"save"/, the currently selected objects
are saved to the undo buffer for future undo operations. The name
of the now following modelling operation <em>has</em> to be provided in
a second argument (<tt/"opname"/).
This name will be displayed in the default console prompt, to inform the
user about which operation would be undone/redone, if undo/redo would be
used (e.g. <tt>"[Undo:MoveObj/Redo:none].../bin&gt;"</tt>).
Since Ayam 1.13, a third argument may be given, that controls, whether
all the children of the selected objects should also be saved. This may
be needed if the modelling action that follows the undo save is about to
change the selected objects and also their children.
Note: undo save does not fail if no objects are selected.
  <item>If the argument is <tt/"clear"/, all currently saved states
will be cleared from the undo buffer.
  <item>The argument <tt/"rewind"/ is available since Ayam 1.14. With
this command you can undo the last undo save operation. This may be
necessary, if a modelling operation failed. Care should be taken,
however, to <em>not</em> rewind the undo state, when a modelling
operation only failed for some (not for all) of the selected objects.
 </itemize>
 <item>Example:
<code>
undo save "MovOb"
set ay_error ""
movOb 0 1 0
if { $ay_error > 1 } {
  undo rewind
}
</code>
<item>Notes: See also section <ref id="undos" name="The Undo System">.
</itemize>

<p><label id="scconvob">
convOb:
<itemize>
 <item>Synopsis: <tt>"convOb [-inplace]"</tt>
 <item>Background: Yes, Undo: depends (if -inplace: Yes), Safe: Yes
 <item>Description: This command calls the registered converter
for the selected object(s). If the option <tt>"-inplace"</tt> is
used, the new object(s) will replace the old object(s).
</itemize>

<p><label id="scforcenot">
forceNot:
<itemize>
 <item>Synopsis: <tt>"forceNot [mod|all]"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command calls the registered notification
callback for the selected object(s) and their parents, or, if no object
is selected, for all objects of the scene.
If the <tt>"mod"</tt> parameter is used, only modified objects
will be notified.
If the <tt>"all"</tt> parameter is used, all objects
will be notified regardless of the selection.
</itemize>

<p><label id="scaddtoproc">
addToProc:
<itemize>
 <item>Synopsis: <tt>"addToProc procedure addition"</tt>
 <item>Background: Yes, Undo: No, Safe: No
 <item>Description: This command adds the code from addition to
the procedure procedure.
 <item>Note: This command uses the introspection facilities of
Tcl and works only correctly for procedures, that end with
a single <tt>"return;"</tt> statement.
</itemize>

<sect1>Scripting Interface Examples
<p>
Here are some complete example scripts for the Ayam Tcl scripting interface.
<p>
You may copy and paste all examples directly from the documentation
into the console of Ayam.

<sect2>Moving Objects<label id="scexmov">
<p>
The following example script shows how to move a selected object
to a specified position in space.
<code>
proc placeOb { x y z } {
  global transfPropData

  # copy Transformations-property data to
  # global array "transfPropData"
  getTrafo

  # set array values according to procedure parameters
  set transfPropData(Translate_X) $x
  set transfPropData(Translate_Y) $y
  set transfPropData(Translate_Z) $z

  # copy Transformations-property data from
  # global array "transfPropData" to selected object
  setTrafo
}
# placeOb
</code>
In order to move all selected objects to 1 1 1 you may enter the
following into the console:
<code>
forAll 0 {placeOb 1 1 1}
</code>
But perhaps you would rather like a small GUI for that?
No problem, the following snippet adds an entry to the custom
menu that opens a small requester for the x-, y-, and z-values and
calls the <tt/"placeOb"/ procedure (defined above) with them:
<code>
global ay
$ay(cm) add command -label "Place Object" -command {
 runTool {x y z} {"X:" "Y:" "Z:"} "forAll 0 {placeOb %0 %1 %2}"
 plb_update; rV
}
</code>
The trailing <tt/"plb_update; rV"/ command ensures that the GUI is updated
properly and all views display the new position of the moved objects.

<sect2>Moving NURBS points<label id="scexnurb">
<p>
The following example script snippet shows how to move control points
of a NURBS curve.
<code>
# first, we create a new NURBS curve with 30 control points
set len 30
crtOb NCurve -length $len
# update selection
uS
# select last object (the newly created curve)
sL
# prepare moving
set i 0
set r 3.0
set angle 0
set angled [expr 3.14159265/2.0]
while { $i < $len } {

    set x [expr $r*cos($angle)]
    set y [expr $r*sin($angle)]
    set z [expr $i/3.0]

    # move control point to new position
    setPnt $i $x $y $z 1.0

    set angle [expr $angle + $angled]
    incr i
}
# redraw all views
rV
</code>
Now use this as path for a Sweep.
For instance, using the next small script.

<sect2>Easy Sweep<label id="scexsweep">
<p>
The following example script shows how to easily create a sweep from a
selected path curve (avoiding the manual and lengthy creation and
parameterisation of a suitable cross section).
<code>
proc easySweep { } {
 # first, we create a sweep object
 crtOb Sweep

 # now, we need to move the selected curve (path) to
 # the sweep and create a cross-section curve there too
 # for that, we move the currently selected curve to the clipboard
 cutOb
 uS

 # how does the current level look like?
 getLevel a b

 # enter the Sweep (the last object in the current level)
 goDown [expr [llength $a]-1]
 uS

 # now, we create a new curve (a closed B-Spline suitable as cross section)
 crtClosedBS 8
 uS

 # how does the current level look like?
 getLevel a b

 # select last object (the newly created curve)
 selOb [expr [llength $a]-1]

 # now, we rotate and scale the curve
 rotOb 0 90 0
 scalOb 0.25 0.25 1.0

 # move trajectory back (we use "pasmovOb" and _not_ "pasOb", because we
 # really want to move (and not copy) the curve object
 pasmovOb
 # go up to where we came from
 goUp

 # update GUI
 uS
 sL

 # redraw all views
 rV
}
# easySweep
</code>

Run this pocedure by selecting a NURBS curve object, then type
into the console:
<code>
easySweep
</code>

You may add this command to the main menu as well:
<code>
global ay
$ay(cm) add command -label "Easy Sweep" -command {
 easySweep
}
</code>
After running the above script you should have a new menu
entry <tt>"Custom/Easy Sweep"</tt> that calls the <tt>easySweep</tt>
procedure.

<sect2>Toolbox Buttons<label id="scextoolbox">
<p>
Here is another example script that shows how you may add buttons
to the toolbox.
myImage should be an image created e.g. from a GIF file of
the size 25 by 25 pixels.
<code>
global ay ayprefs

# create an image from a GIF file:
image create photo myImage -format gif -file /home/user/giffile

if { $ayprefs(SingleWindow) } {
  set b .fv.fTools.f.mybutton
} else {
  set b .tbw.f.mybutton
}

# if the button does not already exist:
if { ![winfo exists $b] } {

  # create it:
  button $b -padx 0 -pady 0 -image myImage -command myCommand

  # tell Ayam about the new button:
  # you can use "linsert", to insert the button in a specific
  # place or just append to the end of the list using "lappend"
  lappend ay(toolbuttons) mybutton

  # display the button:
  toolbox_layout

  # from now on, it will be under the
  # automatic toolbox layout management
}
</code>

This example shows that a) toolbox buttons have to be created in the
frame <tt/".tbw.f"/ for multi-window GUI configurations or
<tt/".fv.fTools.f"/ for single-window GUI configurations,
b) Ayam manages a list of all toolbox buttons in the global array ay
in <tt/"ay(toolbuttons)"/, the order in that list is the order
in which the buttons appear in the toolbox, c) automatic layout
management is carried out by the procedure <tt/"toolbox_layout"/.
<p>
Adding buttons with just text is a little bit more involved,
as the sizes of the new buttons often do not fit well in the
icon button scheme with its constant button size. However,
since Ayam 1.14, the procedure <tt/"toolbox_add"/ can be of
considerable help (see the file <tt/"scripts/topoly.tcl"/
for an example).
<p>
Here is an example that adds two buttons to the bottom of the
toolbox spanning the whole window (this works best with the
standard toolbox layout of 4 by 12 buttons used in the multi-window
GUI configuration):
<code>
# create a frame:
set f [frame .tbw.f.fcollex]

# calculate the row number below the last row:
set row [expr [lindex [grid size .tbw.f] 1] + 1]

# now display the frame at calculated row, spanning the whole window:
grid $f -row $row -column 0 -columnspan [lindex [grid size .tbw.f] 0]\
     -sticky we
# create two buttons inside the frame:
button $f.b1 -width 5 -text "Coll." -command { collMP; rV; }
button $f.b2 -width 5 -text "Expl." -command { explMP; rV; }
pack $f.b1 $f.b2 -side left -fill x -expand yes
</code>

<sect1>Helper Scripts
<p>
This sections contains the documentation of some helper scripts
that are distributed with Ayam.
<p>
All helper scripts may be run via the context menu of the console, the
Tcl <tt>"source"</tt> command, or the <tt>"Scripts"</tt> preference
setting of Ayam on each start.

<sect2>Repair Ayam<label id="repayam">
<p>
Since Ayam 1.8.2 an external Tcl script named <tt>"repairAyam.tcl"</tt> is
provided that may be used to repair the application state of Ayam
should it be stuck e.g. in an endless loop of Tcl error messages.
<p>
On Unix systems <tt>"repairAyam"</tt> may be started from any
shell simply by typing <tt>"./repairAyam.tcl"</tt> or
<tt>"wish repairAyam.tcl"</tt> (without the quotes)
on the command prompt; if the script detects that it is running on Unix
and not in Ayam it will send itself to the Tcl interpreter Ayam is
running in using the Tk send command. On Mac OS X Aqua (not X11!)
AppleScript events will be used instead of the Tk send command.
If this does not work as expected <tt>"repairAyam.tcl"</tt> may still
be run via the Ayam console (as on Win32).
<p>
On Win32 you have to start <tt>"repairAyam.tcl"</tt> from the Ayam console
using the command: <tt>"source scripts/repairAyam.tcl"</tt> or using
the consoles context menu: <tt>"Console/Load File"</tt>.
<p>
The script <tt>"repairAyam.tcl"</tt> should be considered a
<em>last resort</em> to help you save your modified objects!
<p>
The script will close all views, clean up the application state variables,
reset the mouse cursor and the console prompt, and try to update important
main window widgets. Since Ayam 1.9 it will also clear the console and
try to break potential endless loops running e.g. in the console or
in script objects.
<p>
After running <tt>"repairAyam.tcl"</tt> you should immediately save
the scene (or just the important objects you were editing, possibly using
<tt>"Special/Save Selected"</tt>) to a new file, not the scene file
you were working with initially, and restart Ayam.

<sect2>Convert Everything to Polygons<label id="topolytcl">
<p>
Since Ayam 1.13 there ist a script named <tt>"topoly.tcl"</tt> that
recursively browses through the scene and converts everything
to a polygonal representation.
<p>
After running the script, there is a new button in the toolbox
named <tt>"ToPolyMesh"</tt>. Additionally, there is a corresponding
entry in the <tt>"Custom"</tt> main menu.
Pressing the button or using the menu entry immediately starts the
conversion process.
<p>
Since the changes of the conversion are not undoable, the conversion
will not run if the scene contains unsaved changes.
<p>
The conversion will use the parameters from the preference settings
<tt/"SMethod"/, <tt/"SParamU"/, and <tt/"SParamV"/ or from <tt/"TP"/
tags (if present).
TP tags may be created easily using the tesselation tool, see also
section <ref id="tesst" name="The Tesselation Tool">.

<sect2>Restrict the Console<label id="twolconstcl">
<p>
The script <tt>"2lcons.tcl"</tt> (for two line console), may be
used to restrict the screen space occupied by the console.
<p>
Normally, the Ayam console is resized with the main window and
occupies a varying amount of screen space.
After running the script, the console will always resize to exactly
two lines. Different values may be chosen easily by adapting the
script.

<sect2>Use Ayam as Command Line Converter<label id="bgconverttcl">
<p>
Since Ayam 1.15 there is an external Tcl script named <tt>"bgconvert.tcl"</tt>
that converts its arguments, with the help of Ayam running in the
background, from one 3D file format to another.
In the most simple form, it may be used from a UNIX command line
(or shell script) like this:
<code>
bgconvert.tcl infile.x3d outfile.dxf
</code>
The above command would load the X3D file <tt>"infile.x3d"</tt>
into Ayam and export the scene as DXF file to <tt>"outfile.dxf"</tt>.

Ayam has to run already and the plugins required for the import and
export processes need to be available and properly configured
(<tt>"Plugins"</tt> preference setting).
The plugins necessary for the conversion will be loaded automatically.
<p>
Import and export options may also be given like this:
<code>
bgconvert.tcl "infile.rib -p 1" outfile.dxf
</code>
In the example above the <tt>"-p 1"</tt> option switches on reading
of partial RIB files.
Available options and their syntax may be inquired from the
import and export plugin Tcl scripts (e.g. <tt>"plugins/rrib.tcl"</tt>).

<sect2>Access Core Functions from the Toolbox<label id="zaptcl">
<p>
The script <tt>"zap.tcl"</tt> demonstrates, how arbitrary core
functionality that is just available through a main menu entry
or the scripting interface might be accessed easily via the
toolbox window.
<p>
After running the script <tt>"zap.tcl"</tt>, there will be a new
toolbox button, labeled <tt>"Zap!"</tt>, that simply runs the zap
command (which iconifies the complete application).

<sect2>Switch File Dialogs to Kdialog<label id="kdialogtcl">
<p>
The script <tt>"kdialog.tcl"</tt> switches all file dialogs of
Ayam to use the kdialog application of the KDE project instead
of the native Tk file dialog.

<sect2>Switch File Dialogs to Zenity<label id="zdialogtcl">
<p>
The script <tt>"zdialog.tcl"</tt> switches all file dialogs of
Ayam to use the zenity application of the Gnome project instead
of the native Tk file dialog.

<sect2>Use Aqsis from Application Directory<label id="useaqsisapptcl">
<p>
The script <tt>"useaqsisapp.tcl"</tt> sets up Ayam to use Aqsis
from the application directory structure (<tt>"/Applications/Aqsis.app"</tt>)
on Mac OS X. This is the default installation location of Aqsis on Mac OS X.
<p>
The script adapts the executable and shader search paths.
Furthermore, environment variables vital for Aqsis to work will
be set up properly.
<p>
Note that the script does not change the <tt>"RIB-Export/Renderer"</tt>
preferences, you still have to switch to Aqsis using the main menu
<tt>"Special/Select Renderer"</tt> once.

<sect2>Use Pixie from Library Directory<label id="usepixietcl">
<p>
The script <tt>"usepixie.tcl"</tt> sets up Ayam to use Pixie
from the <tt>"/Library/pixie"</tt> directory on Mac OS X.
This is the default installation location of Pixie on Mac OS X.
<p>
The script adapts the executable, shared library, and shader search paths.
Furthermore, environment variables vital for Pixie to work will
be set up properly.
<p>
Note that the script does not change the <tt>"RIB-Export/Renderer"</tt>
preferences, you still have to switch to Pixie using the main menu
<tt>"Special/Select Renderer"</tt> once.


<sect>Import and Export<label id="impex">
<p>
This section contains the documentation of all import and export
modules of Ayam. Except for RIB export, all import and export
modules are plugins that need to be loaded into Ayam before possible
usage.
Loading of an import/export plugin may be done in three different ways:
<enum>
<item><em>explicitly</em> via the main menu entry <tt>"File/Load Plugin"</tt>,
<item><em>automatically</em> on application startup via a script (by adding
e.g. <tt>"plugins/loaddxfio.tcl"</tt> to the <tt>"Scripts"</tt> preference
setting),
<item><em>implicitly</em> via normal scene IO.
<p>
Implicit loading means one can simply use the main menu entries
<tt>"File/Open"</tt> and <tt>"File/Save as"</tt> (or the corresponding
keyboard shortcuts) and specify a filename with the appropriate
extension (e.g. <tt/".dxf"/). Ayam will automatically load the matching plugin
(<tt/"dxfio"/) and open the import (or export) options dialog with
the <tt/"FileName"/ option already set to the filename choosen before.
This feature is available since Ayam 1.13.
</enum>

<p>
Not all features of Ayam are supported in the various export
options. The following table gives an overview of the supported
features per export file format.

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Feature/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>

Quadrics|Yes|No<f><sup>1</sup></f>|Some<f><sup>4</sup></f>|No<f><sup>2</sup></f>|Some<f><sup>4</sup></f>|Some<f><sup>4</sup></f>@<hline>

Trimmed NURBS|Yes|Yes|Yes|No<f><sup>2</sup></f>|Yes|Yes<f><sup>3</sup></f>@<hline>

Parametrics|No<f><sup>1</sup></f>|No<f><sup>1</sup></f>|No<f><sup>1</sup></f>|No<f><sup>2</sup></f>|No<f><sup>1</sup></f>|Some<f><sup>5</sup></f>@<hline>

Curves|No|Yes|Yes|Yes|Yes|Yes@<hline>

Transformations|Yes|No|Yes|No|No|Yes@<hline>

Hierarchy|Yes|No|Yes|No|No|Yes@<hline>

Instances|Yes|No|No|No|No|Yes@<hline>

CSG|Yes|No|No|No|No|No@<hline>
</tabular>
<caption>Ayam Features Supported by Various Export Formats</caption>
</table>

<enum>
<item>will be converted to NURBS
<item>will be converted to PolyMeshes
<item>3D trimcurves exported as PolyLines
<item>some quadrics are converted to NURBS (refer to plugin documentation)
<item>some parametrics are converted to NURBS (refer to plugin documentation)
</enum>

Note that a successful export of a 3D scene to a different application
not only depends on Ayam but also on the quality of the importing
application. For instance, many applications claim to read files in the
Wavefront OBJ format but only import polygonal data or, even worse, only
triangles from such files. By default, Ayam tries to preserve as much
information as possible in the respective export format leading to the
use of NURBS in Wavefront OBJ files.
Consequently, to successfully transfer an Ayam scene to a different
application, in some cases you may need to convert the NURBS objects in
the Ayam scene to polygonal geometry before export. There is a script
provided that helps you doing this (<tt>"topoly.tcl"</tt>, see also section
<ref id="topolytcl" name="Convert Everything to Polygons">).
<p>
Ayam is not perfect either, as in most import options material and
animation data is completely ignored.
<p>
Speaking of import, the following table lists the Ayam features
supported by the various import plugins.

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Feature/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>

Quadrics|Yes|No|Yes|No|Yes|Yes@<hline>

Trimmed NURBS|Yes|Yes|Yes|No|Yes|Yes@<hline>

Parametrics|No|No|No|No|No|Yes@<hline>

Curves|No|Yes|Yes|Yes|Yes|Yes@<hline>

Transformations|Yes|No|Yes|No|No|Yes@<hline>

Hierarchy|Yes|No|Yes|No|No|Yes@<hline>

Instances|Yes|No|No|No|No|No@<hline>

CSG|Yes|No|No|No|No|No@<hline>
</tabular>
<caption>Ayam Features Supported by Various Import Plugins</caption>
</table>

<p>
The following table gives an overview of the file format versions
supported by the various import and export plugins. Import of files
from a different version should be considered unsupported.

<table loc="ht">
<tabular ca="|c|c|c|c|c|c|c|"><hline>
<bf/Format/|<bf/RIB/|<bf/OBJ/|<bf/3DMF(Apple)/|<bf/DXF/|<bf/3DM(Rhino)/|<bf/X3D/@<hline>
Version|3.0|3.0|1.0|14|3.0|3.1@<hline>
</tabular>
<caption>Supported File Format Versions Overview</caption>
</table>

The next sections document the various import and export plugins
in detail.

<sect1>RenderMan Interface Bytestream (RIB) Import<label id="imprib">
<p>
Using the RRIB (for <bf/R/ead <bf/RIB/) plugin you may import RenderMan
Interface Bytestreams of version 3.0 into Ayam.
Start importing a RIB using the menu entry
<tt>"File/Import/RenderMan RIB"</tt>
(if this menu entry is not available, you have to load the
<tt>"rrib"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
<sect2>RIB Primitive Support
<p>
The RRIB plugin supports import of the following geometric
primitives:
<itemize>
<item>Quadrics (Sphere, Disk, Cylinder, Cone, Paraboloid, Hyperboloid, Torus)
<item>bilinear and bicubic patches and patch meshes
<item>NURBS patches (with trim curves)
<item>(general) polygons and (general) polygon meshes
<item>subdivision meshes (with all tags)
</itemize>

Furthermore, the plugin supports reading of CSG, object-instances,
archives, light sources (including area-lights), arbitrary linear
transformations (except shear transformations!), arbitrary
RiOptions and RiAttributes, shaders (except transformation
shaders and without array arguments!), (since Ayam 1.7)
arbitrary primitive variables (e.g. varying or vertex), and
(since Ayam 1.9) procedural objects and delayed read archives.
<p>
The RRIB plugin does not support reading of curves, implicit surfaces
(blobby models) and other calls to the RenderMan Interface that are not
so much useful for a RIB import like e.g. RiMakeTexture.
Unsupported geometric primitives and other calls to the RenderMan Interface
are silently ignored.
<p>
<sect2>RIB Import Options<label id="rribopt">
<p>
The RIB import may be controlled via different options:
<itemize>
<item><tt/"ScaleFactor"/, determines a global scale factor to be applied
to all imported objects.
<item><tt/"ReadFrame"/, specifies the number of the frame in the RIB
to read. A value of -1 means, all frames are to be read. If you specify
a frame number and this frame does not show up in the RIB as
<tt/"FrameBegin &lt;yournumber&gt;"/ nothing will be
imported!
<item><tt/"ReadCamera"/: if this is switched on, a Camera object will
be created when the RIB plugin encounters a <tt/"WorldBegin"/. You may drag
this camera object onto a perspective View object in Ayam after import
to see through the camera of the imported RIB.
<item><tt/"ReadOptions"/, controls, whether RiOptions are
to be imported from the RIB to the scene. Note that those
RiOptions will overwrite the current global settings in the Ayam scene.
<item><tt/"ReadLights"/, if this is enabled the lights from the
RIB will be imported.
<item><tt/"ReadMaterial"/, controls, whether material objects
are to be created for the imported objects. All material objects
are created in a special level named <tt/"Materials"/ in the top level
of the scene. The plugin tries to keep the number of generated
material objects as low as possible by comparing with already
existing materials in this level. This also works with material
objects that exist before the RRIB plugin is invoked (as long as
they reside in this special level).
<item><tt/"ReadPartial"/, this option is useful if you want to
import partial RIBs (e.g. archives) that do not
contain a <tt/"WorldBegin"/.
Be careful with this option (i.e. use it only if reading of a RIB fails),
as it switches reading of all types of objects on, regardless of
the RIB structure.
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are
the only trim curves.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS patches and trim curves so that the distances between different
knots are not smaller than the given value. Using a value of 1.0e-04 leads
to NURBS that may be safely drawn using GLU. The default value 0.0 means
no scaling.
<item><tt/"ErrorLevel"/, this option controls how many error messages
should be printed to the Ayam console while reading the RIB. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
Note that in the case of serious syntactic errors of the RIB file
more informative error messages are printed to the stderr channel
of Ayam (which is not redirected to the Ayam console).
</itemize>

Note that for NURBS patches and bicubic patch meshes, points of type
"P" will be promoted to "Pw". Trimming of NURBS patches by clamping
the knot ranges is not supported (however, since Ayam 1.9 UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values).
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
<p>
Furthermore, objects of type (general) polygon and polygon mesh will
be promoted to general polygon meshes.
<p>
Object-instances are resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
Procedural objects will not be evaluated, instead, RiProc objects
will be created, that carry all arguments and create the same
sequence of RIB requests upon export as was read upon import.

<sect1>RenderMan Interface Bytestream (RIB) Export<label id="exprib">
<p>
RenderMan Interface Bytestream (RIB) export is the most important export
module of Ayam and in fact justifies its existence. All features of the
Ayam object and scene structure are supported (hierarchy, CSG, instances,
materials, lights).
Furthermore, Ayam also supports direct rendering from view windows,
rendering in multiple passes for shadow maps, and permanent previews
(where a RenderMan renderer is directly coupled to an Ayam view window).
<p>
The documentation on RIB export is spread over the Ayam documentation,
this section gives some general information and otherwise just points
to the real documentation sections.
<p>
RIB export is always available, it does not need a plugin to be loaded.
The corresponding main menu entry is <tt>"File/Export/RenderMan RIB"</tt>
and the corresponding keyboard shortcut is <tt/&lt;Ctrl+E&gt;/.
To control the RIB export and rendering, many options exist that are
documented in section <ref id="prefrib" name="RIB export preferences">.
<p>
There are also some special ways to export RIBs available in the
main menu: <tt>"Special/RIB-Export"</tt>; this is documented in
section <ref id="mmspecial" name="Special Menu">.
<p>
Ayam can not only export scenes as RIB but also call various
RenderMan renderers to directly render the exported RIB files to
the screen or to an image file.
Documentation on how to export/render directly from a view window
can be found in section <ref id="vmview" name="The View Menu">.
<p>
RIB export is also possible using the scripting interface,
see section <ref id="script" name="Scripting Interface">.

<sect1>Mops Import<label id="impmops">
<p>
In older versions of Ayam, Mops scenes could be imported using the main
menu entry: <tt>"File/Import Mops"</tt>. Since Ayam 1.13 Mops import is
a plugin named <tt>"mopsi"</tt>. After loading the plugin, Mops scenes
may be imported using the main menu entry <tt>"File/Import/Mops"</tt>.
<p>
Ayam is able to import most elements of a Mops scene except for
RiAttributes attached to arbitrary geometric objects,
because attributes and shaders are managed by material objects in Ayam.
However, if a Mops object has a surface or displacement shader,
a material object with the shaders from the Mops object
and its RiAttributes will be automatically created and linked with
the geometric object while importing. Only Mops objects
with surface or displacement shaders are considered because
otherwise a material object would have to be created for every
imported Mops object.
The material objects are named <tt/"mat0"/, <tt/"mat1"/ and so on.
Make sure, that the current scene in Ayam does not contain material
objects with those names, otherwise Mops import will not be able to
create material objects for the scene to import.
<p>
The import options <tt>"ResetDM"</tt> and <tt>"ResetST"</tt> control,
whether GLU display mode and tolerance settings (see sections
<ref id="ncattr" name="NCurveAttr">,
and <ref id="npattr" name="NPatchAttr">
for more information about display mode and tolerance) of NURBS primitives
should be reset to using global preference values (the default in Ayam)
instead of using the values from the Mops scene file.

<sect1>AutoCAD DXF Import<label id="impdxf">
<p>
The <tt>"dxfio"</tt> plugin allows to import AutoCAD DXF (drawing interchange
format) files into Ayam with the help of the Dime library (from Systems in
Motion, Kongsberg SIM AS, Norway).
<p>
Start importing a DXF file using the main menu entry
<tt>"File/Import/AutoCAD DXF"</tt>
(if this menu entry is not available, you have to load the
<tt>"dxfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
Note that the entire DXF file is read into memory before any geometry is
created.
<p>
<sect2>DXF Entity Support
<p>
The DXF import plugin supports reading of the following DXF entities:
3DFACE, ARC, CIRCLE, ELLIPSE, LINE, SOLID, TRACE, BLOCK, INSERT,
POLYLINE, LWPOLYLINE, and SPLINE. Entities not listed here will
be silently ignored.
<p>
3DFACE entities are imported as PolyMesh objects if either only the first
three points are unique (the entity describes a triangle) or the face
is planar else as BPatch objects.
<p>
ARC, CIRCLE, and ELLIPSE entities will be read as NCircle objects with
corresponding <tt/"TMin"/, <tt/"TMax"/ parameters (for arcs and ellipses)
and scale transformation values (for ellipses) set.
<p>
POLYLINE entities are completely supported:
<itemize>
<item>Polylines will be imported as NCurve objects;
<item>PolyMeshes and PolyFaceMeshes will be imported as PolyMesh objects;
<item>B-Spline and Bezier surfaces will be imported as NPatch objects.
</itemize>
<p>
LINE, LWPOLYLINE, and SPLINE entities will be imported as NCurve objects.
<p>
SOLID and TRACE entities are imported as BPatch objects.
<p>
BLOCK and INSERT entities will be converted to appropriate master (referenced)
and instance objects (references).
<p>
Bulges and extrusions are not supported.
<p>
The following table comprehensively lists the supported DXF entities and
their Ayam counterparts that will be created upon import.

<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/DXF Entity/|<bf/Ayam Object/@<hline>
3DFACE|PolyMesh&thinsp;/&thinsp;BPatch@<hline>
ARC|NCircle@<hline>
CIRCLE|NCircle@<hline>
ELLIPSE|NCircle@<hline>
LINE|NCurve@<hline>
SOLID|BPatch@<hline>
TRACE|BPatch@<hline>
POLYLINE|NCurve&thinsp;/&thinsp;PolyMesh&thinsp;/&thinsp;NPatch@<hline>
LWPOLYLINE|NCurve@<hline>
SPLINE|NCurve@<hline>
INSERT|Instance@<hline>
</tabular>
<caption>DXF Import Conversion Table</caption>
</table>

<sect2>DXF Import Options<label id="impdxfopt">
<p>
The DXF import may be controlled via different options:
<itemize>
<item><tt>"FileName"</tt> is the path and name of the DXF file to import.
<item><tt>"ReadCurves"</tt> if this is disabled, no freeform curves will
be imported.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
imported objects.
<item><tt/"ReadLayers"/: By default, all entities from all layers will be
imported.
Using the <tt/"ReadLayers"/ import option, a single layer or a range
of layers may be selected for import.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of imported
NURBS curves so that the distances between different knots are not smaller
than the given value. A <tt/"RescaleKnots"/ value of 1.0e-04 leads to NURBS
that may be safely drawn using GLU. The default value 0.0 means no scaling.
<item><tt/"ErrorLevel"/: controls how many messages will be printed
to the Ayam console while importing. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, Dime is reading the DXF file; from 50 to 100 percent,
the dxfio plugin is converting the DXF entities to Ayam objects.
</itemize>

<sect1>AutoCAD DXF Export<label id="expdxf">
<p>
The <tt>"dxfio"</tt> plugin allows to export Ayam scenes to AutoCAD DXF
(drawing interchange format) files with the help of the Dime library
(from Systems in Motion, Kongsberg SIM AS, Norway).
<p>
Start exporting to a DXF file using the main menu entry
<tt>"File/Export/AutoCAD DXF"</tt>
(if this menu entry is not available, you have to load the
<tt>"dxfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
Note that the entire Ayam scene is converted to a corresponding
DXF model in memory before it is written to the DXF file.
<p>
Ayam only creates entities of type POLYLINE and SPLINE and misses very
much information that could be saved to other formats (e.g. normals and
texture coordinates). Therefore, the DXF export format should be avoided
if possible.

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the dxfio plugin currently covers
export of all boxes, quadrics, NURBS, PolyMeshes, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/), and objects that
may be converted to NURBS curves or surfaces or to PolyMeshes.
However, all boxes and quadrics will always be converted to NURBS surfaces
and NURBS surfaces will be tesselated to PolyMeshes for export.
<p>
The scene hierarchy and CSG operations are fully ignored, all objects will
be written as if combined by the union operator.
<p>
All transformations will be applied to the control points of the
exported objects.
<p>
PolyMesh objects will be exported to POLYLINE (subtype PolyFaceMesh) entities.
If a PolyMesh object contains faces with holes or with more than four
points, it will be tesselated for export. Eventually existing normals
will not be exported.
<p>
NURBS curves will be exported as SPLINE entities.
<p>
Instance objects are resolved for export.
<p>
Light sources, as well as Cameras, Views, and Materials are not exported.
<p>
Clamping the knot ranges of NURBS curves or surfaces via UMM/VMM tags is
not supported. Texture coordinates will not be exported.

<sect2>DXF Export Options<label id="expdxfopt">
<p>
The DXF export may be controlled via different options:
<itemize>
<item><tt>"FileName"</tt> is the path and name of the DXF file to export to.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
exported objects.
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"ObeyNoExport"/: ignores all objects with <tt/"NoExport"/ tags.
<item><tt/"IgnoreHidden"/: ignores all hidden objects.
<item><tt>"WriteCurves"</tt> if this is disabled, no freeform curves will
be exported.
<item><tt>"TopLevelLayers"</tt> controls whether the top level Level
objects in the Ayam scene to be exported should be interpreted as layers.
If this option is enabled, all objects in these levels will be placed on
the respective layer. Objects that are not in one of those levels
will be written to the default layer. Furthermore, top level object names
will become layer names.
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the dxfio plugin is converting the Ayam objects
to DXF entities; from 50 to 100 percent, Dime is writing the DXF file.
</itemize>

<sect1>Wavefront OBJ Import<label id="impwav">
<p>
Since Ayam 1.8.3 a Wavefront OBJ (version 3.0) import facility is available
and since Ayam 1.13 it is a plugin (objio) that needs to be loaded
before import.
The corresponding main menu entry is <tt>"File/Import/Wavefront OBJ"</tt>
(if this menu entry is not available, you have to load the <tt>"objio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).

<sect2>Wavefront OBJ Statement Support
<p>
Wavefront OBJ import supports reading of polygonal faces with vertex
normals and texture coordinates (the latter are read as primitive variable
tags); statements: <tt>v, vt, vn, f</tt>.
<p>
Furthermore, freeform curves and surfaces (NURBS) with trim curves and with
texture coordinates (again read as primitive variable tags) are supported;
statements: <tt>vp, cstype, deg, curv, curv2, surf, parm, trim, hole, end</tt>.
<p>
Freeform curves and surfaces of basis type bmatrix, cardinal and taylor
are currently not supported. Also, import of special curves and
points (e.g. curve on surface) is currently not supported. Furthermore,
trimming of freeform curves and surfaces by clamping their knot ranges
is not supported (however, since Ayam 1.9, UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values).
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
No material and grouping information will be imported.
Unsupported statements will be silently ignored.
<p>
Wavefront OBJ import expects the file to be syntactically correct.
The plugin is not very good in detecting and reporting errors. If the
import fails, you might want to use a third party tool first to check
whether the Wavefront OBJ file is valid at all.
<p>
Furthermore, note that the objio plugin supports Wavefront version 3.0
syntax only, files that use older syntax will not be imported correctly.

<sect2>Wavefront OBJ Import Options<label id="impwavopt">
<p>
The following options control the Wavefront OBJ import process:
<itemize>
<item><tt>"FileName"</tt> is the name of the Wavefront OBJ file (version 3.0)
<item><tt>"MergeFaces"</tt> controls, whether consecutive polygonal
faces should be merged into a single PolyMesh object for import.
<item><tt>"MergePVTags"</tt> controls, whether the PV tags of PolyMesh
objects should be merged as well if they are subject to automatic
merging (see above).
<item><tt>"ReadCurves"</tt> if this is disabled, no freeform curves will
be imported. This option does <em>not</em> influence the import of trim curves!
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
imported objects.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 100 percent, the objio plugin is reading lines from the
Wavefront OBJ file and creating Ayam objects. The number may be a
bit off occasionally, as the progress meter just counts lines and
assumes a fixed medium line length of 28 characters.
</itemize>

<sect1>Wavefront OBJ Export<label id="expwav">
<p>
Since Ayam 1.7, it is possible to export scenes or objects to the Wavefront
OBJ format (version 3.0). Since Ayam 1.13, Wavefront OBJ export is a plugin
(objio) that needs to be loaded before export.
The corresponding main menu entry is <tt>"File/Export/Wavefront OBJ"</tt>
(if this menu entry is not available, you have to load the <tt>"objio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).

<sect2>Ayam Object and Properties Support
<p>
The Wavefront export currently supports the following
objects:
<itemize>
<item>NCurve and objects that may be converted to NCurve
objects (ICurve, ConcatNC, ExtrNC)
<item>NPatch (with trim curves) and objects that may be converted
to NPatch objects (BPatch, PatchMesh, Revolve, Sweep, Extrude, Skin,
Cap, Gordon, Birail1, Birail2, Text); since Ayam 1.8.3 also Quadrics
will be automatically converted to NURBS surfaces and exported
<item>PolyMesh and objects that may be converted to PolyMesh objects
(MetaObj), faces with holes are not supported by the Wavefront OBJ
format and will be tesselated to triangles for export automatically
<item>Box
<item>Instance, Clone; both will be resolved to normal objects for export
as Wavefront OBJ does not support referenced geometry
<item>Level, CSG operations are not supported and will be written
as normal Level objects, transformations will be delegated
to the child objects
</itemize>

Since the Wavefront OBJ format does not support separate transformation
attributes, all transformation attributes will be used to transform the
coordinate values (the control points) of the exported objects.
The hierarchy of the Ayam scene will be squashed.
<p>
CSG operations are fully ignored, all objects will be written
as if combined by the union operator.
<p>
The Wavefront OBJ export, currently, ignores all material information.
Only the pure geometry information is written to the OBJ file.
Since Ayam 1.8.3, however, texture coordinates from primitive variable
tags can be exported.
<p>
Since Ayam 1.9, UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
<p>
Light sources, as well as Cameras, and Views will not be exported.
<p>
Object names will be exported as <tt>o</tt> statements.

<sect2>Wavefront OBJ Export Options<label id="expwavopt">
<p>
The following parameters control the Wavefront OBJ export:
<itemize>
<item><tt>"FileName"</tt> is the filename of the Wavefront OBJ file;
<item><tt>"WriteSelected"</tt> exports only the currently selected object(s);
<item><tt>"TessPoMesh"</tt> automatically tesselates all PolyMesh objects
to triangles for export;
<item><tt>"WriteCurves"</tt> toggles writing of NURBS curves and NURBS
curve providing objects to the exported Wavefront OBJ file (This option does
<em>not</em> influence the export of trim curves.);
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
exported objects;
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 100 percent, the objio plugin is writing the Ayam objects
to the Wavefront OBJ file.
</itemize>

<sect1>3DMF (Apple) Import<label id="imp3dmf">
<p>
Using the MFIO plugin you may import scenes from the 3DMF format
(QuickDraw 3D Metafile)
from Apple with the help of a free 3DMF parser created
by Duet Development Corp. and distributed by Apple.
Start importing a 3DMF file using the menu entry
<tt>"File/Import/Apple 3DMF"</tt> (if this menu entry is not available,
you have to load the <tt>"mfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The MFIO plugin only supports the 3DMF version 1.0!

<sect2>3DMF Primitive and Attribute Support
<p>
The MFIO plugin supports import of the following geometric primitives:
<itemize>
<item>Polyline, Triangle, TriGrid, Polygon, general Polygon, Box,
<item>NURBS curve, NURBS surface (with trim curves),
<item>Ellipsoid, Cylinder, Cone, Disk, and Torus.
</itemize>
<p>
The following table comprehensively lists the supported 3DMF primitives
and their Ayam counterparts that will be created upon import.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/3DMF Primitive/|<bf/Ayam Object/@<hline>
Polyline|NCurve@<hline>
Triangle|PolyMesh@<hline>
TriGrid|PolyMesh@<hline>
Polygon|PolyMesh@<hline>
Box|Box@<hline>
Ellipsoid|Sphere@<hline>
Cylinder|Cylinder@<hline>
Cone|Cone@<hline>
Disk|Disk@<hline>
Torus|Torus@<hline>
NURBCurve|NCurve@<hline>
NURBCurve2D|NCurve@<hline>
NURBPatch|NPatch@<hline>
Container|Level@<hline>
</tabular>
<caption>3DMF (Apple) Import Conversion Table</caption>
</table>

The following transformations are supported in 3DMF import:
<itemize>
<item>Scale,
<item>Translate,
<item>Rotate, RotateQuaternion, RotateAxis (if axis is X, Y, or Z).
</itemize>
<p>
Furthermore, the import plugin reads the structure of the scene from Container
objects. Reference objects will be resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
Support for import of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect2>3DMF Import Options<label id="imp3dmfopt">
<p>
The following parameters, additionally, control the 3DMF import:
<itemize>
<item><tt>"FileName"</tt> is the filename of the 3DMF file to import;
<item><tt/"ScaleFactor"/: The <tt/"ScaleFactor"/ option allows to apply a
scaling factor to all imported objects.
<item><tt/"ReadCurves"/:
If the <tt/"ReadCurves"/ import option is switched off, no curves will be
imported. This option does <em>not</em> influence the import of trim curves.
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
</itemize>

<sect1>3DMF (Apple) Export<label id="exp3dmf">
<p>
Using the MFIO plugin you may export scenes to the 3DMF format
(QuickDraw 3D Metafile)
from Apple with the help of a free 3DMF parser created by Duet
Development Corp. and distributed by Apple. Start exporting to a
3DMF file using the menu entry <tt>"File/Export/Apple 3DMF"</tt>
(if this menu entry is not available, you have to load the <tt>"mfio"</tt>
plugin using the menu entry <tt>"File/Load Plugin"</tt> first).
<p>
The MFIO plugin only supports the 3DMF version 1.0!

<sect2>Ayam Object and Properties Support
<p>
The MFIO export supports the following geometric objects:
<itemize>
<item>NURBS curve and NURBS surface (with trim curves) including all
NURBS curve/surface providing objects, such as ICurve, Skin etc.,
<item>Sphere, Disk, Cone, Cylinder, Torus,
<item>Box, and PolyMesh.
</itemize>

Objects of types not listed here will be converted to NURBS
(if possible) or to PolyMesh objects automatically for export.
<p>
All transformations are supported and will be written as
Translate, Rotate, and Scale transformations, respectively.
<p>
All Instance objects will be resolved for export.
Level objects (regardless of type) will be written as Container objects.
<p>
If an object has a material, the color and opacity of the material
will be written as DiffuseColor and TransparencyColor, if the respective
red color component has a value different from -1.
<p>
Support for export of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect2>Trim Curves Support
<p>
The 3DMF file format specification for version 1.0 is unfortunately very
terse, when it comes to trim curves. There is no clearly defined way of
saving trim curves in 3DMF 1.0. However, the method presented here is the
only way that works with the free provided 3DMF parser.
Trimmed NURBS patches will be written by Ayam like this:
<code>
Container (
	NURBPatch ( ...
        )
	[transformations & attributes of NURBS patch]
	TrimCurves ( )
	NURBCurve2D ( ...
	)
	Container (
	        NURBCurve2D ( ...
	        )
	        NURBCurve2D ( ...
	        )
        )
)
</code>
There will always be an enclosing container for a NURBS patch.
If the patch is trimmed, after the transformations and attributes
of the patch, a <tt/TrimCurves/ element will follow (which does
<em>not</em> contain the trim curves but is empty). The trim curves follow
now as 2D NURBS curves (simple trims) or container objects (trim loops)
with 2D NURBS curves until the end of the enclosing container. The
transformation attributes of the trim curves will be applied to the NURBS
curve control points for export (there will be no transformations or
attributes for the trim curve elements).
<p>
The Ayam 3DMF import expects the trim curves to be delivered in this
manner.

<sect2>3DMF Export Options<label id="exp3dmfopt">
<p>
The following parameters, additionally, control the 3DMF export:
<itemize>
<item><tt>"FileName"</tt> is the filename of the 3DMF file to export;
<item><tt/"WriteBinary"/: This option controls whether the text version
or the binary version of the 3DMF file format should be used for export.
<item><tt/"ScaleFactor"/:
The <tt/"ScaleFactor"/ option allows to apply a scaling factor to all
exported objects.
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"WriteCurves"/: If the <tt/"WriteCurves"/ option is disabled,
no curves will be written to the exported 3DMF file. This option does
<em>not</em> influence the export of trim curves.
</itemize>

<sect1>3DM (Rhino) Import<label id="imprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that may import
scenes from the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio - <bf/O/pen<bf/N/URBS <bf/IO/)
by Robert McNeel & Associates.
<p>
Start importing from a Rhino 3DM file using the menu entry
<tt>"File/Import/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The onio plugin only supports import of 3DM files of version 3.0
and earlier.

<sect2>3DM Object Support
<p>
The import functionality of the onio plugin currently covers
import of all NURBS and BRep objects and objects that may
be converted to NURBS with routines from the OpenNURBS toolkit
(those objects are: PolylineCurve, PolyCurve, LineCurve, ArcCurve,
CurveOnSurface, RevSurface, SumSurface, and PlaneSurface).
References will be resolved. Names will be imported, but
converted to an ASCII representation. Since Ayam 1.8.3
also Mesh objects will be imported to PolyMesh objects, texture
coordinates will be read and appropriate PV tags will be
created for them.
<p>
The following table comprehensively lists the supported Rhino
3DM primitives and their Ayam counterparts that will be created
upon import.
<p>
<table loc="ht">
<tabular ca="|c|c|"><hline>
<bf/Rhino 3DM Primitive/|<bf/Ayam Object/@<hline>
PolyLineCurve|NCurve@<hline>
PolyCurve|NCurve@<hline>
LineCurve|NCurve@<hline>
ArcCurve|NCurve@<hline>
CurveOnSurface|NCurve@<hline>
Mesh|PolyMesh@<hline>
NurbsCurve|NCurve@<hline>
NurbsSurface|NPatch@<hline>
RevSurface|NPatch@<hline>
SumSurface|NPatch@<hline>
PlaneSurface|NPatch@<hline>
</tabular>
<caption>3DM (Rhino) Import Conversion Table</caption>
</table>

<sect2>3DM Import Options<label id="imp3dmopt">
<p>
The 3DM import process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/: The <tt/"ScaleFactor"/ option allows to apply a
scaling factor to all imported objects.
<item><tt/"Accuracy"/: The <tt/"Accuracy"/ import option controls the
tolerance of OpenNURBS internal operations, in this case the value is
mostly used for conversion operations to the NURBS form.
<item><tt/"ReadCurves"/: If the <tt/"ReadCurves"/ import option is
switched off, no curves will be imported. This option does <em>not</em>
influence the import of trim curves.
<item><tt/"ReadLayers"/: By default, all objects from all layers will be
imported.
Using the <tt/"ReadLayers"/ import option, a single layer or a range
of layers may be selected for import.
<item><tt/"ReadSTrim"/: Another import option is <tt/"ReadSTrim"/.
This useful to ignore simple bounding trim loops of NURBS surfaces if
they are the only trim loop for that surface.
Importing this single bounding trim loop would just make the Ayam scene
more complex than needed in many cases.
This option replaces the <tt/"IgnoreFirstTrim"/ import option
available before Ayam 1.13 with slightly different semantics.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling. Since Ayam 1.13 also eventually
present trim curves will be scaled properly to the new knot ranges of
NURBS patches.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, OpenNURBS is reading the 3DM file into memory;
from 50 to 100 percent, the onio plugin is converting the 3DM objects
to Ayam objects.
</itemize>

<sect1>3DM (Rhino) Export<label id="exprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that exports scenes
to the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio - <bf/O/pen<bf/N/URBS <bf/IO/)
by Robert McNeel & Associates.
<p>
Start exporting to a Rhino 3DM file using the menu entry
<tt>"File/Export/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the onio plugin currently covers
export of all boxes, quadrics, NURBS, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/) and objects that
may be converted to NURBS curves or surfaces.
Even though export of planar cap surfaces of various
tool objects is supported, the export of general trimmed NURBS
patches is not well supported. This is because of a missing feature
(pushing up 2D trim curves to 3D curves for arbitrary NURBS
surfaces) in the OpenNURBS toolkit. Since Ayam 1.9, a coarse
polygonal 3D representation of the 2D trim curves will be
created automatically, so that now general trimmed NURBS patches
may be exported, albeit with lower quality and bigger file size
as would be necessary.
Since Ayam 1.9, UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
See also section <ref id="ummtag" name="UMM/VMM (U/V Min Max) Tag">.
Since Ayam 1.8.3, also PolyMesh objects may be exported.
<p>
Since the Rhino 3DM file format does not support hierarchy and
transformation attributes per object, the hierarchy of the Ayam scene
will be squashed and all transformation attributes will be applied to
the control points of the objects for export. CSG operations are fully
ignored, all objects will be written as if combined by the union operator.
Furthermore, all instance objects will be resolved to normal objects. All
objects will be written to the first layer, the default layer (unless the
<tt>"TopLevelLayers"</tt> option is used). Object names will be written
as well. Names of level objects will be prepended to the names of their
child objects. The object hierarchy:
<code>
+-Arm(Level)
 | MySphere(Sphere)
 \ MyCylinder(Cylinder)
</code>
for instance, leads to two objects in the Rhino file
named <tt>"Arm/MySphere"</tt> and <tt>"Arm/MyCylinder"</tt>.
<p>

<sect2>3DM Export Options<label id="exp3dmopt">
<p>
The 3DM export process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/: The <tt/"ScaleFactor"/ option allows to apply a
scaling factor to all exported objects.
<item><tt/"Accuracy"/: The <tt/"Accuracy"/ option controls the tolerance
of internal OpenNURBS operations (currently those are:
pushing up 2D trim curves to 3D curves and
checking NURBS surfaces for planarity).
<item><tt/"WriteSelected"/: exports only the selected objects.
<item><tt/"ObeyNoExport"/: ignores all objects with <tt/"NoExport"/ tags.
<item><tt/"IgnoreHidden"/: ignores all hidden objects.
<item><tt/"WriteCurves"/: If the <tt/"WriteCurves"/ option is disabled,
no curves will be written to the exported Rhino 3DM file. This option does
<em>not</em> influence the export of trim curves.
<item><tt/"QuadAsBRep"/: If the <tt/"QuadAsBRep"/ option is enabled
spheres, cylinders, cones, and torii will not be exported as collection
of NURBS surfaces (as converted by Ayam) but as BRep objects (as converted
by the OpenNURBS toolkit).
However, not all features of the quadric objects will be translated in
this case:
The BRep sphere does not support ZMin, ZMax, and ThetaMax.
The BRep cylinder does not support ThetaMax (base caps will
be created if the cylinder is closed).
The BRep cone does not support ThetaMax (a base cap will be
created, if the cone is closed).
The BRep torus does not support PhiMin, PhiMax, and ThetaMax.
The <tt/"QuadAsBRep"/ option has no effect on the export of disks,
hyperboloids, and paraboloids. Those will always be exported as NURBS
surfaces.
<item><tt>"TopLevelLayers"</tt> controls whether the top level Level
objects in the Ayam scene to be exported should be interpreted as layers.
If this option is enabled, all objects in these levels will be placed on
the respective layer. Objects that are not in one of those levels
will be written to the default layer. Furthermore, top level object names
will become layer names.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the onio plugin is converting the Ayam objects
to 3DM objects; from 50 to 100 percent OpenNURBS is writing the 3DM file.
</itemize>

<sect1>X3D (Web3D) Import<label id="impx3d">
<p>
Since version 1.13 Ayam provides a plugin named <tt>"x3dio"</tt> that may
import scenes from the XML based X3D file format published by the Web3D
Consortium. The XML parser used in this plugin is based on Expat and SCEW.
<p>
Binary and compressed versions of X3D, as well as VRML files are <em/not/
supported! Only pure XML files are read by the <tt>"x3dio"</tt> plugin.
<p>
Start importing from a Web3D X3D file using the menu entry
<tt>"File/Import/Web3D X3D"</tt>
(if this menu entry is not available, you have to load the
<tt>"x3dio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
<sect2>X3D Element Support
<p>
The import functionality of the <tt>"x3dio"</tt> plugin currently covers
import of the following X3D elements (grouped by components):
<itemize>
<item>Geometry3D:
Box, Sphere, Cylinder, Cone, ElevationGrid, Extrusion,
IndexedFaceSet, IndexedTriangleSet, IndexedTriangleStripSet,
IndexedTriangleFanSet, TriangleSet, TriangleStripSet, TriangleFanSet,
IndexedLineSet, and LineSet.
<p><p>
Cylinders with just one cap are imported as two objects (a Cylinder and
a Disk). In all other cases and also for Cones, the <tt>"Closed"</tt>
attribute of the Ayam object is set according to the cap information of
the X3D element.
<p>
ElevationGrids are imported as bilinear patch meshes.
<p><p>

<item>Geometry2D:
Arc2D, ArcClosed2D, Circle2D, Disk2D, Polyline2D.
<p><p>
Arcs and Circles are imported as NCircle objects.
Closed arcs and Polylines are imported as NURBS curves.
Disks with an inner radius > 0.0 are imported as flat Hyperboloids
(otherwise as Disks).
<p><p>

<item>NURBS:
NurbsCurve, NurbsCurve2D, NurbsPatchsurface,
TrimmedNurbsPatchsurface, Contour2D, ContourPolyline2D,
NurbsSweptSurface, NurbsSwungSurface, NurbsSet.
<p><p>
All NURBS elements are fully supported.
<p><p>

<item>CAD:
QuadSet, IndexedQuadSet, CADLayer, CADAssembly, CADPart, CADFace.
<p><p>
CADLayer objects will be imported as top level level objects.
CADAssembly and CADPart objects will be imported as level objects.
<p><p>

<item>Light sources:
DirectionalLight, PointLight, SpotLight.
<p><p>
The lights will be directly mapped to the standard RenderMan
light sources distant, point, and spot, respectively.
Therefore, the <tt>"radius"</tt> and the <tt>"attenuation"</tt> attributes
of point and spotlights are not supported. However, point and spotlights
still have a quadratic falloff with distance.
<p><p>

<item>Navigation:
Viewpoint.
<p><p>
Viewpoint elements will be imported as view objects (with corresponding
view window) or camera objects depending on the <tt>"ReadViewpoints"</tt>
import option.
<p><p>

<item>Non geometric/Scene structure:
Transformation, Shape, Group, Inline.
<p><p>
Shear transformations are not supported.
<p>
The semantics for inlining are currently not fully standards compliant.
By default, DEFs in inlined files live in their own namespace.
It is not possible to USE a DEF from an inlined file in the
inlining file.
However, if the <tt>"MergeInlineDefs"</tt> import option is switched on,
<em>all</em> DEF namespaces (of inlining and inlined files) will be
merged into one big namespace.
Now it would be possible to USE a DEF from an inlined file in the
inlining file. But beware, this only works correctly, if the DEF
names in all the files are unique.
It is not possible to transfer single definitions from an inlined file
to the inlining file or from the inlining file to the inlined file.
<p>
Also note: Inline URLs that do not point to the file system are not
supported.

</itemize>

Unsupported X3D elements will be silently ignored. Prototyping and
dynamic scenes as well as scripts are not supported.
<p>
Shape elements that contain more than one geometric elements as child
objects will be imported as level objects with the child objects using
the default transformations and the level object using the current
transformation attributes.
<p>
The following table comprehensively lists the supported Web3D
X3D primitives and their Ayam counterparts that will be created
upon import.
<p>
<table loc="!ht">
<tabular ca="|c|c|c|c|"><hline>
<bf/X3D Primitive/|<bf/Ayam Object/|<bf/X3D Primitive/|<bf/Ayam Object/@<hline>
<em/Geometry3D:/|&ensp;|<em/CAD:/|&ensp; @<hline>
Box|Box|QuadSet|PolyMesh@<hline>
Sphere|Sphere|IndexedQuadSet|PolyMesh@<hline>
Cylinder|Cylinder|CADLayer|Level@<hline>
Cone|Cone|CADAssembly|Level@<hline>
ElevationGrid|PaMesh|CADPart|Level@<hline>
Extrusion|PolyMesh|CADFace|Level@<hline>
IndexedFaceSet|PolyMesh|<em/Light:/|&ensp;@<hline>
IndexedTriangleSet|PolyMesh|DirectionalLight|Light@<hline>
IndexedTriangleStripSet|PolyMesh|SpotLight|Light@<hline>
IndexedTriangleFanSet|PolyMesh|PointLight|Light@<hline>
TriangleSet|PolyMesh|&ensp;|&ensp;@<hline>
TriangleStripSet|PolyMesh|&ensp;|&ensp;@<hline>
TriangleFanSet|PolyMesh|&ensp;|&ensp;@<hline>
IndexedLineSet|NCurve|&ensp;|&ensp;@<hline>
LineSet|NCurve|&ensp;|&ensp;@<hline>
<em/Geometry2D:/|&ensp;|&ensp;|&ensp;@<hline>
Arc2D|NCircle|&ensp;|&ensp;@<hline>
ArcClosed2D|NCurve|&ensp;|&ensp;@<hline>
Circle2D|NCircle|&ensp;|&ensp;@<hline>
Polyline2D|NCurve|&ensp;|&ensp;@<hline>
Disk2D|Disk&thinsp;/&thinsp;Hyperboloid|&ensp;|&ensp;@<hline>
<em/NURBS:/|&ensp;|&ensp;|&ensp;@<hline>
NurbsCurve|NCurve|&ensp;|&ensp;@<hline>
NurbsCurve2D|NCurve|&ensp;|&ensp;@<hline>
NurbsSurface|NPatch|&ensp;|&ensp;@<hline>
NurbsPatchsurface|NPatch|&ensp;|&ensp;@<hline>
TrimmedNurbsPatchsurface|NPatch|&ensp;|&ensp;@<hline>
NurbsSweptSurface|Sweep|&ensp;|&ensp;@<hline>
NurbsSwungSurface|Swing|&ensp;|&ensp;@<hline>
</tabular>
<caption>X3D (Web3D) Import Conversion Table</caption>
</table>

<sect2>X3D Attribute Support
<p>
The <tt>"solid"</tt>, <tt>"ccw"</tt>, and <tt>"convex"</tt>
attributes are always ignored.
<p>
The <tt>"DEF"</tt> and <tt>"USE"</tt> attributes are supported for all
elements, however, the corresponding master-instance relationships are
completely resolved upon import.
Instances of objects may be easily created again using Automatic Instancing
(please refer to section <ref id="ai" name="Automatic Instancing">).
<p>
Normals will currently not be generated automatically for any X3D element
and thus the <tt>"creaseAngle"</tt> attribute will be fully ignored.
Note however, that if normals are specified e.g. for an
<tt>"IndexedFaceSet"</tt> element, they will be imported correctly.
<p>
The <tt>"DEF"</tt> attributes will be converted to object names
in some cases.

<sect2>X3D Import Options<label id="impx3dopt">
<p>
The following options further control the X3D import process:
<itemize>
<item><tt>"FileName"</tt> is the name of the X3D file to be imported
<item><tt>"ReadCurves"</tt> if this is disabled, no freeform curves will
be imported. This option does <em>not</em> influence the import of trim curves!
<item><tt>"ReadViewpoints"</tt> controls whether viewpoints should
be read as view, camera, or not at all.
<item><tt/"ReadSTrim"/ if switched off, no simple trims (trims that only
run along the border of a NURBS patch) will be imported if they are the
only trim curves.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. A <tt/"RescaleKnots"/ value of
1.0e-04 leads to NURBS that may be safely drawn using GLU.
The default value 0.0 means no scaling.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
imported objects.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"ErrorLevel"/, this option controls how many error messages
should be printed to the Ayam console while importing. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, the x3dio plugin is reading the XML file,
from 50 to 100 percent the x3dio plugin is creating Ayam objects.
</itemize>

<sect1>X3D (Web3D) Export<label id="expx3d">
<p>
Since version 1.13 Ayam provides a plugin named x3dio that exports
scenes to the XML based X3D file format published by the Web3D Consortium.
The XML parser used in this plugin is based on Expat and SCEW.
<p>
Start exporting to a X3D file using the menu entry
<tt>"File/Export/Web3D (X3D)"</tt>
(if this menu entry is not available, you have to load the
<tt>"x3dio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).

<sect2>Ayam Object and Properties Support
<p>
The export functionality of the x3dio plugin currently covers
export of all boxes, quadrics, NURBS, PolyMeshes, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/) and objects that
may be converted to NURBS curves or surfaces or to PolyMeshes.
<p>
Some NURBS tool objects can be exported as parametric NURBS nodes,
e.g. Sweep objects may be exported as NurbsSweptSurface nodes.
<p>
The scene hierarchy (level objects) will be converted to a
matching transform node hierarchy.
<p>
CSG operations are fully ignored, all objects will be written as
if combined by the union operator.
<p>
Clamping the knot ranges of NURBS via UMM/VMM tags is not supported.
<p>
PolyMesh objects will be exported to IndexedFaceSet nodes.
PolyMesh faces with holes are automatically tesselated. PolyMesh faces
with more than three points are tesselated if the export option
<tt>"TessPoMesh"</tt> is used.
All tesselated faces will be exported to a second IndexedFaceSet
element.
<p>
Light sources are exported if they are point, distant, or spot lights.
<p>
Cameras and Views are exported as Viewpoint nodes. Note however, that
X3D always assumes a perspective viewing transformation. This means,
views of type <tt/"Front"/, <tt/"Side"/, or <tt/"Top"/ will not be
exported properly.
<p>
Object names will be converted to DEF attributes.
<p>
Instances can be resolved or exported as USE/DEF pairs.

<sect2>X3D Export Options<label id="expx3dopt">
<p>
The following parameters, additionally, control the X3D (Web3D) export:
<itemize>
<item><tt>"FileName"</tt> is the filename of the X3D file;
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
exported objects;
<item><tt>"WriteSelected"</tt> exports only the currently selected object(s);
<item><tt>"ObeyNoExport"</tt> toggles export of objects with <tt/"NoExport"/
tags;
<item><tt>"IgnoreHidden"</tt> toggles export of hidden objects;
<item><tt>"TessPoMesh"</tt> automatically tesselates all PolyMesh objects
to triangles for export;
<item><tt>"WriteCurves"</tt> toggles writing of NURBS curves and
NURBS curve providing objects to the exported file (This option does
<em>not</em> influence the export of trim curves.);
<item><tt>"WriteViews"</tt> controls whether views should be exported as
view points;
<item><tt>"WriteParametrics"</tt> toggles writing of the following
tool objects as plain NURBS surface or higher level primitives:
Revolve as NurbsSwungSurface, Sweep as NurbsSweptSurface, Extrude as
NurbsSweptSurface);
<item><tt>"ResolveInstances"</tt> controls, whether instance objects should
be resolved to normal objects or exported as DEF/USE pairs, note that no
attempt is made to detect whether the master objects (the DEFs) will be
exported for all exported instances (USE); this may happen especially in
conjunction with the X3D export options <tt>"WriteSelected"</tt> or
<tt>"IgnoreHidden"</tt>, erroneous X3D files may result unless the
<tt>"ResolveInstances"</tt> option is switched on;
<item><tt>"TopLevelLayers"</tt> arranges for all child objects of top level
objects in the Ayam scene to be put in CADLayer nodes;
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates (see also section
<ref id="pvtag" name="PV (Primitive Variable) Tag">).
<item><tt/"ErrorLevel"/ determines which messages should be output
during export;
<item><tt/"Progress"/ displays the progress of the export;
from 0 to 50 percent, the x3dio plugin is creating a XML document
in memory and from 50 to 100 percent this XML document will be written
to the X3D file.
</itemize>

<sect>Miscellaneous
<p>
This section contains all information about Ayam not fitting elsewhere.

<sect1>The Undo System<label id="undos">
<p>
Using the undo system, you may correct mistakes you made while modelling.
However, only modifications of objects are undoable. This includes changes
made by modelling actions, changes made using property GUIs, but also
changes to views (type changes or changes to the camera settings associated
with a view).
<p>
It is currently <em>not</em> possible to undo any changes to the object
hierarchy, including clipboard (e.g. cut, paste) and drag-and-drop
operations. If you delete an object, it is gone! If you, accidentally, move
an object using drag-and-drop, undo will not help!
<p>
The undo system works by storing copies of the different states of changed
objects in an undo buffer. You may step backward through the saved states using
<tt/&lt;Ctrl+z&gt;/ (undo) but also forward using <tt/&lt;Ctrl+y&gt;/ (redo).
<p>
The storage space occupied by the undo buffer may be adjusted using the
preferences (<tt>"Prefs/Modelling/UndoLevels"</tt>). A value of -1 for
<tt>"UndoLevels"</tt> completely disables the undo system.
The values 0 and 1 are not allowed. The value 2 means that there is
always one state of the scene that can be restored, plus, a potential
undo operation can also always be undone using redo.
<p>
The changes that would be undone or redone are shown in abbreviated form
in the prompt of the Ayam console and, since Ayam 1.14, in the main menu
entries <tt>"Edit/Undo"</tt> and <tt>"Edit/Redo"</tt>.
<p>
Several actions will completely clear the undo buffer (no undo is
possible after those actions):
Delete Object, New Scene, Open (Replace) Scene, and Close View.
<p>
Note that undo/redo will also modify objects that currently reside in the
object clipboard (if they have saved states in the undo buffer).
This means that the following sequence of operations leads to a sphere
placed at <tt>"0,0,0"</tt>:
<code>
create Sphere (at 0,0,0)
move Sphere (to 1,1,0)
cut Sphere (to clipboard)
undo
paste Sphere (from clipboard)
</code>

<sect1>The Modelling Concept Tool-Objects<label id="toolobj">
<p>
This section introduces the modelling concept <em>Tool-Objects</em>,
as used in Ayam.
<p>
In a standard modelling application, to create a surface of revolution,
one would either first create a curve then call the revolve tool to get
an appropriate surface (losing the curve as object, or even keeping it,
but without relation to the surface), or call the revolve tool first,
which would then require the user to draw a curve with similar results:
the created surface will typically lose the relation to the surface of
revolution tool and the curve (even if kept intact) will lose the relation
to the surface. There is no easy way to change parameters for the surface
creation or to change the geometry of the curve later on without doing it
all over again.
<p>
The modelling concept Tool-Objects overcomes these drawbacks by
transforming the revolve <em>tool</em> into a scene <em>object</em>.
<p>
The following example hierarchy shows two objects in a parent-child relation:
<code>
+-Tool_Object(Revolve)
 |         ^
 |         :
 |   <Notification>
 |         :
 \ Parameter_Object(NCurve)
</code>
The parent object is called <em>Tool-Object</em> and the child object is
called <em>Parameter-Object</em>. There is a flow of information from the
parameter object to the tool object. This information flow is controlled
by the so called <em>Notification</em> mechanism. The notification mechanism
makes sure that whenever the parameter objects change, the tool object is
informed so that it may adapt to the changes.
For interactive modelling actions, the notification will be carried out
while dragging the mouse or after release of the mouse button (i.e. after
the modelling action finished),
depending on the main preference setting <tt/"LazyNotify"/.
<p>
In the example above, a NURBS curve is the parameter object and the
tool object is creating a surface of revolution from the curve data.
The NURBS curve and parameters of the Revolve object may change at any
time. When saved to an Ayam scene file, no surface data will be written,
leading to very small files that additionally contain a modelling history
and capture design intent to a certain degree.
<p>
Tool objects may be parameter objects of other tool objects:
<code>
+-Tool_Object(ExtrNP)
 +-Parameter_and_Tool_Object(Revolve)
  \ Parameter_Object(NCurve)
</code>
and there may be more than one parameter object per tool object:
<code>
+-Tool_Object(Skin)
 | Parameter_Object_1(NCurve)
 | Parameter_Object_2(NCurve)
 | ...
 \ Parameter_Object_n(NCurve)
</code>
<p>
Tool objects create new geometric objects from the information delivered
by the parameter object(s) or they modify the parameter object(s) and
deliver them to their respective parent object.
<p>
The pure hierarchical dependency scheme may be broken up by instance objects:
<code>
+-Tool_Object(Revolve)
 \ Parameter_Object(NCurve) --------------
+-Tool_Object(Revolve)                    | !
 \ Parameter_Object(Instance_of_NCurve) <-
</code>
In the scene above, the second Revolve tool object depends on the shape
of the first parameter object. The Instance object transports the data
from one part of the hierarchy to another.
The notification mechanism is aware of this and initiates updates
in the scene hierarchy wherever needed and efficiently (not updating any
objects twice) according to the <tt/"CompleteNotify"/ main preference
setting. In the example above, due to complete notification, the second
Revolve object will get updated automatically whenever the original
NCurve object changes.
<p>
Two other mechanisms exist, that help tool objects to get the information
they need and to increase flexibility in hierarchy building and modelling:
<em>Provision</em> and <em>Conversion</em>. Both mechanisms are quite similar
and convert objects temporarily/transparently (provision) or finally
(conversion) from one type to another, e.g. they convert an ICurve
(interpolating curve) to a plain NCurve (NURBS curve).
<p>
Due to the provision mechanism, an ICurve object could be used instead
of an NCurve as parameter object in all examples above easily.
And with the help of the conversion mechanism, the Revolve
tool objects could be converted to plain NPatch objects (e.g. for
modelling operations not available to Revolve objects).
<p>
Note that instance objects are subject to a second round of provision,
i.e. the master does not need to be of the wanted type but rather
provide the wanted type.
<p>
Even though, theoretically, every tool could be implemented as tool object,
this has not been done in Ayam (mainly, because this would unnecessarily
increase the code base). Only the most often used tools that convey and
capture much design intent were implemented as tool objects (those are
surface or curve creating tools). But also seldom used tools can be elevated
to nearly full tool object capabilities through the employment of the concept
of scripting objects
(see section <ref id="scriptobj" name="Script Object">).
<p>
This can be done easily by e.g. creating script objects of type <tt/"Modify"/
that call those tools from their script (after possible conversion of the
provided object(s) to a proper type, the tool may need to operate on).
Even property GUIs to let the user adjust tool parameters as they know it
from the other Ayam objects can be added and different tools can be combined
in single objects with normal script code for unmatched flexibility.
But let us see a simple example first:
<code>
+-Skin
 +-Script
  \ ExtrNC
</code>
In the scene hierarchy above, the script object could be simply reverting the
extracted curve with code like this:
<code>
convOb -inplace; revertC
</code>
effectively elevating the tool <tt/"revertC"/ to an object.
<p>
A more useful example can be found in the Marsrakete sample scene
(as available from the Ayam home page). Here, a curve extracted
from a patch is trimmed to the right length using a script like this:
<code>
convOb -inplace; trimNC 0.0 0.5
</code>.
See section <ref id="scriptobjex" name="Script Object Example"> for
information on how this script might be expanded to support a
GUI and more error checking.


<sect1>Ayamrc File<label id="ayamrc">
<p>
To customize Ayam the ayamrc file may be used.
This file is either pointed to by the environment
variable <tt>AYAMRC</tt> or is determined as following:
<itemize>
<item>On Unix it is <tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On the Win32 platform (Windows95 - XP) it is
<tt>"&dollar;(HOME)/ayamrc"</tt> if the environment variable
<tt>HOME</tt> exists, else <tt>"&dollar;(TEMP)/ayamrc"</tt>.<p>
<item>On Mac OS X Aqua (not X11!) it is
<tt>"&tilde;/Library/Preferences/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On Mac OS X X11 (not Aqua!) it is
<tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
</itemize>

The ayamrc file is read on each start of Ayam and saved again on exit
(if the preference setting <tt>"Main/AutoSavePrefs"</tt> is enabled).
<p>
The ayamrc file contains:
<enum>
<item>preference settings (including some hidden settings that require
just occasional tweaking and are not reachable using the GUI preference
editor)
<item>position and size of the main window and the toolbox window
<item>keyboard shortcuts to menu entries and modelling actions
<item>RiOption and RiAttribute databases
</enum>

You may edit the file with any text editor, but keep in mind, that the
file will be parsed by Tcl. Should you, for some reason, destroy your
ayamrc so that Ayam does not start correctly anymore you can start Ayam
with the command line option <tt>"-failsafe"</tt>.
When the application is left the next time, or the main menu entry
<tt>"File/Save Prefs"</tt> is invoked, a correct ayamrc file will be
created again.
All preference settings will be reset to factory defaults and all your
edits will be lost, however!
<p>
Another way to reset the ayamrc file is to simply delete the file manually
or using the main menu entry <tt>"Special/Reset Preferences"</tt>.
<p>
To reset single elements to factory defaults, just remove the corresponding
lines from the ayamrc file.
<p>
Finally, resetting single preference settings without a text editor is
also possible with the help of the scripting interface by manipulating
the global <tt/"ayprefs"/ array. The following example leads to a reset
of the tolerance preference setting to the factory default for the
<em>next</em> start of Ayam.
<code>
unset ayprefs(Tolerance)
</code>

<sect2>Changing Keyboard Shortcuts
<p>
You may adapt the keyboard shortcuts used in the GUI to your special
needs using the ayamrc file. Note that if you do that the GUI (the menu
entries and the <tt>"Show Shortcuts"</tt> window)
will adapt to your changes but certainly neither this documentation nor
the tutorials!
Ayam does not check for clashes! This means, the last set binding
for a key will be used.
On Unix, the output of the program <tt/"xev"/ and the
manual page for the <tt/"bind"/ command of Tk provide helpful
information about which strings may be used to describe
key presses.
You can also directly use the Ayam console to infer key names, just enter:
<code>
toplevel .keytest
bind .keytest <Key> {puts %K}
</code>
into the Ayam console.
Now you can activate the new top level window and type on your keyboard
while the Ayam console prints the names of the keys.
<p>
For your convenience, the special string <tt/"Ctrl"/ will be replaced by
<tt/"Control"/ before a shortcut is handed to the <tt/bind/ command.
<p>
Example:
<code>
set aymainshortcuts(Prefs) {Ctrl-p}
</code>
sets the keyboard shortcut for opening of the preferences editor
to <tt/&lt;Ctrl+p&gt;/.
See the ayamrc file itself for a complete listing of available shortcuts.

<sect2>Hidden Preference Settings<label id="hidprefs">
<p>
The ayamrc file currently contains the following adjustable hidden
preference settings:
<itemize>

<item><tt/"Balloon"/: time in ms until the tooltip window appears
(default: 1500ms - 1.5s)

<item><tt/"EFlush"/: time in ms between two flushes of the error message
buffer (default: 2000ms - 2s)

<item><tt/"toolBoxList"/: a list of sections or groups of buttons
describing the appearance of the toolbox window (default, using all
available sections: <tt>{trafo trafo2 solids misco nurbs toolobjs points
nctools1 nctools2 camera misc}</tt>)

<item><tt/"Kill"/: name of a program that kills other processes and accepts
a process id as argument (used by the Rendering GUI)
(default: <tt>"kill"</tt>) (a setting of <tt>"kill"</tt> will be
automatically replaced by <tt>"kill.exe"</tt> on Win32)
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.

<item><tt/"Cat"/: name of a program that can read from and write to
a pipe (used by the Rendering GUI) (default: <tt>"cat"</tt>)
(a setting of <tt>"cat"</tt> will be
automatically replaced by <tt>"cat.exe"</tt> on Win32)

<item><tt/"KeepNTmpFiles"/: how many
incarnations of the scene in RIB form (which actually may be split
in more than one file due to e.g. instances) created when directly
rendering from a view window should be kept on disk (default: 5)

<item><tt/"WarnPropPasteToSel"/: should
<tt>"Special/Clipboard/Paste Property to Selected"</tt> raise a warning
requester? (default: 1 - yes)

<item><tt/"WarnUnknownTag"/ controls the warning messages for
unknown tag types. (default: 1 - yes)

<item><tt/"DailyTips"/: a list of strings that appear as tips
on startup in the console (default: large)

<item><tt/"PickTolerance"/: the tolerance used to determine whether an object
should be picked or not (default: 5); this setting determines the size
of a rectangular area around the picked point in pixels, all objects that
are inside or touch this area are considered picked

<item><tt/"MaxTagLen"/: the maximum number of characters to be displayed
in the buttons in the Tag Property GUI (default: 30)

<item><tt/"Wait"/: set this to <tt/"waitPid"/ if you want to enable
the work around for zombie processes created by the Rendering GUI.
This is e.g. necessary for the Linux platform.

<item><tt/"Prompt"/: controls the prompt for the Ayam console. If
set to an empty string, a default of
<code>
\[Undo:$ay(undoo)/Redo:$ay(redoo)\].../[file tail [pwd]]&gt;
</code>
will be used, which displays the name of the operations that you can
undo and redo and the last component of the current
directory of Ayam like this <tt>"[Undo:None/Redo:None].../scn&gt;"</tt>.
You may e.g. change this to <tt/"[pwd]&gt;"/ to see just the full path
name of the current directory. If you want to display the value of a
variable in the prompt (e.g. designating the current level in
the scene hierarchy) you need to bind a write-trace to that variable.
The write trace in turn must call the procedure <tt/"ayam_updateprompt"/
and may e.g. be established using a small script like this:
<tt/"trace variable &lt;vname&gt; ayam_updateprompt"/.

<item><tt/"BackupExt"/: is the file name extension to be used for backup
files. Default values are <tt>"&tilde;"</tt> for Unix and
<tt>".bak"</tt> for Win32.

<item><tt/"SelXOR_R"/, <tt/"SelXOR_G"/, <tt/"SelXOR_B"/: determine
a color value that is used for drag selection rectangles.
Note that the color is not used directly but combined with the
color value of already drawn pixels by XOR. The default values
are 255 for the red, 128 for the green, and 0 for the blue component.

<item><tt/"IconGamma"/: this setting may be used to adapt the contrast
of all icons (in view menu and the toolbox) to your display gamma. If you
are on a SGI it is recommended to set this to about "0.7". The default
value <tt>""</tt> leads to no changes of any icon images.

<item><tt/"AddViewParams"/ allows to add custom parameters to the
view OpenGL widget creation, like e.g. <tt/"-stereo true"/. The default
value is <tt>""</tt>.

<item><tt/"AskScriptDisable"/ controls the warning dialog that
appears if scenes with script objects or tags are loaded. The default
value is 1 - yes, warn about script objects and tags.

<item><tt/"FixX11Menu"/ enables a workaround for non-sticky menus
on X11 (displaced menus do not stay open). This option is enabled
by default and not used on the Win32 and Aqua platforms.

<item><tt/"FixDialogTitles"/, this option prepends the title of a message box
that is normally displayed in the window frame of the message box to the
message in the box. This may be necessary because on some systems the title
string might be displayed in an unreadable font or not at all.
On Mac OS X Aqua (not X11!) this option is enabled by default.
On all other systems this option is disabled by default.

<item><tt/"FixImageButtons"/, enables a workaround for buttons (e.g.
in the toolbox) that stay depressed when used. This option is disabled
by default on all platforms.

<item><tt/"SafeAutoFocus"/ disables AutoFocus
(see section <ref id="prefgui" name="preference settings">)
when certain dialog windows are open, so that they do not get
shuffled under other windows by accidental mouse movements on systems
where the window manager does only auto raise in conjunction with
auto focus.
This option is enabled by default on Win32.

<item><tt/"UseInternalFD"/ switches to an internal file dialog for loading
of plugins. This option is only used on MacOSX/Aqua (not X11!), because
there the normal file dialog will not enter application bundle directory
structures. This option is enabled by default on MacOSX/Aqua and not
used on any other platform.

<item><tt/"SwapMB"/, <tt/"SwapMBSC"/ allow to swap mouse buttons 2 and 3
on MacOSX/Aqua (not X11!) for specified mouse bindings (<tt/"SwapMBSC"/),
because on MacOSX/Aqua, traditionally, the naming of the
middle and rightmost mouse button is reversed compared to X11/Win32.
This option is enabled by default on MacOSX/Aqua and allows to use
the same set of mouse bindings (the same ayamrc file) for X11 and
Aqua without sacrificing user experience. The middle mouse button,
by default, zooms the view, and the right one moves the view.

<item><tt/"CursorEnd"/, this option is enabled by default. If switched
on, the first click into the console will move the cursor to the input
prompt, ready for command input, instead of moving the cursor to the
point of the click.

<item><tt/"LineWidth"/, line width used for drawing the lines of
unselected objects (blue lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"SelLineWidth"/, line width used for drawing the lines of
selected objects (white lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"ALFileTypes"/, <tt/"ALPlugins"/ two lists that describe
file name extensions and corresponding plugins that import and export
files of the type designated by the file name extensions.

<item><tt/"AUCommands"/, commands that will be run in the console
when <tt/&lt;Shift+Return&gt;/ is used instead of <tt/&lt;Return&gt;/.
See also section <ref id="sciupd" name="Updating the GUI">.
The default value is <tt>"uS;rV;"</tt>, leading to a complete
update of the object hierarchy, the property GUI and all view
windows.

<item><tt/"PolyOffset0"/, <tt/"PolyOffset1"/ two float values, that
control the offsetting of shaded surfaces in the shade and draw
drawing mode (so that the curves always appear on top of the surfaces).
Default values are 1.0, 1.0.

<item><tt/"WheelZoom"/, a float value that controls the zoom factor,
for the mouse wheel; default value is 0.5.

<item><tt/"ShiftTab"/, allows to set a specific keyboard symbol for
systems where pressing the Shift together with the Tab key does not
produce "&lt;Shift-Tab&gt;" (the default) but some other symbol like e.g.
"&lt;ISO_Left_Tab&gt;" (many, but not all, modern X11 systems often use
this).

<item><tt/"ListTypes"/ determines, whether the type of an
object should be displayed in braces in the tree view or listbox.
The default value is 1 - yes, list the types.

<item><tt/"MarkHidden"/ determines, whether hidden objects
should be marked (using a preceding exclamation mark)
in the tree view or object listbox.
The default value is 1 - yes, mark hidden objects.

<item><tt/"LoadEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ on startup.
The default value is 1 - yes, load the environment file on startup.

<item><tt/"NewLoadsEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ also when the scene is
cleared using the main menu entry <tt>"File/New"</tt>.
The default value is 1 - yes, load the environment file on
<tt>"File/New"</tt>.

<item><tt/"PaneMargins"/, is a list of currently five floating
point values, used as a safety margin for the panes:
console vs. hierarchy, hierarchy vs. upper-views, lower-view vs. property,
property vs. hierarchy, upper-view-2 vs. upper-view-1 (in this
order!).
These values control the minimum size of a pane expressed in an
inverse (1/x) and relative way:
the smaller the number, the bigger the margin. The safety margin
of the uppermost horizontal pane (that divides the upper internal
views from the hierarchy and the third view) is e.g. a bit larger
so that the main menu may not be obscured easily (the corresponding
value is 5.0). The default value for the console (20.0) leads to a
small margin, so that the console may be shrunk to 2 or even 1 lines.
The default values are
<code>
{20.0 5.0 10.0 10.0 10.0}
</code>
</itemize>

<sect2>RiOption and RiAttributes Database<label id="rioptdb">
<p>
Using your ayamrc file, you may also adapt the database of RiOptions and
RiAttributes to your rendering system.
<p>
You can then easily add those options and attributes
to your scenes using tags and the main menu entries
<tt>"Special/Tags/Add RiOption"</tt> and
<tt>"Special/Tags/Add RiAttribute"</tt>,
see also sections
<ref id="riatag" name="RiAttribute Tag"> and
<ref id="riotag" name="RiOption Tag">.
<p>
The syntax for a new RiOption is quite simple as the following example shows:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug" } } }
</code>
This snippet sets the section <tt>"runtime"</tt> and adds a single
option, <tt>"verbosity"</tt>, to it. The option is declared to be of type
string using <tt>"s"</tt> and provided with a list of default values:
<tt>"{ "silent" "normal" "stats" "debug" }"</tt>.

To add another option to this section, say the option <tt>"op"</tt>
which shall be an integer value you have to change the aforementioned
snippet to:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug"} }
 { op i }
}
</code>
As you can see, it is not mandatory to provide default values.
Be sure to correctly close all the curly braces, otherwise the next
start of Ayam may fail!

Available types of parameters are:
<itemize>
<item>i: a scalar integer value
<item>j: a pair of integer values
<item>f: a scalar float value
<item>g: a pair of float values
<item>s: a string value
<item>p: a point in space (simply three float values), the default
values (if provided) are three float values in curly braces, such as
<tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
<item>c: a color, the default values (if provided) are three float
values in curly braces, such as <tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
</itemize>

<sect1>Environment Variables<label id="envvars">
<p>
This section documents the environment variables used by Ayam.
<itemize>
<item><tt>"AYAMRC"</tt>: designates the full filename of the ayamrc file.
<item><tt>"HOME"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> is not set).
<item><tt>"TEMP"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> and <tt>"HOME"</tt> are not set); also initial value of the
<tt>"TmpDir"</tt> preference setting (used on Win32 if no ayamrc file exists,
that specifies <tt>"TmpDir"</tt>).
<item><tt>"AYNOSPLASH"</tt>: if this variable is set to 1, the splash
screen will not be shown
<item><tt>"BROWSER"</tt>: filename of the preferred WWW browser (used to
display the documentation URL)
<item><tt>"NETSCAPE"</tt>: (if <tt>"BROWSER"</tt> does not exist) filename
of the Netscape WWW browser (used to display the documentation URL)
<item><tt>"SHADERS"</tt>: initial value of <tt>"Shaders"</tt> preference
setting (used if no ayamrc file exists).
</itemize>

<sect1>Shader Parsing Plugins<label id="spplugins">
<p>
Since Ayam 1.3, the following plugins are provided to allow
parsing of shaders: <tt/"ayslb"/ for Air, <tt/"ayslx"/ for Aqsis,
<tt/"ayso"/ for RDC, <tt/"ayslo"/ for PRMan, <tt/"ayslo3d"/ for 3Delight,
(since Ayam 1.6) <tt/"aysdr"/ for Pixie, and (since Ayam 1.11)
<tt/"aygso"/ for Gelato.
<p>
After loading of one of the aforementioned plugins, Ayam will
be able to parse shaders compiled with the shader compiler
of the respective renderer.
<p>
There can only be one active shader parsing plugin. You can not
first load ayslb and then ayslx and expect Ayam to parse slb
<em>and</em> slx shaders.
<p>
A shader parsing plugin may be loaded
automatically on startup of Ayam using one of the provided Tcl scripts:
<tt/"loadayslb.tcl"/, <tt/"loadayslo.tcl"/, <tt/"loadayslo3d.tcl"/,
<tt/"loadayslx.tcl"/, <tt/"loadayso.tcl"/, <tt/"loadaysdr.tcl"/,
and <tt/"loadaygso.tcl"/.
To automatically load a plugin simply add the appropriate
script to the preference setting
<tt>"Main/Scripts"</tt> using the <tt>"Add"</tt> button in the
preferences editor.
<p>
Additionally, those scripts may be further adapted to
set a different <tt/"Shaders"/ preference setting or to immediately
scan for shaders after loading of the plugin. For that, just remove
the leading hash-marks (&num;) from the corresponding lines in the script.
Changing the scripts for immediate shader parsing is not necessary if you
load the shader parsing plugin automatically on startup of Ayam, as the
loading of the scripts will happen before the Ayam startup sequence
executes the initial shader scanning pass.
<p>
However, the standard behavior of the loading script while manually
loading of such a plugin requires you to adapt the shaders search path
manually and to scan manually for shaders too.
Both actions may be carried out using the preferences editor. Scanning
for shaders may also be started using the main menu:
<tt>"Special/Scan Shaders"</tt>.
<p>
To better accomodate the fast changing world of RenderMan renderers,
since Ayam 1.11 all shader parsing plugins are Ayam version independent
(but still renderer version dependent <em>and</em> Tcl version dependent).
This allows to distribute updated shader parsing plugins without updating
Ayam too and thus in a higher frequency.
Furthermore, compiling a shader parsing plugin is now much easier.

<sect1>Automatic Instancing<label id="ai">
<p>
Automatic Instancing is available via the main menu entry:
<tt>"Special/Instances/Automatic Instancing"</tt>.
Automatic Instancing creates instances from all instantiable
objects, using a simple algorithm that recursively compares
objects. The comparison of materials and tags may be turned off in the
small dialog that pops up after selection of the menu entry
<tt>"Special/Instances/Automatic Instancing"</tt>.
<p>
The algorithm is able to create instances of grouping objects
too (objects with child objects, e.g. levels or tool-objects
like revolve).
However, in order for two grouping objects to be instantiated
not only all child objects and the grouping objects
have to be instantiable, but the child objects also
have to be in the right order. It is not sufficient,
that for every child of the potential master, a matching
child of the potential instance exists.
Instantiation of grouping objects may drastically decrease
the total number of objects in a scene.
<p>
Note that before the automatic instantiation starts, all currently
existing instances will be resolved!
After instantiation some statistics will be displayed in the console.
<p>
Since Ayam 1.14, the instantiation obeys the object selection:
instances are only created from the selected objects.
If no objects are selected, instances are created from all objects
in the current level and below.
<p>
More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Automatic Instancing of
Hierarchically Organized Objects", in: Kunii T.L. (ed.): Spring
Conference on Computer Graphics (SCCG 2001) Conference Proceedings, Budmerice,
Slovakia, 25-28 April 2001, ISBN 80-223-1606-7</it>

<sect1>Importance Driven Rendering (IDR)<label id="idr">
<p>
The importance driven rendering plugin may be used to drastically
reduce rendering times while developing a scene.
It works in three main steps:
<enum>
<item>Importance values are assigned to elements of the scene.
<item>Two rendering passes are started according to the
assigned importance values. Elements of different importance
values are mutually masked out using <tt>"RiMatte"</tt> statements.
<item>The resulting partial images are composed to a single
resulting image, which is then displayed.
</enum>
The parameterisation of the two rendering passes ensures, that
the total rendering time is lower than the rendering time of
a single pass with high quality.
<p>
Many options exist to assign importance and parameterise the
rendering passes:
<p>
Elements of the scenes may be geometric objects, regions in image space,
or regions in object space.
Importance values are currently just binary values.
Assignment may take place manually (using IDR tags) or half-automatic
by derivation of importance from currently selected or changed
objects. To avoid inconsistency in the resulting images, importance
values may be propagated between (geometrically or hierarchically) near
objects, or between objects that are related (e.g. from a material to a
geometric object).
<p>
Parameterisation of the two rendering passes currently includes selection of
a different renderer and the possibility to reduce rendering resolution and
shading rate. To further reduce rendering times for raytracing
renderers, the size of the region to render may be automatically adapted to
the elements of the current importance value (including an optimisation
run that balances renderer startup times and times needed to render
regions not originally occupied by two regions to merge).
<p>
Furthermore, caching of partial images is possible. However, the implementation
of this feature is not very sophisticated at the moment, as it
uses the Unix text tool <tt>"diff"</tt> to decide whether two RIB streams are
identical and hence need no re-rendering.

To start using IDR:
<enum>
<item>load a scene (e.g. the cactus example scene),
<item>load the IDR plugin (menu <tt>"File/Load Plugin"</tt>),
<item>open the IDR control window using the main menu
<tt>"Custom/Open IDR"</tt>,
<item>set the assign mode to <tt>"Selection"</tt>,
<item>select an object in the scene (e.g. the object named <tt>"Pot"</tt>),
<item>then press the <tt>"Render!"</tt> button.
</enum>
Compare the rendering time with a full render from the view window.

IDR requires that atleast the renderer of the second rendering pass
honours RiMatte! Since rgl does not honour RiMatte, it is sometimes
necessary to simply exclude objects of different importance value.
No wrong images are to be expected from this, as rgl does not calculate
other than local lighting effects.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Importance Driven
Rendering - Using Importance Information in the Rendering Process",
in: Hamza M., Sarfraz M. (ed.): Computer Graphics and Imaging (CGIM 2001)
Conference Proceedings, Honolulu, Hawaii, 13-16 August 2001,
ISBN 0-88986-303-2</it>

<sect1>CSG preview using the AyCSG plugin<label id="aycsg">
<p>
<figure loc="ht">
<eps file="pics/csgex.ps" height="5cm">
<img src="pics/csgex.gif">
<caption>CSG preview example (left without, right with CSG)</caption>
</figure>
<p>
The AyCSG plugin may be used to resolve and preview CSG operations.
For this, the plugin uses image based CSG rendering algorithms provided
by the OpenCSG library by Florian Kirsch. The OpenCSG library, currently,
supports the Goldfeather and the SCS algorithm. The latter only works
properly with convex primitives. Since both, Goldfeather and SCS, are
image based rendering algorithms, there is no limit in geometric object
types that may be used in CSG hierarchies. You may e.g. use Quadrics, NURBS,
and Metaballs in every possible combination. You just have to make sure,
that every CSG primitive describes a closed space.
<p>
In order for the CSG rendering algorithms to work properly, the depth
complexity (convexity) of a primitive must be known.
The depth complexity of a primitive determines the maximum number
of forward oriented surfaces any ray through this primitive would pass.
A regular sphere has a depth complexity of 1, a torus of 2, but do
not confuse depth complexity with genus, they are different values!
A 3D representation of the letter A e.g. has a genus of
1 but a depth complexity of 3.
The depth complexity of a primitive should be stored in a <tt/"DC"/ tag.
A torus would e.g. get a tag named <tt/"DC"/ with the value <tt/"2"/.
If no <tt/"DC"/ tag is present for a primitive, a default value for
the depth complexity of <tt/"1"/ will be used.
If you fail to correctly specify the depth complexity, rendering
errors, like missing parts of surfaces, will occur.
<p>
Note that the correct operation of AyCSG not only depends on the
depth complexity but also the winding order of the OpenGL primitives
(triangles or quads) used for drawing of the CSG primitives. The
winding order has to be consistent in a scene, so that the rendering
algorithm can decide what is inside and what is outside by looking
at a single OpenGL primitive. For all quadric primitives of Ayam
the winding order is always consistent. However, for NURBS patches
the winding order depends on the orientation of the patch dimensions.
If NURBS patches are used in CSG operations you, consequently, may
need to revert the patches (e.g. using the <tt/"RevertU"/ tool,
see <ref id="revertut" name="Revert U tool">).
If the winding order of some of the primitives in a CSG hierarchy
is not right, the respective primitives will not be effective
in the CSG operations to the extent that the rendered image becomes
completely empty.
<p>
The AyCSG rendering obeys the <tt>"Draw Selection only"</tt> and
<tt>"Draw Level only"</tt> view options as well as the hide attribute
of objects. If the CSG rendering fails for complete complex scenes,
you might still get a preview of the important CSG using objects by
selecting them and enabling the <tt>"Draw Selection only"</tt> view
option.
<p>
Also note that CSG rendering requires fast graphics hardware
(the more fillrate, the better). Furthermore, your OpenGL subsystem
has to support the PBuffers extension and, depending on the
rendering options chosen, a stencil buffer. Speedups may be
achieved using the <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt> extensions (if available to you).
<p>
Once the AyCSG plugin is loaded successfully you can render the CSG
preview in any view window using the keyboard shortcut
<tt>&lt;Ctrl+Shift+c&gt;</tt> or using the new button in the menu
bar of every view window. If you hold down <tt>&lt;Shift&gt;</tt>
while pressing the button the view will continually render CSG
(the button stays pressed to signify this) until you click onto
the button again.
<p>
The AyCSG plugin supports the following options, that are available
through the main menu entry <tt>"Custom/AyCSG Preferences"</tt>:
<itemize>
<item><tt/"Algorithm"/ allows to switch between the Goldfeather and
SCS algorithm. Note again that the SCS algorithm only works correctly
for convex primitives. The <tt/"Automatic"/ setting chooses one
of the algorithms based on whether concave primitives (depth complexity
&gt; 1) are present or not.
<item><tt/"DCSampling"/ determines a depth complexity sampling
strategy. Quoting from the OpenCSG documentation, the following options
are available:
<p>
<tt/"NoDCSampling"/: Does not employ the depth complexity. This essentially
makes the algorithm O(n&sup2;), but with low constant costs.
<p>
<tt/"OcclusionQuery"/: Uses occlusion queries to profit implicitly from
depth complexity without calculating it. This is especially useful for the
SCS algorithm where this strategy is applied at shape level, resulting in
a O(n*k') algorithm (where k' <= k), without significant constant overhead.
This strategy requires hardware occlusion queries, i.E., the OpenGL
extension <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt>.
<p>
<tt/"DCSampling"/: Calculates the depth complexity k using the stencil
buffer. This makes the algorithm O(n*k), but with high constant costs.
In case of the Goldfeather algorithm, the literature denotes this as
layered Goldfeather algorithm.
<item><tt/"CalcBBS"/ determines whether bounding boxes should be
calculated and used for speed up (not working at the moment).
</itemize>

See also:
<it>Kirsch F. and Doellner J.: "Rendering Techniques for Hardware-Accelerated
Image-Based CSG", in: Skala V. (ed.): Journal of WSCG'04, 221-228,
ISSN 1213-6972</it>

<sect1>Increasing drawing speed<label id="incds">
<p>
In case of sluggish response of the user interface of Ayam
(not accounting for long tree update operations) several
things to increase drawing speed can be done:
<itemize>
<item>Hide objects or complete object hierarchies
using <tt/"Hide"/ in the <tt/"Tools"/ menu.
<item>Disable drawing of true NURBS curves/surfaces, if you can. Use the
ControlHull display modes.
<item>If you need to see curves/surfaces, try to increase the
(GLU) sampling tolerance of the objects (use a value of about 60.0).
<item>Switch the primary modelling view to draw just the selected
object(s) or the current level.
<item>Iconify views you do not need, they will not be redrawn then.
<item>Switch off automatic redrawing of slow redrawing (e.g. shaded)
views, and control their redraw by pressing <tt/&lt;Ctrl+d&gt;/ manually.
<item>Do not create unnecessary caps, they are trimmed NURBS patches
that render very slowly.
<item>Disable <tt/"UseMatColor"/.
</itemize>

<sect1>Restrictions and Implementation Deficiencies<label id="defi">
<p>
Due to the way Ayam is implemented, several restrictions and
deficiencies exist:
<itemize>
<item>Almost all strings in Ayam (scene file names, object names,
material names) are restricted to be 7 bit ASCII. If the scene is
not to be transported between platforms (e.g. between UNIX and Win32),
using 8 bit ASCII should be fine, however.
<item>The maximum scene depth (i.e. the maximum number of nested levels)
depends on the maximum stack size of the operating system Ayam is
running on (due to the use of recursion almost everywhere when traversing
the scene, e.g. for drawing purposes).
<item>Ayam internally operates on double precision math, however,
no control over roundoff error in lengthy calculations exists.
Saving of scene files only uses the precision dictated by the current
standard C library. This may degrade the precision of the models.
Using of double precision numbers via the Tcl scripting interface or
the GUI also can reduce model precision due to
double-string-double-conversions (the precision of those conversion
operations can be adjusted by the user via the <tt/"TclPrecision"/
preference setting, however).
<item>Ayam is currently not portable to 64-bit platforms.
<item>Materials may only be assigned to complete objects, not to
certain parts of objects.
<item>Undo/Redo are not possible for scene structure changes.
<item>Selected points do not survive Undo/Redo/Saving.
<item>There are no acceleration structures for e.g. drawing and object
tree updates. This limits the number of objects that Ayam can handle
simultaneously without big lags in redraws or after scene structure
changes to about 1000. However, Ayam objects should be high-level objects,
not single polygons, anyway.
</itemize>

Ayam user interface deficiencies:
<itemize>
<item>The application state is often communicated via window title
strings only. But certain window systems do not display those
titles well, and they are not to be seen in the single window GUI
mode at all.
</itemize>

<sect1>How to join the fun<label id="secfun">
<p>
Helping to make Ayam even better will spice up your life too!
Here is how to do it:
<enum>
<item>Write/translate tutorials.
<item>Create and submit example objects, scenes, and images.
<item>Implement custom objects like trees, landscape, sky, XSplines,
T-Splines, or whatever you can think of. Note that the license of Ayam
does not prevent you from implementing your custom object as shareware
or even commercial software. However, free software is preferred for
obvious reasons.
<item>Donate source to improve several critical parts of the modeler,
some ideas are: better (more exact) lighting simulation (is this
possible to do with OpenGL at all?), transformation widgets,
true support for subdivision surfaces, lift some deficiencies (see above),
import/export plugins.
The project page of Ayam on SourceForge lists some more tasks and
you are always welcome to discuss such matters in the public forum
or in the feature request tracker.
<item>Donate money by registering ShellyLib.
ShellyLibs source will be converted to a first high level custom object
that creates objects of type seashell for Ayam. This object, however,
will be Shareware!
</enum>

Please do not implement custom objects like simple triangles or polygons.
This would be something that really is not intended by the Ayam Team,
and it would surely show the limits of the current design of all code
operating on the scene structure.

Ayam objects should be high-level objects!

Reading the last paragraph you might think that we are a bit biased
against polygonal models. We are not. Polygonal models are the only
way to preview complex geometry using hardware accelerated graphics,
for the moment. But even while RenderMan supports rendering of
polygonal models, their use as a primitive is not recommended for
good reasons. In other words, use polygonal models in the modeler
as quick representation of your higher level objects, but please,
if you are going to actually render something, do not use that
polygonal representation.
If you want to go a complete polygonal way instead, voila, there
are good modelers out there.

<sect1>References<label id="secref">
<p>
Suggested reading:
<itemize>
<item>Advanced RenderMan: Creating CGI for Motion Pictures by
Tony Apodaca and Larry Gritz (Morgan-Kaufmann, 1999)
<item>The RenderMan Companion: A Programmer's Guide
to Realistic Computer Graphics by Steve Upstill (Addison-Wesley,
1989)
<item>Textures and Modelling: A Procedural Approach by Ebert,
Musgrave, Peachey, Perlin, and Worley (Academic Press, 1994)
</itemize>

WWW resources:
<itemize>
<item>If you are reading this document from a local file system,
maybe an updated version is available from the internet:
<tt>http://www.ayam3d.org/docs/ayam.html</tt>
<item>Ayam Tutorial #1:
<tt>http://www.ayam3d.org/tut1/tutorial1.html</tt>
<item>The Ayam FAQ: <tt>http://www.ayam3d.org/faq.html</tt>
<item>The RenderMan Repository: <tt>http://www.renderman.org/</tt>
<item>The RenderMan Academy: <tt>http://www.rendermanacademy.com/</tt>
</itemize>

<sect1>Acknowledgements
<p>
First of all, I would like to express a big "Thank you!"
to Bernd (Pink) Sieker. He is the first real Mops user
and beta tester, who urged me during the last years
via E-Mail and on IRC to fix this particular bug, add some
essential features, move the lights again etc. pp. in countless
iterations.
Bernd, without your help I surely would not be that far, thanks!

Furthermore, I would like to thank the following people:
<itemize>
<item>Hynek Schlawack: Ayam Makefile configuration GUI
<item>Florian Kirsch: OpenCSG
<item>Bertrand Coconnier: implementation of object picking
<item>Hermann Birkholz: initial implementation of the tree widget, shadow map
support, AI, and IDR
<item>Frank (Copper) Pagels: MetaBalls custom object, TTF parser,
providing a lot of good music
<item>Stephen Echavia: Icons
<item>Larry Gritz: BMRT
<item>Benjamin Bederson, Brian Paul et. al.: The Togl Widget
<item>Jeffrey Hobbs: tkMegaWidget set
<item>Jan Nijtmans: Tcl/Tk PlusPatches, tcl2c, Wrap
<item>Thomas E. Burge: The Affine Toolkit
<item>Apple, Duet Development Corp.: 3DMF parser
<item>Mark J. Kilgard: GLUT
<item>Les A. Piegl and Wayne Tiller: The NURBS Book
<item>W. T. Hewitt and D. Yip: The NURBS Procedure Library
<item>Philippe Lavoie: The NURBS++ Library
<item>Everyone involved in the development of Tcl/Tk, OpenGL, The RenderMan
Interface
</itemize>

OpenGL (R) is a registered trademark of Silicon Graphics, Inc.

The RenderMan (R) Interface Procedures and Protocol are:
Copyright 1988, 1989, 2000 Pixar
All Rights Reserved

RenderMan (R) is a registered trademark of Pixar

The Affine Libraries and Tools are
Copyright (c) 1995, 1996, 1997, 1998 Thomas E. Burge
All rights reserved.

Affine (R) is a registered trademark of Thomas E. Burge.

TIFF Software is
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.

Dime is
Copyright (c) 1998-1999 Systems In Motion, SA
All rights reserved.

AutoCAD (R) is a registered trademark of Autodesk, Inc.

DXF (R) is a registered trademark of Autodesk, Inc.


<sect>Index
<p>
<ref id="index0" name=" 0 ">
<ref id="indexa" name=" A ">
<ref id="indexb" name=" B ">
<ref id="indexc" name=" C ">
<ref id="indexd" name=" D ">
<ref id="indexe" name=" E ">
<ref id="indexf" name=" F ">
<ref id="indexg" name=" G ">
<ref id="indexh" name=" H ">
<ref id="indexi" name=" I ">
<ref id="indexj" name=" J ">
<ref id="indexk" name=" K ">
<ref id="indexl" name=" L ">
<ref id="indexm" name=" M ">
<ref id="indexn" name=" N ">
<ref id="indexo" name=" O ">
<ref id="indexp" name=" P ">
<ref id="indexq" name=" Q ">
<ref id="indexr" name=" R ">
<ref id="indexs" name=" S ">
<ref id="indext" name=" T ">
<ref id="indexu" name=" U ">
<ref id="indexv" name=" V ">
<ref id="indexw" name=" W ">
<ref id="indexx" name=" X ">
<ref id="indexy" name=" Y ">
<ref id="indexz" name=" Z ">
<p>
<label id="index">
<label id="index0">0
<itemize>
<item>2lcons: <ref id="twolconstcl" name="example/helper script">,
<item>3DM: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>3DMF: <ref id="imp3dmf" name="3DMF (Apple) Import">,
<ref id="exp3dmf" name="3DM (Apple) Export">
</itemize>

<label id="indexa">A
<itemize>
<item>About: <ref id="mmhelp" name="main menu entry">
<item>Accuracy: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="exprhino" name="3DM (Rhino) export option">
<item>ACurve: <ref id="acurveobj" name ="ACurve object">
<item>Action: <ref id="iac" name="interactive actions">
<item>Active: <ref id="scriptattr" name="Script attribute">
<item>Adaptive: <ref id="moattr" name="MetaObj attributes">
<item>AddExtensions: <ref id="prefgui" name="preference setting">
<item>addToProc: <ref id="scaddtoproc" name="scripting interface command">
<item>AddViewParams: <ref id="hidprefs" name="hidden preference setting">
<item>ALength: <ref id="acp" name="ACurve attribute">
<item>ALFileTypes, ALPlugins: <ref id="hidprefs" name="hidden preference setting">
<item>Algorithm: <ref id="aycsg" name="AyCSG plugin option">
<item>Align to Parent: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
<item>ANS: <ref id="anstag" name="tag type">
<item>AntiAlias Lines: <ref id="vmconf" name="view menu entry">
<item>Apply: <ref id="propgui" name="apply property GUI">
<item>applyTrafo: <ref id="scapplytrafo" name="scripting interface command">
<item>Archives: <ref id="rio" name="RenderMan interface option">
<item>Area Light: <ref id="alob" name="creation of">
<item>Array: <ref id="cloneobj" name="Clone object">
<item>AskScriptDisable: <ref id="hidprefs" name="hidden preference setting">
<item>Atmosphere: <ref id="imager" name="property">
<item>Attributes: <ref id="attrs" name="attributes property">,
<ref id="riattrs" name="RenderMan/BMRT attributes property">
<item>AUCommands: <ref id="hidprefs" name="hidden preference setting">
<item>AutoCAD DXF: <ref id="impdxf" name="AutoCAD DXF import">,
<ref id="expdxf" name="AutoCAD DXF export">
<item>AutoFocus: <ref id="prefgui" name="preference setting">
<item>Automatic Instancing: <ref id="mmspecial" name="main menu entry">
<item>Automatic Redraw: <ref id="vmconf" name="view menu entry">
<item>AutoResize: <ref id="prefgui" name="preference setting">
<item>AutoSavePrefs: <ref id="prefgui" name="preference setting">
<item>Attribute: <ref id="riatag" name="RiAttribute tag type">
<item>ayamrc: <ref id="ayamrc" name="Ayamrc File">
<item>ayError: <ref id="scayerror" name="scripting interface command">
</itemize>

<label id="indexb">B
<itemize>
<item>Background: <ref id="prefdraw" name="preference setting">
<item>Background Image: <ref id="vat" name="View attribute">
<item>BackupExt: <ref id="hidprefs" name="hidden preference setting">
<item>BakOnReplace: <ref id="prefmain" name="preference setting">
<item>Basis_U, Basis_V: <ref id="pmattr" name="PatchMesh attribute">
<item>BeamDistrib: <ref id="lip" name="Light attribute">
<item>Bevel: <ref id="bevelobj" name="Bevel object">,
<ref id="handb" name="using bevels">,
<ref id="offsetncp" name="offset mode">
<item>Bevel3D: <ref id="offsetncp" name="offset mode">
<item>BevelRadius, BevelRevert, BevelType: <ref id="bevelp" name="Bevel attribute">
<item>bgconvert: <ref id="bgconverttcl" name="example/helper script">
<item>BGImage: <ref id="vat" name="View attribute">
<item>bicubic/bilinear PatchMesh:
<ref id="patchmeshobj" name="PatchMesh object">
<item>Birail1: <ref id="birail1obj" name="Birail1 object">
<item>Birail2: <ref id="birail2obj" name="Birail2 object">
<item>BNS: <ref id="bnstag" name="tag type">
<item>Bound: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>BoundCoord: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Box: <ref id="boxobj" name="Box object">
<item>BPatch: <ref id="bpatchobj" name="BPatch object">
<item>BType_U, BType_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Build: <ref id="bfct" name="build from curves tool">
<item>buildNP: <ref id="scbuildnp" name="scripting interface command">
</itemize>

<label id="indexc">C
<itemize>
<item>CalcBBS: <ref id="aycsg" name="AyCSG plugin option">
<item>Camera: <ref id="cameraobj" name="Camera object">,
<ref id="camp" name="view property">
<item>Cap: <ref id="capobj" name="Cap object">
<item>CastShadows: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Chamfer: <ref id="bevelobj" name="Bevel object">,
<item>CheckLights: <ref id="prefrib" name="preference setting">
<item>Center All Points: <ref id="mmspecial" name="main menu entry">
<item>Circle: <ref id="ncirct" name="NURBS circle tool">,
<ref id="ncircleobj" name="NCircle object">
<item>Clamp: <ref id="clat" name="clamp tool">
<item>clampNC: <ref id="scclampnc" name="scripting interface command">
<item>clampuNP: <ref id="scclampunp" name="scripting interface command">
<item>clampvNP: <ref id="scclampvnp" name="scripting interface command">
<item>Clipboard: <ref id="sciclip" name="scripting interface commands">
<item>Clone: <ref id="cloneobj" name="Clone object">
<item>Close: <ref id="treecontm" name="tree context menu entry">
<item>Closed: <ref id="spattr" name="Sphere attribute">,
<ref id="cnp" name="Cone attribute">,
<ref id="cyp" name="Cylinder attribute">,
<ref id="top" name="Torus attribute">,
<ref id="pap" name="Paraboloid attribute">,
<ref id="hyp" name="Hyperboloid attribute">,
<ref id="ncattr" name="NCurve attribute">,
<ref id="concatncp" name="ConcatNC attribute">
<item>Closed BSpline: <ref id="cbspt" name="closed BSpline tool">
<item>Close_U, Close_V: <ref id="pmattr" name="PatchMesh attribute">
<item>coarsenNC: <ref id="sccoarsennc" name="scripting interface command">,
<ref id="coart" name="coarsen tool">
<item>Collapse: <ref id="collt" name="Collapse tool">,
<ref id="treecontm" name="tree context menu entry">
<item>Color: <ref id="riattrs" name="RenderMan/BMRT attribute">,
<ref id="lip" name="Light attribute">
<item>CompleteNotify: <ref id="prefmodel" name="preference setting">
<item>copOb: <ref id="sccopob" name="scripting interface command">
<item>Copy: <ref id="mmedit" name="main menu entry">
<item>Copy Property: <ref id="mmedit" name="main menu entry">,
<ref id="propgui" name="copying properties">
<item>Concat: <ref id="conct" name="Concat tool">
<item>ConcatNC: <ref id="concatncobj" name="ConcatNC object">
<item>ConcatNP: <ref id="concatnpobj" name="ConcatNP object">
<item>Cone: <ref id="mmcreate" name="main menu entry">,
<ref id="coneobj" name="Cone object">
<item>ConeAngle, ConeDAngle: <ref id="lip" name="Light attribute">
<item>Console: <ref id="cons" name="what is">
<item>Convert: <ref id="mmtools" name="main menu entry">
<item>convOb: <ref id="scconvob" name="scripting interface command">
<item>Coons Patch: <ref id="gordonobj" name="Gordon object">
<item>Create: <ref id="mmcreate" name="create menu">
<item>CreateMP: <ref id="ncattr" name="NCurve attribute">
<item>Create ShadowMap: <ref id="mmspecial" name="main menu entry">,
<ref id="vmview" name="view menu entry">
<item>crtOb: <ref id="sccrtob" name="scripting interface command">
<item>CSG: <ref id="levelobj" name="Level object">,
<ref id="aycsg" name="AyCSG CSG preview plugin">
<item>CursorEnd: <ref id="hidprefs" name="hidden preference setting">
<item>Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Custom: <ref id="cul" name="light type">,
<ref id="mmcustom" name="custom menu">
<item>Custom Object: <ref id="customobj" name="what is">
<item>Cut: <ref id="mmedit" name="main menu entry">
<item>cutOb: <ref id="sccutob" name="scripting interface command">
<item>Cylinder: <ref id="cylinderobj" name="Cylinder object">
</itemize>

<label id="indexd">D
<itemize>
<item>DANS: <ref id="anstag" name="tag type">
<item>Data: <ref id="riprocp" name="RiProc attribute">
<item>DC: <ref id="dctag" name="tag type">
<item>DCSampling: <ref id="aycsg" name="AyCSG plugin option">
<item>DefaultAction: <ref id="prefmodel" name="preference setting">
<item>DefaultMat: <ref id="prefrib" name="preference setting">
<item>DelayedReadArchive: <ref id="riprocp" name="RiProc attribute">
<item>delegTrafo: <ref id="scdelegtrafo" name="scripting interface command">
<item>Delete: <ref id="mmedit" name="main menu entry">,
<ref id="insdelac" name="delete points">
<item>delOb: <ref id="scdelob" name="scripting interface command">
<item>Derivatives: <ref id="icp" name="ICurve attribute">
<item>Difference: <ref id="levelobj" name="Level object">
<item>Direct Editing: <ref id="editac" name="edit points">
<item>Disk: <ref id="diskobj" name="Disk object">
<item>Displacement: <ref id="matshader" name="shader">
<item>Display: <ref id="ridtag" name="RiDisplay tag type">
<item>DisplayMode: <ref id="npattr" name="NPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">
<item>Distant: <ref id="pdsl" name="light type">
<item>DBNS: <ref id="bnstag" name="tag type">
<item>Docs: <ref id="prefgui" name="preference setting">
<item>Double Size: <ref id="vmconf" name="view menu entry">
<item>DrawGrid, DrawLevel, DrawSel, DrawBG:
<ref id="vat" name="View attribute">
<item>Draw Selection only: <ref id="vmconf" name="view menu entry">
<item>Draw Level only: <ref id="vmconf" name="view menu entry">
<item>Draw BGImage: <ref id="vmconf" name="view menu entry">
<item>Draw Grid: <ref id="vmconf" name="view menu entry">
<item>Draw Object CS: <ref id="vmconf" name="view menu entry">
<item>DXF: <ref id="impdxf" name="DXF import plugin">,
<ref id="expdxf" name="DXF export plugin">
<item>DynamicLoad: <ref id="riprocp" name="RiProc attribute">
</itemize>

<label id="indexe">E
<itemize>
<item>Edit: <ref id="editac" name="edit points">,
<ref id="mmedit" name="edit menu">
<item>Edit Local: <ref id="vmconf" name="view menu entry">,
<ref id="editlocal" name ="Editing in Local Space">
<item>EditSnaps: <ref id="prefmodel" name="preference setting">
<item>EDLen: <ref id="icp" name="ICurve attribute">
<item>Elevate: <ref id="elevt" name="elevate tool">
<item>elevateNC: <ref id="scelevatenc" name="scripting interface command">
<item>Elevate UV: <ref id="elevuvt" name="elevate uv tool">
<item>Enable Scripts: <ref id="mmspecial" name="main menu entry">
<item>EndCap: <ref id="extrattr" name="Extrude attribute">,
<ref id="rep" name="Revolve attribute">,
<ref id="swp" name="Sweep attribute">,
<ref id="skp" name="Skin attribute">,
<ref id="birail1p" name="Birail1 attribute">,
<ref id="birail2p" name="Birail2 attribute">
<item>EnvFile: <ref id="prefgui" name="preference setting">
<item>Environment Variables: <ref id="envvars" name="Environment Variables">
<item>Epsilon: <ref id="moattr" name="MetaObj attributes">
<item>ErrorLevel: <ref id="rribopt" name="RIB import option">
<item>estlenNC: <ref id="scestlennc" name="scripting interface command">
<item>ExcludeHidden: <ref id="prefrib" name="preference setting">
<item>Expand: <ref id="treecontm" name="tree context menu entry">
<item>ExpGain, ExpGamma: <ref id="rio" name="RenderMan interface option">
<item>Explode: <ref id="explt" name="Explode tool">
<item>Export: <ref id="exprhino" name="3DM (Rhino) export">,
<ref id="exp3dmf" name="3DMF (Apple) export">,
<ref id="expdxf" name="AutoCAD DXF Export">,
<ref id="expwav" name="OBJ (Wavefront) export">,
<ref id="exprib" name="RIB Export">,
<ref id="impx3d" name="X3D Export">
<item>Export RIB: <ref id="mmfile" name="main menu entry">
<item>Expression: <ref id="mcattr" name="MetaComp attribute">
<item>Exterior: <ref id="matshader" name="shader">
<item>ExtrNC: <ref id="extrncobj" name="ExtrNC object">,
<ref id="extnct" name="extract curve tool">
<item>ExtrNP: <ref id="extrnpobj" name="ExtrNP object">,
<ref id="scextrnp" name="scripting interface command">,
<ref id="extrnpt" name="extract patch tool">
<item>Extrude: <ref id="extrudeobj" name="Extrude object">,
<ref id="extt" name="Extrude tool">
</itemize>

<label id="indexf">F
<itemize>
<item>FAQ: <ref id="secref" name="Ayam FAQ WWW reference">
<item>Far: <ref id="camp" name="camera property">
<item>File: <ref id="mmfile" name="file menu">,
<ref id="riincp" name="RiInc attribute">,
<ref id="riprocp" name="RiProc attribute">
<item>FillGaps: <ref id="concatncp" name="ConcatNC attribute">
<item>FilterFunc: <ref id="rio" name="RenderMan interface option">
<item>FilterWidth: <ref id="rio" name="RenderMan interface option">
<item>FindU: <ref id="miscac" name="modelling action">
<item>FixImageButtons: <ref id="hidprefs" name="hidden preference setting">
<item>FixX11Menu: <ref id="hidprefs" name="hidden preference setting">
<item>FlashPoints: <ref id="prefmodel" name="preference setting">
<item>Flatness: <ref id="moattr" name="MetaObj attributes">
<item>FontName: <ref id="textattr" name="Text attribute">
<item>forAll, forAllT: <ref id="scforall" name="scripting interface command">
<item>Force Notification: <ref id="mmtools" name="main menu entry">
<item>forceNot: <ref id="scforcenot" name="scripting interface command">
<item>Formula: <ref id="mcattr" name="MetaComp attribute">
<item>From: <ref id="camp" name="camera property">,
<ref id="lip" name="Light attribute">
<item>From Camera: <ref id="mmspecial" name="main menu entry">,
<ref id="vmconf" name="view menu entry">
<item>Front: <ref id="vmtype" name="view menu entry">
<item>FTLength: <ref id="concatncp" name="ConcatNC attribute">
</itemize>

<label id="indexg">G
<itemize>
<item>getPnt: <ref id="scgetpnt" name="scripting interface command">
<item>getProperty: <ref id="scgetproperty" name="scripting interface command">
<item>getType: <ref id="scgettype" name="scripting interface command">
<item>Gimbal Lock: <ref id="gimb" name="avoiding Gimbal Locks">
<item>goDown: <ref id="scgodown" name="scripting interface command">
<item>goTop: <ref id="scgotop" name="scripting interface command">
<item>Gordon: <ref id="gordonobj" name="Gordon object">
<item>goUp: <ref id="scgoup" name="scripting interface command">
<item>Grid: <ref id="vat" name="View attribute">
<ref id="prefdraw" name="drawing preference setting">
</itemize>

<label id="indexh">H
<itemize>
<item>Half Size: <ref id="vmconf" name="view menu entry">
<item>HandleSize: <ref id="prefmodel" name="preference setting">
<item>hasChild: <ref id="schaschild" name="scripting interface command">
<item>Height: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="Box attribute">,
<ref id="cnp" name="Cone attribute">,
<ref id="npattr" name="NPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="extrattr" name="Extrude attribute">,
<ref id="vat" name="View attribute">,
<ref id="textattr" name="Text attribute">
<item>Help: <ref id="mmhelp" name="main menu entry">,
<ref id="schelp" name="scripting interface command">
<item>Help on object: <ref id="mmhelp" name="main menu entry">
<item>Hidden Preferences: <ref id="hidprefs" name="hidden preference settings">
<item>Hide: <ref id="mmtools" name="main menu entry">,
<ref id="attrs" name="attribute">
<item>Hide All: <ref id="mmtools" name="main menu entry">
<item>Hider: <ref id="rihtag" name="RiHider tag type">
<item>HideTmpTags: <ref id="prefmisc" name="preference setting">
<item>Highlight Material: <ref id="mmtools" name="main menu entry">
<item>Hole: <ref id="handb" name="using holes">
<item>hSL: <ref id="schsl" name="scripting interface command">
<item>Hyperboloid: <ref id="hyperboloidobj" name="Hyperboloid object">
</itemize>

<label id="indexi">I
<itemize>
<item>IconGamma: <ref id="hidprefs" name="hidden preference setting">
<item>ICurve: <ref id="icurveobj" name ="ICurve object">
<item>IDR: <ref id="idr" name="IDR plugin">
<item>IgnoreFirstTrim: <ref id="imprhino" name="3DM (Rhino) import option">
<item>IgnoreHidden: <ref id="exprhino" name="3DM (Rhino) export option">
<item>IgnoreNormals: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>Image: <ref id="prefrib" name="preference setting">
<item>Imager: <ref id="imager" name="property">
<item>Import: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="imp3dmf" name="3DMF (Apple) Import">,
<ref id="impdxf" name="AutoCAD DXF Import">,
<ref id="impmops" name="Mops Import">,
<ref id="imprib" name="RIB Import">,
<ref id="impwav" name="Wavefront OBJ Import">,
<ref id="impx3d" name="X3D Import">
<item>Importance Driven Rendering: <ref id="idr" name="IDR plugin">
<item>Insert: <ref id="mmfile" name="main menu entry">,
<ref id="insdelac" name="insert points">
<item>insknNC: <ref id="scinsknnc" name="scripting interface command">
<item>insknuNP: <ref id="scinsknunp" name="scripting interface command">
<item>insknvNP: <ref id="scinsknvnp" name="scripting interface command">
<item>Insert Knot: <ref id="insknt" name="insert knot tool">
<item>insertScene: <ref id="scinsertscene" name="scripting interface command">
<item>Instance: <ref id="instanceobj" name ="Instance object">
<item>Instant Apply: <ref id="propgui" name="instant apply facility">
<item>Intensity: <ref id="lip" name="Light attribute">
<item>Interior: <ref id="matshader" name="shader">
<item>Interpolation: <ref id="attrs" name="RenderMan/BMRT attribute">,
<ref id="icurveobj" name="interpolating curve">,
<ref id="swp" name="Sweep attribute">,
<ref id="skp" name="Skin attribute">
<item>InterpolCtrl: <ref id="birail2p" name="Birail2 attribute">
<item>Intersection: <ref id="levelobj" name="Level object">
<item>Invert Selection: <ref id="mmspecial" name="main menu entry">
<item>IsLocal: <ref id="lip" name="Light attribute">
<item>IsoLevel: <ref id="moattr" name="MetaObj attribute">
<item>IsOn: <ref id="lip" name="Light attribute">
<item>IsRat: <ref id="ncattr" name="NCurve attribute">,
<ref id="npattr" name="NPatch attribute">
</itemize>

<label id="indexj">J
<itemize>
<item>.
</itemize>

<label id="indexk">K
<itemize>
<item>kdialog: <ref id="kdialogtcl" name="example/helper script">
<item>Knots: <ref id="ncattr" name="NCurve attribute">
<item>Knot-Type: <ref id="ncattr" name="NCurve attribute">,
<ref id="concatncp" name="ConcatNC attribute">,
<ref id="concatnpp" name="ConcatNP attribute">
<item>Knot-Type_U: <ref id="npattr" name="NPatch attribute">,
<ref id="skp" name="Skin attribute">
<item>Knot-Type_V: <ref id="npattr" name="NPatch attribute">
</itemize>

<label id="indexl">L
<itemize>
<item>Last (None): <ref id="mmtools" name="main menu entry">
<item>LazyNotify: <ref id="prefmodel" name="preference setting">
<item>Length: <ref id="bxp" name="Box attribute">,
<ref id="ncattr" name="NCurve attribute">,
<ref id="acp" name="ACurve attribute">,
<ref id="icp" name="ICurve attribute">
<item>Level: <ref id="levelobj" name="Level object">
<item>Light: <ref id="lightobj" name="Light object">,
<ref id="prefdraw" name="preference setting">
<item>LightAttr: <ref id="lip" name="property">
<item>LightShader: <ref id="lightobj" name="light">
<item>LineWidth: <ref id="hidprefs" name="hidden preference setting">
<item>ListTypes: <ref id="hidprefs" name="hidden preference setting">
<item>LoadEnv: <ref id="hidprefs" name="hidden preference settings">
<item>Load Plugin: <ref id="mmfile" name="main menu entry">
<item>Local: <ref id="vat" name="View attribute">,
<ref id="editlocal" name ="Editing in Local Space">
<item>Locale: <ref id="prefgui" name="preference setting">
<item>Loft: <ref id="skinobj" name="Skin object">
<item>LogFile: <ref id="prefgui" name="preference setting">
<item>Logging: <ref id="prefgui" name="preference setting">
<item>LowerBevel: <ref id="extrattr" name="Extrude attribute">,
<ref id="textattr" name="Text attribute">
<item>LowerCap: <ref id="rep" name="Revolve attribute">,
<ref id="textattr" name="Text attribute">
</itemize>

<label id="indexm">M
<itemize>
<item>MajorRad: <ref id="top" name="Torus attribute">
<item>Make Compatible: <ref id="makecompt" name="NCurve tool">
<item>MarkHidden: <ref id="hidprefs" name="hidden preference settings">
<item>Master: <ref id="mmedit" name="edit menu entry">
<item>Material: <ref id="materialobj" name="Material object">,
<ref id="mmedit" name="edit menu entry">
<item>Materialname: <ref id="matattr" name="attribute">,
<ref id="matprop" name="material property attribute">
<item>MaxRayLevel: <ref id="rio" name="RenderMan interface option">
<item>MaxTagLen: <ref id="hidprefs" name="hidden preference settings">
<item>MaxX, MaxY, MaxZ: <ref id="riprocp" name="RiProc attribute">
<item>Menu: <ref id="mm" name="main menu">,
<ref id="vm" name="view menu">
<item>Merge: <ref id="mmtools" name="Merge PolyMesh tool">
<item>MergeFaces <ref id="impwav" name="Wavefront OBJ import option">
<item>MergePVTags <ref id="impwav" name="Wavefront OBJ import option">
<item>MetaObj, MetaComp: <ref id="metaobjobj" name="MetaObj object">
<item>MFIO Plugin:
<ref id="imp3dmf" name="3DMF (Apple) import">,
<ref id="exp3dmf" name="3DMF (Apple) export">
<item>MinorRad: <ref id="top" name="Torus attribute">
<item>MinSamples, MaxSamples: <ref id="rio" name="RenderMan interface option">
<item>MinX, MinY, MinZ: <ref id="riprocp" name="RiProc attribute">
<item>Mirror: <ref id="cloneattr" name="Clone attribute">
<item>Mode: <ref id="offsetncp" name="OffsetNC attribute">
<item>Mops Import: <ref id="impmops" name="Import of Mops Scenes">
<item>Move: <ref id="vwsc" name="view action">,
<ref id="iac" name="move object">
<item>movOb: <ref id="scmovob" name="scripting interface command">
<item>movPnts: <ref id="scmovpnts" name="scripting interface command">
<item>Multiple Point: <ref id="ncurvemp" name="Multiple Points">
</itemize>

<label id="indexn">N
<itemize>
<item>NCDisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="ncattr" name="NCurve attribute">
<item>NCircle: <ref id="ncircleobj" name="NCircle object">
<item>NCurve: <ref id="ncurveobj" name="NCurve object">
<item>Near: <ref id="camp" name="camera property">
<item>Negative: <ref id="mcattr" name="MetaComp attribute">
<item>Network Surface: <ref id="gordonobj" name="Gordon object">
<item>New: <ref id="mmfile" name="main menu entry">
<item>NewLoadsEnv: <ref id="hidprefs" name="hidden preference settings">
<item>newScene: <ref id="scnewscene" name="scripting interface command">
<item>NoExport: <ref id="noexporttag" name="tag type">
<item>NP: <ref id="nptag" name="tag type">
<item>NPatch: <ref id="npatchobj" name="NPatch object">
<item>NPDisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="npattr" name="NPatch attribute">
<item>NumClones: <ref id="cloneattr" name="Clone attribute">
<item>NumSamples: <ref id="moattr" name="MetaObj attribute">
<item>NURBCircle: <ref id="ncirct" name="NURBS circle tool">
<item>NURBCurve: <ref id="ncurveobj" name="NCurve object">
<item>NURBPatch: <ref id="npatchobj" name="NPatch object">
<item>NURBS: <ref id="scinurbs" name="scripting interface commands">
<item>NURBSphere: <ref id="nspt" name="NURBS sphere tool">
</itemize>

<label id="indexo">O
<itemize>
<item>ObeyNoExport: <ref id="exprhino" name="3DM (Rhino) export option">
<item>OBJ: <ref id="impwav" name="Wavefront OBJ import">,
<ref id="expwav" name="Wavefront OBJ export">
<item>Object: <ref id="prefdraw" name="preference setting">
<item>Objectname: <ref id="attrs" name="attribute">
<item>Objects: <ref id="obj" name="tree/listbox">,
<ref id="objsel" name="selection within a view">
<item>OffsetNC: <ref id="offsetncobj" name="OffsetNC object">
<item>OI: <ref id="oitt" name="tag type">
<item>Open: <ref id="mmfile" name="main menu entry">,
<ref id="treecontm" name="tree context menu entry">
<item>OpenNURBS: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>Optimize: <ref id="mmtools" name="Optimize PolyMesh tool">
<item>OptimizeCoords: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeFaces: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeNew: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Option: <ref id="riotag" name="RiOption tag type">
<item>Order: <ref id="ncattr" name="NCurve attribute">,
<ref id="npattr" name="NPatch attribute">,
<ref id="acp" name="ACurve attribute">,
<ref id="icp" name="ICurve attribute">,
<ref id="rep" name="Revolve attribute">
<item>Order_U: <ref id="skp" name="Skin attribute">
</itemize>

<label id="indexp">P
<itemize>
<item>P1, P2: <ref id="hyp" name="Hyperboloid attribute">
<item>PaneMargins: <ref id="hidprefs" name="hidden preference setting">
<item>Paraboloid: <ref id="paraboloidobj" name="Paraboloid object">
<item>Parameter: <ref id="extrncp" name="ExtrNC attribute">
<item>Parameter Object: <ref id="toolobj" name="modelling concept">
<item>ParamType: <ref id="icp" name="ICurve attribute">
<item>pasOb: <ref id="scpasob" name="scripting interface command">
<item>Paste: <ref id="mmedit" name="main menu entry">
<item>Paste (Move): <ref id="mmspecial" name="main menu entry">
<item>Paste Property: <ref id="mmedit" name="main menu entry">
<item>PatchMesh: <ref id="patchmeshobj" name="PatchMesh object">
<item>PatchNum: <ref id="extrncp" name="ExtrNC attribute">,
<ref id="selectp" name="Select attribute">,
<ref id="trimp" name="Trim attribute">
<item>PatchSamples: <ref id="rio" name="RenderMan interface option">
<item>Perspective: <ref id="vmtype" name="view menu entry">
<item>PhiMin, PhiMax: <ref id="top" name="Torus attribute">
<item>Pick: <ref id="objsel" name="pick objects within a view">
<item>PickEpsilon: <ref id="prefmodel" name="preference setting">
<item>Plot Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Point: <ref id="pdsl" name="light type">
<item>PolyMesh: <ref id="polymeshobj" name="PolyMesh object">
<item>PolyOffset: <ref id="hidprefs" name="hidden preference setting">
<item>PPRender: <ref id="prefrib" name="preference setting">
<item>Preferences: <ref id="prefs" name="Preferences">,
<ref id="hidprefs" name="hidden preference settings">
<item>PrepDiaCap: <ref id="hidprefs" name="hidden preference setting">
<item>Procedurals: <ref id="rio" name="RenderMan interface option">
<item>Prompt: <ref id="hidprefs" name="hidden preference setting">
<item>Properties: <ref id="propgui" name="property GUI">
<item>Primitive: <ref id="levelobj" name="Level object">
<item>Primitive Variable (PV): <ref id="pvtag" name="tag type">
<item>PRManSpec: <ref id="rio" name="RenderMan interface option">
</itemize>

<label id="indexq">Q
<itemize>
<item>QuadAsBRep: <ref id="exprhino" name="3DM (Rhino) export option">
<item>QRender: <ref id="prefrib" name="preference setting">
<item>QRenderPT, QRenderUI: <ref id="prefrib" name="preference setting">
<item>Quat: <ref id="trap" name="transformations property">
<item>QuickDraw 3D Metafile: <ref id="imp3dmf" name="3DMF import">,
<ref id="exp3dmf" name="3DMF export">
<item>Quick Render: <ref id="vm" name="view menu entry">
</itemize>

<label id="indexr">R
<itemize>
<item>Radius: <ref id="spattr" name="Sphere attribute">,
<ref id="dkp" name="Disk attribute">,
<ref id="cnp" name="Cone attribute">,
<ref id="cyp" name="Cylinder attribute">,
<ref id="ncircleattrprop" name="NCircle attribute">,
<ref id="mcattr" name="MetaComp attribute">
<item>RadSteps: <ref id="rio" name="RenderMan interface option">
<item>ReadCurves: <ref id="impwav" name="Wavefront OBJ import/export option">,
<ref id="imprhino" name="3DM (Rhino) import option">
<item>ReadFrame, ReadCamera, ReadOptions, ReadLights, ReadMaterial,
ReadPartial: <ref id="rribopt" name="RIB import option">
<item>ReadLayers: <ref id="imprhino" name="3DM (Rhino) import option">
<item>ReadSTrim: <ref id="impwav" name="Wavefront OBJ import/export option">,
<ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="rribopt" name="RIB import option">,
<ref id="impx3dopt" name="X3D import option">
<item>Rebuild: <ref id="treecontm" name="tree context menu entry">
<item>Rectangle: <ref id="trrt" name="TrimRect tool">
<item>RedirectTcl: <ref id="prefmisc" name="preference setting">
<item>Redo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">
<item>Redraw: <ref id="vm" name="view menu entry">,
<ref id="incds" name="speeding up">,
<ref id="vat" name="View attribute">
<item>Refcount: <ref id="attrs" name="attribute">
<item>Reference Counter: <ref id="instanceobj" name="Instance Object">,
<ref id="materialobj" name="Material Object">
<item>References: <ref id="secref" name="references">
<item>refineNC: <ref id="screfinenc" name="scripting interface command">,
<ref id="refit" name="refine tool">
<item>Relative: <ref id="extrncp" name="ExtrNC attribute">,
<ref id="extrnpp" name="ExtrNP attribute">
<item>remknNC: <ref id="scremknnc" name="scripting interface command">
<item>Remove Knot: <ref id="remknt" name="remove knot tool">
<item>RemoveMerged: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Render: <ref id="vm" name="view menu entry">,
<ref id="prefrib" name="preference setting">
<item>Renderer: <ref id="mmspecial" name="select a different renderer">
<item>RenderMode: <ref id="prefrib" name="preference setting">
<item>RenderPT, RenderUI: <ref id="prefrib" name="preference setting">
<item>Repair Ayam: <ref id="repayam" name="Tcl helper script">
<item>Reparameterise: <ref id="screparamnc" name="scripting interface command">
<item>Replace: <ref id="mmspecial" name="main menu entry">
<item>replaceScene: <ref id="screplacescene" name="scripting interface command">
<item>Rescale Knots to Mindist: <ref id="resckmt" name="NURBCurve tool">
<item>Rescale Knots to Range: <ref id="resckrt" name="NURBCurve tool">
<item>rescaleknNC: <ref id="screscaleknnc" name="scripting interface command">
<item>rescaleknNP: <ref id="screscaleknnp" name="scripting interface command">
<item>RescaleKnots: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="imprib" name="RIB import option">,
<ref id="impwav" name="Wavefront OBJ import option">,
<item>Reset: <ref id="propgui" name="reset property GUI">
<item>ResetDM, ResetST: <ref id="impmops" name="Mops import option">
<item>Reset Preferences: <ref id="mmspecial" name="main menu entry">
<item>ResInstances: <ref id="prefrib" name="preference setting">
<item>Resolve all Instances: <ref id="mmspecial" name="main menu entry">
<item>ResolveInstances: <ref id="expx3dopt" name="X3D (Web3D) export option">
<item>Revert: <ref id="revertt" name="Revert tool">,
<ref id="textattr" name="Text attribute">,
<ref id="concatncp" name="ConcatNC attribute">,
<ref id="offsetncp" name="OffsetNC attribute">,
<ref id="extrncp" name="ExtrNC attribute">
<item>RevertBevels: <ref id="textattr" name="Text attribute">
<item>revertC: <ref id="screvertc" name="scripting interface command">
<item>RevertU, RevertV: <ref id="revertut" name="Revert U tool">,
<ref id="revertvt" name="Revert V tool">
<item>Revolve: <ref id="revolveobj" name="Revolve object">,
<ref id="revt" name="Revolve tool">
<item>RGBA_ONE, RGBA_MIN, RGBA_MAX, RGBA_Dither:
<ref id="rio" name="RenderMan interface option">
<item>RGTrans: <ref id="prefmisc" name="preference setting">
<item>Rhino: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>RiAttribute: <ref id="riattrs" name="property">,
<ref id="riatag" name="tag type">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIB import: <ref id="imprib" name="RIB Import">
<item>RIBFile: <ref id="prefrib" name="preference setting">
<item>RiDisplay: <ref id="ridtag" name="tag type">
<item>RiHider: <ref id="rihtag" name="tag type">
<item>RiInc: <ref id="riincobj" name="RiInc object">
<item>RiOption: <ref id="riotag" name="tag type">
<item>RiOptions: <ref id="rio" name="RenderMan interface options property">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIStandard: <ref id="prefrib" name="preference setting">
<item>RMax: <ref id="pap" name="Paraboloid attribute">
<item>Roll: <ref id="camp" name="Camera attribute">
<item>Root: <ref id="rootobj" name="Root object">
<item>Rotate: <ref id="vwsc" name="view action">,
<ref id="rotac" name="rotate object">,
<ref id="swp" name="Sweep attribute">,
<ref id="cloneattr" name="Clone attribute">
<item>Rotation: <ref id="trap" name="transformations property">,
<ref id="gimb" name="using the transformations property">
<item>Rotational Sweep: <ref id="swingobj" name="Swing object">
<item>rotOb: <ref id="scrotob" name="scripting interface command">
<item>rotPnts: <ref id="scrotpnts" name="scripting interface command">
<item>RP: <ref id="rptag" name="tag type">
<item>Ruled surface: <ref id="skinobj" name="Skin object">,
<item>RunProgram: <ref id="riprocp" name="RiProc attribute">
<item>rV: <ref id="scrv" name="scripting interface command">
</itemize>

<label id="indexs">S
<itemize>
<item>SafeAutoFocus: <ref id="hidprefs" name="hidden preference setting">
<item>Samples: <ref id="lip" name="Light attribute">
<item>Samples_X: <ref id="rio" name="RenderMan interface option">
<item>Samples_Y: <ref id="rio" name="RenderMan interface option">
<item>Save: <ref id="mmfile" name="main menu entry">
<item>Save as: <ref id="mmfile" name="main menu entry">
<item>Save Prefs: <ref id="mmfile" name="main menu entry">
<item>SaveAddsMRU: <ref id="prefmisc" name="preference setting">
<item>SaveMainGeom: <ref id="savemaingeomtag" name="tag type">
<item>SavePaneLayout: <ref id="savepanelayouttag" name="tag type">
<item>SavePrefsGeom: <ref id="prefmisc" name="preference setting">
<item>saveScene: <ref id="scsavescene" name="scripting interface command">
<item>Scale: <ref id="trap" name="transformations property">,
<ref id="scalac" name="scale object">
<item>ScaleFactor: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="exprhino" name="3DM (Rhino) export option">,
<ref id="impwav" name="Wavefront OBJ import option">,
<ref id="expwav" name="Wavefront OBJ export option">,
<ref id="rribopt" name="RIB import option">
<item>scalOb <ref id="scscalob" name="scripting interface command">
<item>scalPnts <ref id="scscalpnts" name="scripting interface command">
<item>Scan Shaders: <ref id="mmspecial" name="main menu entry">
<item>Script: <ref id="script" name="scripting interface">,
<ref id="scriptobj" name="Script object">
<item>Scripts: <ref id="prefgui" name="preference setting">
<item>SDLen: <ref id="icp" name="ICurve attribute">
<item>SDMesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Sections: <ref id="swp" name="Sweep attribute">,
<ref id="rep" name="Revolve attribute">,
<ref id="birail1p" name="Birail1 attribute">,
<ref id="birail2p" name="Birail2 attribute">
<item>Select: <ref id="selectobj" name="Select object">
<ref id="obj" name="select objects with the tree/listbox">,
<ref id="objsel" name="select objects within a view">,
<ref id="selac" name="select points">
<item>Select All: <ref id="mmedit" name="main menu entry">
<item>Select None: <ref id="mmedit" name="main menu entry">
<item>Selected Objects: <ref id="mmspecial" name="main menu entry">
<item>Select Renderer: <ref id="mmspecial" name="main menu entry">
<item>Selection: <ref id="prefdraw" name="preference setting">
<item>SelLineWidth: <ref id="hidprefs" name="hidden preference setting">
<item>selOb: <ref id="scselob" name="scripting interface command">
<item>SelXOR_R, SelXOR_G, SelXOR_B:
<ref id="hidprefs" name="hidden preference setting">
<item>Set BGImage: <ref id="vmconf" name="view menu entry">
<item>Set Gridsize: <ref id="vmconf" name="view menu entry">
<item>Set FOV: <ref id="vmconf" name="view menu entry">
<item>setPnt: <ref id="scsetpnt" name="scripting interface command">
<item>setProperty: <ref id="scsetproperty" name="scripting interface command">
<item>Shade: <ref id="prefdraw" name="preference setting">,
<ref id="vmconf" name="view menu entry">
<item>Shader: <ref id="shd" name="properties">
<item>Shader Parsing: <ref id="spplugins" name="shader parsing plugins">
<item>Shaders: <ref id="prefmain" name="preference setting">,
<ref id="rio" name="RenderMan interface option">,
<ref id="scishaders" name="scripting interface commands">
<item>ShadingRate: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>ShadowBias: <ref id="rio" name="RenderMan interface option">
<item>ShadowMaps: <ref id="prefrib" name="preference setting">,
<ref id="shadowmaps" name="using shadowmaps">
<item>Shadows: <ref id="lip" name="Light attribute">
<item>Shift Closed B-Spline:
<ref id="shiftclbspt" name="shift closed B-Spline tool">
<item>ShiftTab: <ref id="hidprefs" name="hidden preference setting">
<item>Show: <ref id="mmtools" name="main menu entry">
<item>Show All: <ref id="mmtools" name="main menu entry">
<item>Show Shortcuts: <ref id="mmhelp" name="main menu entry">
<item>Show Tooltips: <ref id="mmhelp" name="main menu entry">
<item>Side: <ref id="vmtype" name="view menu entry">,
<ref id="extrncp" name="ExtrNC attribute">
<item>SingleWindow: <ref id="prefmain" name="preference setting">
<item>Skin: <ref id="skinobj" name="Skin object">,
<ref id="skit" name="Skin tool">
<item>sL: <ref id="scsl" name="scripting interface command">
<item>SMChangeShaders: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMFileFormat: <ref id="prefrib" name="preference setting">
<item>SMFileType: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMRender, SMRenderUI, SMRenderPT: <ref id="prefrib" name="preference setting">
<item>SMRes: <ref id="lip" name="Light attribute">
<item>Snap Points to Grid: <ref id="snapac" name="modelling action">
<item>Snap3D: <ref id="prefmodel" name="preference setting">
<item>SP: <ref id="scriptattrprop" name="Script object">
<item>SParamU, SParamV: <ref id="prefmisc" name="preference setting">
<item>Special: <ref id="mmspecial" name="special menu">
<item>Sphere: <ref id="sphereobj" name="Sphere object">,
<ref id="nspt" name="NURBS sphere tool">
<item>Split: <ref id="sptct" name="split to curves tool">,
<ref id="mmtools" name="split polymesh tool">
<item>Split Curve: <ref id="miscac" name="modelling action">
<item>splitNC: <ref id="scsplitnc" name="scripting interface command">
<item>splitNP: <ref id="scsplitnp" name="scripting interface command">
<item>splituNP: <ref id="scsplitunp" name="scripting interface command">
<item>splitvNP: <ref id="scsplitvnp" name="scripting interface command">
<item>Spot: <ref id="pdsl" name="light type">
<item>STagName: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="impwav" name="Wavefront OBJ import option">
<item>StartCap: <ref id="extrattr" name="Extrude attribute">,
<ref id="rep" name="Revolve attribute">,
<ref id="swp" name="Sweep attribute">,
<ref id="skp" name="Skin attribute">,
<ref id="birail1p" name="Birail1 attribute">,
<ref id="birail2p" name="Birail2 attribute">
<item>StdDisplay: <ref id="rio" name="RenderMan interface option">
<item>Step_U, Step_V: <ref id="pmattr" name="PatchMesh attribute">
<item>StepSize: <ref id="moattr" name="MetaObj attributes">
<item>Stretch: <ref id="scalac" name="stretch object">
<item>String: <ref id="textattr" name="Text attribute">
<item>Subdivision Mesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Surface: <ref id="matshader" name="shader">
<item>SwapMB: <ref id="hidprefs" name="hidden preference setting">
<item>Swap UV: <ref id="swapuvt" name="swap uv tool">
<item>swapuvS <ref id="scswapuvs" name="scripting interface command">
<item>Sweep: <ref id="sweepobj" name="Sweep object">,
<ref id="swpt" name="Sweep tool">
<item>Swing: <ref id="swingobj" name="Swing object">
<item>Symmetric: <ref id="acp" name="ACurve attribute">
</itemize>

<label id="indext">T
<itemize>
<item>Tag: <ref id="prefdraw" name="preference setting">
<item>Tags: <ref id="tags" name="tags property">,
<ref id="scitags" name="scripting interface commands">
<item>TC: <ref id="tctag" name="tag type">
<item>TclPrecision: <ref id="prefmisc" name="preference setting">
<item>Tesselate: <ref id="tesst" name="tesselation tool">
<item>TessPoMesh <ref id="expwav" name="Wavefront OBJ export option">
<item>Text: <ref id="textobj" name="Text object">
<item>Textures: <ref id="rio" name="RenderMan interface option">
<item>Texture Coordinates: <ref id="tctag" name="tag type">,
<ref id="tce" name="texture coordinate editor">
<item>ThetaMax: <ref id="spattr" name="Sphere attribute">,
<ref id="dkp" name="Disk attribute">,
<ref id="cnp" name="Cone attribute">,
<ref id="cyp" name="Cylinder attribute">,
<ref id="top" name="Torus attribute">,
<ref id="pap" name="Paraboloid attribute">,
<ref id="hyp" name="Hyperboloid attribute">,
<ref id="rep" name="Revolve attribute">
<item>Threshold: <ref id="moattr" name="MetaObj attributes">
<item>TMin, TMax: <ref id="ncircleattrprop" name="NCircle attribute">
<item>TmpDir: <ref id="prefgui" name="preference setting">
<item>To: <ref id="camp" name="camera property">,
<ref id="lip" name="Light attribute">
<item>To Camera: <ref id="vmconf" name="view menu entry">
<item>Toggle Toolbox: <ref id="mmspecial" name="main menu entry">
<item>Toggle TreeView: <ref id="mmspecial" name="main menu entry">
<item>Tolerance: <ref id="prefdraw" name="preference setting">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="ncattr" name="NCurve attribute">,
<ref id="npattr" name="NPatch attribute">
<item>Tool Objects: <ref id="toolobj" name="modelling concept">
<item>Toolbox: <ref id="toolb" name="toolbox window">
<item>ToolBoxShrink: <ref id="prefmisc" name="preference setting">
<item>ToolBoxTrans: <ref id="prefmisc" name="preference setting">
<item>Tools: <ref id="mmtools" name="tools menu">
<item>Top: <ref id="vmtype" name="view menu entry">
<item>TopLevelLayers: <ref id="expdxfopt" name="DXF export option">,
<ref id="exp3dmopt" name="3DM (Rhino) export option">,
<ref id="expx3dopt" name="X3D (Web3D) export option">
<item>topoly: <ref id="topolytcl" name="example/helper script">
<item>Torus: <ref id="torusobj" name="Torus object">
<item>To XY: <ref id="toxyt" name="To XY tool">
<item>TP: <ref id="tptag" name="tag type">
<item>Transformations: <ref id="trap" name="transformations property">
<item>Translation: <ref id="trap" name="transformations property">
<item>Tree View: <ref id="treeview" name="Tree View">
<item>Trim: <ref id="trimobj" name="Trim object">,
<ref id="vmtype" name="view menu entry">
<item>Trim Curve: <ref id="trim" name="using trim curves">
<item>trimNC: <ref id="sctrimnc" name="scripting interface command">
<item>TrimRect: <ref id="trrt" name="TrimRect tool">
<item>TrueDisp: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>TTagName: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="impwav" name="Wavefront OBJ import/export option">
<item>TwmCompat: <ref id="prefgui" name="preference setting">
<item>Type: <ref id="levelobj" name="Level attribute">,
<ref id="lip" name="Light attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="vat" name="View attribute">,
<ref id="scriptattr" name="Script attribute">,
<ref id="riprocp" name="RiProc attribute">,
<ref id="capattrprop" name="Cap attribute">,
<ref id="ncurveattrprop" name="NCurve attribute">,
<ref id="icp" name="ICurve attribute">
</itemize>

<label id="indexu">U
<itemize>
<item>uCL: <ref id="scucl" name="scripting interface command">
<item>uCR: <ref id="scucr" name="scripting interface command">
<item>UMM: <ref id="ummtag" name="tag type">
<item>Undo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">,
<ref id="scundo" name="scripting interface command">
<item>UndoLevels: <ref id="prefmodel" name="preference setting">
<item>Union: <ref id="levelobj" name="Level object">
<item>UpperBevel: <ref id="extrattr" name="Extrude attribute">,
<ref id="textattr" name="Text attribute">
<item>UpperCap: <ref id="rep" name="Revolve attribute">,
<ref id="textattr" name="Text attribute">
<item>Up Vector: <ref id="camp" name="camera property">
<item>uS: <ref id="scus" name="scripting interface command">
<item>useaqsisapp: <ref id="useaqsisapptcl" name="example/helper script">
<item>UseGrid: <ref id="vat" name="View attribute">,
<ref id="vmconf" name="view menu entry">
<item>UseInternalFD: <ref id="hidprefs" name="hidden preference setting">
<item>UseMatColor: <ref id="prefdraw" name="preference setting">
<item>usepixie: <ref id="usepixietcl" name="example/helper script">
<item>UseSM: <ref id="lip" name="Light attribute">
</itemize>

<label id="indexv">V
<itemize>
<item>Variance: <ref id="rio" name="RenderMan interface option">
<item>View: <ref id="viewobj" name="object">,
<ref id="viewwin" name="Anatomy of a View">
<item>ViewAttrib: <ref id="vat" name="property">
<item>VMM: <ref id="ummtag" name="tag type">
</itemize>

<label id="indexw">W
<itemize>
<item>WarnPropPasteToSel: <ref id="hidprefs" name="hidden preference setting">
<item>WarnUnknownTag: <ref id="hidprefs" name="hidden preference setting">
<item>Wavefront OBJ: <ref id="impwav" name="Wavefront OBJ import">,
<ref id="expwav" name="Wavefront OBJ export">
<item>Weight: <ref id="iac" name="single point weight editing">
<item>WheelZoom: <ref id="hidprefs" name="hidden preference setting">
<item>Width: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="Box attribute">,
<ref id="npattr" name="NPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="vat" name="View attribute">
<item>withOb: <ref id="scwithob" name="scripting interface command">
<item>wrib: <ref id="scwrib" name="scripting interface command">
<item>WriteCurves: <ref id="impwav" name="Wavefront OBJ import/export option">,
<ref id="exprhino" name="3DM (Rhino) export option">
<item>WriteParametrics: <ref id="expx3dopt" name="X3D (Web3D) export option">
<item>WriteIdent: <ref id="prefrib" name="preference setting">
<item>WriteSelected: <ref id="exprhino" name="3DM (Rhino) export option">,
<ref id="expwav" name="Wavefront OBJ export option">
<item>WriteViews: <ref id="expx3dopt" name="X3D (Web3D) export option">
</itemize>

<label id="indexx">X
<itemize>
<item>X3D: <ref id="impx3d" name="X3D (Web3D) Import">,
<ref id="expx3d" name="X3D (Web3D) Export">
</itemize>

<label id="indexy">Y
<itemize>
<item>.
</itemize>

<label id="indexz">Z
<itemize>
<item>Zap Ayam: <ref id="mmspecial" name="main menu entry">
<item>zap: <ref id="zaptcl" name="example/helper script">
<item>zdialog: <ref id="zdialogtcl" name="example/helper script">
<item>ZMin, ZMax: <ref id="spattr" name="Sphere attribute">,
<ref id="dkp" name="Disk attribute">,
<ref id="cyp" name="Cylinder attribute">,
<ref id="pap" name="Paraboloid attribute">
<item>Zoom: <ref id="camp" name="camera property">,
<ref id="vwsc" name="view action">
<item>Zoom to Object: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
</itemize>

</article>
