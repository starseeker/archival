<!doctype linuxdoc system>

<article>

<title>Ayam
<author>Randolf Schultz <tt>(rschultz@informatik.uni-rostock.de)</tt>
<date>14. Apr 2003
<abstract>
This is the documentation of Ayam (1.5) - a free 3D modeling environment
for the RenderMan interface.

Please note, that this document is intended to be a reference manual,
more detailed explanations of how to actually model with Ayam are
given in the tutorials.

This document has been written using the SGML-Tools formatting
system to generate files in a variety of text formats from one source file.
There are HTML and PDF versions of this document
prepared for you.

In addition, you can use the provided SGML-source to generate other formats.

</abstract>

<toc>

<sect>Introduction
<p>
What is Ayam?<p>
Ayam is a free 3D modeling environment for the RenderMan Interface
(formerly known as <tt>"The Mops"</tt>).<p>
On which platforms is Ayam available?<p>
Ayam is primarily aimed at the platforms BMRT (Blue Moon Rendering
Tools, a RenderMan compliant renderer by Larry Gritz (Exluna))
runs on (those are Linux, IRIX, and Win32). Despite of this, Ayam may be used
on many more platforms with any RenderMan compliant renderer.
Due to limitations in the Win32 operating system(s)
(no backlinking) and the current implementation of Ayam,
dynamic loading of custom objects is currently not available on the
Win32 platform!<p>
For platforms where BMRT is not available (e.g. FreeBSD or NetBSD), Ayam
may be compiled with code from the Affine Toolkit with limited
functionality (see also the file INSTALL).
In this case, no parsing of slc compiled shaders will be possible.<p>
What are the features of Ayam?<p>
Here is a short summary:
<itemize>
<item>RIB (RenderMan Interface Bytestream) export and import.
<item>Support for NURBS curves, interpolating curves, (trimmed)
NURBS surfaces, bilinear and bicubic patches and patch meshes,
Boxes, Quadrics (Sphere, Disk,
Cylinder, Cone, Hyperboloid, Paraboloid and Torus), MetaBalls,
polygonal meshes, subdivision meshes and more.
<item>All primitives may be combined with the common
CSG-operations: Intersection, Difference, and Union.
<item>NURBS modeling includes extrude, revolve, sweep and skin
operations (with caps, holes, and bevels) realized as Tool-Objects.
<item>Custom objects that may freely implement their representations
(using OpenGL and RIB) and even small GUIs to edit their type specific
parameters may be written by the user and dynamically loaded at runtime.
<item>Scripting interface: Tcl.
<item>Misc: instancing, arbitrary number of modeling views,
object clipboard, independent property clipboard, console,
n level undo.
</itemize>

<sect>The Ayam GUI
<p>
This section describes the user interface of Ayam.

The whole application may be iconified (zapped) using
the shortcut <tt/&lt;Ctrl+Z&gt;/. If any of the windows
iconified by zap is de-iconified, all other windows
iconified by zap will be de-iconified as well.

<sect1>Anatomy of the Main Window
<p>
The main window is split into three large areas:
<enum>
<item>an area named <tt/"Objects:"/
<item>an area labeled <tt/"Properties:"/
<item>and a text widget (the so called "Console")
</enum>
<figure loc="ht">
<eps file="pics/main.ps" height="7cm">
<img src="pics/main.gif">
<caption>The Main Window</caption>
</figure>
<p>
The relative sizes of the three areas are managed by a so called paned
window management. To change the relative size of the console,
move your mouse pointer to the upper
border of the console until the pointer changes and drag
the border.
The same goes for the right border of the objects section.<p>

<sect2>Objects<label id="obj">
<p>
The label <tt/"Objects"/ may be used to switch between two
representations of the object hierarchy (using a double click).
It is also possible to switch between both representations
using the context menu.
The default representation is a tree view. The second
available representation is a simple listbox (as known from The Mops).
The two representations have very different properties regarding
speed, use of resources, and versatility. The tree is, due to the
Drag-and-Drop operations, much more versatile but also slower.

Both representations manage a so called <tt/"current level"/.
This level is the level that is displayed in the object listbox.
In the tree view the current level is drawn in black while all
other levels are grayed out. Selection of objects
may only take place in the current level!

<bf/Tree View:/<label id="treeview">
<p>
<figure loc="ht">
<eps file="pics/treeview.ps" height="4cm">
<img src="pics/treeview.gif">
<caption>Tree View</caption>
</figure>
<p>

The tree view is very complex and may be slow on slow machines
(Pentium 90 class), especially when dealing with large (deep nested)
scenes.

Objects may be selected using the left mouse button.
Multiple selection of objects is possible using Shift
and Control keys while clicking on objects.

Double clicking on objects with child objects
toggles display of the child level.
The same may be accomplished using single
clicks on the well known plus/minus symbols
in front of the name of those
objects.

Drag-and-Drop operation is also possible to move
objects in the hierarchy and to initiate special
actions like connecting materials to objects.
However, this last feature is documented in section
<ref id="obandprp" name="Ayam Objects and Properties">
as it is object type specific.

The rightmost mouse button opens a context menu with
basic tree and clipboard operations.


<bf/Listbox:/<label id="listbox">
<p>
<figure loc="ht">
<eps file="pics/listbox.ps" height="4cm">
<img src="pics/listbox.gif">
<caption>Listbox</caption>
</figure>
<p>

The hierarchy listbox, displays the object
hierarchy of the current scene.
Using this listbox you may browse through the
hierarchy of the scene with your mouse and you may
select one or more objects.<p>
Browsing and selecting should be very intuitively:
Use a double click to enter a level (or an object with child objects),
and a single click to select objects, multiple objects may be selected using
click and drag, or holding down the Shift or Control key while clicking.
Keyboard operation is also possible if the listbox has the
input focus.<p>
A ".." is displayed as the first element of the current level
if you are "inside" a level or another object.
A double click on the ".." takes you to the parent level.
The buttons below the listbox
may be used to change the selection or to quickly
jump through the hierarchy. They should be self explanatory.

You will notice, that there is a first object called "Root" in the
top level, even though the scene seems to be empty.
See section <ref id="rootobj" name="Root Object"> for more
information regarding this special object, and what it is good for.
Note, that you cannot delete or copy this object.

<sect2>Properties<label id="propgui">
<p>
<figure loc="ht">
<eps file="pics/propgui.ps" height="4cm">
<img src="pics/propgui.gif">
<caption>Properties</caption>
</figure>
<p>
The listbox right next to the object hierarchy
displays the properties of the currently selected
object.<p>
If there are multiple selected objects,
the properties listbox will display no properties at all.<p>
Unlike the objects tree/listbox, where you can select multiple entries,
only one property may be selected.
If a property is selected, the associated GUI will be shown in the 
appropriate area (on the right hand side).
All property GUIs use more or less standardized GUI elements
that are organized in list form. The lists may be scrolled if they get
too long to fit into the window.<p>
If the elements of the property GUI do not fit into the screen
space defined by the current window size, Ayam will automatically
resize the window when you select a property. You can toggle
this behaviour using the preference setting
<tt/"AutoResize"/ (see section <ref id="prefs" name="Preferences">).

If an object and a property are selected and a different object is selected,
the property GUI that has the same index as the previously
selected property in the properties listbox will be
selected and shown. This is not necessarily a property
of the same type.
To avoid that or to clear the property
GUI for fast browsing through the scene you may either double
click on the "Properties" label or use the context menu of the
properties listbox to de-select the current property.

What properties exactly
will be shown, and how the GUIs look alike depends on the
selected object and the selected property.
This is documented in section
<ref id="obandprp" name="Ayam Objects and Properties">.

Here are some general remarks:<p>
The various things that may be changed using a property GUI
will normally not be applied to the object until the "Apply"-button
is pressed!<p>
You can undo all changes to the arguments of a property that
have been made after the last click on "Apply" with the "Reset" button.
This does, however, not use the undo mechanism of Ayam!<p>
Note, that property GUIs of custom objects may also offer interactive
elements that do an instant "Apply". Most GUIs of the
core objects of Ayam and the Scene object do not change anything
until the "Apply" button is used, however.<p>

A property may be copied and pasted to another
object, see the <tt/"Edit"/ menu. You can also
paste properties to different types of properties
(e.g. pasting parameters from a surface shader to the
displacement shader) using <tt/"Paste to selected"/ in the
<tt>"Special/Clipboard"</tt> sub-menu.<p>
Pasting a property to multiple selected objects does work too.
This is a great way to apply e.g. a surface shader
to a big number of material objects, without going the long way
of setting a new shader and entering parameters for it
for every object.<p>
Since you may not want to copy and paste whole properties all the time,
you may mark single parameters with a double click on the
labels of the parameters. The marked parameters will then be preceded
by an exclamation mark.<p>
If you now copy this property all marked parameters
will be omitted.<p>
It is also possible to copy just the parameters you marked
using <tt/"Copy Marked Prop"/.<p>
A simple example:<p>
Our task is to give a big number of material objects the same color,
but they already have different opacity settings. Copying the complete
attribute property would destroy the opacity values. We can accomplish
this by copying just the color attribute, but leave all other
attributes as they are:<p>
<enum>
<item>Change the color of a first material object using the <tt/"Attributes"/
property GUI. (Do not forget the <tt/"Apply"/ button!)
<item>Mark the color parameter as to be copied using a double click
on the text <tt/"Color"/; it should read <tt/"!Color"/ now.
<item>Copy just the color parameter to the property clipboard,
using <tt/"Copy Marked Prop"/ in the <tt/"Edit"/ menu or the
hot key <tt/&lt;Ctrl+I&gt;/.
<item>Select all other material objects.
<item>Paste the property using <tt/"Paste Property"/ or <tt/&lt;Ctrl+V&gt;/.
<item>All done!
</enum>

Care must be taken when pasting incomplete properties
to objects which do not have complete properties already.
Do not paste an incomplete shader property to an object
which does not already have the same shader!

<sect2>The Console<label id="cons">
<p>
The third part of the main window is the console.
The console is mainly for text output (informative, warning and
error messages). For this, the console captures the
stderr and stdout channels of the Tcl-interpreter Ayam is
running in. You can also redirect all Tcl error messages that would
normally cause a Tcl error requester to appear to the console using the
preference setting <tt>"Misc/RedirectTcl"</tt>
(see section <ref id="prefmisc" name="Miscellaneous Preferences">).<p>
But you can also enter commands, new Tcl procedures and so on in the
console. However, this is a feature for the advanced user that
studied section <ref id="script" name="The Tcl Scripting Interface">.
You need to explicitly click into the console to give it the
input focus and thus enable input.
<p>
An important thing to know is that the
keyboard shortcuts for the various main menu entries do not
work if the console has the input focus! Instead, other
keyboard shortcuts (related to the console) are in effect!
How do you get out of this? Simply press <tt/&lt;Shift+TAB&gt;/ or click
into an entry in a property GUI to move
the focus away from the console and enable the main
menu shortcuts again.
<p>
Note, that the <tt/&lt;TAB&gt;/ key alone does not move the
focus away from the console.
<tt/&lt;TAB&gt;/ instead completes names of files, commands
(procedures), variables and widgets.
You may try this out by typing <tt/tip/ in the console,
then press <tt/&lt;TAB&gt;/.
The console automagically completes <tt/tip/ to <tt/tipoftheDay/
(the procedure that prints out the tip of the day, try it).<p>

Another simple demonstration of the consoles capabilities:
<itemize>
<item>Create ten boxes by clicking on the box icon ten times.
<item>Select all ten boxes.
<item>Go to the console by clicking into it.
<item>Enter the following:
<tt>forAll 0 &lcub;movOb &dollar;i 0 0; rotOb &lsqb;expr &dollar;i*10&rsqb; 0 0&rcub;</tt>
</itemize>

This example uses three procedures:
<itemize>
<item><tt/forAll/: allows to execute
a command for each of the selected objects, or for each object in the
current level if no objects are selected.
<item><tt/movOb/: moves the selected object(s).
<item><tt/rotOb/: rotates the selected object(s).
</itemize>

See section <ref id="script" name="The Tcl Scripting Interface"> for a
listing of all the available commands.<p>
Note, that the example uses a side effect (the variable <tt/i/ that
holds the index of the currently processed object) to calculate
the amount of the movement and rotation.<p>
For more information regarding the console,
please refer to the appropriate documentation by the original
author Jeffrey Hobbs (see the console context menu, that you may
open with your right mouse button).

<sect1>The Main Menu<label id="mm">
<p>
Another important part of the main window has not been discussed so
far. This is the main menu bar. Note, that many menu entries have keyboard
shortcuts that are displayed in each entry. You can adapt the shortcuts
using the file <tt>"ayamrc"</tt>
(See section <ref id="ayamrc" name="Ayamrc File">).

<label id="mmfile">
The <tt/File/ menu deals with standard file operations:<label id="filem">
<itemize>
<item><tt/New/, clears the current scene (deletes all objects) and reloads
the working environment (if the preference setting
<tt>"Main/NewLoadsEnv"</tt> is enabled).
<item><tt/Replace/, clears the current scene and closes all views,
then loads a new scene from disk. All objects from the file
will be read.
<item><tt/Insert/, inserts the objects and views of a ayam file
into the current scene. All objects from the file
will be read.
<item><tt/Save as/, saves the current scene asking for a new file name.
<item><tt/Save/, saves the scene. If the scene has not been saved before
(read, you have not given it a file name) you will be asked for
a file name.
<item><tt/Import Mops/, import a scene from The Mops,
see section <ref id="impmops" name="Import of Mops Scenes">
for more information.
<item><tt/Export RIB/, exports the current scene to a RIB,
asking which camera (which view) to use.
<item><tt/Load Custom/, loads a file containing a custom object or a plugin.
Depending on the OS Ayam is running on, these are files with the
file name extension so or dll.
See section <ref id="customobj" name="Custom Objects">
for more information about custom objects.
<item><tt/Save Prefs/, save the current preference settings
to the ayamrc file after making a backup copy of this file (see section
<ref id="ayamrc" name="Ayamrc File"> for more
information about this file).
<item><tt/1./,<tt/2./,<tt/3./,<tt/4./, immediately replace the
current scene with the one in the menu entry. The menu entries
are updated and rotated upon successful loading and saving of a scene.
<item><tt/Exit!/, remove all temporary files, save preferences (if
the preference setting <tt>"Main/AutoSavePrefs"</tt> is turned on)
and quit the application.
</itemize>

<label id="mmedit">
The <tt/Edit/ menu contains object and property clipboard
operations, undo actions, and lets you open the preferences editor:
<itemize>
<item><tt/Copy/, copies the currently selected object(s) into the clipboard.
<item><tt/Cut/, moves the currently selected object(s) into the clipboard.
<item><tt/Paste/, copies the object(s) from the clipboard to the current level
of the scene.
Note, that the content of the clipboard remains intact after this
operation, this means that you can paste multiple times!
You can move objects
out of the clipboard using the menu entry
<tt>"Special/Clipboard/Paste (Move)"</tt>.
<item><tt/Delete/, removes the selected object(s) from the scene.<p>

<item><tt/Copy Property/, copies the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).
Marked parameters will be omitted!
<item><tt/Copy Marked Prop/, copies the currently marked parameters
of the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).
<item><tt/Paste Property/, copies a property from the property clipboard
to the currently selected object(s).<p>

<item><tt/Undo/, perform undo operation (see section
<ref id="undos" name="The Undo System"> for more information)
<item><tt/Redo/, perform redo operation (see section
<ref id="undos" name="The Undo System"> for more information)<p>

<item><tt/Material/, searches for the material object currently
associated with the selected object and selects it for editing.
If the selected object has no material yet, a new material
will be created first.<p>
<item><tt/Master/, searches for the master object of the
currently selected instance object and selects it for editing,
see section <ref id="instanceobj" name="Instance Object">.

<item><tt/Preferences/, opens the preferences dialog (see section
<ref id="prefs" name="Preferences"> for more information).
</itemize>

<label id="mmcreate">
The <tt/Create/ menu entries let you create objects. In contrast
to the object creation via the toolbox some menu entries
present you with small requesters, where you may adjust
parameters for the object to be created.
Here are the entries of the <tt/Create/ menu:
<itemize>
<item><tt/NURBCurve/, create a new NURBS curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="ncurveobj" name="NCurve Object">.
<item><tt/ICurve/, create a new interpolating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="icurveobj" name="ICurve Object">.
<item><tt/NURBPatch/, create a new NURBS patch. A small dialog box will
pop up, where you may specify the width and height of the new patch. See
also section <ref id="npatchobj" name="NPatch Object">.
<item><tt/BPatch/, create a new bilinear patch. See
also section <ref id="bpatchobj" name="BPatch Object">.
<item><tt/PatchMesh/, create a new patch mesh. See
also section <ref id="patchmeshobj" name="PatchMesh Object">.
<item><tt/Solid/, create a new solid primitive object, for use in CSG.
<tt/Box,/ <tt/Sphere/, <tt/Disk/, <tt/Cone/, <tt/Cylinder/, <tt/Torus/,
<tt/Hyperboloid/ or <tt/Paraboloid/ may be selected.
See also section <ref id="csgprim" name="CSG Primitives">.
<item><tt/Level/, creates a new hierarchy object. <tt/Level/
just groups objects, <tt/Union/, <tt/Intersection/,
<tt/Difference/, and <tt/Primitive/ are CSG operations. See
also section <ref id="levelobj" name="Level Object">.
<item><tt/Light/, create a new light source. See
also section <ref id="lightobj" name="Light Object">.
<item><tt/Custom Object/, create a new custom object. If this sub-menu
is empty no custom object has been loaded yet. See
also section <ref id="customobj" name="Custom Object">.
<item><tt/Instance/, create an instance of the currently selected
object, see section <ref id="instanceobj" name="Instance Object">
for more information regarding instances.
<item><tt/Clone/, create a clone object, see
section <ref id="cloneobj" name="Clone Object">
<item><tt/View/, a new View window will be opened. See
also section <ref id="viewobj" name="View Object">.
<item><tt/Material/, create a new material. A small dialog box will
pop up, where you have to specify the name of the new material. See
also section <ref id="materialobj" name="Material Object">.
<item><tt/Camera/, create a new camera. Camera objects may be used
to temporarily save view camera settings, see
section <ref id="cameraobj" name="Camera Object">.
<item><tt/RiInc/, create a new RIB-include object. Those objects
may be used to include objects into your scenes
that just exist as a piece of RIB, see
also section <ref id="riincobj" name="RInc Object">.
</itemize>

<label id="mmtools">
The <tt/Tools/ menu:
<itemize>
<item><tt/Create/, <tt/NURBCurve/, and
<tt/NURBPatch/, are sub-menus with various NURBS based modeling
tools, that are explained in depth in section
<ref id="nmtool" name="NURBS Modeling Tools">.
<item><tt/PolyMesh/: sub-menu for polygonal mesh related tools:
<itemize>
<item><tt/Merge/: merges all currently selected PolyMesh objects into
a single PolyMesh object, without checking for doubly used points,
loops, or faces. Normally, the currently selected PolyMesh objects will not
be changed by this tool. But you may let the merge-tool delete them
immediately, if you enable the <tt/RemoveMerged/-option.
If the <tt/OptimizeNew/-option is enabled, the <tt/Optimize/-tool
(see below) will be started after the merge operation with the
newly created merged object as argument.
<item><tt/Optimize/: optimizes the selected PolyMesh object(s)
by removing all multiply used control points (if the option
<tt/OptimizeCoords/ is enabled) or multiply used faces (not implemented yet).
If the option <tt/IgnoreNormals/ is enabled, the optimize-tool will
consider points with equal coordinates but differing normals
to be equal (and optimize them).
Removing multiply used control points using the <tt/Optimize/-tool
may decrease the memory consumption of the control points
by a factor of about six, depending on the connectivity of the original
mesh.
</itemize>
<item><tt/Show/, <tt/Hide/ set and unset the <tt/Hide/
attribute of the selected object(s) thus making them invisible.
Note, that hidden objects may be excluded from RIB-Export, when
the preference setting <tt>"RIB-Export/ExcludeHidden"</tt> is
activated.
<item><tt/Show All/ and <tt/Hide All/ set and unset the <tt/Hide/
attribute of all objects in the scene (including the root object
and all views!) regardles of the currently selected objects (and
without changing the current selection). These operations are
not undoable.
<item><tt/Convert/, starts the convert action that has been
registered for the type of the selected object(s). The exact
behaviour depends on the type of the selected object(s):
Instances are e.g. resolved to normal objects in place but
Revolve objects will be converted to simple NURBS patches without
destroying the original objects. This operation is
not undoable.
<item><tt/Force Notification/, force the notification callbacks of
all selected objects (or all objects in the scene if no objects are selected)
to be called. The notification callbacks are used by objects
like e.g. Revolve to be informed about changes of their child
objects to properly adapt to those changes.
</itemize>

<label id="mmcustom">
The <tt/Custom/ menu is initially empty. Custom objects and plugins,
may create entries here.

<label id="mmspecial">
The <tt/Special/ menu:
<itemize>
<item><tt/Save Selected as/, saves just the currently selected objects
to disk. Note, that Ayam will not check, whether the objects are
saved with their materials. It is also possible to save
instance objects without their master objects. This will lead
to errors while loading such a scene later on.
<item><tt/Save Environment/, saves the root object and all
views to the file pointed to by the preference
setting <tt>"Main/EnvFile"</tt>. Note, that there will be no
check whether loading of that environment on next start up is
enabled in the preferences. Note also, that using <tt/Save Environment/
you can just save environment files that contain the root object
and all views. If you want to include geometric objects in your
environment or if you want to exclude the root object and just
save views you have to use <tt>"File/Save"</tt> or
<tt>"Special/Save Selected as"</tt> respectively.
<item><tt>Clipboard/Paste (move)</tt>, moves objects from the clipboard back
to the scene (clearing the clipboard). This is the only way to
get referenced objects out of the clipboard.
<item><tt>Clipboard/Paste Property to selected</tt> paste the property
from the property clipboard to the currently selected
property of the currently selected object. No type check of the
properties will take place! You may e.g. copy the settings from a
displacement shader to a surface shader (as long as the copied arguments
of both shaders have the same names and types).
<item><tt>Points/Select All Points</tt>, selects all points of the currently
selected object(s).
<item><tt>Points/Invert Selection</tt>, selects all points of the currently
selected object(s) that are not selected, and de-select all points that
are currently selected.
<item><tt>Points/Apply To All</tt>, applies the transformations encoded in the
transformations property of the selected objects to all points of those
objects.
This will have the effect of resetting the transformations property
to the default values without transforming the points.
<item><tt>Points/Apply To Selected</tt>, applies the transformations
encoded in the
transformations property of the selected objects to the selected points.
This will reset the transformations property without transforming the
selected points. The points currently not selected will be transformed,
however!
<item><tt>Instances/Resolve all Instances</tt>, converts all instances
of the current level (and its child objects) to normal objects.
<item><tt>Instances/Automatic Instancing</tt>, pops up a small dialog box,
where you may parameterize and start the automatic instantiation
algorithm (that automatically creates instances from
equal objects). See section <ref id="ai" name="Automatic Instancing">
for more information regarding automatic instancing.
<item><tt>Tags/Add RiOption</tt>, pops up a small dialog box, where you may
select and parameterize a RiOption tag to add as tag to the Root object
(see <ref id="riotag" name="RiOption Tag">). The Root object does
not have to be selected, and the current selection will not be changed
by this action.
<item><tt>Tags/Add RiAttribute</tt>, pops up a small dialog box, where you may
select and parameterize a RiAttribute tag to add as tag to the currently
selected object(s)
(see <ref id="riatag" name="RiAttribute Tag">).
<item><tt>Tags/Edit TexCoords</tt>, opens the texture coordinates editor.
(see also section <ref id="tctag" name="TC (TextureCoordinates) Tag">).
<item><tt>Select Renderer</tt> opens a dialog where the renderer
for direct rendering from a view may be choosen.
The changes will have effect on all options that
control direct rendering from a view, except whether RenderGUIs should
be used.
If the <tt>"ScanShaders"</tt> checkmark is activated, Ayam will
additionally try to load the corresponding shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">))
and rescan for compiled shaders. Note, that in order for the
<tt>"ScanShaders"</tt> feature to work
properly you also have to set the <tt>"Main/Shaders"</tt> and
<tt>"Main/Plugins"</tt> preference setting correctly
(see also section <ref id="prefmain" name="The Main Preferences">).

<item><tt>RIB-Export/From Camera</tt>, writes a complete RIB of
the current scene with the camera transformations taken from the
currently selected camera object. The size of the rendered image will
be taken from the RiOptions of the root object. If they are zero,
default values of 400 pixels width and 300 pixels height will be used.
The type of the projection written will be perspective.
Otherwise the RIB looks exactly the same as if exported via
main menu <tt>File/Export RIB</tt>.

<item><tt>RIB-Export/Selected Objects</tt>, exports only the
selected objects to a RIB. Note that instances will always be resolved
and light objects are simply ignored. Note also that this RIB,
since it e.g. lacks camera transformation and WorldBegin/End directives,
may not be rendered directly by a RenderMan compliant renderer
(unless the renderer is really forgiving about mis-structured RIBs).
The main use of this feature is to let you create RIBs that may be easily
included in other RIBs using e.g. ReadArchive.

<item><tt>RIB-Export/Create ShadowMaps</tt>, creates the shadow maps
for the current scene.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/Toggle ToolBox/ closes or opens the toolbox window
(see <ref id="toolb" name="The Tool Box Window">). From version 1.3 on,
Ayam remembers the state of the toolbox in the saved preferences.
<item><tt/Toggle TreeView/ toggles object tree view and object listbox.
From version 1.3 on, Ayam remembers whether the tree view or the
object listbox is open in the saved preferences
(see also section <ref id="obj" name="Objects"> for more information
about both representations).
<item><tt>Zap Ayam</tt> iconifies all currently open windows of Ayam.
If one of the iconified windows is de-iconified later, all other zapped
windows will be de-iconified as well.
</itemize>

<label id="mmhelp">
The <tt/Help/ menu:
<itemize>
<item><tt/Help/, opens a web browser and displays the documentation,
the URL to display is taken from the <tt/Docs/ preference setting.
<item><tt/Help on object/, opens a web browser and displays
documentation about the currently selected type of object,
the URL to display is derived from the <tt/Docs/ preference setting,
this feature will not work with frame redirects e.g.
<tt>http://www.ayam3d.org/</tt>; use
<tt>http://ayam.sourceforge.net/docs/</tt> or a <tt>file:</tt>-URL
as base URL in the <tt/Docs/ preference setting instead!
<item><tt/Show Shortcuts/, displays some important shortcuts for modeling
actions, you may leave this window open when doing your first
steps in modeling with Ayam.
<item><tt/About/, displays some version, copyright,
and trademark information.
<item><tt/Show Tooltips/, enables tool tips (balloon help)
for various user interface elements (including the tool box buttons).
</itemize>


<sect1>Anatomy of a View<label id="viewwin">
<p>
<figure loc="ht">
<eps file="pics/view.ps" height="7cm">
<img src="pics/view.gif">
<caption>A View Window</caption>
</figure>
<p>
The view window is split into a menu bar and a
OpenGL-widget, where interaction and drawing takes place.
The title of the view window gives information about
name, current type, and action of the view.

<sect1>The View Menu<label id="vm">
<p>
<label id="vmview">
Here are all meny entries of the <tt/"View"/ menu:
<itemize>
<item><tt/Quick Render/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"QRender"/ command
(see the preferences) will be called. Note, that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
<item><tt/Render/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"Render"/ command
(see the preferences) will be called. Note, that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
<item><tt/Redraw/: forces the OpenGL-widget to be drawn, this is
particularly useful if automatic redrawing of the view has been disabled.
<item><tt/Export RIB/ exports the scene to a RIB. This does exactly the
same as the main menu entry <tt/Export RIB/, except that the current view is
already selected in the dialog box.
<item><tt/Open PPrev/, <tt/Close PPrev/: those menu entries are just
available, if the compile time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
Permanent preview (PPrev) continuously writes a RIB stream to
a (fast) RenderMan renderer, a frame for each redraw operation
of the view window that was used to open the the preview. This way, the
RenderMan renderer immediately displays all changes in the scene.
This is a great way to test many different camera or light settings without
the need to manually start a rendering process and close the preview window
for each different setting.
As the RIB client library usually is not able to handle more
than one open RIB stream, RIB-Export and direct rendering from
view windows is not available until the permanent view window is closed.
<item><tt/Create ShadowMaps/: creates the shadow maps for the current scene.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.
<item><tt/Close/: the View window will be removed.
</itemize>

<label id="vmtype">
The <tt/"Type"/ menu entries:
<itemize>
<item><tt/Front/
<item><tt/Side/
<item><tt/Top/
<item><tt/Perspective/
<item><tt/Trim/
</itemize>
may be used to change the type of the view, which
restrains the scope of certain modeling actions.
See sections <ref id="viewobj" name="View Object"> and
<ref id="vwsc" name="View Window Shortcuts and Actions">
for more information.

<label id="vmconf">
The <tt/"Configure"/ menu may be used to change preferences of the view. 
Some preferences are outlined in greater detail in
section <ref id="vat" name="ViewAttrib">.
<itemize>
<item><tt/Automatic Redraw/, toggles whether the view should
be redrawn, whenever the scene changes. If this is disabled,
you can force a redraw using <tt>View/Redraw</tt>.
<item><tt/Shade/ toggles whether the view should draw a shaded
representation rather than a wireframe.
<item><tt/Draw Selection only/, if this is enabled, just the
currently selected objects (and their children) will be drawn.
<item><tt/Draw Level only/, if this is enabled, just the
objects of the current level (and their children) will be drawn.
<item><tt/Draw BGImage/, if this is enabled, a background
image will be drawn. You can define this image using the
view attribute <tt/BGImage/.
<item><tt/Draw Grid/, if this is enabled the grid will be drawn.
<item><tt/Use Grid/, if this is enabled the grid will be used to
constrain modeling actions to grid coordinates.
<item><tt/Set Gridsize/, may be used to change the size of the grid
associated with this view. Another way to change the grid size is
to use the grid menu on the rightmost side, see below.
<item><tt/Half Size/, change width and height to the half of the
current values.
<item><tt/Double Size/, change width and height to the double of the
current values.
<item><tt/From Camera/, copy camera settings from the currently
selected camera object to the view.
<item><tt/To Camera/, copy camera settings to the currently
selected camera object from the view.
<item><tt/Set FOV/, lets you specify a field of view value
for the view, and adapts the zoom accordingly. This is just
working for perspective views, of course.
<item><tt/Zoom to Object/, adapt the camera settings, so that
the currently selected objects are centered in the view.
<item><tt/Align to Object/, align the view to the coordinate
system of the currently selected object or to the parent
object of the current level if no object is currently selected.
<item><tt/Edit Local/, if this is enabled modelling will take place
in local object space and not in world space. The grid will be
changed accordingly (interpreted as if defined in the local coordinate space).
See also section <ref id="editlocal" name="Editing in Local Space">.
</itemize>

The <tt/"Grid"/ menu may be used to change the current grid size:<p>
On the right hand side in the menu bar there is a little icon
that displays the current grid size.
You may click on the icon to display a menu with predefined
grid size values.
Choosing one of the values 0.1, 0.25, 0.5, or 1.0 will set the
grid size of the view to the value and additionally
switch on drawing of the grid and snapping to the grid.
The last entry, however, will set the grid size to 0.0 and
switch off drawing and snapping to the grid.
If a gridsize other than 0.1, 0.25, 0.5, or 1.0 is in effect
for the view, a different icon with a small x will be displayed in the
menu instead.

<sect2>View Window Shortcuts and Actions<label id="vwsc">
<p>
Important keyboard commands of a <tt/View/:
<itemize>
<item><tt/&lt;Left&gt;/, <tt/&lt;Up&gt;/, <tt/&lt;Right&gt;/,
<tt/&lt;Down&gt;/ rotate viewer around origin.
<item><tt/&lt;Add&gt;/, <tt/&lt;Sub&gt;/ (on the numeric keypad) zoom view.
</itemize>

Interactive actions modifying a view:
<itemize>
<item>Using <tt/&lt;v&gt;/ you may move the view with your mouse.
<item>Using <tt/&lt;V&gt;/ you move the camera in the direction it is
looking. Note, that this affects both, from and to setting of the
virtual camera. Furthermore, this movement will have no visible effect in
parallel views.
<item><tt/&lt;R&gt;/ (note the case!) starts rotating the virtual
camera around the point it is looking to.
<item>Rotating the view is also possible in any
modeling mode, when holding down the <tt/&lt;Alt&gt;/-key.
<item><tt/&lt;o&gt;/ starts zooming the view. Moving the mouse up
zooms in and moving the mouse down zooms out.
</itemize>

You may also move the view by dragging with the rightmost mouse
button and zoom the view with the middle mouse button.

If you have a wheel mouse and it is configured to send
Mouse4 and Mouse5 button events, Ayam will zoom the view
when you turn the wheel.

Using the menu entry <tt/"Zoom to Object"/ or
the shortcut <tt/&lt;Ctrl+o&gt;/ you can change the
views from to and zoom settings so that the selected objects
will be displayed centered in the view window.
This is handy, if you are e.g. searching for objects or simply
lost in space.

Using the menu entry <tt/"Align to Parent"/ or
the shortcut <tt/&lt;Ctrl+a&gt;/ you can change the
views camera settings so that it is aligned to the
coordinate system of the parent object of the current
level. This is handy for modeling in local coordinate
systems.

<sect1>Selecting Objects within a View<label id="objsel">
<p>
When no action is active for views (i.e. the views action is
<tt/"Pick"/) you can pick objects that appear within a view.
This section describes techniques that you can use for selecting
one or more objects within a view.

<sect2>Selecting Individual Objects<label id="oneobjsel">
<p>
Selecting objects within a view is a straightforward operation that uses
standard methods. You will use the following two selection operations most
frequently:

<itemize>
<item> To select a single object within a view, move the cursor to the object
and click mouse button 1 (the leftmost one).
Once you select an object, any objects previously
selected are unselected automatically.
<item> To select an additional object, move the cursor to the object and
<tt/&lt;Shift&gt;/+Click (again with the leftmost mouse button).
Previously selected objects remain selected, and
the newly picked object is added to the selection. Notice that the picked item
must belong to the same level as the previously selected objects. An
alternative method for selecting multiple objects is to drag a rectangle
around them. For more information see
<ref id="mulobjsel" name="Drag-selecting Multiple Objects">
</itemize>

<sect2>Drag-selecting Multiple Objects<label id="mulobjsel">
<p>
You can select multiple objects using the <tt/&lt;Shift&gt;/+Click method
described in section <ref id="oneobjsel" name="Selecting Individual Objects">.
An additional method for selecting multiple objects is to drag a rectangle
around those objects. However only objects that belong to the current level
can be picked within a drag-selection. If you want to select multiple objects
that belong to another level you must change the current level by either
selecting it in the tree/listbox or by picking one object from that level
on a view. 

<p>
The procedure for drag-selecting multiple objects also uses a standard method:

<enum>
<item> Imagine a rectangle that encloses only the objects you want to select.
<item> Click at one corner of the rectangle and, while continuing to press the
mouse button, drag until you have enclosed all the objects.
<item> Release the mouse button. All the valid objects inside or crossing the
rectangle are selected and any objects previously selected are unselected
automatically.
</enum>

<p>
Note, that if you press <tt/&lt;Shift&gt;/ during the drag-selection, objects
that are enclosed by the rectangle will be added to the current selection
instead of replacing it.

<sect2>Ambiguous Picking<label id="ambobjsel">
<p>
In some cases Ayam is unable to differentiate between the objects you have
selected and other nearby or related objects. This ambiguity can arise as
follows:

<itemize>
<item>Imagine a small square surrounding the cursor. When you click an object,
any other valid objects that fall inside this square are also considered to
be possible selections. For example, if you select an item that is positioned
very close to another one, Ayam may consider both items to be possible
selections.
<item>If your model is three-dimensional (which is likely to happen),
imagine a line that is perpendicular to the screen and that passes through
the cursor and into the model. When you pick an object, any objects that
intersect this line are considered to be possible candidates for selection.
</itemize>

<p>
<figure loc="ht">
<eps file="pics/ampick.ps" height="3cm">
<img src="pics/ampick.gif">
<caption>List of Ambiguous Candidates</caption>
</figure>

<p>
If your selection is ambiguous Ayam displays a window that contains a list of
the possible candidates for selection. When you click a name in the list,
the corresponding object is highlighted. Click <tt/"OK"/ when you have
determined which object to select or <tt/"Cancel"/ to close the list and keep
the previous selection unchanged.

<p>
Notes:
<itemize>
<item> While the list of ambiguous candidates is opened you can not pick other
objects within the views.
<item> It is possible to use the <tt/"Zoom to Object"/ action (shortcut
<tt/&lt;Ctrl+o&gt;/) while the ambiguous select listbox is open to get
a better view of the temporarily selected object.
<item> The tolerance used to determine whether an object should be picked
or not can be adjusted (see <tt/"PickTolerance"/ in <ref id="hidprefs" 
name="Hidden Preference Settings">).
</itemize>

<sect1>The Tool Box Window<label id="toolb">
<p>
<figure loc="ht">
<eps file="pics/tools.ps" height="8cm">
<img src="pics/tools.gif">
<caption>The Tool Box</caption>
</figure>
<p>
The tool window displays some buttons that start interactive
modeling actions or other modeling tools, or create objects.<p>
Note, that in contrast to the keyboard shortcuts of the
view windows the buttons switch to the modeling actions for
all available views. For more information about the actions
see section <ref id="iac" name="Interactive Actions">.<p>

The tool window may be configured by the user using the
preference setting toolBoxList in the ayamrc file.
You may select from the groups and change the order in which
they appear in the tool window. See section
<ref id="hidprefs" name="Hidden Preference Settings"> for
more information.<p>

You may also resize the window to change from the vertical
standard layout to a horizontal one, optimizing the
use of precious screen space. After resizing, the tool box will
re-layout the buttons, warning you if the space is to small for all
buttons to display, and if the window is too big for the desired layout
shrink wrap the window to match the size occupied by the buttons.
Furthermore, using the preference setting <tt>Misc/ToolBoxTrans</tt>
the tool box can be made transient.
It will then (depending on the window manager or its configuration)
get a different or no decoration, no icon, and will always be iconified
when the main window gets iconified.

<sect1>Preferences<label id="prefs">
<p>

<figure loc="ht">
<eps file="pics/prefs.ps" height="6cm">
<img src="pics/prefs.gif">
<caption>Preferences Dialog</caption>
</figure><p>
The preferences dialog may be opened using
the main menu entry <tt>"Edit/Preferences"</tt> or the
shortcut <tt/&lt;Ctrl+p&gt;/.<p>
Use
<itemize>
<item><tt/"Ok"/ to close the preference editor and
apply all changes,
<item><tt/"Apply"/ to apply the changes, but
leave the editor open,
<item><tt/"Def."/ to reset to the settings
that have been loaded on program startup (these
are not the factory defaults, to get back to the factory
defaults, restart Ayam with the command line option <tt/"-failsafe"/!),
<item><tt/"Cancel"/ to close the dialog without applying changes
(done after the last press of <tt/"Apply"/).
</itemize>

The preferences are divided into five sections.

<sect2>The Main Preferences<label id="prefmain">
<p>
The <tt/"Main"/ section contains the most used preference settings:
<itemize>
<item><tt/"Shaders"/ contains a number of paths (separated by <tt/":"/
on Unix and <tt/";"/ on Win32) where Ayam looks for compiled
shaders (e.g. files with the extension <tt/".slc"/ that have been compiled
with slc from BMRT). Using the <tt/"Add"/ button, you may add
another path, simply press it and select a file inside the directory
you want to add. Note, that currently the filename of a compiled shader
may contain just two <tt/"."/ at maximum.
<item><tt/"Scan for Shaders!"/ initiates a rebuild of the internal
shaders database. All shaders in the directories specified by
the <tt/"Shaders"/ entry will be scanned and entered in that database.
Watch the console for error messages that may appear while scanning.
See also section <ref id="parseshd" name="Shader Parsing"> for more
information on scanning shaders.
</itemize>

The next sub-section contains GUI (user interface) related
settings.<label id="prefgui">
<itemize>
<item><tt/"Locale"/, sets a language for the balloon help texts,
the default value menu shows all currently available locales.
The value will have no effect until Ayam is restarted!
<item><tt/"AutoResize"/ toggles, whether the main window
should be resized horizontally according to the property GUI whenever
a new GUI is displayed.
<item><tt/"AutoFocus"/ controls whether Ayam should automatically
move the focus to a view or the main window, when the mouse pointer
enters it. Note, that this may only work correctly, when a window
of Ayam already has the focus. Notice also, that moving the focus
to a window might also raise it (depending on your operating system
or window manager).
<item><tt/"TwmCompat"/ changes, how Ayam tells the window manager
new geometries of windows. Might be useful, if you suffer from jumping
windows.
<item><tt/"ListTypes"/ determines, whether the type of an
object should be displayed in brackets in the tree view or listbox.
<item><tt/"AutoSavePrefs"/, if this is switched on, Ayam will write
the preferences settings to the file ayamrc when the program quits.
<item><tt/"LoadEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ on startup. 
<item><tt/"NewLoadsEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ also when the scene is
cleared using the main menu entry <tt>"File/New"</tt>.
<item><tt/"EnvFile"/; This file typically contains some view
objects to create a standard 2-, 3-, or 4-view working environment.
<item><tt/"Scripts"/ is a list of filenames of Tcl scripts that should
be executed on startup.
<item><tt/"Plugins"/ is a list of directories that contain custom
objects or plugins. Those directories will e.g. be searched for
custom objects when unknown object types are encountered while reading
Ayam scene files. If a matching custom object is found, it will be
automatically loaded into Ayam, so that scene loading may proceed without
an error.
<item><tt/"Docs"/ is an URL that points to the documentation in
HTML format.
<item><tt/"TmpDir"/ is the directory, where temporary RIBs are
created, e.g. when rendering directly from view windows.
</itemize>

<sect2>Modeling Preferences<label id="prefmodel">
<p>
The next section of the preferences, <tt/"Modeling"/,
contains modeling related settings:
<itemize>
<item><tt/"PickEpsilon"/ is used by the single point editing actions
to determine which point (vertice) of an object has been selected. 
A smaller <tt/"PickEpsilon"/ means more exact picking.
If you set it to 0.0, however, the picking code will always return the nearest
point (vertice) to the picking coordinates.
<item><tt/"LazyNotify"/ determines whether notification shall
occur on all mouse movements or just on release of the mouse button,
for the interactive modeling actions.
Notification is the mechanism used to inform objects that rely
on certain child objects (e.g. the Revolve custom
object) about changes of their child objects, so that the parent can adapt
to the child objects automagically.
<item><tt/"EditSnaps"/ determines, whether points
should be snapped to the grid when a grid is defined and
in use for the single point modeling actions.
<item><tt/"UndoLevels"/ determines the number of modeling steps
that should be saved in the undo buffer. Useful values range
from 2 to 50 (depending on how much memory you like to spend).
If you set <tt/"UndoLevels"/ to -1, the undo system will be disabled
completely.
For more information, see also the section
<ref id="undos" name="The Undo System">.
</itemize>

<sect2>Drawing Preferences<label id="prefdraw">
<p>
The preferences in the <tt/"Drawing"/ section let you specify
how objects are being drawn:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a NURBS curve
or NURBS patch using GLU.
Smaller tolerance settings lead to higher quality. Useful values
range from 1 to 100.
This setting has no effect for objects that override it
using a local tolerance setting different from 0.
<item><tt/"DisplayMode"/ sets the display mode for NURBS patches.
Either the control hull (or control polygon) is drawn (ControlHull), or 
just the outlines of the polygons created by the tesselation
(OutlinePoly), or just the outlines of the patch (OutlinePatch).
Note, that this setting just affects the drawing of patches if
the view is not in shaded mode.
Note also, that this setting has no effect for objects that override it
using a local DisplayMode setting different from "Global".
<item><tt/"NCDisplayMode"/ sets the display mode for NURBS curves,
The control hull (control polygon) or the curve or a
combination of both may be displayed.
Note, that this setting has no effect for objects that override it
using a local DisplayMode setting different from "Global".
<item><tt/"UseMatColor"/ determines, whether the shaded representation
uses the color defined by the material of an object for
rendering.
<item><tt/"Background"/, <tt/"Object"/, <tt/"Selection"/, <tt/"Grid"/,
<tt/"Tag"/, <tt/"Shade"/, and <tt/"Light"/ let you set colors that
will be used when drawing or shading. 
</itemize>

<sect2>The RIB-Export Preferences<label id="prefrib">
<p>
The <tt/"RIB-Export"/ section of the preferences contains settings that
affect how RIBs are created.
<itemize>
<item><tt/"RIBFile"/ allows to set the file Ayam is exporting
RenderMan Interface Bytestreams (RIBs) to. Note, that some
filenames have special meaning:<p>

If you set <tt/"RIBFile"/ to <tt/"Scene"/ (this is the default)
the RIB file name will be derived from the name of
the currently loaded scene with the last extension replaced by
<tt/".rib"/. If you set <tt/"RIBFile"/ to <tt/"Scenefile"/, the leading
path will be stripped from the scene name additionally.
Use <tt/"Scenefile"/, if you render with shadow maps.
This way the scene will use relative paths to
load the shadow maps and you may move
the RIBs around more easily.<p>

<tt/"Ask"/ is another special setting, that allows
to select a different filename each time you export a RIB file.
A file selection dialog will pop up, after the selection of the
view to export.
The same effect may be achieved by leaving <tt/"RIBFile"/ totally
empty!<p>

If you set <tt/"RIBFile"/ to <tt/"rendrib"/,
libribout.a does not create a RIB file at all, but immediately pipes the
resulting byte stream into rendrib (the BMRT renderer) for rendering.
The same goes for <tt/"rgl"/.
Moreover, filenames that start with a pipe symbol <tt/"|"/ will
cause the program behind the symbol to be started by libribout
and the written RIB to be piped into. This works e.g.
with Photorealistic RenderMan, try it out with <tt/"|render"/.
In the latter cases of direct rendering, you will probably want to set
up the RIB to render to the display (read leave the <tt/"Image"/
preference setting empty.
However, when you use these options of direct rendering, be warned, that
for the time of the rendering Ayam will be frozen (it will neither
respond to mouseclicks nor will it update any windows), until the
rendering is finished and the display window of the renderer is closed.

<item><tt/"Image"/ specifies the image file that will be created,
when you render the exported RIB file.
You may set it to <tt/"RIB"/, this will create image
files that are named as the exported RIB file (with the last
file extension replaced by <tt/".tif"/). Again, setting
it to <tt/"Ask"/ will cause a dialog box to appear,
each time you export to a RIB file.
Note, that in contrast to the <tt/"RIBFile"/ option leaving the field
totally empty is not equal to entering <tt/"Ask"/ but generates
RIB files that will be set up to render to the display.

<item><tt/"ResInstances"/, if this is enabled all instance
objects are resolved (temporarily) before being written to the RIB file.

<item><tt/"CheckLights"/, if this is enabled Ayam will
check the current scene for lights before RIB export. If no lights or
no lights that are actually switched on are to be found in
the scene, a distant headlight will be added to the scene
automatically for RIB export.

<item><tt/"DefaultMat"/ determines a default material setting
that should be written in the top level of the RIB, so that it
is in effect for all objects, that are not connected to a material
object. Many RenderMan compliant renderers will not render the
objects at all, if no material is defined.
The default <tt/"matte"/, writes just a simple
<tt>RiSurface "matte"</tt> (without parameters) to the RIB.
The setting <tt/"default"/ looks for a material object named
<tt/"default"/ and writes it's complete shaders and attributes,
if it does not find such a material it falls back to <tt/"matte"/.
The setting <tt/"none"/ does not write any default material setting.
<item><tt/"RIStandard"/ determines whether Ayam
should omit all non standard RenderMan interface options and
attributes on RIB export.

<item><tt/"WriteIdent"/ determines, whether Ayam should
write special RiAttributes
(<tt>"RiAttribute "identifier" &lsqb"name"&rsqb</tt>)
with the names of the objects to the RIB to aid in RIB file debugging.

<item><tt/"ShadowMaps"/ determines, whether shadow maps should
be used, when writing light sources. It is not sufficient
to switch this on to render using shadow maps, light sources
that shall use shadow maps have to be parameterized
as well, see section <ref id="shadowmaps" name="Using ShadowMaps">.
If <tt/"ShadowMaps"/ is set to <tt/"Automatic"/, the
exported RIBs will automatically render and use all shadow maps;
if it is set to <tt/"Manual"/, the shadow maps will be rendered on
user request only (using the view menu entry:
<tt>"View/Create ShadowMaps"</tt>). <tt/"Manual"/ should be used,
when rendering directly from view windows with shadow maps.

<item><tt/"ExcludeHidden"/ causes hidden objects not to be
exported to RIB files.

<item><tt/"RenderMode"/ allows to switch between two different methods
of forcing a renderer to render to the screen (via a RiDisplay statement
in the exported RIB, necessary for e.g. PRMan and RDC;
or via a command line argument, e.g. <tt>-d</tt> for rendrib from BMRT).

<item><tt/"QRender"/ determines the command that should be executed,
upon quick rendering a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"QRenderUI"/, enables the Rendering GUI for quick rendering,
see discussion of <tt/"RenderUI"/ below.

<item><tt/"QRenderPT"/, progress template for quick rendering,
see discussion of <tt/"RenderPT"/ below.

<item><tt/"Render"/ determines the command that should be executed,
upon normal rendering of a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"RenderUI"/ enables the renderer user interface (Rendering GUI),
which consists of a simple progress bar, a label that displays the
estimated or elapsed rendering time, a checkbutton to control
ringing the bell when the rendering is finished,
and a cancel button. This GUI is displayed
when a renderer is invoked directly from a view window
using the <tt/"Render"/ view menu entry (or the equivalent keyboard shortcut).
Proper work of this GUI depends on the existence of
two external programs: <tt/"cat"/ and <tt/"kill"/ (those programs
should be available on every Unix platform). If you do not have
those programs in your path, do not enable the RenderUI option.
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam1.4.
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"RenderPT"/ is a string that contains a progress output
template used by Ayam to determine the current percentage of completion
of the rendering for display in the Rendering GUI. The special symbol <tt/"%d"/
denotes the position of the percentage number in the output of the renderer.
For rendrib from BMRT2.6 this should be set to <tt/"R90000 %d"/ and
the special command line option <tt/"-Progress"/ should be used.
For rendrib from BMRT2.5 it should be set to "<tt/"Done computing %d"/
and no special option has to be given to the renderer.

<item><tt/"SMRender"/, renderer to use for the rendering of shadow maps
using the view menu entry <tt>"View/Create ShadowMaps</tt>,
<tt>%s</tt> denotes the name of the RIB file.
<item><tt/"SMRenderUI"/, enables the Rendering GUI for the rendering
of shadow maps, see discussion of <tt/"RenderUI"/ above.
<item><tt/"SMRenderPT"/, progress template for the rendering
of shadow maps, see discussion of <tt/"RenderPT"/ above.

<item><tt/"PPRender"/ is the name of the renderer to use for the
permanent preview feature (see also section <ref id="vm" name="View Menu">).
This setting is just available, if the compile
time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
</itemize>

<sect2>Miscellaneous Preferences<label id="prefmisc">
<p>
The (<tt/"Misc"/) section of the preferences contains the dreaded
miscellaneous settings.

The first sub-section deals with error message handling:
<itemize>
<item><tt/"RedirectTcl"/ controls, whether error messages
stemming from Tcl/Tk should be redirected to the console,
rather than be handled by Tcls sometimes annoying error
handling dialog box. However, this dialog box with the built in
stack trace can also become very handy, if you write and debug
Tcl scripts.
<item><tt/"Logging"/ determines, whether error messages should
be written to the file specified by <tt/"LogFile"/.
If this is enabled, you should clear the log manually from time
to time, as Ayam will always append to <tt/"LogFile"/.
<item><tt/"LogFile"/; see above.
</itemize>

The last sub-section contains miscellaneous user interface
related preferences:
<itemize>
<item><tt/"SaveAddsMRU"/; if this is switched on, saving to a file
will add that file to the most recently used list in the main menu
for quick access.
<item><tt/"ToolBoxTrans"/; controls whether the tool box window
should be declared as a transient window of the main window.
It will then, depending on the window manager or its configuration,
get a different or no decoration, no icon (or no entry in the
task bar on Windows), and will always be iconified
when the main window gets iconified.
<item><tt/"ToolBoxShrink"/; controls whether the tool box window
should automatically shrink-wrap around the calculated layout 
of the buttons after a resize operation.
<item><tt/"RGTrans"/; controls whether the RenderUI-windows
should be declared as a transient window of the main window.
See the discussion of <tt/"ToolBoxTrans"/ above for more information
about transient windows.
<item><tt/"HideTmpTags"/ may be used to hide tags that are marked
temporary (internal tag types do so) from the tag property GUI.
<item><tt/"TclPrecision"/; this is the precision Tcl handles floating
point numbers with. You may want to decrease this number to about 5
if any numbers in the entry fields are represented in an exact, but also
too lengthy and hard to read fashion, like 0.4999999 instead of 0.5.
Note that you may loose information in doing so. The default value used
by Tcl is 12 and results in no loss of information. The default value
used by Ayam is 6 and should result in a good balance between precision
and readability.
<item><tt/"SMethod"/; is the sampling method used by the NURBS to PolyMesh
(tesselation) facility (based on GLU V1.3+). Three methods are available:
<tt/"DomainDistance"/ (the default) simply tesselates the NURBS into equally
sized pieces with regard to parametric space; <tt/"SParam"/ controls
the number of sampling points in u and v direction;
<tt/"PathLength"/ ensures that no edge of a polygon generated by
the tesselation is longer than the value specified by <tt/"SParam"/;
<tt/"ParametricError"/ ensures that the distance between the tesselated
surface and the original surface is no point bigger than the value specified
by <tt/"SParam"/. Note that <tt/"SParam"/ is expressed in object space
units for the last two sampling methods.
<item><tt/"SParam"/; is a parameter for the sampling method above.
The default value for the sampling method <tt/"DomainDistance"/ is 10. Higher
values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"PathLength"/ is 30.
Smaller values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"ParametricError"/ is 0.5.
Smaller values lead to better quality and more tesselated polygons.

</itemize>

<sect>Interactive Actions (Modeling)<label id="iac">
<p>
Before invoking any modeling action you should select
one or more objects using the main window or using the pick action!<p>

Every action can be started with a key press (a shortcut) when
the focus is in a view window or by pressing the
associated button in the tool window. 
Using a shortcut starts that action in the current view only,
the other views are not affected. Starting an action from the
tool window will cause the action to be started in all
view windows simultaneously.<p>

To break an action, the <tt/&lt;Esc&gt;/ key may be used.

The default action for all views, which is also in effect after
use of the <tt/&lt;Esc&gt;/ key, is <tt/"Pick"/,
see section
<ref id="objsel" name="Selecting Objects within a View">
for more information about picking objects.

Note, that the modeling actions
are not available in perspective views.<p>

If an action is in effect for a view, the views title will be changed
appropriately.<p>

A modelling action is performed by clicking into the
view to mark a point in space or to pick a vertex, then dragging
the mouse.<p>

You may undo/redo the effects of an action using <tt/&lt;Ctrl+z&gt;/
and <tt/&lt;Ctrl+y&gt;/ (see section
<ref id="undos" name="The Undo System"> for more information).<p>

Grids are available to restrict the modeling actions to certain
points and help in exact modeling.

Also note, that you may use the middle and rightmost mouse button
to zoom and move the view while modeling actions are active.

For actions that modify the camera of a view
please see section <ref id="vwsc" name="View Window Shortcuts and Actions">.

<sect1>Moving Objects or Selected Points
<p>
Using the modeling action <tt/"Move"/ (shortcut: <tt/&lt;m&gt;/)
you may move selected objects or the selected (tagged) points
of the selected objects.<p>

Note, that the objects/points will be moved in the XY-plane for
Front-views, the ZY-plane for Side-views, and the XZ-plane
for Top-views only, no matter how the view is rotated.

<sect1>Rotating Objects or Selected Points<label id="rotac">
<p>
Using the modeling action <tt/"Rotate"/ (shortcut: <tt/&lt;r&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects.<p>

Note, that if multiple objects are selected, each object is rotated
around the center of its own local coordinate system.
The axis of rotation is always parallel to the Z-axis in Front-views, the
Y-axis in Top-views, and the X-axis in Side-views.<p>

<sect1>Rotating Objects or Selected Points around a Point
<p>
Using the modeling action <tt/"Rotate about"/ (shortcut: <tt/&lt;a&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects around a specified point in space.
The action requires a point to be specified using a single
click after the action has been started.
The point will then be marked by a little red cross.
If you want to rotate about a different point, you need to restart the
action (press <tt/&lt;a&gt;/ again).
<p>
After the first click, the action works the same way as
the Rotate action, except that it rotates around the specified point.
This also works with multiple selected objects.
Note, that this action does not only change the Rotate_X(_Y,_Z)
properties of the selected objects, but also the Translate_X(_Y,_Z)
properties.
<p>
To avoid degenerated coordinates due to roundoff errors
it is highly suggested to use grids with this action.

<sect1>Scaling Objects or Selected Points<label id="scalac">
<p>
There are several different actions available to scale
objects or the selected (tagged) points
of the selected objects.<p>

The modeling action <tt/"Scale 3D"/ (shortcut: <tt/&lt;S&gt;/, note the
big S!) scales all three axes of the selected objects or
the selected (tagged) points of the selected objects
by the same factor.<p>

The modeling action <tt/"Scale 2D"/ (shortcut: <tt/&lt;s&gt;/)
scales just two axes of the selected objects or
the selected (tagged) points of the selected objects. Those axes are
XY in a Front-view, ZY in a Side-view, and XZ in a Top-view.<p>

The modeling actions <tt/"Scale X"/ (shortcut: <tt/&lt;x&gt;/),
<tt/"Scale Y"/ (shortcut: <tt/&lt;y&gt;/), and
<tt/"Scale Z"/ (shortcut: <tt/&lt;z&gt;/) scale only one axis
of the selected objects or
the selected (tagged) points of the selected objects.

The modeling action <tt/"Stretch 2D"/ (shortcut: <tt/&lt;Alt+s&gt;/)
works much like <tt/"Scale 2D"/ but the scale factor for each
axis may be different. Never start this action by a click
near one of the axes to be changed, as this will cause
very big scale factors for the other axis. Try it first with
a centered box by starting from one of the vertices,
then try it once starting on the X-axis.<p>


<sect1>Selecting Points<label id="selac">
<p>
The modeling action <tt/"Select Points"/
(shortcut: <tt/&lt;t&gt;/; tag points)
may be applied to a NURBS curve, NURBS patch or objects
that support single point editing only. Objects draw the
selectable points using small rectangular handles.
Selected points will be drawn in dark red.<p>

The selected points may be modified using the modeling actions
Move, Rotate, and Scale as discussed above.
Selected points always take precedence for those modeling actions.<p>

After the pick (the selection of a point), the picked point
will be added to the list of selected points for the selected object.
If the selected point is already in that list
it will be removed from the list instead. Note that the list
of selected points will not be deleted from the object
until a de-select is performed using the shortcut <tt/&lt;D&gt;/.<p>

Note, that the list of selected points is not copied, if the object is copied
using the clipboard.
Undo and redo will destroy the list of selected points too!<p>

However, it is perfectly legal to select some points, move them using
the move action, then switch to single point editing, edit
some other or even one of the selected points, switch back
to the selection action, add other points to the selection or delete some
points from the selection, switch to rotate, rotate the selected
points and so on.<p>

You may also add a bigger number of points
to the selection using a click and drag operation. All points
that are inside the rectangular region defined by the click and drag
will be added to the selection.

<sect1>Editing Points<label id="editac">
<p>
To edit the points of an object three actions are available.
All actions may be applied to a single NURBS curve, NURBS patch or objects
that support single point editing only.
Objects mark themselves
editable by drawing the editable points using small rectangular handles.
<itemize>
<item>The modeling action <tt/"Edit"/ (shortcut: <tt/&lt;e&gt;/)
works much like the move action, but it moves
single points instead of objects.<p>

<item>The modeling action <tt/"Edit Weights"/ (shortcut: <tt/&lt;w&gt;/)
changes the w coordinate of a
single point by dragging the mouse left or right.
The weights may be reset for all points
using the shortcut: <tt/&lt;W&gt;/.<p>

<item>The modeling action <tt/"Direct Point Edit"/ (shortcut:
<tt/&lt;p&gt;/)
opens a small window where you may change the coordinates of the
selected point directly by entering numbers.
Note, that the w coordinate setting will be ignored if the
picked point does not have weight information (is not homogenous).
Using the small menu on top of the coordinate window you may
determine whether editing takes place in local object or global
world space.
<p>
Notice that since Ayam 1.4 the direct point editing dialog may stay
open all the time. Furthermore, it is not necessary that the original
object stays selected, you may select other objects to e.g. infer new
point coordinates from their properties and apply them to the
original object.
However, certain actions like deleting objects, will also delete the
reference to the selected points. In this case you will have to select
the object and then a point to edit again. Furthermore notice that
the coordinate values displayed in the direct point editing window
will not update when the point is modified by another modeling
action. Simply click on the point again in a view where the
direct point editing action is active, to update the coordinate
values in the direct point editing dialog.
</itemize>

<sect1>Inserting or Deleting Points<label id="insdelac">
<p>
The modeling action <tt/"Insert Point"/ (shortcut: <tt/&lt;i&gt;/)
may be applied to NURBS and ICurves curves only.
A new control point will be inserted in the curve right
after the picked point. The new point will be inserted in the
middle between the selected point and the next point, changing
the shape of the curve. It is possible to insert control
points into certain types of NURBS curves using knot insertion,
see the insert knot tool <ref id="insknt" name="The Insert Knot Tool">.<p>

The modeling action <tt/"Delete Point"/ (shortcut: <tt/&lt;d&gt;/)
may be applied to NURBS and ICurves curves only.
The selected control point will be deleted from the curve.
Deleting points from a curve with knot type custom
may currently lead to an incorrect knot sequence, please
check the new sequence.<p>

<sect1>Miscellaneous Actions<label id="miscac">
<p>
This section documents some special modeling actions.
<itemize>
<item>The modeling action <tt/"FindU"/ (shortcut: <tt/&lt;u&gt;/)
may be applied to NURBS curves only.
This action may be used to get the corresponding parametric
value u from a point on a curve. Pick a point on the curve
(not a control point!). If this
is done, the appropriate value for u is calculated, stored
in the global variable u, and additionally written to the console.
A small cross is drawn at the position of the picked point.
Remember to exactly pick a point on the curve or nearby, otherwise
the calculation may fail and no value will be written to the console.<p>

<item>The modeling action <tt/"Split Curve"/ (shortcut <tt/&lt;c&gt;/)
may be applied to NURBS curves only.
Using this action you may split a NURBS curve into two new curves
at a point on the curve that may be specified by picking a point
on the curve.
Remember to exactly pick a point on the curve or nearby otherwise
the calculation of the parametric value for the split will fail.
The selected curve will be changed by this action, and
a new curve will be created. It is currently not possible to undo
the changes of a split!
</itemize>

<sect1>Editing in Local Space<label id="editlocal">
<p>
Normally, all editing takes place in world space and the input
plane of all modelling actions is constrained to the world
XY-, ZY-, or XZ-plane (depending on the type of view used).
<p>
However, if a view is aligned and switched to local, you can also
edit in local object space. This means you can e.g. edit a
two-dimensional parameter curve of a Skin object where both objects
(curve and skin) are rotated and scaled arbitrarily
and make sure that the curve remains two-dimensional all the time.
<p>
All you need to do is to first select the curve and then press
<tt/"Ctrl+a"/ to align the view and then <tt/"Ctrl+l"/ to make it local.
In practice, this means that the input plane of an aligned local view
will match the XY-, ZY-, or XZ-plane of the local object space,
depending on the type of the view (<tt/"Front"/, <tt/"Side"/, or <tt/"Top"/).
<p>
Furthermore, grids will also act as if defined in local object space.
In contrast to their normal behaviour, they can also be scaled
differently in X-window and Y-window coordinates in aligned local views
(if the local object space is deformed this way).

<sect>Objects and Properties<label id="obandprp">
<p>
This section informs you about the property GUIs that
appear in the properties section of the
main window if a single object and a property
have been selected.

<sect1>Standard Properties<label id="stdprop">
<p>
Most Ayam objects have standard properties, they are used
to control transformations and attributes of objects.
The following sections describe the standard properties
Transformations, Attributes, Material, Shaders, and Tags.

<sect1>Transformations<label id="trap">
<p>
Use this property to edit the location, orientation and
size of an object.
<itemize>
<item><tt/"Reset All!"/ immediately resets all transformation
attributes to the default values.
<item><tt/"Translation_X (_Y, _Z)"/ is the displacement of the
object from the world origin in X (Y, Z) direction.

<item><tt/"Rotation_X (_Y, _Z)"/ is the angle (in degrees)
of the rotation of the object around the X (Y, Z) axis.
Read the next section for more information on how to use these
entries. Read it!

<item><tt/"Scale_X (_Y, _Z)"/ determines a scale factor that will be
applied to the object in the direction of the local X (Y, Z) axis.

<item><tt/"Quat0 (1, 2, 3)"/ the quaternion that is used to determine
the orientation of the object in space. This quaternion is not here
to be edited directly! The sole purpose of its appearance here
is to allow copying and pasting of rotations.
</itemize>

<sect2>Using the Rotation Property<label id="gimb">
<p>
The orientation of an object in space may be expressed using
so called Euler angles. This notation (simply three angles
determining a rotation about the axes of the coordinate system)
suffers from a phenomenon called gimbal lock.

To avoid gimbal locks, Ayam internally holds the orientation
of an object in a quaternion.

This quaternion not only holds information about the angles
but also about the order in which partial rotations occured.

It is important to know, that the values of the angles of
the rotation property must not be read in a way that
the object will first be rotated around X by x-angle degrees
then around Y y-angle degrees then around Z z-angle degrees.
In fact, no information about the order in which partial
rotations occured may be derived from that three values.
This implies, that e.g. the values 0 0 45 may denote
a different orientation than the very same values
0 0 45 (no joke)!

But how do you get the three entries to do what you want?
You either want to rotate the object around an axis by a given
amount or you want to undo a rotation or undo all rotations.

Rotating an object is easy, simply add the amount about
which you want to rotate the object to the value currently
displayed in the appropriate entry. If you want to rotate
about 45 degrees about X and the x-angle entry displays a 30,
enter 75.
Then press the apply button.
If you change multiple entries the rotations made will be
in the order X (if changed) then Y (if changed) then Z (if changed).
Do not change more than one entry at once until you exactly
know what you are doing.

Undoing a single rotation works in the same way, just use a subtraction
instead of an addition.

Undoing all rotations (resetting the object to its original state)
is simple too: enter 0 for all three entries at once,
then press apply.

If you want to copy the orientation of an object to other objects
using the property clipboard, make sure that you select all Rot and
Quat property elements.

<sect1>Attributes<label id="attrs">
<p>
The attributes of an object contain currently:
<itemize>
<item><tt/"Name"/, the name of the object. It is also displayed
in the object listbox or tree and may be written to RIB streams.
<item><tt/"Hide"/, if this attribute is set this object is not drawn.
It may also be excluded from RIB export.
<item><tt/"Refcount"/, just displays how many objects
point to this object. Objects with a reference count different
from zero may not be deleted.
</itemize>

<sect1>Material<label id="matprop">
<p>
The material property allows you to connect geometric objects
to material objects (see also section
<ref id="materialobj" name="Material Object">).
<itemize>
<item><tt/"Clear Material"/ immediately clears any connection
of the current object to its material.
<item><tt/"Name"/ is the name of the material of this object.
An easy way to connect materials to objects is to simply
drop the geometric objects onto the material object using Drag-and-Drop
in the tree view.
</itemize>

<sect1>Shaders<label id="shd">
<p>
Shader properties are used to attach shaders of a certain type to objects.
The name of the property contains the type of the shader, e.g.
light shaders may be attached using a property named <tt/"LightShader"/ only.
Other types of shaders or shader properties are: <tt/"Surface"/,
<tt/"Displacement"/, <tt/"Interior"/, <tt/"Exterior"/, <tt/"Atmosphere"/,
and <tt/"Imager"/.
<p>
Each shader property GUI, even if no shader is attached to an object,
starts with the <tt/"Set new shader."/-button. This button allows
to select a new shader of the appropriate type.
If you press the <tt/"Set new shader."/-button, a dialog with a
list of shaders pops up. If this list is empty, Ayam
is probably not set up properly (or you simply do not have
shaders of the appropriate type). Check the preference setting
<tt>"Main/Shaders"</tt>.
After a new shader has been set, the arguments of the shader will be
parsed and a GUI will be generated to allow the arguments of the shader
to be filled with values.
<p>
The <tt/"Delete shader."/-button may be used to
delete the current shader from the selected object.
<p>
The <tt/"Default Values."/-button resets all arguments
of the shader to the default values.
See also section <ref id="workshd" name="Working with Shaders"> below.
<p>
All other elements of the shader property GUI depend on the currently
attached shader.

<sect2>Shader Parsing<label id="parseshd">
<p>
If no plugin is loaded, the official Ayam binaries use libslcargs
(from BMRT) to parse shaders that have been compiled with slc (the
shader compiler from BMRT). Parsing incorporates detecting the
type of the shader and detecting the names, types, and default values of
all shader arguments.
<p>
Note, that currently, Ayam only works properly with shaders
that have at most two dots in their file name and that Ayam will simply
skip all array arguments (and emit a warning message) while parsing
a shader. Those array arguments consequently never appear in the
shader property GUIs and RIBs exported by Ayam. Also note, that
default values for shader arguments of type color will be silently
clamped to the range 0-255.
<p>
Many shaders use array arguments to define transformation matrices.
If this is the case and you have access to the shader source code
you may want to modify those shaders to enable working with the
transformation matrix carrying shader arguments.
To do this, just change all definitions of transformation matrix
carrying floating
point arrays to real matrices.
If the shader contains a
<p>
<tt>"float a_matrix_parameter[16]"</tt>
<p>
change this to
<p>
<tt>"matrix a_matrix_parameter"</tt>.
<p>
Note, that these changes of the shader argument
definitions probably also require changes of the code that uses those
arguments.
Ayam is able to deal with matrices because
of their fixed size of 16 float values, and because libslcargs is able
to deliver the default values for a matrix (but not for an array!).
<p>
If Ayam has been compiled without a shader parsing library
(e.g. without libslcargs), Ayam will parse XML files created
by <tt/"sdpslparse"/ from the K-3D project
(see <tt>"http://www.k-3d.com/"</tt>)
instead of compiled shaders.
The <tt/"Set new shader."/-button will in this case always
open a file requester, allowing you to select a XML file,
that has been created by sdpslparse.
Furthermore, the <tt/"Default Values."/-button will not be available;
you have to use <tt/"Set new shader."/ instead.
<p>
From V1.3 on, Ayam also supports shader parsing plugins to allow parsing
of shaders compiled with different shader compilers, see also section
<ref id="spplugins" name="Shader Parsing Plugins">.

<sect2>Working with Shaders<label id="workshd">
<p>
The <tt/"Default Values."/-button resets all arguments
of the shader to the default values.
For that, the compiled shader will be parsed again.
Therefore, this button is quite handy if you have to deal with
changing shaders: just edit the shader, recompile it, then back
in Ayam just hit the <tt/"Default Values."/-button. Note, that
this destroys your possibly carefully adjusted shader argument values.
<p>
If you want to keep the old shader argument values when a shader
changes, simply copy the shader property using the property clipboard
(main menu: <tt>"Edit/Copy Property"</tt>) before
you load the new default values and paste the property
back using <tt>"Edit/Paste Property"</tt> after loading of the
new default values.
Note, that this works only properly, if you do not change
the type of existing shader arguments and if no shader arguments
are removed in the new shader!
<p>
You can also just copy certain parameter values by selecting
them using double-clicks on the parameter names in the shader
property GUI and then use e.g. <tt>"Edit/Copy Marked Prop"</tt>
(see also the description of the property clipboard in section
<ref id="propgui" name="Properties">).

<sect1>Tags<label id="tags">
<p>
Use this property to edit the tags of an object.<p>
Tags provide an easy way to attach arbitrary information to
objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.<p>
The Tags property GUI consists of the following standard
elements:
<itemize>
<item><tt/"Remove all Tags!"/ immediately removes all tags
from the object.
<item><tt/"Remove Tag!"/ is a menu, that allows you
to remove a single tag from the object.
<item><tt/"Add Tag!"/ opens a small dialog box, where you
may enter a new tag type and value. Once you press the <tt/"Ok"/
button, a new entry will be added to the tags property, displaying
the new tag. Just click on the entry to get back to the dialog,
to remove the tag using <tt/"Clear"/ then <tt/"Ok"/, or to change
the type or value of the tag.
</itemize>

The next sub-sections describe the currently available tag types.
Note, that extensions and plugins may define their own types.

<sect2>RiAttribute Tag<label id="riatag">
<p>
The tag type <tt/"RiAttribute"/ can be used to attach
arbitrary RenderMan interface attributes to objects.
This is handy if you use a renderer with lots of RiAttributes
that differ from the standard RiAttributes.<p>
<tt/"RiAttribute"/ tags attached to a geometric object override
<tt/"RiAttribute"/ tags possibly attached to the material object of this
geometric object.<p>
In order to create a tag of type RiAttribute, the type string must be
<tt/"RiAttribute"/. The syntax of the value string is as following:<p>
<tt/attrname,paramname,paramtype,param/<p>
where attrname is the name of the attribute (e.g. "render") paramname
is the name of the parameter (e.g. "displacementbound") paramtype is a
single character defining the type of the parameter (it may be one of
<tt/f/ - float,<tt/i/ - integer, <tt/s/ - string,
<tt/c/ - color, <tt/p/ - point) and finally
param is the value of the parameter itself (a float: "1", a string: "on",
a color: "1,1,1" or a point: "0.4,0.5,1.0").<p>

Examples:<p>
<tt>RiAttribute render,truedisplacement,i,1</tt><p>
<tt>RiAttribute radiosity,specularcolor,c,0.5,0.5,0.5</tt>

Note, that the RiAttribute tag handles just a single parameter at once.
Also note, that RiAttribute tags may be created much more easily
using the menu entry <tt>Special/Tags/Add RiAttribute</tt>.
The database of RiAttributes for this GUI may be extended
by the user using the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>RiOption Tag<label id="riotag">
<p>
The tag type <tt/"RiOption"/ can be used to attach
arbitrary RenderMan interface options to objects.
This is handy if you use a renderer with lots of RiOptions
that differ from the standard RiOptions.
However, they will be only used by the RIB exporter
if they are attached to the <tt/"Root"/ object!
The syntax is similar to the <tt/"RiAttribute"/ tag
type, see above.
Note, that RiOption tags may be created easily
using the menu entry <tt>Special/Tags/Add RiOption</tt>.
Tags created with this GUI will always be added to
the <tt/"Root"/ object. It does not
have to be selected!
Furthermore, the database of RiOptions for this GUI may be extended
by the user using the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>TC (TextureCoordinates) Tag<label id="tctag">
<p>
The tag type <tt/"TC"/ can be used to attach
texture coordinates to objects or materials.
<tt/"TC"/ tags attached to a geometric object override
<tt/"TC"/ tags possibly attached to the material object of this
geometric object.
The <tt/"TC"/ tag always contains a list of eight comma separated
float values, that specify a mapping for four points (a quadrilateral) in
texture space from the default values (0,0), (1,0), (0,1), and (1,1)
to the new specified values.<p>

Examples:<p>
<tt>TC 0,0,10,0,0,10,10,10</tt><p>
Changes the texture coordinate space so that more and smaller tiles
of a texture would be displayed on a primitive.<p>

<tt>TC 0,0,0,1,1,0,1,1</tt><p>
Flips the texture coordinate space over two corners.
A shader normally generating vertical stripes will create
horizontal stripes now.<p>

<tt>TC 0,1,0,0,1,1,1,0</tt><p>
Turns the texture coordinate space by 90 degrees.
A shader normally generating vertical stripes will create
horizontal stripes now.<p>

Note, that the exact behaviour depends heavily on the shader and its use
of the texture coordinates!

<sect3>Texture Coordinate Editor<label id="tce">
<p>
The texture coordinate editor may be opened using the
main menu entry <tt>"Special/Tags/Edit TexCoords"</tt> and
lets you edit texture coordinate
tags in an intuitive way.<p>
For that, the texture coordinates are displayed as a black
polygon in a canvas with regard to the original values,
that are displayed in gray.
Small arrows point to positive s and t direction respectively.

<figure loc="ht">
<eps file="pics/tce.ps" height="6cm">
<img src="pics/tce.gif">
<caption>Texture Coordinate Editor</caption>
</figure>
<p>

The <tt/"RotateR"/ and <tt/"RotateL"/ buttons shift the coordinate
values between the four points. This results in a 90 degree
rotation.
<p>
The <tt/"FlipS"/ and <tt/"FlipT"/ buttons flip the texture
coordinate values in s and t direction respectively. This is
useful, if you want to correct a texture mapping for
an image that appears upside down.
<p>
The next buttons allow to move (using <tt/"MoveS"/ and <tt/"MoveT"/)
and scale (using <tt/"ScaleS"/ and <tt/"ScaleT"/) the texture coordinates
by a specific amount that is given in the first entry field.
<p>
The <tt/"Load"/ and <tt/"Save"/ menu buttons allow you to:
<itemize>
<item>load the default values
<item>load texture coordinates from a selected BPatch object:
The xy coordinates of the four points of the selected BPatch
will be interpreted as st coordinates.
This allows for more complex transformations of the texture coordinates
e.g. rotations about an angle of 45 degrees.
<item>load TC tags from the selected object
<item>save the texture coordinates to a BPatch object
<item>save TC tags to a selected object; Note, that it is not
possible to save the TC tag to multiple selected objects.
Use the property clipboard to achieve this.
</itemize>
Note, that the tag numbers in the
menu entries count TC tags only.

The texture coordinate dialog is modeless, it may stay open
while you model.
The <tt/"Dismiss"/ button closes the dialog.

<sect2>RiHider Tag<label id="rihtag">
<p>
The tag type <tt/"RiHider"/ can be used to choose and parameterize
different algorithms for hidden surface removal.
RiHider tags have to be attached to the root object in order to be used.
The syntax of a RiHider tag is quite similar to a RiAttribute tag:
<tt/"&lt;type&gt;,&lt;parameterlist&gt;"/
where <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.

An example for a RiHider tag could look like this:
<code>RiHider hidden,depthfilter,s,midpoint</code>

<sect2>RiDisplay Tag<label id="ridtag">
<p>
The tag type <tt/"RiDisplay"/ can be used to add more output
files of different type (e.g. containing depth-buffer information)
to the scene.
RiDisplay tags have to be attached to the root object in order to be used.
The syntax of a RiDisplay tag is as follows:
<tt/"&lt;name&gt;,&lt;type&gt;,&lt;mode&gt;,&lt;parameterlist&gt;"/,
where name is e.g. a file or device name, type specifies the
destination of the image data (e.g. screen or file), mode
specifies which information should be stored or displayed
(e.g. color values: rgb, or depth values: z),
and <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
The name will be automatically changed to <tt/"+name"/ on RIB export
if it does not already start with a plus.

An example for a RiDisplay tag could look like this:
<code>RiDisplay imagez.tif,file,z</code>

<sect2>NoExport Tag<label id="noexporttag">
<p>
The tag type <tt/"NoExport"/ can be used to exclude certain objects
from exported RIBs. The value string of this tag is ignored. All
that counts is the presence of the tag. Child objects of objects
with the <tt/"NoExport"/ tag will also be excluded from the RIB.

<sect2>Internal Tags
<p>
The following tags are of no general use. They are used
by Ayam internally only.
<sect3>OI - Object ID Tag<label id="oitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between instance objects and
the original objects they are pointing to.<p>
The tag type <tt/OI/ is not meant to be used by the end user.
Furthermore, changing the IDs avails to nothing as the
tags are rebuilt before every export/save operation.

<sect3>MI - Material ID Tag<label id="mitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between material objects and
the objects they are assigned to.<p>
The tag type <tt/MI/ is not meant to be used by the end user.
Furthermore, changing the IDs avails to nothing as the
tags are rebuilt before every export/save operation.

<sect1>Root Object<label id="rootobj">
<p>
There is always exactly one root object in the scene.
This object is something special in that it cannot be deleted
or copied. 
It holds options global to the scene like RiOptions, atmosphere and
imager shaders. Furthermore, all views are
child objects of the root object.

If you hide the Root object the little red/green/blue coordinate system
will not be drawn in any view.

<sect2>RiOptions<label id="rio">
<p>
RenderMan Interface options.
Both, standard and BMRT specific options may be set.
Please refer to the documentation of the RenderMan Interface
and the documentation of BMRT for more detailed information about the
options.

<itemize>
<item><tt/"Width"/, <tt/"Height"/, if greater than zero this value
will be used for the image-size instead of the corresponding
dimension of the view window, but only for real RIB exports
and not for the QuickRender and Render actions in view windows.
These will always use the dimensions of the view window.
<item><tt/"Variance"/, maximum allowed variance of two pixel values.
The default 0.0 causes no setting in the RIB. If the variance is > 0.0
no pixel samples setting will be written to the RIB. Various
sources discourage the use of variance based sampling, because
e.g. the number of samples actually taken (and therefore the rendering
time) might not easily be predicted anymore.
<item><tt/"Samples_X"/, <tt/"Samples_Y"/ number of samples taken per
pixel.
<item><tt/"FilterFunc"/, function used to filter final pixel values.
<item><tt/"FilterWidth"/, <tt/"FilterWidth"/ size of the filter.
<item><tt/"ExpGain"/, Exposure
<item><tt/"ExpGamma"/, Exposure Gamma
<item><tt/"RGBA_ONE"/, <tt/"RGBA_MIN"/, <tt/"RGBA_MAX"/,
<tt/"RGBA_Dither"/, specify Quantization and Dithering
<item><tt/"MinSamples"/, <tt/"MaxSamples"/, minimum and maximum number
of samples per pixels.
<item><tt/"MaxRayLevel"/, maximum number of recursive rays.
<item><tt/"ShadowBias"/, minimum distance that one object has to
be in order to shadow another object.
<item><tt/"PRManSpec"/, toggles behaviour of BMRT's specular() function
between PRMan compatible (default) and RiStandard compatible.
<item><tt/"RadSteps"/, number of radiosity steps, the default 0 leads
to no radiosity calculations to be performed.
<item><tt/"PatchSamples"/, minimum number of samples per patch to
calculate the radiosity form factors for this patch.
<item><tt/"Textures"/, <tt/"Includes"/ and <tt/"Shaders"/ are
search paths for the renderer.
<item><tt/"TextureMem"/ and <tt/"GeomMem"/ determine how much
memory rendrib (from BMRT) should use at maximum to cache textures and
tesselated geometry.
</itemize>

<sect2>Imager, Atmosphere<label id="imager">
<p>
These properties let you define shaders for the
root object, please refer to section
<ref id="shd" name="Shaders">
for information on how to deal with shader property GUIs.
Imager shaders are executed once for every rendered pixel,
they may e.g. be used to set a specific background color.
Atmosphere shaders are volume shaders that
may be used to implement global atmospheric
optical effects like fog.

<sect1>View Object<label id="viewobj">
<p>
Every view window (see also section
<ref id="viewwin" name="Anatomy of a View">)
has a corresponding view object as a child object of the root object.
You can change camera settings, the type of the view,
and other things related to the view using the properties of the view object.
Note, that deleting the object that represents a view, will not
close the view window. You will just lose a way to configure it.
Please, do not mess with the objects in other ways (e.g. copy them),
you are asking for trouble otherwise!
<p>
Each view is associated with a virtual camera.
The type of the view determines the Up-vector of that camera.
If the type is "Top" the Up-vector corresponds to the world
Z-axis, else the world Y-axis.
The type of the view, additionally, determines the so called input plane
of the view. Interactive modeling actions in a view are limited to that
input plane (unless the view is switched to local modeling; available since
Ayam1.4; see also section <ref id="editlocal" name="Editing in Local Space">).
The standard input planes are as following: Front - XY-plane,
Side - ZY-plane, Top - XZ-plane, Trim - XY-plane.
<p>
In perspective views no interactive modeling actions are possible,
but you may position the camera and pick objects.
<p>
Views of type <tt/"Trim"/ are very special. They are used to edit
trimcurves of NURBPatch objects only. They display that trimcurves as
normal NURBCurves when the current level is inside a NURBPatch.
The extensions of the patch in parameter-space are drawn as a rectangle.
The trimcurves should completely lie inside this rectangle.
Note that picking of objects currently does not work in views of type
<tt/"Trim"/.
<p>
View object act in special ways, when certain objects are dropped
onto them in the tree view:
<p>
When a camera object is dropped onto a view object
using Drag-and-Drop in the tree view
the camera settings of the camera object will
be copied to the views camera.
<p>
When a light object of type <tt/"Spot"/ is dropped onto a view object
using Drag-and-Drop in the tree view
the views camera will be changed, so that
the user looks along the light to see what objects of the scene
are lighted by the light object (this works best
with perspective views that have equal width and height).
<p>

<sect2>Camera<label id="camp">
<p>
This section describes all elements of the <tt/"Camera"/ property:
<itemize>
<item><tt/"From"/ is the point where the camera (that is attached
to the view) is situated.
<item><tt/"To"/ is the point the camera is looking to.
<item><tt/"Up"/ is the up vector of the camera.
<item><tt/"Near"/ defines the near clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Near should always be positive for perspective views, and
smaller than far.
<item><tt/"Far"/ defines the far clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Far should always be bigger than near.
<item><tt/"Roll"/ defines an angle by which the camera is rotated
around the axis that is defined by the points from and to.
<item><tt/"Zoom"/ is a zoom factor.
</itemize>

Note, that the up vector is not checked for erroneous values
(e.g. pointing in the direction of from-to) when applying the changes
of the <tt/"Camera"/ property.

<sect2>ViewAttrib<label id="vat">
<p>
This section describes the elements of the <tt/"ViewAttrib"/ property:
<itemize>
<item><tt/"Type"/ specifies the type of the view. Front, Side, Top (all
parallel), Perspective and Trim (again parallel) may be selected.
<item><tt/"Width"/ and <tt/"Height"/ control the size of the view
window.
<item><tt/"Redraw"/ toggles automatic redrawing of the view.
If this is disabled, no drawing takes place in the view until an
explicit redraw is requested (using the view menu, or the shortcut
<tt>&lt;Ctrl+d&gt;</tt>).
<item><tt/"Shade"/ toggles shading of surfaces.
Note that the lighting is in no way an exact (or even similar)
representation of the light information you specified with Light objects!
Instead, a single light source, located at the camera origin
(a headlight), will be used!

<item><tt/"DrawSel"/ toggles drawing of selected objects. If this is
enabled, only the current selected objects will be drawn.
<item><tt/"DrawLevel"/ toggles drawing of the objects of the current
level only. If this is enabled, only the objects of the current
level will be drawn.
<item><tt/"Grid"/ is the grid size, 0.0 means no grid.
<item><tt/"DrawGrid"/ toggles drawing of the current grid.
<item><tt/"UseGrid"/ toggles, whether the current grid should be
used by the interactive modeling actions.
<item><tt/"Local"/ enables editing in local object space.
See also section <ref id="editlocal" name ="Editing in Local Space">.

<item><tt/"DrawBG"/ controls whether the background image should
be drawn.
<item><tt/"BGImage"/ is the name of a TIFF file, that will
be used as texture for the background image. Ayam will read
this image once when you apply the changes to the
<tt/"ViewAttrib"/ property
but reread
the image file if the notification callback of the view object
is invoked (e.g. using the main menu entry
<tt>"Tools/Force Notification"</tt>).
</itemize>

<sect1>Camera Object<label id="cameraobj">
<p>
Camera objects are used to temporarily save camera settings
of views.
Therefore, they has just have two properties
explained above, see sections <ref id="camp" name="Camera"> and
<ref id="attrs" name="Attributes">.
<p>
When a view object is dropped onto a camera object using Drag-and-Drop
in the tree view, the camera settings from the view will be copied
to the camera object.

<sect1>CSG Primitives<label id="csgprim">
<p>
<figure loc="ht">
<eps file="pics/primitives.ps" height="7cm">
<img src="pics/primitives.gif">
<caption>CSG Primitives</caption>
</figure>
<p>

<sect2>Box Object<label id="boxobj">
<p>
A solid box, centered at the origin of the object coordinate system.
This object will always be exported as solid primitive in RIBs;
consisting of six bilinear patches.
<sect2>BoxAttrib<label id="bxp">
<p>
<itemize>
<item><tt/"Width"/ is the width of the box (size of the box in
direction of the X axis of the objects coordinate system).
<item><tt/"Length"/ is the length of the box (size of the box in
direction of the Z axis of the objects coordinate system).
<item><tt/"Height"/ is the height of the box (size of the box in
direction of the Y axis of the objects coordinate system).
</itemize>

<sect2>Sphere Object<label id="sphereobj">
<p>
A sphere, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple sphere (depending on the <tt/"Closed"/ parameter
of the SphereAttrib property) in RIBs.

<sect3>RiSphereAttr<label id="spattr">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that if this option is in use and <tt/"ZMin"/, <tt/"ZMax"/ or
<tt/"ThetaMax"/ have other than the default values,
a single sphere will be written (in the worst case) as a
CSG hierarchy of two spheres, two cylinders and eight disks!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the sphere, default is 1.
<item><tt/"ZMin"/ may be used to chop the sphere off at a certain
place at Z.
<item><tt/"ZMax"/ may be used to chop the off at a certain
place at Z.
<item><tt/"ThetaMax"/ is the sweeping angle of the sphere default is 360.
</itemize>

<sect2>Disk Object<label id="diskobj">
<p>
A disk, centered at the origin of the object coordinate system.
This object will always be exported as simple disk in RIBs.

<sect3>RiDiskAttr<label id="dkp">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the disk, default is 1.
<item><tt/"ZMin"/ displaces the disk along the Z axis, default is 0.
<item><tt/"ThetaMax"/ is the sweeping angle of the disk, default is 360.
</itemize>

<sect2>Cone Object<label id="coneobj">
<p>
A cone, centered at the origin of the object coordinate system,
with the base at the XY plane.
This object will be exported as solid primitive or as
simple cone (depending on the <tt/"Closed"/ parameter
of the ConeAttrib property) in RIBs.

<sect3>RiConeAttr<label id="cnp">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cone will be written (in the worst case) as a
CSG hierarchy of a cone, a disk and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cone at the base, default is 1.
<item><tt/"Height"/ is the height of the cone, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cone, default is 360.
</itemize>

<sect2>Cylinder Object<label id="cylinderobj">
<p>
A cylinder, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple cylinder (depending on the <tt/"Closed"/ parameter
of the RiCylinderAttr property) in RIBs.
Note, that the OpenGL representation of this object
does not reflect the settings of the following parameters
of the CylinderAttrib property: <tt/"Closed"/ and
<tt/"ThetaMax"/.

<sect3>RiCylinderAttr<label id="cyp">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cylinder will be written (in the worst case) as a
CSG hierarchy of a cylinder, two disks and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cylinder, default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cylinder, default is 360.
</itemize>

<sect2>Torus Object<label id="torusobj">
<p>
A torus, centered at the origin of the object coordinate system.
A torus is a donut like shape, that results from sweeping
a small circle ( that has been displaced along X sufficiently )
around the Z axis.
This object will be exported as solid primitive or as
simple torus (depending on the <tt/"Closed"/ parameter
of the RiTorusAttr property) in RIBs.

<sect3>RiTorusAttr<label id="top">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that if this option is in use and
<tt/"PhiMin"/, <tt/"PhiMax"/ or <tt/"ThetaMax"/ have different than the
default values,
a single torus will be written (in the worst case) as a
CSG hierarchy of a torus, two disks and two hyperboloids!
But it may be used in CSG operations, safely.
<item><tt/"MajorRad"/ is the radius of the torus, measured
from the Z axis to the center of the swept smaller circle, default is 0.75.
<item><tt/"MinorRad"/ is the radius of the swept circle, default is 0.25.
<item><tt/"PhiMin"/ determines an angle to limit the swept circle,
default is -180.
<item><tt/"PhiMax"/ determines an angle to limit the swept circle,
default is 180.
<item><tt/"ThetaMax"/ is the sweeping angle of the torus, default is 360.
</itemize>

<sect2>Paraboloid Object<label id="paraboloidobj">
<p>
A paraboloid, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple paraboloid (depending on the <tt/"Closed"/ parameter
of the RiParaboloidAttr property) in RIBs.

<sect3>RiParabAttr<label id="pap">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that if this option is in use and
<tt/"ZMin"/, <tt/"ZMax"/ or <tt/"ThetaMax"/ have different
than the default values,
a single paraboloid will be written (in the worst case) as a
CSG hierarchy of a paraboloid, two disks and two bicubic patches!
But it may be used in CSG operations, safely.
<item><tt/"RMax"/ is the radius of the paraboloid at a Z of <tt/"ZMax"/,
default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the paraboloid, default is 360.
</itemize>

<sect2>Hyperboloid Object<label id="hyperboloidobj">
<p>
A hyperboloid, centered at the origin of the object coordinate system.
This shape will be created by sweeping a line specified by two
points in space around the Z axis.
This object will be exported as solid primitive or as
simple hyperboloid (depending on the <tt/"Closed"/ parameter
of the RiHyperbAttr property) in RIBs.

<sect3>RiHyperbAttr<label id="hyp">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note, that due to a bug in BMRT that is still present in V2.3.6
this option does not work properly when
<tt/"ThetaMax"/ has a different than the default value and the
hyperboloid has no displacement shader. In fact, using a displacement
shader with a km (amount of displacement) of 0.0 is a work-around
for this bug (found by T. E. Burge).
Also note, that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single hyperboloid will be written (in the worst case) as a
CSG hierarchy of a hyperboloid, two disks and two bilinear patches!
<item><tt/"P1_X"/, <tt/"P1_Y"/ and <tt/"P1_Z"/, define point one,
default is (0, 1, -0.5).
<item><tt/"P2_X"/, <tt/"P2_Y"/ and <tt/"P2_Z"/, define point two,
default is (1, 0, 0.5).
<item><tt/"ThetaMax"/ is the sweeping angle of the hyperboloid, default is 360.
</itemize>

<sect1>Level, Union, Intersection, Difference, Primitive<label id="levelobj">
<p>
Objects of type <tt/Level/, <tt/Union/, <tt/Intersection/, <tt/Difference/,
<tt/Primitive/ are
used to build object hierarchies and perform CSG
operations.
Note, that child objects of a level inherit the levels transformations
attributes and shaders.
If you have a NURBS patch in a level that is translated to 10,0,0,
the origin of the local coordinate system of the NURBS patch
will be situated at 10,0,0. If you decide to move the patch by a value
of 5 in X direction, you will finally arrive at 15,0,0.<p>
Levels do not have object type specific properties, just standard
properties (see section <ref id="stdprop" name="Standard Properties">).

New solid primitives may be created with levels of type <tt/Primitive/.
Note, that Ayam is not able to check whether your new primitive obeys
the rule of total closeness.

<sect1>Material Object<label id="materialobj">
<p>
Material objects are used to attach RiAttributes and
shaders to geometric objects.

When geometric objects are dropped onto a material object
using Drag-and-Drop in the tree view
they will be connected to this object.

When geometric objects are connected to a material
object this material object may not be deleted.

<sect2>RiAttributes<label id="riattrs">
<p>
Using this property standard and BMRT specific attributes may be set.
Please refer to the documentation of the RenderMan interface
and the documentation of BMRT for more detailed information about the
RenderMan specific attributes.

<itemize>
<item><tt/"Materialname"/ denotes the name of the material. Note,
that material names have to be unique in a scene. If two
materials with the same name exist, only the first material
created with this name is "registered" and thus
may be connected to geometric objects.
<item><tt/"Refcount"/ shows how many geometric objects
are connected to (are of) this material.
<item><tt/"Registered"/ displays, if this material may be
connected to geometric objects, see discussion about material names above.
<item><tt/"Color"/, the color of the object. If you set one of the
entries to a negative value (e.g. -1), the color will not be set at all
for this object.
<item><tt/"Opacity"/, the opacity of the object, the default
255 255 255 means the object is totally opaque. If you set one of the
entries to a negative value (e.g. -1), the opacity will not be set at all
for this object.
<item><tt/"ShadingRate"/, determines how often shaders are evaluated for
a sample.
<item><tt/"Interpolation"/, determines how return values computed
by the shaders are interpolated across a geometric primitive.
<item><tt/"Sides"/, determines how many sides of the surface of a
geometric primitive should be shaded.
<item><tt/"BoundCoord"/, sets the coordinate system in which the
displacement bound is expressed.
<item><tt/"BoundVal"/, displacement bound value.
<item><tt/"TrueDisp"/, toggles true displacements on or off. Default off.
<item><tt/"CastShadows"/, determines how the object casts shadows:
the default <tt/"Os"/ means the object casts shadows according to it's
opacity; <tt/"None"/ object does not cast any shadows; <tt/"Opaque"/
the object is completely opaque and casts shadows; <tt/"Shade"/
the object has a complex opacity pattern determined by it's surface
shader, that is used in shadow calculations.
<item><tt/"Camera"/, <tt/"Reflection"/, and <tt/"Shadow"/ toggle
visibility attributes.
</itemize>

<sect2>Surface, Displacement, Interior, Exterior<label id="matshader">
<p>
These properties let you define shaders for the
material object, please refer to section
<ref id="shd" name="Shaders">
for information on how to deal with shader property GUIs.<p>
Surface shaders may be used to procedurally encode
lighting models and textures. Displacement shaders
may procedurally deform the object while rendering.
Interior and Exterior shaders are so called volume
shaders that may be used to capture
special optical effects, encoding how
light is affected while passing through an object.

<sect1>Light Object<label id="lightobj">
<p>
The behaviour of a light source object depends heavily on the type
of the light source.
There are four different types available:
<tt/"custom"/, <tt/"point"/, <tt/"distant"/ and <tt/"spot"/.

Custom Lights:<label id="cul">
<p>
Light sources of type custom use
the attached light shader.

Note, that Ayam is trying to guess from the names of the light shader
arguments to draw the light.
The names <tt/"from"/ and <tt/"to"/ denote location and
destination of the lightsource. You should not use these names for other
things in your light shaders!

Point-, Distant-, and Spotlights:<label id="pdsl">
<p>
These (standard) light sources have well defined parameters that
will be displayed in the <tt/"LightAttr"/ property.
Please refer to the RenderMan documentation for more information
about the standard light sources
(see section <ref id="secref" name="references">).

<sect2>LightAttr<label id="lip">
<p>
Depending on the type of the light source, the light attribute
property contains different parameters. Parameters that
are not displayed will not be used on RIB export, consequently.<p>

Using <tt/"Type"/ you can change the type of the light source.
When you change the type of a light source,
the property GUI will be changed when you use the <tt/"Apply"/-button.

<tt/"IsOn"/ allows you to switch the light off or on. The default
value is on.<p>

With the light attribute <tt/"Shadows"/ you may determine
whether the lightsource should cast shadows.
The default is off, no shadows!<p>

The attribute <tt/"Samples"/ determines the number of times to sample
an area light source, independent of pixel samples, the default value is 1.
This attribute is available for custom lights only!<p>

<tt/"UseSM"/ determines, whether shadow maps should be created
and used for this light source. The resolution of the
shadow map may be determined by <tt/"SMRes"/. If
<tt/"SMRes"/ is 0, a default of 256 by 256 pixels will be used.
These options are for renderers that do not support raytraced
shadows like PRMan or Aqsis only.

For lights of type <tt/"Distant"/ the <tt/"Scale"/ attributes
of the <tt/"Transformations"/ property of the light
object may be used to scale the camera transformation
used for the creation of the corresponding shadow map.
Values of 1 for <tt/"Scale_X"/ and <tt/"Scale_Y"/ create
a shadow map that is sized 1 by 1 units in world space.

All other parameters that may appear in the <tt/"LightAttr"/
property are the standard parameters
for the standard RenderMan light sources: distant, point, and
spot:
<itemize>
<item><tt/"From"/ and <tt/"To"/ denote position and target of the light
source as point in space. You may edit both points using standard
point editing actions (see also section <ref id="iac" name="interactive actions">).
<item><tt/"Color"/ is the color of the light, emitted by the light source.
<item><tt/"Intensity"/ is the intensity of the light, emitted by the
light source. Note, that the standard point and spot lights have
a quadratic falloff (with distance), that requires the intensity
to be set to quite high values in order to achieve some
illumination effect (e.g. around 30 for the standard distance of
<tt/"From"/ and <tt/"To"/ of a spot light).
<item><tt/"ConeAngle"/ is the angle of the beam of a spot light.
<item><tt/"ConeDAngle"/ (cone delta angle) is the angle that determines a
falloff area at the edge of the beam of a spot light.
<item><tt/"BeamDistrib"/ (beam distribution) determines, how the light falls
off in the beam of the spot light. Larger values result in narrower
light sources.
</itemize>

In order to ease the parameterization of spot lights,
you may drop the light source object on to a view object
(preferably one with a perspective viewing transformation and with
equal width and height)
to see what objects of the scene are actually lighted by
the light object.

<sect2>Using ShadowMaps<label id="shadowmaps">
<p>
Using shadow maps requires the global preference setting
<tt>"RIB-Export/ShadowMaps"</tt> to be switched on.
Furthermore, for each light source for which a shadow map should be
created, the attributes <tt/"IsOn"/ and <tt/"UseSM"/ have to be
switched on.
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Automatic"</tt>,
Ayam will create a special version of the RIB on export, that creates
all shadow maps automatically. This is done, by rendering depth images
from the position of every light source that casts shadows.
Special light source shaders later pick up these depth images
and calculate shadows.
This approach implies, that the scene is rendered multiple times.
To reduce the size of the RIB, the objects to be rendered
are written to a second RIB file named <tt>"&lt;scene&gt;.obj.rib"</tt>.
This file is read from the main RIB several times via
<tt>"ReadArchive"</tt>. The RIB contains multiple frames which may
be rendered separately.
To help you picking the right frame number for the image (e.g.
to re-render just the image),
a comment with the frame number of the last frame (the image) will be
written as last statement to the RIB.
<p>
Because multiple files (RIBs and shadow maps) are used, it is suggested
to change the preference setting <tt>"RIB-Export/RIBFile"</tt> to
<tt>"Scenefile"</tt>. This will strip the leading absolute path component
from the filenames so that you may move the scene from one
system to another more easily.
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Manual"</tt>,
the exported scene will not render the shadow maps but rather
expects them to be present already. You can create them manually
(hence the name <tt>"Manual"</tt>) using the view menu entry
<tt>"View/Create ShadowMaps"</tt> or the main menu entry
<tt>"Special/RIB-Export/Create ShadowMaps"</tt>.
The manual approach has the advantage,
that the shadow maps will not be re-created each time you render
the scene.
<p>
Ayam supports three different methods for the creation
of shadow maps for certain types of light sources: point, distant, and spot:
<p>
The point method is used with
lights of type <tt>"Point"</tt> and custom lights that have a light
shader argument named "from".
Six shadow maps pointing in all possible axis aligned
directions and named <tt>"&lt;rib&gt;.point&lt;num&gt;_&lt;dir&gt;.shd"</tt>
(where <tt>"&lt;rib&gt;"</tt> is the name of the RIB,
<tt>"&lt;num&gt;"</tt> is the number of the light source that makes
use of shadow maps and <tt>"&lt;dir&gt;"</tt> is one of
<tt/"x+"/, <tt/"x-"/, <tt/"y+"/, <tt/"y-"/, <tt/"z+"/, or <tt/"z-"/)
will be created.
<p>
The distant method is used with lights of type <tt>"Distant"</tt>
and custom lights that have a light
shader argument named "from" and a light
shader argument named "to".
One shadow map is created and named
<tt>"&lt;rib&gt;.dist&lt;num&gt;.shd"</tt>.
By default, the size of the shadow map is 1 by 1 units in world space,
but this may be adapted using the scale transformation attributes of
the light object.
<p>
The spot method is used with lights of type <tt>"Spot"</tt>
and custom lights that have a light
shader argument named "from", a light
shader argument named "to", and a light shader argument named "coneangle".
One shadow map is created and named
<tt>"&lt;rib&gt;.spot&lt;num&gt;.shd"</tt>.
The spot method uses the cone angle (and additionally the delta cone
angle, if present) argument to determine the size of the shadow map
in world space.
<p>
If a light object of type <tt>"Spot"</tt>, <tt>"Distant"</tt> or
<tt>"Point"</tt> is used, Ayam automatically changes the name of the exported
light shader to <tt>"shadowspot"</tt>, <tt>"shadowdistant"</tt>,
and <tt>"shadowpoint"</tt> respectively. Additionally, the shader
will be parameterized to use the created shadow maps.
If the light source is of type <tt>"Custom"</tt>, no automatic renaming
and adjusting of the shader takes place. This means, you have
to make sure that the shader really uses the shadow maps, by
selecting the right shader and parameterizing it accordingly.
See the discussion above for the names of the shadow map files.
Those file names, probably, will have to be entered as parameter
to the light shader.
<p>
For example, you will not get any shadows if you use a light source of type
<tt/"Custom"/ with a <tt/"distantlight"/ shader attached, even though
Ayam is able to create the necessary shadow maps. The <tt/"distantlight"/
shader just makes no use of them.
You have to manually switch to a shader that
makes use of the shadow maps (<tt/"shadowdistant"/ in this case) to get
shadows.
<p>
Here is a short example for a scene using a shadow map:
<enum>
<item>Go to the preferences (section <tt/"RIB-Export"/) and set
<tt/"ShadowMaps"/ to <tt>"Automatic"</tt>.
<item>Create two boxes.
<item>Open the <tt/"Transformations"/ property of the second box.
<item>Translate it by X: 0.0, Y: -1.0, Z: 0.0.
<item>Scale it by X: 4.0, Y:1.0, Z:4.0.
<item>Create a light source.
<item>Open the <tt/"LightAttr"/ property.
<item>Change the type to <tt/"Spot"/. Press <tt/"Apply"/.
<item>Now change the parameters of the spot light to <tt/"IsOn"/: Yes,
<tt/"Intensity"/: 18.0,
<tt/"UseSM"/: Yes, <tt/"ConeAngle"/: 45.0, <tt/"BeamDistrib"/: 3.0,
<tt/"From"/: -2, 2, 2, <tt/"To"/: 1, 0, -1;
leave all other parameters at their default values.
<item>Create a new view and make it perspective (Menu:
<tt>"Type/Perspective"</tt>).
<item>Export a RIB from that perspective view (Menu:
<tt>"View/Export RIB"</tt>).
<item>Render the RIB with a RenderMan compliant renderer, that uses
shadow maps, e.g. Photorealistic RenderMan (prman) or Aqsis.
</enum>

This scene is distributed with Ayam as an example scene named
<tt>"shadowmaps.ay"</tt>.

Note, that for Aqsis you should add a RiHider hidden,depthfilter,s,midpoint
tag to your root object if shadow maps are in use. Other renderers might
require additional tweaking using shadow bias RiOption tags.

Do not render directly from a view window if your renderer
does not write image files when the command line option
to render directly to the display (-d for rendrib, or -fb for Aqsis)
is in use. This command line
option may inhibit writing of the shadow maps, so that the resulting
image will look wrong.

<sect2>Using AreaLights<label id="alob">
<p>
A common idealized light source has no own geometry. This means
shadows resulting from it have sharp borders. Soft shadows may
be generated using AreaLights.<p> 
How do you create AreaLights?<p>
You simply have to create a single object as child object of a
custom light object that has the <tt>"arealight"</tt>
shader attached. This child object determines the geometry of
the lightsource. According to L. Gritz, Spheres and Cylinders
work best as arealight geometry for BMRT,
because of special sampling code.<p>
An example:
<itemize>
<item>Create a custom light object.
<item>Assign the arealight light shader to it.
<item>Create a Sphere.
<item>Drag-and-Drop the Sphere onto the Light object so that it becomes
a child of the light object.
<item>Transform the object to your hearts content; the position
and size of the object determines the position and size of the lightsource!
</itemize>

There is an example scene named <tt>"arealight.ay"</tt> distributed with Ayam.

<sect1>NURBCurve Object<label id="ncurveobj">
<p>
NURBS curves are used to build more complex smoothly shaped 
objects using operations like extrude, revolve, sweep or skin.
They can be closed and used to emulate Bezier and
B-Spline curves easily.<p>

<sect2>Multiple Points<label id="ncurvemp">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A NURBS Curve with Multiple Points (big handles)</caption>
</figure>
<p>
The NURBS curves of Ayam support so called multiple points.
A multiple point is made of a number of different control points that have
the same coordinates.
Modeling actions will always modify all the control points that
make up a multiple point.
Multiple points will be drawn with a bigger
handle than normal points (see image above).
They may e.g. be used to create closed curves.
Note, that the control points that make up a multiple point
do not have to be consecutive (in the control point vector of the
NURBS curve).
Multiple points may be created using the collapse tool,
and split up again using the explode tool (see sections
<ref id="collt" name="The Collapse Tool"> and
<ref id="explt" name="The Explode Tool"> for more information regarding
those tools).
Note, that even though you might have exploded some multiple points
Ayam will re-create them on several occasions like reading
of a scene, inserting/deleting points, and applying the NURBCurveAttrib
property if they still have identical coordinate values.
In other words, you should immediately edit the control
points after exploding!
You may also totally inhibit creation of multiple points for a
NURBS curve using the attribute <tt/"CreateMP"/.

<sect2>NCurveAttrib<label id="ncattr">
<p>
The first section of the NCurveAttrib property contains curve specific
settings:<p>
<itemize>
<item><tt/"Length"/ is the number of control points of the curve.
<item><tt/"Order"/ is the order of the curve.
<item><tt/"Knot-Type"/: Using <tt/"Knot-Type"/ you may select from
NURB, Bezier, B-Spline and Custom knot sequences.
If the knot type is not Custom, the next setting
<tt/"Knots"/ will be ignored. Instead, knots of type NURB, Bezier or
B-Spline will be generated.
How do the different knot types affect the curve?

The knot type NURBS will generate knot values from 0.0 to 1.0, where
the multiplicity of the knots at the ends will be of order of the curve.
This guarantees that the curve will touch the control points at the ends
of the curve.

The knot type Bezier will generate just 0.0 and 1.0 values. Note, that
the order of the curve has to be equal to the length of the curve, if
Bezier knots are generated. Otherwise, the generated knot sequence is
illegal. The resulting curve looks and behaves exactly like a real
Bezier curve, interpolating it's ends and so on.

The knot type B-Spline will generate values
without any multiple knots. The resulting curve looks
and behaves like a B-Spline curve.
<item><tt/"Knots"/ lets you enter your own custom knot sequences.
Note, that <tt/"Knots"/ are not in use if <tt/"Knot-Type"/ is of type
NURB, B-Spline or Bezier!
<item><tt/"Closed"/ toggles the closeness of the curve.
If this is enabled, the last p control points of the curve will be
made identical to the first p (where p is the degree of the curve,
read order-1). All those points will be multiple points and 
single point editing actions will edit both points from now on.<p>
Note, that for a cubic spline (order 4) you will
need atleast 6 control points to close it. It is important to know,
that the multiple points alone can not guarantee that the curve
is closed if the knot type of the curve is Custom, if you really
want a closed curve switch to type B-Spline.<p>
Also note, that a NURBS circle as created by the NURBCircle tool
is not a closed curve following this definition, it is nevertheless
a closed curve.
<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this curve. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

The GLU-Parameters control the appearance of the curve when
curve/surface display is enabled.
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a curve.
Smaller tolerance settings lead to higher quality.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"DisplayMode"/ determines how the curve should
be drawn. The control hull (control polygon) or the curve or a
combination of both may be displayed. The setting <tt/"Global"/
means, that the global preference setting
<tt>"Drawing/NCDisplayMode"</tt> should be used.

</itemize>

When changing more than one of the above values the changes will be
applied in the order of the values in the property. The
sum of the changed values should describe a valid NURBS curve.
It is perfectly legal to change the length of the curve,
it's order, and switch to a custom knot vector (be sure to actually
enter a valid new knot vector) at once.
Ayam will check your changes and fall back to certain
default values if e.g. your knot sequence is wrong.
Check the console for any messages!

<sect1>NURBPatch Object<label id="npatchobj">
<p>
<sect2>NPatchAttrib<label id="npattr">
<p>
The first section of the NPatchAttrib property contains patch specific
settings:<p>
<itemize>
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
<item><tt/"Order_U"/ and <tt/"Order_V"/ set the orders of the patch.
<item><tt/"Knot-Type"/ and <tt/"Knots"/: For a discussion of the
<tt/"Knot-Type"/ and <tt/"Knots"/ parameters,
please see section <ref id="ncattr" name="NCurveAttrib">.
</itemize>

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"Display"/ sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<tt>"Drawing/DisplayMode"</tt> should be used.
</itemize>

<sect1>Trim Curves<label id="trim">
<p>
Trim curves may be used to cut out certain parts of a NURBS patch.
They are simple 2D NURBS curves defined in the parametric space
of the associated NURBS patch. Trim curves have to be defined as child
objects of the NURBS patch object they belong to. In contrast to other
child objects, however, they do not inherit the transformation attributes
of the parent object. Trim curve editing should take place in views
of type <tt>Trim</tt>, that draw the boundaries of the parametric
space of the corresponding NURBS patch as rectangle, but otherwise
act as normal <tt>Front</tt> views.

Note, that the direction of the trim curve determines which part of
the NURBS patch should be cut out. You can use the <tt/Revert/ tool
(<tt>Tools/NURBCurve</tt> menu) to easily change the direction
of a trim curve.

Some special restrictions apply to trim curves:
<itemize>
<item>All trim curves should entirely lie in the (u,v) parameter
space of the NURBS patch (remember the rectangle in the <tt>Trim</tt> view).
Note, that this restriction does not apply to the control points,
but the curves! It is ok to have control points outside the
rectangle if the defined curve is inside the rectangle.
<item>The last control point of a trim curve must be identical
to the first control point.
<item>Trim loops (multiple trim curves that form loops) are possible too;
the last control point of each curve in the loop must be identical
to the first control point of the next curve in the loop and 
the first control point of the first curve of a loop must be identical
to the last control point of the last curve of that loop.
<item>To mark a set of curves to be a loop, they must be
simply placed in a level. The order of the curves
in this level is the order of the loop.
<item>Drawing trimmed NURBS patches with certain implementations of
OpenGL may require a special trim curve (a piecewise linear
curve that encloses the whole
NURBS patch) to be present. Such a curve may be generated with
the <tt/TrimRect/ tool. You can find this tool in the <tt>Tools/Create</tt>
menu. This curve is needed if you want to cut out a hole with
a single trim curve. This curve is generally not needed if you want
to render the patch with BMRT but it should not hurt if it is present.
<item>If there are nested trim curves, their direction must alternate.
<item>Trim curves may not intersect each other or themself.
</itemize>
Note, that Ayam is not checking whether your trim curves
follow these rules!

Warning: Certain OpenGL implementations may be easily crashed
with trimmed NURBS patches with curves that do not follow the
aforementioned rules! When in doubt or while heavy modeling,
switch to wireframe drawing and switch off shading temporarily
and you will be on the safe side.

Since Ayam V1.5 also NURBS curve providing objects are supported
as trim curves.

<sect1>BPatch Object<label id="bpatchobj">
<p>
A BPatch is a bilinear patch (as it is used to build
box objects, see <ref id="boxobj" name="Box Object">).

<sect2>BPatchAttrib<label id=bpattr>
<p>
The BPatchAttrib property allows you to set the
four points defining the geometry of the patch:<p>
<itemize>
<item><tt/"P1_X"/, <tt/"P1_Y"/, <tt/"P1_Z"/, first point.
<item><tt/"P2_X"/, <tt/"P2_Y"/, <tt/"P2_Z"/, second point.
<item><tt/"P3_X"/, <tt/"P3_Y"/, <tt/"P3_Z"/, third point.
<item><tt/"P4_X"/, <tt/"P4_Y"/, <tt/"P4_Z"/, fourth point.
</itemize>

<sect1>PatchMesh Object<label id="patchmeshobj">
<p>

The PatchMesh object may be used to model with bilinear and
bicubic patch meshes.
The PatchMesh object may be converted to a NURBS patch
representation. However, this does not work for all possible
types of patch meshes (e.g. patch meshes with the basis types
Catmull-Rom, Hermite, or Custom).
The NURBS patch representation is also in use when
drawing the patch mesh (if the <tt/"DisplayMode"/ is not <tt/"ControlHull"/)
and when shading the patch mesh.
Consequently, there is currently no shaded representation of
patch meshes of basis type Catmull-Rom, Hermite or Custom.

<sect2>PatchMeshAttr<label id="pmattr">
<p>
The first section of the PatchMeshAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Type"/ may be set to <tt/"Bilinear"/ or <tt/"Bicubic"/.
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
<item><tt/"Close_U"/ and <tt/"Close_V"/ determine, whether the patch
mesh should be closed in u- and v-direction respectively.
<item><tt/"BType_U"/ and <tt/"BType_V"/ control the basis type
for bicubic patches. You may choose between the basis types:
<tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Catmull-Rom"/,
<tt/"Hermite"/, and <tt/"Custom"/.
In the latter case (<tt/"Custom"/), additional parameters may be set.
Those are <tt/"Step_U"//<tt/"Step_V"/ (the stepsize of the basis) and
<tt/"Basis_U"//<tt/"Basis_V"/ the basis itself
(please see the RenderMan Companion for a discussion of basis types).
</itemize>
The parameters <tt/"BType_U"/ and <tt/"BType_V"/ and consequently
<tt/"Step_U"//<tt/"Step_V"/ and <tt/"Basis_U"//<tt/"Basis_V"/ are
only available to bicubic patch meshes.

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<tt>"Drawing/DisplayMode"</tt> should be used.
</itemize>

<sect1>PolyMesh Object<label id="polymeshobj">
<p>

The PolyMesh object may be used to include objects that
have been modeled using the polygonal modeling paradigm
in Ayam scenes.
<p>
There are no special modeling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The PolyMesh object is equivalent to the general points polygons
primitive of the RenderMan interface. This means, each PolyMesh
object may contain multiple general (convex or concave) polygons,
which in turn may consist of an outer loop and an arbitrary number
of inner loops that describe holes in the polygon. The loops use a point
indexing scheme to efficiently reuse coordinate values.
This general approach requires a so called tesselation to be carried
out, in order for the PolyMesh object to be shaded.
For that, Ayam uses the tesselation routines of the GLU library.
<p>
Ayam is able to automatically create face normals for PolyMeshes.
They will be calculated while tesselating the PolyMesh and be
perpendicular to the plane determined by the first three vertices
of the outer loop of a polygon.
Furthermore, Ayam supports vertex normals (normals stored for every
control point).
<p>
Note, that storing a bunch of triangles each in its own PolyMesh
object will lead to a real waste of memory. You may use the
merge tool (main menu <tt>"Tools/PolyMesh/Merge"</tt>) to merge
many PolyMesh objects into a single PolyMesh object.

<sect2>PolyMeshAttr<label id="pomattr">
<p>
The PolyMeshAttr GUI just displays some information about the
PolyMesh object:
<itemize>
<item><tt/"NPolys"/ the number of polygons.
<item><tt/"NControls"/ the total number of control points
defined.
<item><tt/"HasNormals"/ is 1 if the object uses vertex normals,
else it is 0.
</itemize>

<sect1>SDMesh Object<label id="sdmeshobj">
<p>
The SDMesh object may be used to include objects that
have been modeled using the subdivision modeling paradigm
in Ayam scenes.
<p>
There are no special modeling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The SDMesh object is equivalent to the Subdivision Mesh
primitive of the RenderMan interface. This means, each SDMesh
object may contain multiple faces with arbitrary number
of vertices that form a polygonal mesh. This polygonal mesh is
then successively refined using a subdivision scheme and, depending
on the number of refinement (or subdivision) steps, results in
a more or less smooth surface. There are several different
subdivision schemes, but the scheme currently supported
by most RenderMan compliant renderers is named "Catmull-Clark".
<p>
Tags may be specified for faces, edges, or vertices
to control the subdivision process (e.g. to create sharp corners or edges
in the resulting surface). All tags known from the RenderMan interface
(hole, crease, corner, and interpolateboundary) are supported by Ayam,
but they may currently not be changed by the user.
<p>
Furthermore, Ayam is currently not able to do the subdivision and
show the resulting smooth surface. All that is shown in wireframe and
shaded views is the original polygonal mesh.

<sect2>SDMeshAttr<label id="sdmattr">
<p>
The SDMeshAttr GUI just displays some information about the
SDMesh object:
<itemize>
<item><tt/"Scheme"/, subdivision scheme, currently only 0 (Catmull-Clark). 
<item><tt/"NFaces"/, the number of faces.
<item><tt/"NControls"/, the total number of control points
defined.
</itemize>

<sect1>Instance Object<label id="instanceobj">
<p>
The term instance is unfortunately misleading (and can be very confusing
if you are accustomed to the terminology of object oriented programming),
but it is the term that seems to be used and understood by most
computer graphic artists. A better term would be link, as an instance
object has the same basic properties as a link in a Unix file system.
A link is just a pointer to an original file, the same goes for
an instance object: it is just a pointer to an original object (master).
A link can be placed anywhere on the file system,
an instance object can be placed anywhere in the hierarchy, and
additionally, it can be transformed (otherwise it would be pretty
useless).<p>
The sole purpose of instance objects is to save storage.
The amount of saved diskspace can be very high, but this depends
heavily on the scene. If there are no similar objects in the scene
you can hardly use instancing. Similar means "the same except for
the transformation property" in this context.
<p>
Some simple rules for instancing:
<itemize>
<item>No instances may be created of objects of the following types:
Root, View, Instance, Material, Light. Do not try to fool
Ayam and create instances of levels that contain aforementioned
types of objects, things will go awry! You may, however, put some instances
into a level object and create instances of this level
(this is sometimes called hierarchical instancing). But you may not
put instances of a level into the very same level (this would
be recursive instancing, which is not supported by Ayam).
<item>The original object may not be deleted from the scene
as long as there are instances of that object in the scene or in the
object clipboard.
</itemize>

If you cannot delete an object, and the error message tells
you something about a reference counter, then you were about
to violate the second rule. Clean the clipboard using
the menu <tt>"Special/Clipboard/Paste (Move)"</tt> and delete
or resolve all references.
<p>
Note, that it is not possible to copy a master object and some instances
of it, so that the new instances point to the newly created master.
All copies of instance objects always point to the same master object.
However, it is possible to move instances using Drag-and-Drop in the tree
view or using the clipboard with <tt>"Edit/Cut"</tt> and then
<tt>"Special/Clipboard/Paste (Move)"</tt>.
<p>
You can resolve an instance object at any time using
the converter registered for objects of type <tt>Instance</tt> (simply
select the instance object and use the menu entry
<tt>"Tools/Convert"</tt>). To resolve all instance objects in a scene
to normal objects, you may use the main menu entry:
<tt>"Special/Instances/Resolve all Instances"</tt>.
<p>
The RIB export of instances does not use the RiInstance facility
of the RenderMan interface, but the ReadArchive mechanism.
This means, every original object in the scene will be written
in a separate archive (RIB file) on disk, and every instance will
cause that archive file to be read. You can change that behaviour
using the preference setting <tt/"ResInstances"/.
If <tt/"ResInstances"/ is enabled, all instances will be resolved
(temporarily) before being exported to RIB.
<p>
Ayam can also create instances automatically (see section
<ref id="ai" name="Automatic Instancing">).
<p>
To easily find the master object of an instance, just select the
instance, then use the main menu entry: <tt>"Edit/Master"</tt>.

<sect1>Clone Object<label id="cloneobj">
<p>
<figure loc="ht">
<eps file="pics/clone.ps" height="5cm">
<img src="pics/clone.gif">
<caption>Clone Object with Trajectory (white)</caption>
</figure>
<p>
The Clone object allows you to easily create and control a number
of instances of a single object.
The instances will be created internally and transformed,
each by a certain amount.
The original object is the first child object of the Clone object.
If a second object is present as child of the Clone object
it is treated as trajectory curve, similar to the Sweep object
(see section <ref id="sweepobj" name="Sweep Object">).
If you use a trajectory curve to place the clones, you may want
to hide the parameter object and add a <tt/"NoExport"/ tag to it.
<p>
It is not possible to create clones from objects that may not
be master objects of instance objects (e.g. instances, light objects, or
material objects).
<p>
The following attributes further control the
clone process:
<sect2>CloneAttr<label id="cloneattr">
<p>
<itemize>
<item><tt/"NumClones"/ the number of clones to create.
<item><tt/"Rotate"/ is only used, if a trajectory curve is present.
If it is enabled all clones will be aligned according to the normal of
the trajectory curve.
<item><tt/"Translate_X"/, <tt/"Translate_Y"/, <tt/"Translate_Z"/,
<tt/"Rotate_X"/, <tt/"Rotate_Y"/, <tt/"Rotate_Z"/,
<tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/,
those attributes control the transformation of the
instances. They are not used, if a trajectory curve is present.
</itemize>

<sect1>Revolve Object<label id="revolveobj">
<p>
<figure loc="ht">
<eps file="pics/revolve.ps" height="5cm">
<img src="pics/revolve.gif">
<caption>Revolve Object (Curve, Surface of Revolution)</caption>
</figure>
<p>
The Revolve object forms a surface of revolution from
a NURBS curve.
<p>
The Revolve object has the generating NURBS curve as child object
and watches its changes and adapts to it automagically.
<p>
The axis of revolution is always the Y axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Y axis of the revolve
object itself). The generating curve should lie in the XY plane of this
coordinate system. If not, it will be squashed down
to this plane!
<p>
The following simple experiment should make the last
statements more clear, during all steps watch the movements
of the revolution:<p>
<itemize>
<item>Create a NURBCurve. Select it.
<item>Create a Revolve custom object using the menu entry
(<tt>Tools/NURBCurve/Revolve</tt>).
<item>Select the Revolve object, and rotate it around Z. (The axis
of the revolution changes. The generating NURBS curve, as child object,
will also be rotated.)
<item>Now enter the Revolve object, select the child curve and
edit the control points (Note, how the Revolution changes).
<item>Rotate the curve around Z (Note, how the Revolution changes).
<item>Switch to a Side view, edit the generating curve here in Z
direction only (Revolution does not change!).
</itemize>

You may convert the current surface of revolution and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>. 

<sect2>RevolveAttr<label id="rep">
<p>
Using the parameter <tt/"ThetaMax"/ you can specify the
sweeping angle of the revolution just like with an ordinary
RenderMan quadric.

The revolve object can automatically generate caps,
which are trimmed NURBS patches. Using <tt/"UpperCap"/,
<tt/"LowerCap"/, <tt/"StartCap"/, and <tt/"EndCap"/,
you determine whether such caps should be
generated, default is off (no caps).

If the side caps of a surface of revolution of an open
curve are not created correctly, (GLU
complains about "intersecting or misoriented trimcurves"),
try to revert the revolved curve.

See section <ref id="npattr" name="NPatchAttrib"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Extrude Object<label id="extrudeobj">
<p>
<figure loc="ht">
<eps file="pics/extrude.ps" height="4cm">
<img src="pics/extrude.gif">
<caption>Extrude Object (Curve, normal Extrusion, Extrusion with Caps)</caption>
</figure>
<p>
The extrude object forms an extrusion from
a number of NURBS curves.<p>

The first curve determines the outline, and the other curves
determine holes in the extrusion object. Holes may be
used by objects that form e.g. letters.<p>

The object has the generating NURBS curves as child objects
and watches them and adapts to them automagically.<p>

The extrude object can generate caps, if the generating
curves are closed. Cap generation may fail, if the outer
curve has weights and the curve itself leaves the convex
hull of the control polygon. Be careful when using curves
with weights!<p>

The sharp corners between caps and extrusion may be beveled.<p>

The axis of the extrusion is always the Z axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Z axis of the extrude
object itself). The generating curves should lie in the XY plane of this
coordinate system. If not, they will be squashed down
to this plane!<p>

You may convert the current surface of extrusion and the caps and bevels,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>. 

<sect2>ExtrudeAttr<label id="extrattr">
<p>
Using the parameter <tt/"Height"/ you determine how
big in Z direction the extrusion should be. Note, that
the height of the bevels will not be taken into account here,
if you have an extrusion with height 1.0 and you switch on
beveling (upper and lower) with radius 0.1 you end up
with an object that is 1.2 whatever big in Z direction.

The extrude object can automatically generate caps,
that are trimmed NURBS patches. Using <tt/"UpperCap"/ and
<tt/"LowerCap"/ you determine whether such caps should be
generated, default is off (no caps). Note, that this feature
does only work properly, if the generating NURBS curves are closed
and not self intersecting, this is because the generating curves themselves
are used as trim curves for the caps. Warning, Ayam will not check whether
your curves conform to this criteria. Ayam, however,
detects the correct orientation of the curves
(and reverts them if necessary).

Using <tt/"LowerBevel"/ and <tt/"UpperBevel"/ you determine
whether bevels should be created to round the otherwise sharp
corners of the extrusion with the cap. The bevels may be
controlled using <tt/"BevelType"/ and <tt/"BevelRadius"/.
<tt/"BevelType"/ allows to choose from <tt/"Round"/ (a complete round bevel,
built using a quarter circle), <tt/"Linear"/ (not round at all,
but just a connecting linear patch) and <tt/"Ridge"/
which forms a more complex beveling similar to some frames for
(real world) images. 
The <tt/"BevelRadius"/ determines the size of the bevels. It is
expressed in untransformed object coordinates of the generating curve,
but the resulting radius of the bevel may differ a bit (depending
on the shape of the curve).

See section <ref id="npattr" name="NPatchAttrib"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Using Holes and Bevels<label id="handb">
<p>
All curves forming holes in the extruded object
must be defined inside (geometrically)
the first curve (the outline curve). Additionally,
they may not intersect each other or themself and
you cannot have hole curves inside hole curves.
Ayam will not check whether your curves conform to these criteria!

With the direction of the curve you decide the direction of the
bevel as well (should it round outwards or inwards?).
If the bevels of the holes look wrong try to
revert the generating curves of the holes.
Note, that beveling does not work well with open curves.
You should always use closed curves for beveling!
Beveling may lead to self intersecting trimcurves in sharp
corners of an extrusion. Decrease the bevel radius or round
the corners of the extruded curve (using insertion of additional
control points) if cap generation fails due to self intersecting bevels.

<sect1>Sweep Object<label id="sweepobj">
<p>
<figure loc="ht">
<eps file="pics/sweep.ps" height="6cm">
<img src="pics/sweep.gif">
<caption>Sweep Object (Two Curves, Resulting Swept Surface)</caption>
</figure>
<p>
The sweep object forms a surface that results from
moving a NURBS curve (cross section) along a second NURBS curve
(trajectory). The cross section may be scaled while sweeping
using a third curve, the scaling function.
<p>
The sweep object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section,
the second is the trajectory, and the third curve represents
the scaling function.
<p>
Note, that the <tt/"Translate"/ attributes of the cross section curve
will be fully ignored. All other transformation attributes
(of cross section and trajectory!) will be used to determine
place, orientation and size of the sweep object!
<p>
The cross section curve has to be defined in the YZ-plane. This means,
that a simple circular curve as e.g. created with the toolbox has to
be rotated 90 degrees around the Y-axis.
<p>
The scaling function is sampled for each section and the Y-component
of the coordinates of the current curve point will be used as
scale factor, that is applied to the cross section in Y- and Z-direction.
This implies, that a scaling function that does nothing should e.g. be
linear from (0,1,0) to (1,1,0).
<p>
<figure loc="ht">
<eps file="pics/ssweep.ps" height="5cm">
<img src="pics/ssweep.gif">
<caption>Sweep Object with Scaling Function (white)</caption>
</figure>
<p>
Here is a short example for the creation of a sweep:
<itemize>
<item>Create a circular BSpline using the toolbox. (This will be our
cross section.)
<item>Rotate it by 90 degrees around the Y-axis. (Use the
<tt/"Transformations"/ property for that.)
<item>Create a simple NURBS curve using the toolbox.
<item>Select both curves. (Select the first curve, hold down
the <tt/"Shift"/ key and select the other curve.)
<item>Create the Sweep object using the toolbox.
<item>Now you may enter the Sweep object and modify
the second curve, the trajectory. (Press <tt/"e"/,
then drag some control points around.)
<item>To modify the cross section you would need to switch to a
view of type <tt/"Side"/. (Use the <tt/"Ctrl+s"/ shortcut while
the view has the input focus.)
</itemize>

Section <ref id="scexsweep" name="Easy Sweep"> has an example
script that automates creation and parameterization of
a suitable cross section curve.
<p>
You may convert the current sweep and the caps, if there are any,
to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>SweepAttr<label id="swp">
<p>
If <tt/"Interpolation"/ is enabled, all section curves
will be interpolated by the swept surface.<p>
The second parameter <tt/"Sections"/ determines how many
sections (in u direction) should be used, when generating the
sweep NURBS patch. The NURBS patch always has sections+1 control
points in u direction.<p>
If <tt/"Rotate"/ is enabled, the cross sections will be
rotated so that they are always perpendicular to the trajectory,
this is the default.

The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
Sweep on both ends.
Note, that this works properly only if the cross section
curve is closed and planar (defined in the XY plane).

See section <ref id="npattr" name="NPatchAttrib"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Skin Object<label id="skinobj">
<p>
<figure loc="ht">
<eps file="pics/skin.ps" height="6cm">
<img src="pics/skin.gif">
<caption>Skin Object (Curves, Resulting Skinned Surface)</caption>
</figure>
<p>
The skin object forms a surface that results from
lying a surface through a set of curves, where the first and
last curve will be interpolated by the surface.<p>
Note, that the curves may be of arbitrary length and order.
If the curves are of different length or order, they will all be
converted internally until they match. Be warned, that this process
may consume a considerable amount of time (for the ones of you
who know NURBS better: all unclamped curves have to be converted to
clamped ones; then, for every curve with low order degree elevation
has to be done; then a uniform knot vector has to be found; then all
curves have to be refined using this new knot vector; interpolation
adds another dimension of complexity...). If you experience
lags when editing the child curves of a Skin try to switch
to lazy notification.<p>
Also note, that the resulting patch may be quite big, even though
the curves are not, if the orders of the curves do not match.
A skinned patch from two curves of length 4 but one with
order 4 and the other with order 2 will result in a patch with
a width of 2 and a height of 10!

The skin object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.

You may convert the current skin and the caps, if there are any,
to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>SkinAttr<label id="skp">
<p>
The first parameter <tt/"Interpolation"/ controls,
whether the inner curves should be interpolated by the
skinning surface.<p>
The second parameter <tt/"Order_U"/ determines the order
of the resulting surface in u direction (the order in v direction is
determined by the curves). The order may not be lower than the
number of curves used. If the specified value is lower than the number
of curves the order of the generated surface will be silently
set to the number of curves.<p>
Using the next parameter <tt/"Knot-Type_U"/, you can adapt the
type of the knot vector that should be used in the u direction of the
skin. Note, that this setting will have no effect if interpolation
is switched on because then a chord length parameterisation
will be used. If the knot type is Bezier and the specified
order does not match the number of skinned curves, then the order
will be silently adapted to the number of skinned curves.

The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be used
to automatically create cap surfaces to close the skin
on both ends.
Note, that this works only if the first (last) curve is
closed and planar (defined in XY plane).
Furthermore, if the Skin is not interpolating the
first (last) parameter curve (this may be the case
if the <tt/"Knot-Type_U"/ parameter is set
to <tt/"B-Spline"/) the cap will not be created on the right
place. It will always be on the same position as the
first (last) parameter curve.

See section <ref id="npattr" name="NPatchAttrib"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Cap Object<label id="capobj">
<p>
<figure loc="!ht">
<eps file="pics/cap.ps" height="6cm">
<img src="pics/cap.gif">
<caption>Cap Object (Curve, Resulting Cap Surface)</caption>
</figure>
<p>
The cap object forms a surface that fills
a planar NURBS curve. If multiple curves
are present as child objects, the curves
following the first curve define holes in
the cap surface (see also section
<ref id="handb" name="Using Holes and Bevels">).
<p>
Note, that the curves have to be planar
and defined in the XY plane. Furthermore,
cap generation may fail, if the control points of the
first curve have weights and the curve leaves the convex
hull of the control polygon. Be careful when using weights!
<p>
You may convert the current cap
to an ordinary NURBS patch object using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>CapAttr<label id="capp">
<p>
See section <ref id="npattr" name="NPatchAttrib"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"CapAttr"/ property.

<sect1>ICurve Object<label id="icurveobj">
<p>
The ICurve object creates an interpolating
spline which is either a C2 cubic with n+2 control points
or a curve with n points with arbitrary order
from a set of control points.<p>
The global interpolation generates a bit smoother curves
which look best with an order of 3, your mileage may vary however.<p>
<figure loc="!ht">
<eps file="pics/icurves.ps" height="7cm">
<img src="pics/icurves.gif">
<caption>Different ICurves</caption>
</figure>
<p>
The image above shows some interpolating curves, the left ones
are C2 cubic, the right ones Global4D, the upper open, and the lower
closed ones. The interpolation fidelity for the closed curves
could be increased considerably adjusting <tt/"IParam"/, see below.

In both interpolation modes chord length parameterization will be used
to determine the knot vector of the interpolating curve.

This object makes use of the provide mechanism. It marks itself
as providing a NURBCurve (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g. revolve, sweep, extrude, and skin) are
able to work with an ICurve object instead of an object
of type NURBCurve.

You may convert the current ICurve to an ordinary NURBS curve
using the main menu entry <tt>"Tools/Convert"</tt>.

<sect2>ICurveAttr<label id="icp">
<p>
<itemize>
<item>Using <tt/"Length"/ you determine the number of points to interpolate.

<item>The curve can be closed with the parameter <tt/"Closed"/.

<item>The parameter <tt/"Mode"/ determines whether the curve should
be a C2 cubic curve (with n+2 control points (n+3 if the curve is
closed)) or a so called global interpolating curve
(with n control points (n+3 if the curve is closed)
and arbitrary order).

<item>The next parameter <tt/"Order"/ is used only if the mode is
Global4D. It determines the order of the interpolating curve. If the
specified order is bigger than the number of control points used
by the interpolating curve, then the order is silently changed to
match the number of control points.

<item>The parameter <tt/"IParam"/ is used to control the position
of the second and last-1 control point of the interpolating curve.
It scales the vectors used to position the aforementioned points.
You can try to change (decrease) this value, if you are not satisfied
with the shape of the curve near the first or last interpolated point.
This parameter has no effect on open curves when the mode is Global4D.

<item>See section <ref id="ncattr" name="NCurveAttrib"> for a description
of the last attribute: <tt/"Tolerance"/ .
</itemize>

<sect1>ConcatNC Object<label id="concatncobj">
<p>
<figure loc="ht">
<eps file="pics/concatnc.ps" height="5cm">
<img src="pics/concatnc.gif">
<caption>ConcatNC Object from a Linear Curve and 3 Instances (white)</caption>
</figure>
<p>
The ConcatNC object concatenates all child objects
(which should be NURBS curves or provide NURBS curves)
to a single NURBS curve. Since the ConcatNC object also
provides a NURBS curve, it is possible to use it as
child object for another ConcatNC object (with possibly
different parameters) or as a parameter object for a tool object
that works with NURBS curves such as Revolve or Extrude.
<p>
How does the concatenation work?
First, all curves will be clamped (see section
<ref id="clat" name="clamp tool"> for more information on clamping).
Then, the control points of all child curves are simply copied
into a new big control point vector, without checking for double
points.
Attributes like order, display mode, tolerance
etc. for the new concatenated curve are taken from the first child object.
The knot sequence of the new concatenated curve will be NURBS.
This means, the shape of the concatenated curve will differ from the
child curves if
any of the child curves has a custom knot vector with non
equidistant knots.
<p>
You may convert the current ConcatNC object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following attributes further control the
concatenation process:
<sect2>ConcatNCAttr<label id="concatncp">
<p>
<itemize>
<item>Using <tt/"Closed"/ you may create a closed concatenated curve.
If <tt/"FillGaps"/ (below) is enabled, an additional fillet will
be created for the last and the first child curve to close
the concatenated curve. If <tt/"FillGaps"/ (below) is not enabled,
the concatenated curve will be closed with the same algorithm
that is also used by the close curve tool (possibly changing
the shape again!).
<item><tt/"FillGaps"/, creates fillet curves for all gaps between
the child curves of the ConcatNC object. The fillet curves will be
cubic Bezier curves. The direction of the tangents in the endpoints of
the fillets and the gap enclosing curves will match, so that the
transition should be G1 continuous.
<item><tt/"Revert"/ the orientation of the concatenated curve will be reversed.
</itemize>

<sect1>RiInc Object<label id="riincobj">
<p>
RiInc objects may be used to include objects or whole scene parts into your
scenes that, for some reason, are just available as
a piece of RIB.
<sect2>RiIncAttr<label id="riincp">
<p>
<itemize>
<item>Using <tt/"File"/ you specify the file of the
RIB to be included.
<item><tt/"Width"/, <tt/"Height"/, and <tt/"Length"/ specify
the size of a box, that will be drawn as a geometric
representation of the RIB.
</itemize>

<sect1>Custom Objects<label id="customobj">
<p>
What is a custom object?

Think of it as a plugin that extends Ayam's capabilities by
defining totally new types of e.g. geometric objects.
A simple example is the CSphere custom object, which implements
a sphere and has a new property named <tt/"CSphereAttr"/.
This property contains all parameters of a simple RenderMan Interface
quadric sphere.

Since a custom object has total control over properties and representations,
you should refer to the documentation of the custom object for more
information regarding it's properties.

<sect1>Metaball Object<label id="metaobjobj"><label id="metacompobj">
<p>
<figure loc="ht">
<eps file="pics/meta.ps" height="5cm">
<img src="pics/meta.gif">
<caption>A Metaball Object from Six Meta Components</caption>
</figure>
<p>
A metaball object is a custom object (see also section
<ref id="customobj" name="Custom Object">).
It allows you to model with implicit surfaces in realtime.
<p>
To start modelling you should first create a MetaObj object using the menu
<tt>"Create/Custom Object/MetaObj"</tt> (if this menu entry is not
available, you have to load the <tt>"metaobj"</tt> plugin using the menu entry
<tt>"File/Load Custom"</tt>).
<tt>"Create/Custom Object/MetaObj"</tt> creates a so called meta world with a
single meta component (a sphere) in it.
Meta components live only in a meta world. Type, parameters, and
transformation attributes of the meta components define the function
of an implicit surface. The MetaObj object, that represents the
meta world, evaluates this function on a regular three-dimensional
grid and creates a polygonal
representation for a specific function value (the so called threshold value).
<p>
This process may be further parameterized using the <tt/"MetaObjAttr"/
property:
<sect2>MetaObjAttr<label id="moattr">
<p>
<itemize>
<item>With the parameter <tt/"NumSamples"/ you specify the resolution of the
three-dimensional regular grid, on which the implicit function is
evaluated, in each dimension.
A higher number of samples results in better quality but more polygons
are created and more CPU power and memory are needed. For modelling
you should set this to a lower value of about 40. For final rendering
you may increase this to about 160.
<item><tt/"IsoLevel"/, defines the threshold value for that a polygonal
representation of the implicit function should be created. Normally, you
should not need to change this value.
<item>To show the actual bounds of the meta world, you may enable
the <tt>"ShowWorld"</tt> parameter.
</itemize>

While modelling with meta balls you may add other <tt/"MetaComp"/ objects
to the <tt/"MetaObj"/ object and parameterize them.
A <tt/"MetaComp"/ object has the following properties.

<sect2>MetaCompAttr<label id="mcattr">
<p>
<itemize>
<item><tt/"Formula"/ specifies the type of the meta component.
The following types are available: Metaball, Torus, Cube, Heart, and
Custom which gives you the possibility to use your own formulas.
<item>With the parameter <tt/"Negative"/ you define a component with a
negative effect on the implicit function value.
Negative components are not visible on their own but they are useful
for modelling holes. Just try it.
</itemize>

The other parameter are specific to the type of the component:

<sect2>Metaball<label id="mbcp">
<p>
<itemize>
<item><tt/"Radius"/ sets the radius of the metaball
<item><tt/"EnergyCoeffA"/, <tt/"EnergyCoeffB"/, and <tt/"EnergyCoeffC"/
are some parameters for the metaball formula.
Usually you can leave those parameters at their default values.
If you change them, be careful.
</itemize>

<sect2>Torus<label id="mtcp">
<p>
<itemize>
<item><tt/"Ri"/ the inner radius of the torus
<item><tt/"Ro"/ the outer radius if the torus
<item><tt/"Rotate"/ rotates the torus about 90 degree
</itemize>

<sect2>Cube<label id="mucp">
<p>
<itemize>
<item><tt/"EdgeX"/, <tt/"EdgeY"/, and <tt/"EdgeZ"/,  let you define the
sharpness of the edges of the cube
</itemize>

<sect2>Custom<label id="cucp">
<p>
<itemize>
<item><tt/"Expression"/ is a piece of Tcl script, that represents your
own custom formula for a meta component. The expression may call any
Tcl commands to calculate a field value from the current grid position,
which is given in the global variables <tt>"x"</tt>, <tt>"y"</tt>, and
<tt>"z"</tt>.
The expression has to return the field value in the global variable
<tt>"f"</tt>.
Here is an example for a custom expression:
<code>
set f [expr {pow($x,4)+pow($y,4)+pow($z,4)}]
</code>
Note, that those expressions are called many times
and since they are programmed in Tcl, this can be quite slow.
You should use any tricks (like the curly braces
in the expr-statement above) to speed up the expression.
</itemize>

<sect>NURBS Modeling Tools<label id="nmtool">
<p>
This section describes NURBS curve and surface related modeling
tools, which you can find in the <tt/"Tools"/ menu.

<sect1>The Closed BSpline Tool<label id="cbspt">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A Closed B-Spline</caption>
</figure>
<itemize>
<item>Arguments: Number of control points (i).
<item>Operation: This tool creates a closed cubic B-Spline curve with
i+3 control points in the XY plane. The control points are arranged
in a circle of radius 1 centered around the origin. This gives the curve
a circular appearance (see image above) but it is not a true circle.
Use the NURBCircle
tool (see below) to create a true circle instead.
<item>Note: i must be atleast 3. The first three control
points of the new curve will be identical to the last three.
Additionally, the curve will be marked as closed, and the generation
of multiple points will be enabled, so that point
edit actions know that they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

<sect1>The NURBCircle Tool<label id="ncirct">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBCircle tool creates a full circular NURBS curve
of radius 1 in the XY plane located at the origin.
<item>Note: The NURBS curve created by the NURBCircle tool is rational
(uses weights). This means, editing the curve (e.g. moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished). Use a closed B-Spline
created with the Closed BSpline Tool (see above) if you want to edit
the curve further.
You can use this circle to easily create a NURBS-torus by moving
the circle along X and then revolving it. The amount of movement
determines the radius of the torus, whereas the radius of the circle
determines the thickness.
</itemize>

<sect1>The NURBCircleArc Tool<label id="ncircat">
<p>
<itemize>
<item>Arguments: angle of the arc in degrees
<item>Operation: The NURBCircle tool creates a circular NURBS curve
arc of radius 1, with the specified angle, in the XY plane,
located at the origin.
</itemize>

<sect1>The TrimRect Tool<label id="trrt">
<p>
<itemize>
<item>Arguments: None
<item>Operation: The TrimRect tool creates a piecewise linear
NURBS curve of rectangular
shape, that fits in the (u,v) parameter space of a NURBS patch, for use
as trim curve.
<item>Note: To fit the curve to the parameter space of a NURBS patch,
the current level should be inside the NURBS patch.
If the current level is not inside a NURBS patch, a
curve with the coordinates (-1,-1), (-1,1), (1,1), and (1,-1)
will be created instead.
See section <ref id="trim" name="Trim Curves"> for a more
detailed discussion of trim curves and how to use this rectangular
curve.
</itemize>

<sect1>The NURBSphere Tool<label id="nspt">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a half circle NURBS curve
and revolves it about the Y axis thus forming a sphere of radius 1.
<item>Note: The NURBS curve is deleted afterwards.
</itemize>

<sect1>The NURBSphere2 Tool<label id="nsp2t">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a Cobb-NURBSphere,
consisting of 6 NURBPatches. 
<item>Note: The NURBPatches are of high order (5).
</itemize>

<sect1>The Revolve Tool<label id="revt">
<p>
<itemize>
<item>Arguments: The revolve tool takes a single NURBS curve from
the selection.
<item>Operation: It creates a Revolve object, and moves
the selected curve to it.
<item>Note: See section <ref id="revolveobj" name="Revolve Object">
for more information regarding the revolve object.
</itemize>

<sect1>The Extrude Tool<label id="extt">
<p>
<itemize>
<item>Arguments: The revolve tool takes the selected NURBS curves from
the selection.
<item>Operation: It creates an Extrude object, and moves
the selected curves to it.
<item>Note: See section <ref id="extrudeobj" name="Extrude Object">
for more information regarding the extrude object.
</itemize>

<sect1>The Sweep Tool<label id="swpt">
<p>
<itemize>
<item>Arguments: The sweep tool takes two NURBS curves from
the selection.
<item>Operation: It creates a Sweep object, and moves
the selected curves to it.
<item>Note: See section <ref id="sweepobj" name="Sweep Object">
for more information regarding the sweep object.
</itemize>

<sect1>The Skin Tool<label id="skit">
<p>
<itemize>
<item>Arguments: The skin tool takes all NURBS curves from
the selection.
<item>Operation: It creates a Skin object, and moves
the selected curves to it.
<item>Note: See section <ref id="skinobj" name="Skin Object">
for more information regarding the skin object.
</itemize>

<sect1>The Cap Tool<label id="capt">
<p>
<itemize>
<item>Arguments: The cap tool takes a single NURBS curve from
the selection.
<item>Operation: It creates a Cap object, and moves
the selected curve to it.
<item>Note: See section <ref id="capobj" name="Cap Object">
for more information regarding the cap object.
</itemize>

<sect1>The Revert Tool<label id="revertt">
<p>
<itemize>
<item>Arguments: The revert tool takes all NURBS curves and
ICurves from the selection.
<item>Operation: The direction of the selected NURBS curves will be
reversed.
<item>Note: The direction of a NURBCurve is shown as
a small arrow at the end of the curve.
</itemize>

<sect1>The Concat Tool<label id="conct">
<p>
<itemize>
<item>Arguments: The concat tool takes two NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be concatenated
and a new third curve will be created.
<item>Note: If one of the curves has weights, the resulting curve
will have weights too. If the knot type of the first curve
is custom, it will be converted to NURB, otherwise the knot type
of the new curve will be that of the first selected curve.
Due to those changes of the knot values the resulting curve might
differ from the original curves.
See also section <ref id="concatncobj" name="ConcatNC Object">.
The original NURBS curves will not be deleted by this tool.
</itemize>

<sect1>The Split Tool<label id="splitt">
<p>
<figure loc="ht">
<eps file="pics/splitnc.ps" height="4cm">
<img src="pics/splitnc.gif">
<caption>Left: original curve, Right: resulting split curves for t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The split curves tool takes a single NURBS curve from
the selection and additionally requests a parametric value.
<item>Operation: The selected NURBS curve will be split into two
new NURBS curves at the designated parametric value. The splitting process
involves application of knot insertion, so that both new curves will
get a custom knot vector.
<item>Note: The original selected NURBS curve will be changed and
form the first of the two new curves, so you may want to keep a copy
of it somewhere.
</itemize>


<sect1>The Elevate Tool<label id="elevt">
<p>
<itemize>
<item>Arguments: The elevate tool takes a number of NURBS curves from
the selection and additionally requests an integer value.
<item>Operation: The order of the selected NURBS curves will be raised
by the specified integer value without changing the shape of the curve.
<item>Note: If the knot vector of the curve is not clamped, it
will be clamped automatically. The knot type of the curve will
be changed to custom.
</itemize>

<sect1>The Refine Tool<label id="refit">
<p>
<figure loc="ht">
<eps file="pics/refine.ps" height="4cm">
<img src="pics/refine.gif">
<caption>Successive Application of Refine Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
refined by inserting a knot in the middle of each inner knot interval
without changing the shape of the curve.
<item>Note: Because a new knot is inserted in the middle of
each interval, knot vectors of type NURB and B-Spline will
not change in type. See the image above for an example of a
successive refinement of a simple NURBS curve. Note, that the shape
of the curve does not change, but the position of
certain control points does.
If you want to refine a curve with new control points and not
change the position of existing control points, use the NCAttribute
property GUI instead (simply increase the length of the curve
by oldlength-1).
</itemize>

<sect1>The Clamp Tool<label id="clat">
<p>
<figure loc="ht">
<eps file="pics/clampnc.ps" height="4cm">
<img src="pics/clampnc.gif">
<caption>Left: original curve, Right: clamped curve</caption>
</figure>
<itemize>
<item>Arguments: The clamp tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
changed using knot insertion so that the first and the last knot
have a multiplicity equal to the order of the curve,
without changing the shape of the curve. The curve will
interpolate the first and the last control point afterwards.
The knot type of the curve will be changed to custom.
</itemize>

<sect1>The Insert Knot Tool<label id="insknt">
<p>
<figure loc="ht">
<eps file="pics/inskn.ps" height="4cm">
<img src="pics/inskn.gif">
<caption>Left: original curve, Right: a knot has been inserted 1 time at t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS curves from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected curves, without changing the
shape of the curve(s).
The knot type of the curve will be changed to custom.
</itemize>

<sect1>The Collapse Points Tool<label id="collt">
<p>
<itemize>
<item>Arguments: The collapse tool expects a selected NURBS curve
and a number of selected (tagged) control points (see section
<ref id="selac" name="Selecting Points"> for information on how
to select (tag) control points).
<item>Operation: The selected control points will be made a
single multiple point, all points will get the coordinate values
of the last tagged point.
</itemize>

<sect1>The Explode Points Tool<label id="explt">
<p>
<itemize>
<item>Arguments: The explode tool expects a selected NURBS curve
and a number of selected (tagged) multiple points (see section
<ref id="selac" name="Selecting Points"> for information on how
to select (tag) control points).
<item>Operation: The points forming the selected multiple points will
be made to simple points again and may be edited separately.
<item>Note, that even though you might have exploded some multiple points
Ayam will re-create them on several occasions like reading
of a scene, inserting/deleting points, and applying the NURBCurveAttrib
property if they still have identical coordinate values. In other
words, you should immediately edit the control points after exploding!
</itemize>

<sect1>The Split to Curves Tool<label id="sptct">
<p>
<itemize>
<item>Arguments: The split to curves tool takes a single NURBS patch from
the selection.
<item>Operation: The selected NURBS patch will be split into NURBS curves,
along direction u or v.
<item>Note: The NURBS patch is not deleted afterwards.
</itemize>

<sect1>The Build from Curves Tool<label id="bfct">
<p>
<itemize>
<item>Arguments: The build from curves tool takes a number of NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be parsed, all curves
that are of equal length or longer than the first selected curve
will be used to form a new NURBS patch of the following dimensions:
Width: length of the first selected curve,
Height: number of used curves. Other parameters (Knot-Type_U, Knots_U
etc.) are taken from the first curve.
<item>Note: The NURBS curves are not deleted afterwards.
</itemize>


<sect>The Tcl Scripting Interface<label id="script">
<p>
The scripting interface is mainly a bunch of Tcl procedures
and Tcl commands that a big part of Ayam uses internally.<p>
Using Tcl, you could directly modify the code Ayam consists
of. This is, however, not recommended for good reasons.
So watch out for already existing procedures and commands when
implementing your own!<p>
Using procedures and commands not listed in this documentation
is dangerous too. Implementation and interfaces of that
commands may change in future versions.

The scripting interface may be used directly from the console
of Ayam. You can, of course, also write procedures in your own
Tcl script files, that may be loaded at any time into Ayam using
the console and the Tcl command <tt/"source"/.<p>
You can also arrange for a script to be executed automatically
on startup using the preference setting <tt>"Main/Scripts"</tt>.

Note, that most of the listed commands work in background,
without changing anything to the Ayam GUI and Ayam view windows,
for execution speed. If you want your changes to become visible
you have to update the various parts of the GUI explicitly.<p>

From scripts it may be necessary to check wether an error occured
during the execution of a command. All commands return
TCL_OK in any case so checking their return value avails to nothing,
but they set the global Tcl variable <tt>ay_error</tt> to 1 if an
error occured. You need to set it to zero before and check it after the
operation in question to see whether the operation performed successfully.


<sect1>Index of Procedures and Commands
<p>

<sect2>Creating Objects<label id="crtob">
<p>
To create new objects the <tt/"crtOb"/ command can be used.
<itemize>
 <item>Synopsis: <tt/"crtOb type [args]"/
 <item>Description: New objects may be created with the command <tt/"crtOb"/,
type may be derived from the type name, as displayed in the tree view.<p>

Depending on the type, further arguments may (or have to) be given,
other types expect objects to be selected:<p>
  <itemize>
  <item><tt/"NCurve"/: NURBS curves accept a single integer as length of
the new curve, the length defaults to 4. Example:
<tt/"crtOb NCurve -length 10; uS; rV"/
  <item><tt/"NPatch"/: NURBS patches accept two integers as width and
height of the new patch, width and height both default to 4. Example:
<tt/"crtOb NPatch -width 2 -height 2; uS; rV"/
  <item><tt/"Level"/: Levels must be given an additional argument
determining the type of the new level, this argument may be one of:
<tt/"0"/ (level), <tt/"1"/ (union), <tt/"2"/ (intersection),
<tt/"3"/ (difference), <tt/"4"/ (primitive).
 <item><tt/"Material"/: Materials must be given an additional
argument giving the name of the new material. Example:
<tt/"crtOb Material default; uS; rV"/
 <item><tt/"Instance"/: creates an instance of the selected object.
 <item>...
 </itemize>
</itemize>

<sect2>Manipulating the Selection<label id="selob">
<p>
This function is probably the most important one, because
a lot of the other commands operate on selected objects only.<p>
selOb:
<itemize>
 <item>Synopsis: <tt/"selOb [index]"/
 <item>Description: Use this command to set or clear the current
selection, index may be an ordered list of indizes, a single index or empty.
If no index is given, the current selection will be cleared.
</itemize>

<sect2>Clipboard Operations<label id="copob">
<p>

copOb - copy object:
<itemize>
 <item>Synopsis: <tt/"copOb"/
 <item>Description: Copy the selected object(s) to the object clipboard.
</itemize>

cutOb - cut object:
<itemize>
 <item>Synopsis: <tt/"cutOb"/
 <item>Description: Move the selected object(s) into the object clipboard.
</itemize>

pasOb - paste object:
<itemize>
 <item>Synopsis: <tt/"pasOb"/
 <item>Description: Copy the selected object(s) from the object
clipboard to the current level.
</itemize>

delOb - delete object:
<itemize>
 <item>Synopsis: <tt/"delOb"/
 <item>Description: Delete the selected object(s) from the scene.
</itemize>

cmovOb - paste (move) object:
<itemize>
 <item>Synopsis: <tt/"cmovOb"/
 <item>Description: Move the objects from the object
clipboard to the current level.
</itemize>

pclip_copy - copy a property to the clipboard
<itemize>
 <item>Synopsis: <tt/"pclip_copy mode"/
 <item>Description:  Copy the currently selected
property from the currently selected
object to the property clipboard.
If mode is 0, omit all marked entries, if mode is 1 copy just
marked entries.
</itemize>

pclip_paste - paste a property
<itemize>
 <item>Synopsis: <tt/"pclip_paste"/
 <item>Description: Copy the property from the property clipboard
to the currently selected object.
Note, that you may call this procedure also using the shortcut
<tt/"pasteProp"/.
</itemize>

<sect2>Hierarchy Operations<label id="gdown">
<p>

goDown:
<itemize>
 <item>Synopsis: <tt/"goDown index"/
 <item>Description: Enter the object determined by index. If index is 0
and the current level is inside some other object (not the root)
the parent level will be entered instead. 
</itemize>

goUp:
<itemize>
 <item>Synopsis: <tt/"goUp"/
 <item>Description: Go one level up in the object hierarchy. 
</itemize>

goTop:
<itemize>
 <item>Synopsis: <tt/"goTop"/
 <item>Description: Go to the top level of the object hierarchy.
</itemize>

<sect2>Transformations<label id="movob">
<p>

movOb - move objects:
<itemize>
 <item>Synopsis: <tt/"movOb dx dy dz"/
 <item>Description: Move the selected object(s) by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

rotOb - rotate objects:
<itemize>
 <item>Synopsis: <tt/"rotOb dx dy dz"/
 <item>Description: Rotate the selected object(s) by dx degrees around the
objects X axis then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

scalOb - scale objects:
<itemize>
 <item>Synopsis: <tt/"scalOb dx dy dz"/
 <item>Description: Scale the selected object(s) by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

movSel - move selected points:
<itemize>
 <item>Synopsis: <tt/"movSel dx dy dz"/
 <item>Description: Move the selected points by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

rotSel - rotate selected points:
<itemize>
 <item>Synopsis: <tt/"rotSel dx dy dz"/
 <item>Description: Rotate the selected points by dx degrees around the
objects X axis then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

scalSel - scale selected points:
<itemize>
 <item>Synopsis: <tt/"scalSel dx dy dz"/
 <item>Description: Scale the selected points by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

delegTrafo - delegate transformations:
<itemize>
 <item>Synopsis: <tt/"delegTrafo"/
 <item>Description: delegates the transformations associated
with the selected objects to their child objects. Additionally,
the transformations
of the selected objects will be reset to the default values.
</itemize>

applyTrafo - delegate transformations:
<itemize>
 <item>Synopsis: <tt/"applyTrafo sel&verbar;all"/
 <item>Description: applies the transformations encoded in the
transformation attributes of the selected objects to the points
(either all points, or just the seleted ones) of those objects.
Additionally, the transformations of the selected objects will
be reset to the default values.
</itemize>

<sect2>Manipulating Shaders<label id="delsh">
<p>

shaderSet:
<itemize>
 <item>Synopsis: <tt/"shaderSet shadertype [varname]"/
 <item>Description: Set the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. If varname is not given, the shader in question
is deleted from the object instead.
</itemize>

shaderGet:
<itemize>
 <item>Synopsis: <tt/"shaderGet shadertype varname"/
 <item>Description: Get the shader of type shadertype for the selected
object, . Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. The shader will be written to an array
pointed to by varname.
</itemize>


<sect2>Manipulating NURBS Curves and Surfaces<label id="gncp">
<p>

clampNC:
<itemize>
 <item>Synopsis: <tt/"clampNC"/
 <item>Description: Clamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve will be changed to custom and
the knots will have o equal values at start and end (where o is the
order of the curve).
</itemize>

elevateNC:
<itemize>
 <item>Synopsis: <tt/"elevateNC n"/
 <item>Description: Elevate the order of the selected NURBS curves
without changing the shape of the curves by n.
The knot type of the elevated curves will be changed to custom.
</itemize>

insknNC - insert knot:
<itemize>
 <item>Synopsis: <tt/"insknNC u r"/
 <item>Description: Insert a new knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curves) r times. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the curve and n is the length of the curve.
The knot type of the curves will always be changed to custom but
the shape of the curves will not change!
</itemize>

refineNC:
<itemize>
 <item>Synopsis: <tt/"refineNC [{u1 u2 un}]"/
 <item>Description: Refine the knot vector of the selected NURBS curve
without changing the shape of the curve with n new knots {u1 u2 un}.
Or, if no list of new knots is given, add a new knot into each interval
in the old knot vector.
The knot type of the refined curve will be changed to custom.
</itemize>

revertNC:
<itemize>
 <item>Synopsis: <tt/"revertNC"/
 <item>Description: Revert the direction of the selected NURBS curves.
</itemize>

splitNP:
<itemize>
 <item>Synopsis: <tt/"splitNP (u|v)"/
 <item>Description: splits the selected NURBPatch into NURBS curves,
along u or v.
</itemize>

buildNP:
<itemize>
 <item>Synopsis: <tt/"buildNPatch"/
 <item>Description: builds a NURBPatch from the selected NURBS curves.
</itemize>


<sect2>Manipulating Points<label id="scpoints">
<p>

Use these two commands to read or manipulate single
points of arbitrary objects.
Note, that the exact arguments needed, depend on the
type of the object, e.g. a NURBS curve requires just one
index parameter (indexu), whereas a NURBS patch requires two
(indexu and indexv).

getPnt:
<itemize>
 <item>Synopsis: <tt/"getPnt [-trafo] indexu [indexv] varx vary varz [varw]"/
 <item>Description: Get a control point of the currently
selected object and write it's coordinates into the variables
varx, vary, varz and varw.
If the special argument <tt/"-trafo"/ is given, the coordinates
will be transformed by the values given in the objects
Transformation property.
</itemize>

setPnt:
<itemize>
 <item>Synopsis: <tt/"setNP indexu [indexv] x y z [w]"/
 <item>Description: Set a control point of the
currently selected object to the coordinates x, y, z and w.
</itemize>


<sect2>Updating the GUI<label id="upd">
<p>

rV - redraw all views:
<itemize>
 <item>Synopsis: <tt/"rV"/
 <item>Description: Redraws all currently open views, except for
iconified views and views where automatic redraw has been turned off.
</itemize>

uCL - update current level:
<itemize>
 <item>Synopsis: <tt/"uCL mode [args]"/
 <item>Description: see discussion of <tt/"uS"/ below.
</itemize>

uCR - update current level:
<itemize>
 <item>Synopsis: <tt/"uCR"/
 <item>Description: see discussion of <tt/"uS"/ below.
</itemize>

uS - update select:
<itemize>
 <item>Synopsis: <tt/"uS [update_prop maintain_selection]"/
 <item>Description: Update the object listbox or tree view after a change
to the object hierarchy.<p>

If update_prop is 0 no update of the property GUIs will take place.
If maintain_selection is 1 the old selection will be established again.
If both arguments are omitted update_prop defaults
to 1 and maintain_selection to 0.
 <item>Deficiencies: uS completely removes the object tree from
the tree widget and rebuilds
it, which can be a very time consuming operation (depending on the complexity
of the scene). There are some options to speed this process up:
 <itemize>
 <item> If there were just changes to the current level (and below)
the global array entry <tt/"ay(ul)"/ (UpdateLevel) may be set
to the current level before calling <tt/"uS"/. This will not remove
and update the complete scene but just the part below <tt/"ay(ul)"/.
Example: <tt>set ay(ul) $ay(CurrentLevel); uS;</tt>.
 <item> If objects have been created and thus just need to be
added to the current level, the command <tt/"uCR"/ may be used instead
of <tt/"uS"/.
 <item> If just names or types of objects of the current level changed,
the command <tt/"uCL cl"/ may be used instead of <tt/"uS"/.
 </itemize>
</itemize>


plb_update:
<itemize>
 <item>Synopsis: <tt/"plb_update"/
 <item>Description: Clear the current property GUI, ask the
selected object for a list of properties and insert them in the
property listbox, then rebuild the property GUI.
</itemize>

<sect2>Custom Objects<label id="lc">
<p>

io_lc - load custom:
<itemize>
 <item>Synopsis: <tt/"io_lc filename"/
 <item>Description: Load the custom object from file filename.
</itemize>

<sect2>Applying Commands to a Number of Objects<label id="fall">
<p>
There are two commands that help to apply arbitrary commands
to a number of objects, forAll and forAllT.

forAll:
<itemize>
 <item>Synopsis: <tt>"forAll recursive command"</tt>
 <item>Description: The forAll command executes command for all
objects that have been selected currently, or for every object
of the current level if nothing has been selected. If recursive
is 1 then forAll will recurse into every object (if it has child objects)
before the execution of command. Note, that forAll will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu.
 <item> Deficiencies:
 <itemize>
  <item>A recursive forAll will
e.g. also descend into NURBS patches (if they have trim curves) and apply
the command to the trim curves, which might not exactly be what you
want. Use <tt>"forAllT"</tt> in this case.
  <item>The command will not have access to global arrays unless
e.g. one of the following construct is in use:<p>

<tt>"forAll 0 &lcub; uplevel &num;0 &lcub; command &rcub; &rcub;"</tt><p>
<tt>"forAll 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). Command
may just modify existing objects.
 </itemize>
</itemize>

forAllT:
<itemize>
 <item>Synopsis: <tt>"forAllT type recursive command"</tt>
 <item>Description: forAllT works the same way as forAll, with an
additional type check. The command will not be executed if the type of the
current object does not match the argument type. Note, that forAll will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu.<p>

Note, that the type strings will be converted to lowercase before
comparison, so that it is legal to use it e.g. this way:
<p><tt>"forAllT ncurve 0 &lcub;puts $i&rcub;"</tt><p>
 <item>Deficiencies:
 <itemize>
  <item>The command will not have access to global arrays unless
e.g. the following construct is in use:
<p><tt>"forAllT ncurve &lcub;uplevel &num;0 &lcub;command&rcub;&rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). Command
may just modify existing objects.
 </itemize>
</itemize>

<sect2>Scene IO<label id="scio">
<p>

newScene:
<itemize>
 <item>Synopsis: <tt>"newScene"</tt>
 <item>Description: clears the current scene.
</itemize>

replaceScene:
<itemize>
 <item>Synopsis: <tt>"replaceScene filename"</tt>
 <item>Description: clears the current scene, then loads a new scene
from filename.
</itemize>

insertScene:
<itemize>
 <item>Synopsis: <tt>"insertScene filename"</tt>
 <item>Description: inserts a scene from filename.
</itemize>

saveScene:
<itemize>
 <item>Synopsis: <tt>"saveScene filename"</tt>
 <item>Description: saves the current scene to filename.
</itemize>

<sect2>Reporting Errors<label id="sierr">
<p>

ayError:
<itemize>
 <item>Synopsis: <tt>"ayError code place detail"</tt>
 <item>Description: This command reports errors or warnings.
You should always use ayError instead of puts because the error
reporting mechanism of Ayam features compression of repeated
messages and logging to files. Code should be one of: 1: warning, 2:
error, 3: flush messages, 4: unspecified output.
There are more codes defined (see ayam.h, look for Return/Error Codes)
but they are not needed in the Tcl script context.
Place should describe the procedure where the error occured.
Detail is the string to be output.
</itemize>


<sect2>Miscellaneous<label id="gtype">
<p>

getType:
<itemize>
 <item>Synopsis: <tt>"getType varname"</tt>
 <item>Description: This command writes the type of the
selected object into the variable varname. The types are
the well known strings that are displayed in the hierarchy list box
if the objects are not named (NPatch, NCurve, Sphere, etc.).
</itemize>

tmpGet:
<itemize>
 <item>Synopsis: <tt>"tmpGet tmpdir varname"</tt>
 <item>Description: This command calculates a name for a temporary
file in tmpdir and puts the complete name into varname.
</itemize>

hasChild:
<itemize>
 <item>Synopsis: <tt>"hasChild"</tt>
 <item>Description: This command returns 0 if the selected object
has no child objects, otherwise it returns 1.
</itemize>

undo:
<itemize>
 <item>Synopsis: <tt>"undo [redo|save|clear]"</tt>
 <item>Description:
 <itemize>
  <item>If called without arguments, this command performs the undo
  operation. 
  <item>If the argument is <tt/"redo"/, this command performs the redo
  operation.
  <item>If the argument is <tt/"save"/, the currently selected objects
  are saved to the undo buffer for future undo operations. 
  <item>If the argument is <tt/"clear"/, the undo buffer is cleared.
 </itemize>
</itemize>

convOb:
<itemize>
 <item>Synopsis: <tt>"convOb"</tt>
 <item>Description: This command calls the registered converter
for the selected object.
</itemize>

forceNot:
<itemize>
 <item>Synopsis: <tt>"forceNot"</tt>
 <item>Description: This command calls the registered notification
callback for the selected object(s) and their parents, or if no object
is selected for all objects of the scene.
</itemize>

<sect1>Scripting Interface Examples
<p>
Here are some example scripts for the Ayam Tcl scripting interface.

You may copy and paste all examples directly from the documentation
into the console of Ayam.

<sect2>Moving Objects<label id="scexmov">
<p>
The following example script shows how to move a selected object
to a specified position in space.
<code>
proc placeOb { x y z } {
  global transfPropData

  # copy Transformations-property data to
  # global array "transfPropData"
  getTrafo

  # set array values according to procedure parameters
  set transfPropData(Translate_X) $x
  set transfPropData(Translate_Y) $y
  set transfPropData(Translate_Z) $z

  # copy Transformations-property data from
  # global array "transfPropData" to selected object
  setTrafo
}
# placeOb
</code>
In order to move all selected objects to 1 1 1 you may enter the
following into the console:
<code>
forAll 0 {placeOb 1 1 1}
</code>
But perhaps you would rather like a small GUI for that?
No problem, the following snippet adds an entry to the custom
menu that opens a small requester for the x-, y-, and z-values and
calls the <tt/"placeOb"/ procedure (defined above) with them:
<code>
global ay
$ay(cm) add command -label "Place Object" -command {
 runTool {x y z} {"X:" "Y:" "Z:"} "forAll 0 {placeOb %0 %1 %2}"
 uS
}
</code>

<sect2>Moving NURBS points<label id="scexnurb">
<p>
The following example script snippet shows how to move control points
of a NURBS curve.
<code>
# first, we create a new NURBS curve with 30 control points
set len 30
crtOb NCurve -length $len
# update selection
uS
# select last object (the newly created curve)
sL
# prepare moving
set i 0
set w 1.0
set angle 0
while { $i < $len } {

    set x [expr 3*cos($angle)]
    set y [expr 3*sin($angle)]
    set z [expr $i/3.0]

    # move control point to new position
    setPnt $i $x $y $z $w

    incr angle 90
    incr i
}
# redraw all views
rV
</code>
Now use this as path for a Sweep.
For instance, using the next small script.

<sect2>Easy Sweep<label id="scexsweep">
<p>
The following example script shows how to easily create a
sweep from a selected path curve (avoiding the manual and lengthy creation
and parameterization of a suitable cross section).
<code>
proc easySweep { } {
 # first, we create a sweep object
 crtOb Sweep

 # now, we need to move the selected curve (path) to
 # the sweep and create a cross-section curve there too
 # for that, we move the currently selected curve to the clipboard
 cutOb
 uS

 # how does the current level look like?
 getLevel a b

 # enter the Sweep (the last object in the current level)
 goDown [expr [llength $a]-1]
 uS

 # now, we create a new curve (a closed BSpline suitable as cross section)
 crtClosedBS 8
 uS

 # how does the current level look like?
 getLevel a b

 # select last object (the newly created curve)
 selOb [expr [llength $a]-1]

 # now, we rotate and scale the curve
 rotOb 0 90 0
 scalOb 0.25 0.25 1.0

 # move trajectory back (we use "cmovOb" and _not_ "pasOb", because we
 # really move (and not copy) the curve
 cmovOb
 # go up to where we came from
 goUp

 # update GUI
 uS
 sL
 # redraw all views
 rV
}
# easySweep
</code>

You may add this command to the main menu as well:
<code>
global ay
$ay(cm) add command -label "Easy Sweep" -command {
 easySweep
}
</code>
<sect2>Tool Box Buttons<label id="scextoolbox">
<p>
Here is another example that shows how you may add buttons
to the tool box.
myImage should be an image created e.g. from a GIF file of
the size 25 by 25 pixels.
<code>
global ay

# create an image from a GIF file:
image create photo myImage -format gif -file /home/user/agif

set b .tbw.f.mybutton

# if the button not already exists:
if { ![winfo exists $b] } {

  # create it:
  button $b -padx 0 -pady 0 -image myImage -command myCommand

  # tell Ayam about the new button:
  # you can use linsert, to insert the button in a specific
  # place or just append to the end of the list
  lappend ay(toolbuttons) mybutton

  # display the button:
  # from now on, it will be under the
  # automatic tool box layout management
  toolbox_layout
}
</code>

This example shows that a) buttons have to be created in the
frame <tt/".tbw.f"/
b) Ayam manages a list of all buttons in the global array ay
in <tt/"ay(toolbuttons)"/, the order in that list is the order
in which buttons appear in the tool box c) automatic layout
management is carried out by the procedure <tt/"toolbox_layout"/.
<p>
Adding buttons with just text is a little bit more involved,
as the sizes of the new buttons often do not fit well in the
icon button scheme with its constant button size.
<p>
Here is an example that adds two buttons to the bottom of the
tool box spanning the whole window (this works best with the
standard tool box layout of 4 by 12 buttons):
<code>
# create a frame:
set f [frame .tbw.f.fcollex]

# create two buttons inside the frame:
button $f.b1 -width 5 -text "Coll." -command { collNC; rV; }
button $f.b2 -width 5 -text "Expl." -command { explNC; rV; }
pack $f.b1 $f.b2 -side left -fill x -expand yes

# calculate the row number below the last row:
set row [expr [lindex [grid size .tbw.f] 1] + 1]

# now display the frame at calculated row, spanning the whole window:
grid $f -row $row -column 0 -columnspan [lindex [grid size .tbw.f] 0]
</code>

<sect>Miscellaneous
<p>
<sect1>The Undo System<label id="undos">
<p>
Using the undo system you may correct mistakes you made
while modeling.
However, it is currently not possible to undo any changes to the object
hierarchy, including clipboard and Drag-and-Drop operations.
If you delete an object, it is gone! If you, accidentally, move
an object using Drag-and-Drop, undo will not help!
Only changes to objects are undoable. This includes changes
made by modeling actions, changes made using property GUIs, but also changes
to views (type changes or changes to the camera settings associated
with a view).
<p>
The undo system works by storing copies of the different
states of changed objects in an undo buffer. The storage space occupied by
the undo buffer may be adjusted using the preferences
(Prefs/Modeling/UndoLevels). Note, that a value of -1 for UndoLevels
completely disables the undo system.
You may step backward through the saved states using
<tt/&lt;Ctrl+z&gt;/ (undo) but also forward using <tt/&lt;Ctrl+y&gt;/ (redo).
<p>
Several actions will completely clear the undo buffer (no undo is
possible after those actions):
Delete Object, New Scene, Replace Scene, and Close View.
<p>
Note, that undo/redo will also modify objects that currently reside in the
object clipboard if they have saved states in the undo buffer.

<sect1>Ayamrc File<label id="ayamrc">
<p>
To customize Ayam the ayamrc file may be used.
This file is either pointed to by the environment
variable <tt>AYAMRC</tt> or is determined as following:
<itemize>
<item>On Unix it is <tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On Win32 platforms (Windows95-2000) it is
<tt>"&dollar;(HOME)/ayamrc"</tt> if the environment variable
<tt>HOME</tt> exists, else <tt>"&dollar;(TEMP)/ayamrc"</tt>.<p>
</itemize>

The ayamrc file is read on each start of Ayam and saved again
on exit (if the preference setting <tt>"Main/AutoSavePrefs"</tt> is enabled).
<p>
The ayamrc file contains:
<enum>
<item>preference settings (including some hidden settings that require
just occasional tweaking and are not reachable using the GUI preference editor)
<item>position and size of the main window and the tool box window
<item>keyboard shortcuts to menu entries and modeling actions
<item>RiOption and RiAttribute databases
</enum>

You may edit the file by hand, but keep in mind, that the
file will be parsed by Tcl. Should you, for some reason,
destroy your ayamrc so that Ayam does not start
correctly anymore
you may start Ayam with the command line option <tt>"-failsafe"</tt>.
When the application is left the next time, or the main menu entry
<tt>"Save Prefs"</tt> is invoked
a correct ayamrc will be created again. All preference settings
will be reset to factory defaults, however!<p>

<sect2>Changing Keyboard Shortcuts
<p>
You may adapt the shortcuts used in the GUI to
your special needs using the ayamrc file. 
Note, that if you do that the GUI (the menu entries)
will adapt to your changes but certainly neither this documentation nor
the tutorials!
Ayam does not check for clashes! This means, the last set binding
for a key will be used.
On Unix, the output of the program <tt/xev/ and the
manual page for the <tt/bind/ command of Tk provide helpful
information about which strings may be used to describe
key presses.
For your convenience, the special string <tt/"Ctrl"/ will be replaced by
<tt/"Control"/ before a shortcut is handed to the <tt/bind/ command.

Example:
<code>
set aymainshortcuts(Prefs) {Ctrl-p}
</code>
sets the keyboard shortcut for opening of the preferences editor
to <tt/&lt;Ctrl+p&gt;/.
See the ayamrc file itself for a complete listing of available shortcuts.

<sect2>Hidden Preference Settings<label id="hidprefs">
<p>
The ayamrc file currently contains the following adjustable hidden
preference settings:
<itemize>
<item><tt/"Balloon"/: time in ms until the tooltip window appears
(default: 1500 - 1.5s)
<item><tt/"EFlush"/: time in ms between two flushes of the error message buffer
(default: 2000 - 2s)
<item><tt/"toolBoxList"/: a list of sections describing the appearance of the
tool box window (default; using all available sections: <tt>{trafo
trafo2 solids misco nurbs toolobjs points nctools1 nctools2 camera
misc}</tt>)
<item><tt/"Kill"/: name of a program that kills other processes and accepts
a process id as argument (used by the Rendering GUI)
(default: <tt>"kill"</tt>) (a setting of <tt>"kill"</tt> will be
automatically replaced by <tt>"kill.exe"</tt> on Win32)
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam1.4.
<item><tt/"Cat"/: name of a program that can read from and write to
a pipe (used by the Rendering GUI) (default: <tt>"cat"</tt>)
(a setting of <tt>"cat"</tt> will be
automatically replaced by <tt>"cat.exe"</tt> on Win32)
<item><tt/"KeepNTmpFiles"/: how many
incarnations of the scene in RIB form (which actually may be split
in more than one file due to e.g. instances) created by Direct
Rendering should be kept on disk (default: 5)
<item><tt/"Wpclip_pastetosel"/: should
<tt>"Special/Clipboard/Paste Property to Selected"</tt> raise a warning
requester? (default: 1 - yes)
<item><tt/"DailyTips"/: a list of strings that appear as tips
on startup in the console
<item><tt/"PickTolerance"/: the tolerance used to determine whether an object
should be picked or not (default: 5); this setting determines the size
of a rectangular area around the picked point in pixels, all objects that
are inside or touch this area are considered picked
<item><tt/"MaxTagLen"/: the maximum number of characters to be displayed
in the buttons in the Tag Property GUI (default: 30)
<item><tt/"Wait"/: set this to <tt/"waitPid"/ if you want to enable
the work around for zombie processes created by the Rendering GUI.
This is necessary for the Linux platform.
<item><tt/"Prompt"/: controls the prompt for the console. If
set to an empty string a default of <tt/"[file tail [pwd]]&gt;"/
will be used, which displays the last component of the current
directory of Ayam. You may e.g. change this to <tt/"[pwd]&gt;"/
to see the full path. If you want to display the value of a
variable in the prompt (e.g. designating the current level in
the scene hierarchy) you need to bind a write-trace to that variable,
that calls the procedure <tt/"update_prompt"/. This write-trace
may e.g. be established using a small script:
<tt/"trace variable &lt;vname&gt; update_prompt"/.
</itemize>

<sect2>RiOption and RiAttributes Database<label id="rioptdb">
<p>
Using your ayamrc file, you may also adapt the database of RiOptions and
RiAttributes to your rendering system.
<p>
You can then easily add those options and attributes
to your scenes using tags and the main menu entries
<tt>"Special/Tags/Add RiOption"</tt> and
<tt>"Special/Tags/Add RiAttribute"</tt>,
see also sections
<ref id="riatag" name="RiAttribute Tag"> and
<ref id="riotag" name="RiOption Tag">.
<p>
The syntax for a new RiOption is quite simple as the following example shows:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug" } } }
</code>
This snippet sets the section <tt>"runtime"</tt> and adds a single
option, <tt>"verbosity"</tt>, to it. The option is declared to be of type
string using <tt>"s"</tt> and provided with a list of default values:
<tt>"{ "silent" "normal" "stats" "debug" }"</tt>.

To add another option to this section, say the option <tt>"op"</tt>
which shall be an integer value you have to change the aforementioned
snippet to:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug"} }
 { op i }
}
</code>
As you can see, it is not mandatory to provide default values.
But be careful with the brackets!

Available types of parameters are:
<itemize>
<item>i: a scalar integer value
<item>f: a scalar float value
<item>s: a string value
<item>p: a point in space (simply three float values), the default
values (if provided) are three float values in curly braces, such as
<tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
<item>c: a color, the default values (if provided) are three float
values in curly braces, such as <tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
</itemize>


<sect1>Import of Mops Scenes<label id="impmops">
<p>
Mops scenes may be imported using the main menu entry:
<tt>"File/Import Mops"</tt>.
<p>
Ayam is able to import most elements of a Mops scene except for
RiAttributes attached to arbitrary geometric objects,
because attributes and shaders are managed by material objects in Ayam.
However, if a Mops object has a surface or displacement shader,
a material object with the shaders from the Mops object
and its RiAttributes will be automatically created and linked with
the geometric object while importing. Only Mops objects
with surface or displacement shaders are considered because
otherwise a material object would have to be created for every
imported Mops object.
The material objects are named <tt/"mat0"/, <tt/"mat1"/ and so on.
Make sure, that the current scene in Ayam does not contain material
objects with those names, otherwise Mops import will not be able to
create material objects for the scene to import.
<p>
The import options <tt>"ResetDM"</tt> and
<tt>"ResetDM"</tt> control, whether GLU display mode
and tolerance settings (see sections
<ref id="ncattr" name="NCurveAttrib">, and
<ref id="npattr" name="NPatchAttrib"> for more information about
tolerance and display mode)
of NURBS primitives should be reset
to using global preference values (the default in Ayam)
instead of using the values from the Mops scene file.

<sect1>Import of RenderMan Interface Bytestreams (RIB)<label id="rrib">
<p>
Using the RRIB (Read RIB) plugin you may import RenderMan Interface
Bytestreams into Ayam.
Start importing a RIB using the menu entry
<tt>"Custom/RRIB/Import RIB"</tt>
(if this menu entry is not available, you have to load the
<tt>"rrib"</tt> plugin using the menu entry
<tt>"File/Load Custom"</tt> first).
<p>
The RRIB plugin supports import of the following geometric
primitives:
<itemize>
<item>Quadrics (Sphere, Disk, Cylinder, Cone, Paraboloid, Hyperboloid, Torus)
<item>bilinear and bicubic patches and patch meshes
<item>NURBS patches (with trim curves)
<item>(general) polygons and (general) polygon meshes
<item>subdivision meshes (with all tags)
</itemize>

Furthermore, the plugin supports reading of CSG, object-instances,
archives, light sources (including area-lights), arbitrary linear
transformations (except shear transformations!), arbitrary
RiOptions and RiAttributes, and shaders (except transformation
shaders and without array arguments!).
<p>
The RRIB plugin does not support reading of curves, implicit surfaces
(blobby models), procedural objects, delayed read archives, arbitrary
primitive variables (e.g. varying or vertex) and other calls to the
RenderMan Interface not that useful for a RIB import like e.g. RiMakeTexture.
Unsupported geometric primitives and other calls to the RenderMan Interface
are silently ignored.
<p>
The RIB import may be controlled via different options:<label id="rribopt">
<itemize>
<item><tt/"ReadFrame"/, specifies the number of the frame in the RIB
to read. A value of -1 means, all frames are to be read. If you specify
a frame number and this frame does not show up in the RIB as
<tt/"FrameBegin &lt;yournumber&gt;"/ nothing will be
imported!
<item><tt/"ReadCamera"/: if this is switched on, a Camera object will
be created when the RIB plugin encounters a <tt/"WorldBegin"/. You may drag
this camera object onto a perspective View object in Ayam after import
to see through the camera of the imported RIB.
<item><tt/"ReadOptions"/, controls, whether RiOptions are
to be imported from the RIB to the scene. Note, that those
RiOptions will overwrite the current global settings in the Ayam scene.
<item><tt/"ReadLights"/, if this is enabled the lights from the
RIB will be imported.
<item><tt/"ReadMaterial"/, controls, whether material objects
are to be created for the imported objects. All material objects
are created in a special level named <tt/"Materials"/ in the top level
of the scene. The plugin tries to keep the number of generated
material objects as low as possible by comparing with already
existing materials in this level. This also works with material
objects that exist before the RRIB plugin is invoked (as long as
they reside in this special level).
<item><tt/"ReadPartial"/, this option is useful if you want to
import partial RIBs (e.g. archives) that do not
contain a <tt/"WorldBegin"/.
Be careful with this option (i.e. use it only if reading of a RIB fails),
as it switches reading of all types of objects on, regardless of
the RIB structure.
<item><tt/"ErrorLevel"/, this option controls how many error messages
should be printed to the Ayam console while reading the RIB. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
Note that in the case of serious syntactic errors of the RIB file
more informative error messages are printed to the stderr channel
of Ayam (which is not redirected to the Ayam console).
</itemize>

Note that for NURBS patches and bicubic patch meshes, points of type
"P" will be promoted to "Pw".
Furthermore, objects of type (general) polygon and polygon mesh will
be promoted to general polygon meshes.
Object-Instances are resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).

<sect1>3DMF Import Export (MFIO) Plugin<label id="mfioplugin">
<p>
Using the MFIO plugin you may import and export scenes
from (to) the 3DMF format (version 1.0 only!) from Apple.
Start importing a 3DMF file using the menu entry
<tt>"Custom/3DMF/Import"</tt>
(if this menu entry is not available, you have to load the
<tt>"mfio"</tt> plugin using the menu entry
<tt>"File/Load Custom"</tt> first).
<p>
Import supports the following primitives:
<itemize>
<item> Polyline, Triangle, TriGrid, Polygon, general Polygon, Box,
<item> NURBS curve, NURBS surface (with trim curves),
<item> Ellipsoid, Cylinder, Cone, Disk, and Torus.
</itemize>

The following transformations are supported:
<itemize>
<item> Scale,
<item> Translate,
<item> Rotate, RotateQuaternion, RotateAxis (if axis is X, Y, or Z).
</itemize>
Furthermore, the import plugin reads the structure of the scene from Container
objects. Reference objects will be resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
The MFIO export supports the following primitives:
<itemize>
<item> NURBS curve and NURBS surface (with trim curves) including all
NURBS curve/surface providing objects, such as ICurve, Skin etc.,
<item> Sphere, Disk, Cone, Cylinder, Torus,
<item> Box, and PolyMesh.
</itemize>

All transformations are supported and will be written as
Translate, Rotate, and Scale transformations, respectively.
All Instance objects will be resolved for export.
Level objects (regardless of type) will be written as Container objects.
If an object has a material, the color and opacity of the material
will be written as DiffuseColor and TransparencyColor, if the red
component has a value different from -1.
<p>
Support for import or export of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect1>Shader Parsing Plugins<label id="spplugins">
<p>
Since Ayam1.3, the following plugins are provided to allow
parsing of shaders: <tt/"ayslb"/ for Air, <tt/"ayslx"/ for Aqsis,
<tt/"ayso"/ for RDC, <tt/"ayslo"/ for PRMan, and <tt/"ayslo3d"/ for 3Delight.
<p>
After loading of one of the aforementioned plugins, Ayam will
be able to parse shaders compiled with the shader compiler
of the respective renderer.
<p>
A shader parsing plugin may be loaded
automatically on startup of Ayam using one of the provided Tcl scripts:
<tt/"loadayslb.tcl"/, <tt/"loadayslo.tcl"/, <tt/"loadayslo3d.tcl"/,
<tt/"loadayslx.tcl"/, and <tt/"loadayso.tcl"/.
To automatically load a plugin simply add the appropriate
script to the preference setting
<tt>"Main/Scripts"</tt> using the <tt>"Add"</tt> button in the
preferences editor.
<p>
Additionally, those scripts may be further adapted by the user to
set a different <tt/"Shaders"/ preference setting or to immediately
scan for shaders after loading of the plugin. For that, just remove
the leading hash-marks (&num;) from the corresponding lines in the script.
However, the standard behavior while loading of
such a plugin requires you to scan manually for shaders and to adapt
the shaders search path manually too. Both actions may be carried
out using the preferences editor.

<sect1>Automatic Instancing<label id="ai">
<p>
Automatic Instancing is available via the main menu entry:
<tt>"Special/Instances/Automatic Instancing"</tt>.
Automatic Instancing creates instances from all instantiable
objects from the current level and below,
using a simple algorithm that recursively compares
objects. The comparison of materials and tags may be turned off in the
small dialog that pops up after selection of the menu entry
<tt>"Special/Instances/Automatic Instancing"</tt>.

The algorithm is able to create instances of grouping objects
too (objects with child objects, e.g. levels or tool-objects
like revolve).
However, in order for two grouping objects to be instantiated
not only all child objects and the grouping objects
have to be instantiable, but the child objects also
have to be in the right order. It is not sufficient,
that for every child of the potential master, a matching
child of the potential instance exists.
Instantiation of grouping objects may drastically decrease
the total number of objects in a scene.

Note, that before the automatic instantiation starts, all currently
existing instances will be resolved!
After instantiation some statistics will be displayed in the console.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Automatic Instancing of
Hierarchically Organized Objects", in: Kunii T.L. (ed.): Spring
Conference on Computer Graphics (SCCG 2001) Conference Proceedings, Budmerice,
Slovakia, 25-28 April 2001, ISBN 80-223-1606-7</it>

<sect1>Importance Driven Rendering (IDR)<label id="idr">
<p>
The importance driven rendering plugin may be used to drastically
reduce rendering times while developing a scene.
It works in three main steps:
<enum>
<item>Importance values are assigned to elements of the scene.
<item>Two rendering passes are started according to the
assigned importance values. Elements of different importance
values are mutually masked out using <tt>"RiMatte"</tt> statements.
<item>The resulting partial images are composed to a single
resulting image, which is then displayed.
</enum>
The parameterization of the two rendering passes ensures, that
the total rendering time is lower than the rendering time of
a single pass with high quality.
<p>
Many options exist to assign importance and parameterize the
rendering passes:
<p>
Elements of the scenes may be geometric objects, regions in image space,
or regions in object space.
Importance values are currently just binary values.
Assignment may take place manually (using IDR tags) or half-automatic
by derivation of importance from currently selected or changed
objects. To avoid inconsistency in the resulting images, importance
values may be propagated between (geometrically or hierarchically) near
objects, or between objects that are related (e.g. from a material to a
geometric object).
<p>
Parameterization of the two rendering passes currently includes selection of
a different renderer and the possibility to reduce rendering resolution and
shading rate. To further reduce rendering times for Raytracing
renderers, the size of the region to render may be automatically adapted to
the elements of the current importance value (including an optimization
run that balances renderer startup times and times needed to render
regions not originally occupied by two regions to merge).
<p>
Furthermore, caching of partial images is possible. However, the implementation
of this feature is not very sophisticated at the moment, as it
uses the Unix text tool <tt>"diff"</tt> to decide whether two RIB streams are
identical and hence need no re-rendering.

To start using IDR:
<enum>
<item>load a scene (e.g. the cactus example scene),
<item>load the IDR plugin (menu <tt>"File/Load Custom"</tt>),
<item>open the IDR control window using the main menu
<tt>"Custom/Open IDR"</tt>,
<item>set the assign mode to <tt>"Selection"</tt>,
<item>select an object in the scene (e.g. the object named <tt>"Pot"</tt>),
<item>then press the <tt>"Render!"</tt> button.
</enum>
Compare the rendering time with a full render from the view window.

IDR requires that atleast the renderer of the second rendering pass
honours RiMatte! Since rgl does not honour RiMatte, it is sometimes
necessary to simply exclude objects of different importance value.
No wrong images are to be expected from this, as rgl does not calculate
other than local lighting effects.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Importance Driven
Rendering - Using Importance Information in the Rendering Process",
in: Hamza M., Sarfraz M. (ed.): Computer Graphics and Imaging (CGIM 2001)
Conference Proceedings, Honolulu, Hawaii, 13-16 August 2001,
ISBN 0-88986-303-2</it>

<sect1>Increasing drawing speed<label id="incds">
<p>
In case of sluggish response of the user interface of Ayam
(not accounting for long tree update operations) several
things to increase drawing speed can be done:
<itemize>
<item>Hide objects or complete object hierarchies
using <tt/"Hide"/ in the <tt/"Tools"/ menu.
<item>Disable drawing of true NURBS curves/surfaces, if you can. Use the
ControlHull display modes.
<item>If you need to see curves/surfaces, try to increase the
(GLU) sampling tolerance of the objects (use a value of about 60.0).
<item>Switch the primary modeling view to draw just the selected
object(s) or the current level.
<item>Iconify views you do not need, they will not be redrawn then.
<item>Switch off automatic redrawing of slow redrawing (e.g. shaded)
views, and control their redraw by pressing <tt/"Ctrl+d"/ manually.
<item>Do not create unnecessary caps, they are trimmed NURBS patches
that render very slowly.
<item>Disable <tt/"UseMatColor"/.
</itemize>

<sect1>How can you help?
<p>

<enum>
<item>Write/translate tutorials.
<item>Implement custom objects. This will be discussed a bit more later on.
<item>Donate source to improve several critical parts of the modeler,
some ideas are: better (more exact) lighting simulation (is this
possible to do with OpenGL at all?), CSG-preview with OpenGL,
true support for subdivision surfaces. The project page of Ayam
on SourceForge lists some more tasks.
<item>Debug the MF3D code, which is currently not working
well with binary files from different byte-order platforms.
<item>Donate money by registering ShellyLib.
ShellyLibs source will be converted to a first high level custom object
that creates objects of type seashell for Ayam. This object,
however, will be Shareware!
</enum>

You can help by implementing more different high
level objects like Trees, Landscape, Sky, Text, whatever you can think of.
Note, that the license of Ayam does not prevent you from implementing your
object as Shareware or even Commercial software. However, Freeware is
preferred for obvious reasons.

But please do me a favour and do not implement objects like
simple triangles or polygons. This would be something that really is
not intended by me, and it would surely show the limits of the current
design of all code operating on the scene structure.
Ayam objects should be high-level objects!

Reading the last paragraph you might think that I am a bit biased
against polygonal models. I am not. Polygonal models are the only
way to preview complex geometry using hardware accellerated graphics,
for the moment. But even while RenderMan supports rendering of
polygonal models their use as a primitive is not recommended for
good reasons. In other words, use polygonal models in the modeler
as quick representation of your higher level objects, but please,
if you are going to actually render something, do not use that
polygonal representation.
If you want to go a complete polygonal way instead, voila, there
are good modelers out there.

<sect1>References<label id="secref">
<p>
Suggested reading:
<itemize>
<item>Advanced RenderMan: Creating CGI for Motion Pictures by
Tony Apodaca and Larry Gritz (Morgan-Kaufmann, 1999)
<item>The RenderMan Companion: A Programmer's Guide
to Realistic Computer Graphics by Steve Upstill (Addison-Wesley,
1989)
<item>Textures and Modeling: A Procedural Approach by Ebert,
Musgrave, Peachey, Perlin, and Worley (Academic Press, 1994)
</itemize>

WWW resources:
<itemize>
<item>The RenderMan Repository: <tt>http://www.renderman.org/</tt>
</itemize>

<sect1>Acknowledgements
<p>
First of all, I would like to express a big "Thank you!"
to Bernd (Pink) Sieker. He is the first real Mops user
and beta tester, who urged me during the last years
via E-Mail and on IRC to fix this particular bug, add some
essential features, move the lights again etc. pp. in countless
iterations.
Bernd, without your help I surely would not be that far, thanks!

Furthermore, I would like to thank the following people:
<itemize>
<item>Bertrand Coconnier: implementation of object picking
<item>Hermann Birkholz: initial implementation of the tree widget, shadow map
support, AI, and IDR
<item>Frank (Copper) Pagels: MetaBalls custom object, providing a lot of
good music
<item>Stephen Echavia: Icons
<item>Larry Gritz: BMRT
<item>Benjamin Bederson, Brian Paul et. al.: The Togl Widget
<item>Jeffrey Hobbs: tkMegaWidget set
<item>Jan Nijtmans: Tcl/Tk PlusPatches, tcl2c, Wrap
<item>Thomas E. Burge: The Affine Toolkit
<item>Apple, Duet Development Corp.: 3DMF parser
<item>Mark J. Kilgard: GLUT
<item>Les A. Piegl and Wayne Tiller: The NURBS Book
<item>W. T. Hewitt and D. Yip: The NURBS Procedure Library
<item>Philippe Lavoie: The NURBS++ Library
<item>Everyone involved in the development of Tcl/Tk, OpenGL, The RenderMan
Interface
</itemize>

OpenGL (R) is a registered trademark of Silicon Graphics, Inc.

The RenderMan (R) Interface Procedures and Protocol are:
Copyright 1988, 1989, 2000 Pixar
All Rights Reserved

RenderMan (R) is a registered trademark of Pixar

The Affine Libraries and Tools are
Copyright (c) 1995, 1996, 1997, 1998 Thomas E. Burge
All rights reserved.

Affine (R) is a registered trademark of Thomas E. Burge.

TIFF Software is
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.

<sect>Index
<p>
<ref id="indexa" name="A">
<ref id="indexb" name="B">
<ref id="indexc" name="C">
<ref id="indexd" name="D">
<ref id="indexe" name="E">
<ref id="indexf" name="F">
<ref id="indexg" name="G">
<ref id="indexh" name="H">
<ref id="indexi" name="I">
<ref id="indexj" name="J">
<ref id="indexk" name="K">
<ref id="indexl" name="L">
<ref id="indexm" name="M">
<ref id="indexn" name="N">
<ref id="indexo" name="O">
<ref id="indexp" name="P">
<ref id="indexq" name="Q">
<ref id="indexr" name="R">
<ref id="indexs" name="S">
<ref id="indext" name="T">
<ref id="indexu" name="U">
<ref id="indexv" name="V">
<ref id="indexw" name="W">
<ref id="indexx" name="X">
<ref id="indexy" name="Y">
<ref id="indexz" name="Z">
<p>

<label id="indexa">A
<itemize>
<item>About: <ref id="mmhelp" name="main menu entry">
<item>Action: <ref id="iac" name="interactive actions">
<item>Align to Parent: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
<item>Apply: <ref id="propgui" name="apply property GUI">
<item>Area Light: <ref id="alob" name="creation of">
<item>Atmosphere: <ref id="imager" name="property">
<item>Attributes: <ref id="attrs" name="attributes property">,
<ref id="riattrs" name="RenderMan/BMRT attributes property">
<item>AutoFocus: <ref id="prefgui" name="preference setting">
<item>Automatic Instancing: <ref id="mmspecial" name="main menu entry">
<item>Automatic Redraw: <ref id="vmconf" name="view menu entry">
<item>AutoResize: <ref id="prefgui" name="preference setting">
<item>AutoSavePrefs: <ref id="prefgui" name="preference setting">
<item>ayamrc: <ref id="ayamrc" name="Ayamrc File">
<item>ayError: <ref id="sierr" name="scripting interface command">
</itemize>

<label id="indexb">B
<itemize>
<item>Background: <ref id="prefdraw" name="preference setting">
<item>Background Image: <ref id="vat" name="view attribute">
<item>Basis_U, Basis_V: <ref id="pmattr" name="PatchMesh attribute">
<item>BeamDistrib: <ref id="lip" name="light attribute">
<item>Bevel: <ref id="handb" name="using bevels">
<item>BevelRadius, BevelType: <ref id="extrattr" name="extrude attribute">
<item>BGImage: <ref id="vat" name="view attribute">
<item>bicubic/bilinear PatchMesh:
<ref id="patchmeshobj" name="PatchMesh object">
<item>Bound: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>BoundCoord: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Box: <ref id="mmcreate" name="main menu entry">,
<ref id="boxobj" name="object">
<item>BPatch: <ref id="bpatchobj" name="object">
<item>BType_U, BType_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Build: <ref id="bfct" name="build from curves tool">
<item>buildNP: <ref id="gncp" name="scripting interface command">
</itemize>

<label id="indexc">C
<itemize>
<item>Camera: <ref id="cameraobj" name="camera object">,
<ref id="camp" name="view property">
<item>Cap: <ref id="capobj" name="object">,
<item>CastShadows: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>CheckLights: <ref id="prefrib" name="preference setting">
<item>Circle: <ref id="ncirct" name="NURBS circle tool">
<item>clampNC: <ref id="gncp" name="scripting interface command">,
<ref id="clat" name="clamp tool">
<item>Clone:<ref id="cloneobj" name="object">
<item>Closed: <ref id="spattr" name="sphere attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="top" name="torus attribute">,
<ref id="pap" name="paraboloid attribute">,
<ref id="hyp" name="hyperboloid attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="icp" name="ICurve attribute">,
<ref id="concatncp" name="ConcatNC attribute">
<item>Closed BSpline: <ref id="cbspt" name="closed BSpline tool">
<item>Close_U, Close_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Collapse: <ref id="collt" name="Collapse tool">
<item>Color: <ref id="riattrs" name="RenderMan/BMRT attribute">,
<ref id="lip" name="light attribute">
<item>copOb: <ref id="copob" name="scripting interface command">
<item>Copy: <ref id="mmedit" name="main menu entry">
<item>Copy Property: <ref id="mmedit" name="main menu entry">,
<ref id="propgui" name="copying properties">
<item>Concat: <ref id="conct" name="Concat tool">
<item>ConcatNC:<ref id="concatncobj" name="ConcatNC object">
<item>Cone: <ref id="mmcreate" name="main menu entry">,
<ref id="coneobj" name="object">
<item>ConeAngle, ConeDAngle: <ref id="lip" name="light attribute">
<item>Console: <ref id="cons" name="what is">
<item>Convert: <ref id="mmtools" name="main menu entry">
<item>convOb: <ref id="gtype" name="scripting interface command">
<item>CreateMP: <ref id="ncattr" name="NURBCurve attribute">
<item>Create ShadowMaps: <ref id="mmspecial" name="main menu entry">,
<ref id="vmview" name="view menu entry">
<item>crtOb: <ref id="crtob" name="scripting interface command">
<item>Custom: <ref id="cul" name="light type">
<item>Custom Object: <ref id="customobj" name="what is">
<item>Cut: <ref id="mmedit" name="main menu entry">
<item>cutOb: <ref id="copob" name="scripting interface command">
<item>Cylinder: <ref id="mmcreate" name="main menu entry">,
<ref id="cylinderobj" name="object">
</itemize>

<label id="indexd">D
<itemize>
<item>DefaultMat: <ref id="prefrib" name="preference setting">
<item>delegTrafo: <ref id="movob" name="scripting interface command">
<item>Delete: <ref id="mmedit" name="main menu entry">,
<ref id="insdelac" name="delete points">
<item>delOb: <ref id="copob" name="scripting interface command">
<item>Difference: <ref id="mmcreate" name="main menu entry">,
<ref id="levelobj" name="object and properties">
<item>Direct Editing: <ref id="editac" name="edit points">
<item>Disk: <ref id="mmcreate" name="main menu entry">,
<ref id="diskobj" name="object">
<item>Displacement: <ref id="matshader" name="shader">
<item>DisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">
<item>Distant: <ref id="pdsl" name="light type">
<item>Docs: <ref id="prefgui" name="preference setting">
<item>Double Size: <ref id="vmconf" name="view menu entry">
<item>DrawGrid, DrawLevel, DrawSel, DrawBG:
<ref id="vat" name="view attribute">
<item>Draw Selection only: <ref id="vmconf" name="view menu entry">
<item>Draw Level only: <ref id="vmconf" name="view menu entry">
<item>Draw BGImage: <ref id="vmconf" name="view menu entry">
<item>Draw Grid: <ref id="vmconf" name="view menu entry">
</itemize>

<label id="indexe">E
<itemize>
<item>Edit: <ref id="editac" name="edit points">
<item>Edit Local: <ref id="vmconf" name="view menu entry">,
<ref id="editlocal" name ="Editing in Local Space">
<item>EditSnaps: <ref id="prefmodel" name="preference setting">
<item>elevateNC: <ref id="gncp" name="scripting interface command">,
<ref id="elevt" name="elevate tool">
<item>EndCap: <ref id="rep" name="revolve attribute">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">
<item>EnvFile: <ref id="prefgui" name="preference setting">
<item>ErrorLevel: <ref id="rribopt" name="RIB import option">
<item>ExcludeHidden: <ref id="prefrib" name="preference setting">
<item>ExpGain, ExpGamma: <ref id="rio" name="RenderMan interface option">
<item>Explode: <ref id="explt" name="Explode tool">
<item>Export RIB: <ref id="mmfile" name="main menu entry">
<item>Expression: <ref id="mcattr" name="MetaComp attribute">
<item>Exterior: <ref id="matshader" name="shader">
<item>Extrude: <ref id="extrudeobj" name="object">,
<ref id="extt" name="Extrude tool">
</itemize>

<label id="indexf">F
<itemize>
<item>Far: <ref id="camp" name="camera property">
<item>FillGaps: <ref id="concatncp" name="ConcatNC attribute">
<item>FilterFunc: <ref id="rio" name="RenderMan interface option">
<item>FilterWidth: <ref id="rio" name="RenderMan interface option">
<item>FindU: <ref id="miscac" name="modeling action">
<item>forAll, forAllT: <ref id="fall" name="scripting interface command">
<item>forceNot: <ref id="gtype" name="scripting interface command">
<item>Formula: <ref id="mcattr" name="MetaComp attribute">
<item>From: <ref id="camp" name="camera property">,
<ref id="lip" name="light attribute">
<item>From Camera: <ref id="mmspecial" name="main menu entry">,
<ref id="vmconf" name="view menu entry">
<item>Front: <ref id="vmtype" name="view menu entry">
</itemize>

<label id="indexg">G
<itemize>
<item>getPnt: <ref id="scpoints" name="scripting interface command">
<item>getType: <ref id="gtype" name="scripting interface command">
<item>Gimbal Lock: <ref id="gimb" name="avoiding">
<item>goDown: <ref id="gdown" name="scripting interface command">
<item>goTop: <ref id="gdown" name="scripting interface command">
<item>goUp: <ref id="gdown" name="scripting interface command">
<item>Grid: <ref id="vat" name="view attribute">
<ref id="prefdraw" name="drawing preference setting">
</itemize>

<label id="indexh">H
<itemize>
<item>Half Size: <ref id="vmconf" name="view menu entry">
<item>HandleSize: <ref id="prefmodel" name="preference setting">
<item>hasChild: <ref id="gtype" name="scripting interface command">
<item>Height: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="box attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="extrattr" name="extrude attribute">,
<ref id="vat" name="view attribute">
<item>Help: <ref id="mmhelp" name="main menu entry">
<item>Help on object: <ref id="mmhelp" name="main menu entry">
<item>Hidden Preferences: <ref id="hidprefs" name="Hidden Preference Settings">
<item>Hide: <ref id="mmtools" name="main menu entry">
<item>Hide All: <ref id="mmtools" name="main menu entry">
<item>HideTmpTags: <ref id="prefmisc" name="preference setting">
<item>Hole: <ref id="handb" name="using holes">
<item>Hyperboloid: <ref id="mmcreate" name="main menu entry">,
<ref id="hyperboloidobj" name="object">
</itemize>

<label id="indexi">I
<itemize>
<item>ICurve: <ref id="icurveobj" name ="object">
<item>IDR: <ref id="idr" name="IDR plugin">
<item>IgnoreNormals: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>Image: <ref id="prefrib" name="preference setting">
<item>Imager: <ref id="imager" name="property">
<item>import Mops scene: <ref id="impmops" name="Mops Import">
<item>import RIB: <ref id="rrib" name="RIB Import">
<item>Importance Driven Rendering: <ref id="idr" name="IDR plugin">
<item>Insert: <ref id="mmfile" name="main menu entry">,
<ref id="insdelac" name="insert points">
<item>insKn: <ref id="gncp" name="scripting interface command">
<item>Insert Knot: <ref id="insknt" name="insert knot tool">
<item>insertScene: <ref id="scio" name="scripting interface command">
<item>Instance: <ref id="instanceobj" name ="object">
<item>Intensity: <ref id="lip" name="light attribute">
<item>Interior: <ref id="matshader" name="shader">
<item>Interpolation: <ref id="attrs" name="RenderMan/BMRT attribute">,
<ref id="icurveobj" name="interpolating curve">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">
<item>Intersection: <ref id="mmcreate" name="main menu entry">,
<ref id="levelobj" name="object">
<item>Invert Selection: <ref id="mmspecial" name="main menu entry">
<item>IParam: <ref id="icp" name="ICurve attribute">
<item>IsoLevel: <ref id="moattr" name="MetaObj attribute">
<item>IsOn: <ref id="lip" name="light attribute">
</itemize>

<label id="indexj">J
<itemize>
<item>
</itemize>

<label id="indexk">K
<itemize>
<item>Knots: <ref id="ncattr" name="NURBCurve attribute">
<item>Knot-Type: <ref id="ncattr" name="NURBCurve attribute">
<item>Knot-Type_U: <ref id="skp" name="skin attribute">
</itemize>

<label id="indexl">L
<itemize>
<item>LazyNotify: <ref id="prefmodel" name="preference setting">
<item>Length: <ref id="bxp" name="box attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="icp" name="ICurve attribute">
<item>Level: <ref id="mmcreate" name="main menu entry">,
<ref id="levelobj" name="object and properties">
<item>Light: <ref id="mmcreate" name="main menu entry">,
<ref id="lightobj" name="object">
<ref id="prefdraw" name="preference setting">
<item>LightAttr: <ref id="lip" name="property">,
<item>LightShader: <ref id="lightobj" name="light">
<item>ListTypes: <ref id="prefgui" name="preference setting">
<item>Load Custom: <ref id="mmfile" name="main menu entry">
<item>LoadEnv: <ref id="prefgui" name="preference setting">
<item>Local: <ref id="vat" name="view attribute">,
<ref id="editlocal" name ="Editing in Local Space">
<item>Locale: <ref id="prefgui" name="preference setting">
<item>LogFile: <ref id="prefgui" name="preference setting">
<item>Logging: <ref id="prefgui" name="preference setting">
<item>LowerBevel: <ref id="extrattr" name="extrude attribute">
<item>LowerCap: <ref id="rep" name="revolve attribute">,
<ref id="extrattr" name="extrude attribute">
</itemize>

<label id="indexm">M
<itemize>
<item>MajorRad: <ref id="top" name="torus attribute">
<item>Master: <ref id="mmedit" name="edit menu entry">
<item>Material: <ref id="materialobj" name="object">,
<ref id="mmedit" name="edit menu entry">
<item>MaxRayLevel: <ref id="rio" name="RenderMan interface option">
<item>MaxTagLen: <ref id="hidprefs" name="Hidden Preference Settings">
<item>Menu: <ref id="mm" name="main menu">,
<ref id="vm" name="view menu">
<item>MetaObj, MetaComp: <ref id="metaobjobj" name="object and properties">
<item>MFIO Plugin:
<ref id="mfioplugin" name="3DMF import export (MFIO) plugin">
<item>MinorRad: <ref id="top" name="torus attribute">
<item>MinSamples, MaxSamples: <ref id="rio" name="RenderMan interface option">
<item>Mode: <ref id="icp" name="ICurve attribute">
<item>Mops Import: <ref id="impmops" name="Import of Mops Scenes">
<item>Move: <ref id="vwsc" name="view action">,
<ref id="iac" name="move object">
<item>movOb, movSel: <ref id="movob" name="scripting interface command">
<item>Multiple Point: <ref id="ncurvemp" name="Multiple Points">
</itemize>

<label id="indexn">N
<itemize>
<item>Name: <ref id="attrs" name="attribute">
<item>NCDisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="ncattr" name="NURBCurve attribute">
<item>Near: <ref id="camp" name="camera property">
<item>Negative: <ref id="mcattr" name="MetaComp attribute">
<item>New: <ref id="mmfile" name="main menu entry">
<item>NewLoadsEnv: <ref id="prefgui" name="preference setting">
<item>newScene: <ref id="scio" name="scripting interface command">
<item>NoExport: <ref id="noexporttag" name="tag type">
<item>NumClones: <ref id="cloneattr" name="Clone attribute">
<item>NumSamples: <ref id="moattr" name="MetaObj attribute">
<item>NURBCircle: <ref id="ncirct" name="NURBS circle tool">
<item>NURBCurve: <ref id="mmcreate" name="main menu entry">,
<ref id="ncurveobj" name="object">
<item>NURBPatch: <ref id="mmcreate" name="main menu entry">,
<ref id="npatchobj" name="object">
<item>NURBSphere: <ref id="nspt" name="NURBS sphere tool">
</itemize>

<label id="indexo">O
<itemize>
<item>Object: <ref id="prefdraw" name="preference setting">
<item>Objects: <ref id="obj" name="tree/listbox">,
<ref id="objsel" name="selection within a view">
<item>OI: <ref id="oitt" name="tag type">
<item>OptimizeCoords: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeFaces: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeNew: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Order: <ref id="ncattr" name="NURBCurve attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="icp" name="ICurve attribute">
<item>Order_U: <ref id="skp" name="skin attribute">
</itemize>

<label id="indexp">P
<itemize>
<item>P1, P2: <ref id="hyp" name="hyperboloid attribute">
<item>Paraboloid: <ref id="mmcreate" name="main menu entry">,
<ref id="paraboloidobj" name="object">
<item>pasOb: <ref id="copob" name="scripting interface command">
<item>Paste: <ref id="mmedit" name="main menu entry">
<item>Paste Property: <ref id="mmedit" name="main menu entry">
<item>PatchMesh: <ref id="patchmeshobj" name="object">
<item>PatchSamples: <ref id="rio" name="RenderMan interface option">
<item>Perspective: <ref id="vmtype" name="view menu entry">
<item>PhiMin, PhiMax: <ref id="top" name="torus attribute">
<item>Pick:<ref id="objsel" name="pick objects within a view">
<item>PickEpsilon: <ref id="prefmodel" name="preference setting">
<item>Point: <ref id="pdsl" name="light type">
<item>PolyMesh: <ref id="polymeshobj" name="object">
<item>PPRender: <ref id="prefrib" name="preference setting">
<item>Preferences: <ref id="prefs" name="Preferences">,
<ref id="hidprefs" name="Hidden Preference Settings">
<item>Prompt: <ref id="hidprefs" name="hidden preference setting">
<item>Properties: <ref id="propgui" name="property GUI">
<item>Primitive: <ref id="mmcreate" name="main menu entry">,
<ref id="levelobj" name="object and properties">
<item>PRManSpec: <ref id="rio" name="RenderMan interface option">
</itemize>

<label id="indexq">Q
<itemize>
<item>QRender: <ref id="prefrib" name="preference setting">
<item>QRenderPT, QRenderUI: <ref id="prefrib" name="preference setting">
<item>Quat: <ref id="trap" name="transformation property">
<item>Quick Render: <ref id="vm" name="view menu entry">
</itemize>

<label id="indexr">R
<itemize>
<item>Radius: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="mcattr" name="MetaComp attribute">
<item>RadSteps: <ref id="rio" name="RenderMan interface option">
<item>ReadFrame, ReadCamera, ReadOptions, ReadLights, ReadMaterial,
ReadPartial: <ref id="rribopt" name="RIB import option">
<item>RedirectTcl: <ref id="prefmisc" name="preference setting">
<item>Redo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">
<item>Redraw: <ref id="vm" name="view menu entry">,
<ref id="incds" name="speeding up">,
<ref id="vat" name="view attribute">
<item>Reference Counter: <ref id="instanceobj" name="Instance Object">,
<ref id="materialobj" name="Material Object">
<item>References: <ref id="secref" name="references">
<item>refineNC: <ref id="gncp" name="scripting interface command">,
<ref id="refit" name="refine tool">
<item>RemoveMerged: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Render: <ref id="vm" name="view menu entry">,
<ref id="prefrib" name="preference setting">
<item>Renderer: <ref id="mmspecial" name="select a different renderer">
<item>RenderMode: <ref id="prefrib" name="preference setting">
<item>RenderPT, RenderUI: <ref id="prefrib" name="preference setting">
<item>Replace: <ref id="mmfile" name="main menu entry">
<item>replaceScene: <ref id="scio" name="scripting interface command">
<item>Reset: <ref id="propgui" name="reset property GUI">
<item>ResetDM, ResetST: <ref id="impmops" name="Mops import option">
<item>ResInstances: <ref id="prefrib" name="preference setting">
<item>Resolve all Instances: <ref id="mmspecial" name="main menu entry">
<item>Revert: <ref id="revertt" name="Revert tool">,
<ref id="concatncp" name="ConcatNC attribute">
<item>revertNC: <ref id="gncp" name="scripting interface command">
<item>Revolve: <ref id="revolveobj" name="object">,
<ref id="revt" name="Revolve tool">
<item>RGBA_ONE, RGBA_MIN, RGBA_MAX, RGBA_Dither:
<ref id="rio" name="RenderMan interface option">
<item>RGTrans: <ref id="prefmisc" name="preference setting">
<item>RiAttribute: <ref id="riattrs" name="property">,
<ref id="riatag" name="tag type">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIB import: <ref id="rrib" name="RIB Import">
<item>RIBFile: <ref id="prefrib" name="preference setting">
<item>RiDisplay: <ref id="ridtag" name="tag type">
<item>RiHider: <ref id="rihtag" name="tag type">
<item>RiInc: <ref id="riincobj" name="object">
<item>RiOption: <ref id="riotag" name="tag type">
<item>RiOptions: <ref id="rio" name="RenderMan interface options property">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIStandard: <ref id="prefrib" name="preference setting">
<item>RMax: <ref id="pap" name="paraboloid attribute">
<item>Roll: <ref id="camp" name="camera property">
<item>Root: <ref id="rootobj" name="object">
<item>Rotate: <ref id="vwsc" name="view action">,
<ref id="rotac" name="rotate object">,
<ref id="swp" name="sweep attribute">
<item>Rotation: <ref id="trap" name="transformation property">,
<ref id="gimb" name="using the transformations property">
<item>rotOb, rotSel: <ref id="movob" name="scripting interface command">
<item>rV: <ref id="upd" name="scripting interface command">
</itemize>

<label id="indexs">S
<itemize>
<item>Samples: <ref id="lip" name="light attribute">
<item>Samples_X: <ref id="rio" name="RenderMan interface option">
<item>Samples_Y: <ref id="rio" name="RenderMan interface option">
<item>Save: <ref id="mmfile" name="main menu entry">
<item>Save as: <ref id="mmfile" name="main menu entry">
<item>Save Prefs: <ref id="mmfile" name="main menu entry">
<item>SaveAddsMRU: <ref id="prefmisc" name="preference setting">
<item>saveScene: <ref id="scio" name="scripting interface command">
<item>Scale: <ref id="trap" name="transformation property">,
<ref id="scalac" name="scale object">
<item>scalOb, scalSel: <ref id="movob" name="scripting interface command">
<item>Scripts: <ref id="prefgui" name="preference setting">
<item>SDMesh: <ref id="sdmeshobj" name="object">
<item>Sections: <ref id="swp" name="sweep attribute">
<item>Select: <ref id="obj" name="select objects with the tree/listbox">,
<ref id="objsel" name="select objects within a view">,
<ref id="selac" name="select points">
<item>Selected Objects: <ref id="mmspecial" name="main menu entry">
<item>Select Renderer: <ref id="mmspecial" name="main menu entry">
<item>Selection: <ref id="prefdraw" name="preference setting">
<item>Set Gridsize: <ref id="vmconf" name="view menu entry">
<item>Set FOV: <ref id="vmconf" name="view menu entry">
<item>setPnt: <ref id="scpoints" name="scripting interface command">
<item>Shade: <ref id="prefdraw" name="preference setting">,
<ref id="vmconf" name="view menu entry">
<item>Shader: <ref id="shd" name="property">
<item>Shader Parsing: <ref id="spplugins" name="shader parsing plugins">
<item>Shaders: <ref id="prefmain" name="preference setting">
<item>ShadingRate: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>ShadowBias: <ref id="rio" name="RenderMan interface option">
<item>ShadowMaps: <ref id="prefrib" name="preference setting">,
<ref id="shadowmaps" name="using shadowmaps">
<item>Shadows: <ref id="lip" name="light attribute">
<item>Show: <ref id="mmtools" name="main menu entry">
<item>Show All: <ref id="mmtools" name="main menu entry">
<item>Show Shortcuts: <ref id="mmhelp" name="main menu entry">
<item>Show Tooltips: <ref id="mmhelp" name="main menu entry">
<item>Side: <ref id="vmtype" name="view menu entry">
<item>Skin: <ref id="skinobj" name="object">,
<ref id="skit" name="Skin tool">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMRes: <ref id="lip" name="light attribute">
<item>SParam: <ref id="prefmisc" name="preference setting">
<item>Sphere: <ref id="mmcreate" name="main menu entry">,
<ref id="sphereobj" name="object">,
<ref id="nspt" name="NURBS sphere tool">
<item>Split: <ref id="sptct" name="split to curves tool">,
<item>Split Curve: <ref id="miscac" name="modeling action">
<item>splitNPatch: <ref id="gncp" name="scripting interface command">
<item>Spot: <ref id="pdsl" name="light type">
<item>StartCap: <ref id="rep" name="revolve attribute">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">
<item>Step_U, Step_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Stretch: <ref id="scalac" name="stretch object">
<item>Subdivision Mesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Surface: <ref id="matshader" name="shader">
<item>Sweep: <ref id="sweepobj" name="object">,
<ref id="swpt" name="Sweep tool">
</itemize>

<label id="indext">T
<itemize>
<item>Tag: <ref id="prefdraw" name="preference setting">
<item>Tags: <ref id="tags" name="tags property">
<item>TC: <ref id="tctag" name="tag type">
<item>TclPrecision: <ref id="prefmisc" name="preference setting">
<item>TextureCoordinates: <ref id="tctag" name="tag type">,
<ref id="tce" name="texture coordinate editor">
<item>ThetaMax: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="top" name="torus attribute">,
<ref id="pap" name="paraboloid attribute">,
<ref id="hyp" name="hyperboloid attribute">,
<ref id="rep" name="revolve attribute">
<item>Threshold: <ref id="moattr" name="MetaObj attributes">
<item>TmpDir: <ref id="prefgui" name="preference setting">
<item>To: <ref id="camp" name="camera property">,
<ref id="lip" name="light attribute">
<item>To Camera: <ref id="vmconf" name="view menu entry">
<item>Toggle ToolBox: <ref id="mmspecial" name="main menu entry">
<item>Toggle TreeView: <ref id="mmspecial" name="main menu entry">
<item>Tolerance: <ref id="prefdraw" name="preference setting">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="npattr" name="NURBPatch attribute">
<item>Tool: <ref id="toolb" name="tool box window">
<item>ToolBoxTrans: <ref id="prefmisc" name="preference setting">
<item>Top: <ref id="vmtype" name="view menu entry">
<item>Torus: <ref id="mmcreate" name="main menu entry">,
<ref id="torusobj" name="object">
<item>Transformations: <ref id="trap" name="transformations property">
<item>Translation: <ref id="trap" name="transformation property">
<item>Tree View: <ref id="treeview" name="Tree View">
<item>Trim: <ref id="vmtype" name="view menu entry">
<item>Trim Curve: <ref id="trim" name="using trim curves">
<item>TrimRect: <ref id="trrt" name="TrimRect tool">
<item>TrueDisp: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>TwmCompat: <ref id="prefgui" name="preference setting">
<item>Type: <ref id="levelobj" name="level attribute">,
<ref id="lip" name="light attribute">,
<ref id="pmattr" name="patchmesh attribute">,
<ref id="vat" name="view attribute">
</itemize>

<label id="indexu">U
<itemize>
<item>uCL, uCR: <ref id="upd" name="scripting interface command">
<item>Undo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">
<item>UndoLevels: <ref id="prefmodel" name="preference setting">
<item>Union: <ref id="mmcreate" name="main menu entry">,
<ref id="levelobj" name="object and properties">
<item>UpperBevel: <ref id="extrattr" name="extrude attribute">
<item>UpperCap: <ref id="rep" name="revolve attribute">,
<ref id="extrattr" name="extrude attribute">
<item>Up Vector: <ref id="camp" name="camera property">
<item>uS: <ref id="upd" name="scripting interface command">
<item>UseGrid: <ref id="vat" name="view attribute">,
<ref id="vmconf" name="view menu entry">
<item>UseMatColor: <ref id="prefdraw" name="preference setting">
<item>UseSM: <ref id="lip" name="light attribute">
</itemize>

<label id="indexv">V
<itemize>
<item>Variance: <ref id="rio" name="RenderMan interface option">
<item>View: <ref id="mmcreate" name="main menu entry">,
<ref id="viewobj" name="object">,
<ref id="viewwin" name="Anatomy of a View">
<item>ViewAttrib: <ref id="vat" name="property">
</itemize>

<label id="indexw">W
<itemize>
<item>Weight: <ref id="iac" name="single point weight editing">
<item>Width: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="box attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="vat" name="view attribute">
<item>WriteIdent: <ref id="prefrib" name="preference setting">
</itemize>

<label id="indexx">X
<itemize>
<item> 
</itemize>

<label id="indexy">Y
<itemize>
<item> 
</itemize>

<label id="indexz">Z
<itemize>
<item>ZMin, ZMax: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="pap" name="paraboloid attribute">
<item>Zoom: <ref id="camp" name="camera property">,
<ref id="vwsc" name="view action">
<item>Zoom to Object: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
</itemize>


</article>
