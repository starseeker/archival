<!doctype linuxdoc system>

<article>

<title>Ayam

<author>Randolf Schultz <tt>(rschultz@informatik.uni-rostock.de)</tt>

<date>27. Feb 2007

<abstract>
This is the documentation of Ayam 1.13 - a free 3D modelling environment
for the RenderMan interface.

Please note, that this document is intended to be a reference manual,
more detailed explanations of how to actually model with Ayam are
given in the tutorials.

This document has been written using the SGML-Tools formatting
system to generate files in a variety of text formats from one source file.
There are HTML and PDF versions of this document prepared for you.

In addition, you can use the provided SGML-source to generate other formats.
</abstract>

<toc>

<sect>Introduction
<p>
This section contains general information about Ayam and this document.

<sect1>About Ayam
<p>
Ayam is a free 3D modelling environment for the RenderMan Interface,
distributed under the BSD licence.
<p>
Ayam was formerly known as <tt>"The Mops"</tt>.
<p>
Here is a short summary of the Ayam feature set:
<itemize>
<item>RIB (RenderMan Interface Bytestream) export and import.
<item>Support for NURBS curves, interpolating curves, (trimmed)
NURBS surfaces, bilinear and bicubic patches and patch meshes,
Boxes, Quadrics (Sphere, Disk, Cylinder, Cone, Hyperboloid, Paraboloid
and Torus), MetaBalls, polygonal meshes, subdivision meshes and more.
<item>All primitives may be combined with the common
CSG-operations: Intersection, Difference, and Union.
<item>NURBS modelling includes extrude, revolve, sweep, birail, skin,
and gordon operations (with caps, holes, and bevels) realized as
Tool-Objects.
<item>Wavefront OBJ export and import, Rhino 3DM export and import.
<item>Custom objects that may freely implement their representations
(using OpenGL and RIB) and even small GUIs to edit their type specific
parameters may be written by the user and dynamically loaded at runtime.
<item>Scripting interface: Tcl.
<item>Script objects.
<item>Miscellaneous: (automatic) instancing, arbitrary number of modelling
views, object clipboard, independent property clipboard, console,
n-level undo.
</itemize>
<p>
Since Ayam 1.12, dynamic loading of custom objects and certain plugins
are also available on the Win32 platform (they were not available
before)!
<p>
Ayam is primarily aimed at the Linux, IRIX, and Win32 platforms.
On those platforms BMRT (Blue Moon Rendering Tools, a RenderMan
compliant renderer by Larry Gritz) is available.
Even though the distribution of BMRT is stopped it is still
the recommended renderer for Ayam.
Despite of this, Ayam may be used on many more platforms with any
RenderMan compliant renderer.
<p>
For platforms where BMRT is not available (e.g. FreeBSD or NetBSD), Ayam
may be compiled with code from the Affine Toolkit with limited
functionality (see also the file INSTALL).
In this case, no parsing of slc compiled shaders will be possible.
Since Ayam 1.6 it is also possible to completely replace BMRT shader parsing
and RIB writing by code from the Aqsis project, thus completely
eliminating the need for BMRT. Furthermore, shader parsing plugins are
available for all major RenderMan compliant renderers allowing
a tight integration of Ayam with those renderers.

<sect1>About this manual
<p>
How should one read this manual?
<p>
Since this manual is intended to be a reference manual, it is
probably pointless to read it from the beginning to the end
(except maybe for the next section, explaining the basics).
Instead, just look up the documentation of the things you are interested
in via the table of contents or the index. Cross references will then
guide you to other important parts of the documentation.
Again: this manual has a rather large index, please use it
(see section <ref id="index" name="Index">)! 
<p>
This manual is organized in the following way:
<p>
After this first section, the user interface of Ayam is introduced and
basic handling instructions for the application are given in the second
section.
In the third section all interactive modelling actions are documented.
The fourth section details all object types and object properties,
followed by documentation on all NURBS modelling tools in the fifth
section.
In the sixth section the Tcl scripting interface is explained and the
following seventh section has all information about the import and export
plugins. The eighth section is the dreaded miscellaneous section that
contains documentation not fitting elsewhere.
<p>
In this manual, the following typographic conventions are used:
<itemize>
<item>keyboard shortcuts: <tt/&lt;Ctrl+c&gt;/, for shortcuts like
<tt/&lt;Ctrl+Shift+t&gt;/ an abbreviated version: <tt/&lt;Ctrl+T&gt;/
will be used
<item>names (of object types, menu entries, properties, or property elements):
<tt/"A Name"/
<item>Tcl code examples:
<code>
set riopt(runtime) { a b }
</code>
<item>Object hierarchies:
<code>
+-Parent_Object(Type)
 | First_Child_Object(Type)
 | Second_Child_Object(Type)
 | [Third_Child_Object_may_be_present_or_not(Type)]
 | Empty_Level(Level)
 +-Sub_Level(Level)
 | | First_Child_Object_of_Sub_Level(Type)
 | \ Last_Child_Object_of_Sub_Level(Type)
 \ Last_Child_Object(Type)
</code>
</itemize>

<sect>The Ayam GUI
<p>
This section describes the user interface of Ayam.
<p>
The user interface of Ayam is split into three types of toplevel windows:
a main window, a toolbox and an arbitrary number of view windows.
The main window displays the object hierarchy and allows to edit
object properties. The toolbox window is for easy creation of
objects and starting of modelling actions and tools. The modelling actions
are then carried out in view windows, where also the scene is displayed.
<p>
The whole application with all windows may be iconified (zapped) using
the shortcut <tt/&lt;Ctrl+Z&gt;/. If any of the windows
iconified by zap is de-iconified, all other windows
iconified by zap will be de-iconified as well.

<sect1>Anatomy of the Main Window
<p>
The main window is split into three large areas:
<enum>
<item>an area named <tt/"Objects:"/
<item>an area labeled <tt/"Properties:"/
<item>and a text widget (the so called "Console")
</enum>
<figure loc="ht">
<eps file="pics/main.ps" height="8cm">
<img src="pics/main.gif">
<caption>The Main Window</caption>
</figure>
<p>
The relative sizes of the three areas are managed by a so called paned
geometry management. To change the relative size of the console,
you may move your mouse pointer to the upper border of the console until
the pointer changes and then drag the border.
The same goes for the right border of the objects section.

<sect2>Objects<label id="obj">
<p>
The default representation of the object hierarchy is a tree view.
The second available representation is a simple listbox (as known from
<tt/"The Mops"/).
The label <tt/"Objects"/ may be used to switch between the two
representations of the object hierarchy quickly (using a double click).
It is also possible to switch between both representations
using the context menu.
<p>
The two representations have very different properties regarding
speed, use of resources, and versatility. The tree is, due to the
Drag-and-Drop operations, much more versatile but also slower.
<p>
Both representations manage a so called <tt/"current level"/.
This level is the level that is displayed in the object listbox.
In the tree view the current level is drawn in black while all
other levels are grayed out. Selection of objects
may only take place in the current level!
<p>
After the start-up of Ayam you will notice, that there is a first
object called <tt/"Root"/ in the top level of the scene, even though the
scene seems to be empty.
See section <ref id="rootobj" name="Root Object"> for more
information regarding this special object, and what it is good for.
Note that you cannot delete or copy this object.

<bf/Object Tree View:/<label id="treeview">
<p>
<figure loc="ht">
<eps file="pics/treeview.ps" height="6cm">
<img src="pics/treeview.gif">
<caption>Object Tree View</caption>
</figure>
<p>

The object tree view is quite complex and may be slow on slow machines
(of the Pentium 90 class), especially when dealing with scenes
that contain many objects. This should not be a problem nowadays.
Nevertheless, Ayam tries to keep tree update delays as low as possible,
but this only works if the scene uses the hierarchy and changes
happen in sub levels (not the root level).
<p>
In the tree view, objects may be selected using the left mouse button.
Multiple selection of objects is possible by holding down the
<tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/ key while clicking on objects.
<p>
Double clicking on objects with child objects toggles display of the
child level.
The same may be accomplished using single clicks on the well known
plus/minus symbols in front of the name of those objects.
<p>
Drag-and-Drop operation is also possible to move objects in the
hierarchy and to initiate special actions like connecting materials
to objects. However, this last feature is documented in section
<ref id="obandprp" name="Ayam Objects and Properties">
as it is object type specific.
<p>
<label id="treecontm">
The rightmost mouse button opens a context menu with
basic tree and clipboard operations:
<itemize>
<item><tt>"Tree/Rebuild"</tt> completely removes the tree nodes, rebuilds the
hierarchy, and selects the root object

<item><tt>"Tree/Expand"</tt> opens all nodes with child nodes

<item><tt>"Tree/Collapse"</tt> closes all nodes with child nodes

<item><tt>"Switch to Listbox"</tt> removes the tree and replaces it
with the object listbox (see below).

<item><tt>"Deselect Object"</tt> deselects the currently selected
object(s).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="main menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>
<p>
Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object, since Ayam 1.7 holding down the <tt/&lt;Shift&gt;/ key
while pressing <tt/&lt;Up&gt;/ or <tt/&lt;Down&gt;/ will not move the
selection, but rather extend it in the respective direction,

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all objects in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

<item><tt/&lt;Space&gt;/ toggles display of the child objects of the
selected object(s).

<item><tt/&lt;Shift-Home&gt;/ and <tt/&lt;Shift-End&gt;/ are available
since Ayam 1.11 and extend the selection up to the first
or last object in the current level respectively.

</itemize>

If those shortcuts do not work you may need to press <tt/&lt;Esc&gt;/
first (when a property GUI has the input focus) or <tt/&lt;Shift-Tab&gt;/
(when the console has the input focus).

<bf/Object Listbox:/<label id="listbox">
<p>
<figure loc="ht">
<eps file="pics/listbox.ps" height="6cm">
<img src="pics/listbox.gif">
<caption>Object Listbox</caption>
</figure>
<p>

The object listbox displays the object hierarchy of the current scene.
Using this listbox you may browse through the hierarchy of the scene
with your mouse and you may select one or more objects.
<p>
Browsing and selecting should be very intuitively:
Use a double click to enter a level (or an object with child objects),
and a single click to select objects, multiple objects may be selected using
click and drag, or holding down the <tt/&lt;Shift&gt;/ or <tt/&lt;Ctrl&gt;/
key while clicking.
Keyboard operation is also possible if the listbox has the
input focus.
<p>
A <tt/".."/ is displayed as the first element of the current level
if you are "inside" a level or another object.
A double click on the <tt/".."/ takes you to the parent level.
The buttons below the listbox may be used to change the selection or
to quickly jump through the hierarchy. They should be self explanatory.
<p>
<label id="lbcontm">
The rightmost mouse button opens a small context menu:
<itemize>
<item><tt>"Switch to Tree"</tt> removes the listbox and replaces it
with the tree view (see above).

<item><tt>"Copy Object", "Cut Object", "Paste Object", "Delete Object"</tt>
are standard clipboard operations as documented in
section <ref id="mmedit" name="main menu">.

<item><tt>"Help on Object"</tt> displays the help of the selected
object.
</itemize>

Since Ayam 1.6 the scene may be navigated and objects may be selected
using the keyboard alone:
<itemize>
<item><tt/&lt;Up&gt;/ and <tt/&lt;Down&gt;/ move the selection to the previous
or next object, since Ayam 1.7 holding down the <tt/&lt;Shift&gt;/ key
while pressing <tt/&lt;Up&gt;/ or <tt/&lt;Down&gt;/ will not move the
selection, but rather extend it in the respective direction,

<item><tt/&lt;Home&gt;/ and <tt/&lt;End&gt;/ select the first
or last object in the current level,

<item><tt/&lt;Right&gt;/ enters the (first) selected object,

<item><tt/&lt;Left&gt;/ enters the parent level,

<item><tt/&lt;Ctrl+a&gt;/ and <tt/&lt;Ctrl+n&gt;/ select or de-select
all object in the current level. If the current level is the root level,
the Root object will not be selected by <tt/&lt;Ctrl+a&gt;/.

<item><tt/&lt;Shift-Home&gt;/ and <tt/&lt;Shift-End&gt;/ are available
since Ayam 1.11 and extend the selection up to the first
or last object in the current level respectively.

</itemize>
<p>
If those shortcuts do not work you may need to press <tt/&lt;Esc&gt;/
first (when a property GUI has the input focus) or <tt/&lt;Shift-Tab&gt;/
(when the console has the input focus).

<sect2>Properties<label id="propgui">
<p>
<figure loc="ht">
<eps file="pics/propgui.ps" height="6cm">
<img src="pics/propgui.gif">
<caption>Properties</caption>
</figure>
<p>
The listbox right next to the object hierarchy displays the properties
of the currently selected object.
<p>
If there are multiple selected objects, the properties listbox will
display no properties at all.
<p>
Unlike the object tree/listbox, where you can select multiple entries,
only one property may be selected.
If a property is selected, the associated GUI will be shown in the
appropriate area (on the right hand side).
<p>
Since Ayam 1.8 the keyboard may be used to select properties,
just press one of the <tt/&lt;0&gt;/-<tt/&lt;9&gt;/ keys (most comfortably
using the numeric keypad). <tt/&lt;0&gt;/ always selects the last and
often the only object type specific property, whereas <tt/&lt;1&gt;/
selects the first property, which often contains the standard
transformations.
<p>
All property GUIs use more or less standardized GUI elements that are
organized in list form. The lists may be scrolled if they get too long
to fit into the window.
<p>
If the elements of the property GUI do not fit into the screen space
that is defined by the current window size, Ayam will automatically
resize the main window when you select a property. You can control
this behaviour using the preference setting
<tt/"AutoResize"/ (see section <ref id="prefs" name="Preferences">).
<p>
If an object and a property are selected and a different object is selected,
the property GUI that has the same index as the previously selected
property in the properties listbox will be selected and shown. This is
not necessarily a property of the same type!
To avoid that or to clear the property GUI for fast browsing through the
scene you may either double click on the "Properties" label or use the
context menu of the properties listbox to de-select the current property.
<p>
What properties exactly will be shown, and how the GUIs look alike
depends on the selected object and the selected property.
This is documented comprehensively in section
<ref id="obandprp" name="Ayam Objects and Properties">.
<p>
Here are some general remarks about object properties:
<p>
The various things that may be changed using a property GUI
will normally not be applied to the selected object until the
<tt/"Apply"/-button is pressed!
<p>
Since Ayam 1.8.3 holding down the <tt/"Shift"/ button while
interacting with the property GUI or pressing <tt/"Return"/
when entry widgets have the keyboard input focus will lead
to an instant apply.
<p>
You can undo all changes to the arguments of a property that have been
made after the last <tt/"Apply"/ operation with the <tt/"Reset"/-button.
This does, however, not use the undo mechanism of Ayam!
<p>
Note also that property GUIs of custom objects may offer interactive
elements that do an instant "Apply" operation. Most GUIs of the core
objects of Ayam do not change anything until the <tt/"Apply"/-button
is used, however.
<p>
If a property GUI element has the keyboard input focus (it is then usually
displayed with a black rim around it), all the keyboard shortcuts for
the main menu and scene navigation will have no effect until the
keyboard input focus is moved away from the property GUI. You may
accomplish this easily using the <tt/&lt;Esc&gt;/ key.
<p>
A property may be copied and pasted to another object, see the
<tt/"Edit"/ menu. You can also paste property values to different types
of properties (e.g. pasting parameters from a surface shader to the
displacement shader) using <tt/"Paste to selected"/ in the
<tt>"Special/Clipboard"</tt> sub-menu.
<p>
Pasting a property to multiple selected objects does work too.
This is a great way to apply e.g. a surface shader to a big number
of material objects, without going the long way of setting a new
shader and entering parameters for it for every object.
<p>
Since you may not want to copy and paste whole properties all the time,
you may mark single parameters with a double click on the
labels of the parameters. The marked parameters will then be preceded
by an exclamation mark (!) in the property GUI.
<p>
If you now copy this property, all marked parameters will be omitted.
<p>
It is also possible to copy just the parameters you marked using
<tt/"Copy Marked Prop"/.
<p>
A simple example for the property clipboard:
<p>
Our task is to give a big number of material objects the same color,
but they already have different opacity settings. Copying the complete
attribute property would destroy the opacity values. We can solve
this by copying just the color attribute, but leave all other
attributes as they are:
<enum>
<item>Change the color of a first material object using the
<tt/"Attributes"/ property GUI. (Do not forget the <tt/"Apply"/ button!)

<item>Mark the color parameter as to be copied using a double click
on the text <tt/"Color"/; it should read <tt/"!Color"/ now.

<item>Copy just the color parameter to the property clipboard,
using <tt/"Copy Marked Prop"/ in the <tt/"Edit"/ menu or the
hot key <tt/&lt;Ctrl+I&gt;/.

<item>Select all other material objects.

<item>Paste the property using <tt/"Paste Property"/ or <tt/&lt;Ctrl+V&gt;/.

<item>All done!
</enum>
<p>
Special care must be taken when pasting incomplete properties to objects
which do not have complete properties already. Do not paste an incomplete
shader property to an object which does not already have the same shader!

<sect2>The Console<label id="cons">
<p>
The third part of the main window is the console. The console is mainly
for text output (informative, warning, and error messages). For this,
the console captures the stderr and stdout channels of the Tcl-interpreter
Ayam is running in. You can also redirect all Tcl error messages, that would
normally cause a Tcl error dialog window to appear, to the console using the
preference setting <tt>"Misc/RedirectTcl"</tt>
(see section <ref id="prefmisc" name="Miscellaneous Preferences">).
<p>
You can also enter commands, even new Tcl procedures and so on in the
console. However, this is a feature for the advanced user that
studied section <ref id="script" name="The Tcl Scripting Interface">.
You need to explicitly click into the console to give it the input
focus and thus enable input.
<p>
An important thing to know is that the keyboard shortcuts for the
various main menu entries do not work if the console has the input
focus! Instead, other keyboard shortcuts (related to the console)
are in effect!
How do you get out of this? Simply press <tt/&lt;Shift+Tab&gt;/ to move
the focus away from the console and enable the main menu shortcuts again.
<p>
Note that the <tt/&lt;Tab&gt;/ key alone does not move the focus away
from the console.
<tt/&lt;Tab&gt;/ instead completes names of files, commands (procedures),
variables, and widgets.
You may try this out by typing <tt/tip/ in the console,
then press <tt/&lt;Tab&gt;/.
The console automagically completes <tt/tip/ to <tt/tipoftheDay/
(the procedure that prints out the tip of the day, just try it).
<p>
Another simple demonstration of the consoles capabilities:
<itemize>
<item>Create ten boxes by clicking on the box icon ten times.
<item>Select all ten boxes.
<item>Go to the console by clicking into it.
<item>Enter the following:
<tt>forAll 0 &lcub;movOb &dollar;i 0 0; rotOb &lsqb;expr &dollar;i*10&rsqb; 0 0&rcub;</tt>
</itemize>
<p>
This example uses three procedures:
<itemize>
<item><tt/forAll/: allows to execute
a command for each of the selected objects, or for each object in the
current level if no objects are selected.
<item><tt/movOb/: moves the selected object(s).
<item><tt/rotOb/: rotates the selected object(s).
</itemize>
<p>
See section <ref id="script" name="The Tcl Scripting Interface"> for a
listing of all the available commands.
<p>
Note that the example uses a side effect (the variable <tt/"i"/ that
holds the index of the currently processed object) to calculate
the amount of the movement and rotation.
<p>
For more information regarding the console, please refer to the
appropriate documentation by the original author Jeffrey Hobbs
(see the console context menu, that you may open with your right
mouse button).

<sect1>The Main Menu<label id="mm">
<p>
Another important part of the main window has not been discussed so
far. This is the main menu bar. Note that many menu entries have keyboard
shortcuts that are displayed in each entry. You can adapt the shortcuts
using the file <tt>"ayamrc"</tt>
(See section <ref id="ayamrc" name="Ayamrc File">).
<p>
<label id="mmfile">
The <tt/"File"/ menu deals with standard file operations:<label id="filem">
<itemize>
<item><tt/"New"/, clears the current scene (deletes all objects) and reloads
the working environment (if the preference setting
<tt>"Main/NewLoadsEnv"</tt> is enabled).
This operation is not undoable!

<item><tt/"Open"/, clears the current scene and closes all views,
then loads a new scene from disk. All objects from the file
will be read. Depending on the setting of
<tt>"Preferences/Main/BakOnReplace"</tt>
a backup copy of the file that is read will be made before loading.
This operation is not undoable!
<p>
Since Ayam 1.13 also files supported by any of the import plugins
may be imported using this route. Note that this only works if the
selected file has a file name extension. The appropriate plugin will
be loaded automatically (from the list of plugin directories in the
preferences) if needed and the import options dialog of the plugin
will be opened, with the <tt/"FileName"/ option already set.
Mind that in this case, no backup copy of the file will be made.
See also section <ref id="impex" name="Import and Export">.

<item><tt/"Insert"/, inserts the objects and views of an Ayam scene file
into the current scene. All objects from the file will be read. The new
objects will be created in the top level of the scene.
This operation is not undoable!
<p>
Since Ayam 1.13 also files supported by any of the import plugins
may be imported using this route. See above (<tt/"Open"/).

<item><tt/"Save as"/, saves the current scene asking for a new file name.
<p>
Since Ayam 1.13 also files supported by any of the export plugins
may be exported using this route. See above (<tt/"Open"/).

<item><tt/"Save"/, saves the scene. If the scene has not been saved before
(read, you have not given it a file name) you will be asked for a file
name first.

<item><tt>"Import/"</tt>, since Ayam 1.13 this sub menu is initially
empty. You need to load a plugin manually, on application startup
via a script or automatically via <tt>"File/Open"</tt> to gain access
to the menu entries described here.

<item><tt>"Import/Apple 3DMF"</tt>, import a scene from the Apple
3DMF format, see section <ref id="imp3dmf" name="3DMF (Apple) Import">
for more information.

<item><tt>"Import/AutoCAD DXF"</tt>, import a scene from the AutoCAD
DXF format, see section <ref id="impdxf" name="AutoCAD DXF import">
for more information.

<item><tt>"Import/Mops"</tt>, import a scene from The Mops,
see section <ref id="impmops" name="Import of Mops Scenes">
for more information.

<item><tt>"Import/Rhino 3DM"</tt>, import a scene from the Rhino
3DM format, see section <ref id="imprhino" name="3DM (Rhino) Import">
for more information.

<item><tt>"Import/Wavefront OBJ"</tt>, import a scene from the Wavefront
OBJ format, see section <ref id="impwav" name="Wavefront OBJ import">
for more information.

<item><tt>"Export/"</tt>, since Ayam 1.13 this sub menu initially
only contains the <tt>"RenderMan RIB"</tt> entry. You need to load a
plugin manually, on application startup via a script, or automatically
via <tt>"File/Save as"</tt> to gain access to the other menu entries
described here.

<item><tt>"Export/RenderMan RIB"</tt>, exports the current scene to a RIB,
asking which camera (which view) to use.

<item><tt>"Export/Apple 3DMF"</tt>, export a scene to the Apple
3DMF format, see section <ref id="exp3dmf" name="3DMF (Apple) Export">
for more information.

<item><tt>"Export/Rhino 3DM"</tt>, export a scene to the Rhino
3DM format, see section <ref id="exprhino" name="3DM (Rhino) Export">
for more information.

<item><tt>"Export/Wavefront OBJ"</tt>, exports the current scene to a
Wavefront OBJ file, see also section
<ref id="expwav" name="Wavefront OBJ export">.

<item><tt/"Load Plugin"/, loads a file containing a custom object or a plugin.
Depending on the platform Ayam is running on, these are files with the
file name extension <tt/".so"/ or <tt/".dll"/.
See section <ref id="customobj" name="Custom Objects">
for more information about custom objects.

<item><tt/"Save Prefs"/, save the current preference settings
to the ayamrc file after making a backup copy of this file (see section
<ref id="ayamrc" name="Ayamrc File"> for more information about this file).

<item><tt/"1."/, <tt/"2."/, <tt/"3."/, <tt/"4."/, immediately replace the
current scene with the one in the menu entry. The menu entries
are updated and rotated upon successful loading and saving of a scene
so that the first entry always contains the scene that was loaded
(or saved) last.

<item><tt/"Exit!"/, remove all temporary files, save preferences (if
the preference setting <tt>"Main/AutoSavePrefs"</tt> is turned on)
and quit the application.
</itemize>

<label id="mmedit">
The <tt/"Edit"/ menu contains object and property clipboard
operations, undo actions, and lets you open the preferences editor:
<itemize>
<item><tt/"Copy"/, copies the currently selected object(s) into the clipboard.
This operation is not undoable!

<item><tt/"Cut"/, moves the currently selected object(s) into the clipboard.
This operation is not undoable!

<item><tt/"Paste"/, copies the object(s) from the clipboard to the current
level of the scene. Note that the content of the clipboard remains intact
after this operation, this means that you can paste multiple times!
You can move objects out of the clipboard (clearing it) using the menu entry
<tt>"Special/Clipboard/Paste (Move)"</tt>.
Also note that referenced objects, when moved into the clipboard with
<tt/"Cut"/, can not be moved out of it using a simple <tt/"Paste"/, use
<tt>"Special/Clipboard/Paste (Move)"</tt> instead!
This operation is not undoable!

<item><tt/"Delete"/, removes the selected object(s) from the scene.
This operation is not undoable!

<item><tt/"Copy Property"/, copies the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).
Marked parameters will be omitted!

<item><tt/"Copy Marked Prop"/, copies the currently marked parameters
of the currently selected property of the
currently selected object to the property clipboard (the property
clipboard is completely independent from the normal object clipboard!).

<item><tt/"Paste Property"/, copies a property from the property clipboard
to the currently selected object(s).

<item><tt/"Undo"/, perform undo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Redo"/, perform redo operation (see section
<ref id="undos" name="The Undo System"> for more information).

<item><tt/"Material"/, searches for the material object currently
associated with the selected object and selects it for editing.
If the selected object has no material yet, a new material
will be created first.

<item><tt/"Master"/, searches for the master object of the
currently selected instance object and selects it for editing,
see also section <ref id="instanceobj" name="Instance Object">.

<item><tt/"Preferences"/, opens the preferences dialog (see section
<ref id="prefs" name="Preferences"> for more information).
</itemize>

<label id="mmcreate">
The <tt/"Create"/ menu entries let you create objects. In contrast
to the object creation via the toolbox some menu entries present you
with small requesters, where you may adjust parameters for the object
to be created. Here are the entries of the <tt/Create/ menu:
<itemize>
<item><tt/"NURBCurve"/, create a new NURBS curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="ncurveobj" name="NCurve Object">.

<item><tt/"ICurve"/, create a new interpolating curve. A small dialog box will
pop up, where you may specify the length of the new curve. See
also section <ref id="icurveobj" name="ICurve Object">.

<item><tt/"NCircle"/, create a new NURBS circle. See
also section <ref id="ncircleobj" name="NCircle Object">.

<item><tt/"NURBPatch"/, create a new NURBS patch. A small dialog box will
pop up, where you may specify the width and height of the new patch. See
also section <ref id="npatchobj" name="NPatch Object">.

<item><tt/"BPatch"/, create a new bilinear patch. See
also section <ref id="bpatchobj" name="BPatch Object">.

<item><tt/"PatchMesh"/, create a new patch mesh. See
also section <ref id="patchmeshobj" name="PatchMesh Object">.

<item><tt/"Solid"/, create a new solid primitive object, for use in CSG.
<tt/"Box"/, <tt/"Sphere"/, <tt/"Disk"/, <tt/"Cone"/, <tt/"Cylinder"/,
<tt/"Torus"/, <tt/"Hyperboloid"/ or <tt/"Paraboloid"/ may be selected.
See also section <ref id="qprim" name="Quadric Primitives">.

<item><tt/"Level"/, creates a new hierarchy object. <tt/"Level"/
just groups objects, <tt/"Union"/, <tt/"Intersection"/,
<tt/"Difference"/, and <tt/"Primitive"/ are CSG operations. See
also section <ref id="levelobj" name="Level Object">.

<item><tt/"Light"/, create a new light source. See
also section <ref id="lightobj" name="Light Object">.

<item><tt/"Custom Object"/, create a new custom object. If this sub-menu
is empty no custom object has been loaded yet. See
also section <ref id="customobj" name="Custom Object">.

<item><tt/"View"/, a new View window will be opened. See
also section <ref id="viewobj" name="View Object">.

<item><tt/"Instance"/, create an instance of the currently selected
object, see section <ref id="instanceobj" name="Instance Object">
for more information regarding instances.

<item><tt/"Clone"/, create a clone object, see
section <ref id="cloneobj" name="Clone Object">

<item><tt/"Mirror"/, create a clone object, that is immediately
configured as a mirror, see also
section <ref id="cloneobj" name="Clone Object">

<item><tt/"Material"/, create a new material. A small dialog box will
pop up, where you have to specify the name of the new material. See
also section <ref id="materialobj" name="Material Object">.

<item><tt/"Camera"/, create a new camera. Camera objects may be used
to temporarily save view camera settings, see
section <ref id="cameraobj" name="Camera Object">.

<item><tt/"RiInc"/, create a new RIB-include object. Those objects
may be used to include objects into your scenes
that just exist as a piece of RIB, see
also section <ref id="riincobj" name="RiInc Object">.

<item><tt/"RiProc"/, create a new procedural object, see
also section <ref id="riprocobj" name="RiProc Object">.

<item><tt/"Script"/, create a new script object, see
also section <ref id="scriptobj" name="Script Object">.

<item><tt/"Text"/, create a new text object, see
also section <ref id="textobj" name="Text Object">.
</itemize>

<label id="mmtools">
The <tt/"Tools"/ menu:
<itemize>
<item><tt/"Last (None)"/, this menu entry is available since Ayam 1.13.
It allows quick access to the last used entry/tool in the <tt/"Tools"/
menu hierarchy. The label of the entry will be changed appropriately,
e.g. to <tt/"Last (Revert U)"/, when a tool was started.

<item><tt/"Create"/, <tt/"NURBCurve"/, and
<tt/"NURBPatch"/, are sub-menus with various NURBS based modelling
tools, that are explained in depth in section
<ref id="nmtool" name="NURBS Modelling Tools">.

<item><tt/"PolyMesh"/: sub-menu for polygonal mesh related tools:
<itemize>
<item><tt/"Merge"/: merges all currently selected PolyMesh objects into
a single PolyMesh object, without checking for doubly used points,
loops, or faces. Normally, the currently selected PolyMesh objects will not
be changed by this tool. But you may let the merge-tool delete them
immediately after the merging operation, by enabling the
<tt/"RemoveMerged"/-option.
If the <tt/"OptimizeNew"/-option is enabled, the <tt/"Optimize"/-tool
(see below) will be started after the merge operation with the
newly created merged object as argument.

<item><tt/"Split"/: splits the faces from the selected PolyMesh objects
into a second PolyMesh object. The faces to be split off are selected
by selecting all their control points with the select points modelling
action (see also section <ref id="selac" name="Selecting Points">).
The original selected PolyMesh objects will be changed. The changes to
the original objects are undoable. Since the split operation does not
create optimized new objects, the <tt/"Optimize"/-tool (see below) may
be started immediately after splitting using the <tt/"OptimizeNew"/-option.

<item><tt/"Optimize"/: optimizes the selected PolyMesh object(s)
by removing all multiply used control points (if the option
<tt/"OptimizeCoords"/ is enabled) or multiply used faces (not implemented
yet). If the option <tt/"IgnoreNormals"/ is enabled, the optimize-tool will
consider points with equal coordinates but differing normals
to be equal (and optimize them).
Removing multiply used control points using the <tt/"Optimize"/-tool
may decrease the memory consumption of the control points
by a factor of about six, depending on the connectivity of the original
mesh.
</itemize>

<item><tt/"Points"/: sub-menu for tools that work on points:
<itemize>
<item><tt>"Select All Points"</tt>, selects all points of the currently
selected object(s).

<item><tt>"Invert Selection"</tt>, selects all points of the currently
selected object(s) that are not selected, and de-select all points that
are currently selected.

<item><tt>"Apply To All"</tt>, applies the transformations encoded in
the transformations property of the selected objects to all points of those
objects.
This will have the effect of resetting the transformations property
to the default values without (visibly) changing the points of the
selected objects.

<item><tt>"Apply To Selected"</tt>, applies the transformations
encoded in the transformations property of the selected objects to the
selected points.
This will reset the transformations property without (visibly)
changing the selected points. The points currently not selected
will be transformed, however!

<item><tt>"Center All Points (3D)"</tt>, moves all points of the
selected objects so that their common center (the center of gravity)
is the center of the respective objects coordinate system.
Note that, currently, this works on each of the selected objects
separately!
<item><tt>"Center All Points (2D-XY)"</tt>,
<tt>"Points/Center All Points (2D-YZ)"</tt>,
<tt>"Points/Center All Points (2D-XZ)"</tt>: work like the center
3D tool but just center in the designated plane.
</itemize>

<item><tt/"Show"/, <tt/"Hide"/ set and unset the <tt/"Hide"/
attribute of the selected object(s) thus making them invisible.
Note that hidden objects may be excluded from RIB-Export, when
the preference setting <tt>"RIB-Export/ExcludeHidden"</tt> is
activated.

<item><tt/"Show All"/ and <tt/"Hide All"/ set and unset the <tt/"Hide"/
attribute of all objects in the scene (including the root object
and all views!) regardles of the currently selected objects (and
without changing the current selection). These operations are
not undoable.

<item><tt/"Convert"/, starts the convert action that has been
registered for the type of the selected object(s). The exact
behaviour depends on the type of the selected object(s):
a Revolve object will e.g. be converted to a level containing NURBS
patches that make up the surface of revolution and the caps.
This operation is not undoable, i.e. the newly created objects
will not be removed by using the undo system.

<item><tt/"Convert (In Place)"/, starts the convert action as
outlined above, but replaces the original objects with the
new converted ones. This operation, in contrast to the simple
conversion, is undoable.

<item><tt/"Force Notification"/, force the notification callbacks of
all selected objects (or all objects in the scene if no objects are selected)
to be called. The notification callbacks are used by objects
like e.g. Revolve to be informed about changes of their child
objects to properly adapt to those changes.

<item><tt/"Highlight Material"/, colours all objects of the same
material in red color in the tree view. This tool expects a selected
material object or a normal object that has a material attached.
It will not work for material objects that are not registered or
have no normal objects that refer to them. It will also not work
for objects that have no material assigned. If the reference counter
of a material object is not zero, but <tt/"Highlight Material"/
reports 0 objects found, the referring objects probably reside
in the object clipboard. You can clear the tree view again by pressing
<tt/&lt;Ctrl+l&gt;/.
</itemize>

<label id="mmcustom">
The <tt/"Custom"/ menu is initially empty. Custom objects and plugins,
may create entries here.

<label id="mmspecial">
The <tt/"Special"/ menu contains seldom used tools:
<itemize>
<item><tt/"Save Selected as"/, saves just the currently selected objects
to disk. Note that Ayam will not check, whether the objects are saved
with their materials. It is also possible to save instance objects
without their master objects. This will lead to errors while loading
such a scene later on.

<item><tt/"Save Environment"/, saves the root object and all
views to a so called environment scene file, which is read
on program startup and <tt>"File/New"</tt>.
Initially, the file requester that asks for the name
of the new environment uses the value of the preference
setting <tt>"Main/EnvFile"</tt>. Note that there will be no
check whether loading of that environment on next start up is
enabled in the preferences. Note also, that using <tt/"Save Environment"/
you can just save environment files that contain the root object
and all views. If you want to include geometric objects in your
environment or if you want to exclude the root object and just
save views you have to use <tt>"File/Save"</tt> or
<tt>"Special/Save Selected as"</tt> respectively.

<item><tt>"Clipboard/Paste (move)"</tt>, moves objects from the clipboard
back to the scene (clearing the clipboard). This is the only way to
get referenced objects out of the clipboard.

<item><tt>"Clipboard/Replace"</tt>, replaces the currently selected
object(s) with the object clipboard content, moving the replaced
objects into the clipboard. If multiple objects are selected
in non consecutive sequences, only the first consecutive sequence
or single object is replaced.

<item><tt>"Clipboard/Paste Property to selected"</tt> paste the property
from the property clipboard to the currently selected
property of the currently selected object. No type check of the
properties will take place! You may e.g. copy the settings from a
displacement shader to a surface shader (as long as the copied arguments
of both shaders have the same names and types).

<item><tt>"Instances/Resolve all Instances"</tt>, converts all instances
of the current level (and its child objects) to normal objects.

<item><tt>"Instances/Automatic Instancing"</tt>, pops up a small dialog box,
where you may parameterize and start the automatic instantiation
algorithm (that automatically creates instances from
equal objects). See section <ref id="ai" name="Automatic Instancing">
for more information regarding automatic instancing.

<item><tt>"Tags/Add RiOption"</tt>, pops up a small dialog box, where you may
select and parameterize a RiOption tag to add as tag to the Root object
(see <ref id="riotag" name="RiOption Tag">). The Root object does
not have to be selected, and the current selection will not be changed
by this action.

<item><tt>"Tags/Add RiAttribute"</tt>, pops up a small dialog box, where
you may select and parameterize a RiAttribute tag to add as tag to the
currently selected object(s) (see <ref id="riatag" name="RiAttribute Tag">).

<item><tt>"Tags/Edit TexCoords"</tt>, opens the texture coordinates editor.
(see also section <ref id="tctag" name="TC (Texture Coordinates) Tag">).

<item><tt>"RIB-Export/From Camera"</tt>, writes a complete RIB of
the current scene with the camera transformations taken from the
currently selected camera object. The size of the rendered image will
be taken from the RiOptions of the root object. If they are zero,
default values of 400 pixels width and 300 pixels height will be used.
The type of the projection written will be perspective.
Otherwise the RIB looks exactly the same as if exported via
main menu <tt>"File/Export/RenderMan RIB"</tt>.

<item><tt>"RIB-Export/Selected Objects"</tt>, exports only the
selected objects to a RIB. Note that instances will always be resolved,
hidden objects and objects with <tt>"NoExport"</tt> tags are treated
as on normal export operations, and light objects are simply ignored.
Note also that the created RIB, since it e.g. lacks camera transformation
and WorldBegin/End directives, may not be rendered directly by a
RenderMan compliant renderer (unless the renderer is really forgiving
about mis-structured RIBs).
The main use of this feature is to let you create RIBs that may be easily
included in other RIBs using e.g. the ReadArchive directive.

<item><tt>"RIB-Export/Create ShadowMaps"</tt>, creates the shadow maps
for the current scene.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Enable Scripts"/ enables all disabled script tags and
objects. Objects and tags in the object clipboard are not
affected!

<item><tt>"Select Renderer"</tt> opens a dialog where the renderer
for direct rendering from a view may be choosen.
The changes will have effect on all options that
control direct rendering from a view, except whether RenderGUIs should
be used.
If the <tt>"ScanShaders"</tt> checkmark is activated, Ayam will
additionally try to load the corresponding shader parsing plugin
(see also section <ref id="spplugins" name="Shader Parsing Plugins">))
and rescan for compiled shaders. Note that in order for the
<tt>"ScanShaders"</tt> feature to work
properly you also have to set the <tt>"Main/Shaders"</tt> and
<tt>"Main/Plugins"</tt> preference setting correctly
(see also section <ref id="prefmain" name="The Main Preferences">).

<item><tt>"Scan Shaders"</tt> initiates the shader scanning.

<item><tt>"Reset Preferences"</tt> removes the current ayamrc file
where the preferences are saved, after a restart of Ayam, all
preferences will be reset to factory defaults. See also
section <ref id="ayamrc" name="Ayamrc File"> for more information
about the ayamrc file.

<item><tt/"Toggle Toolbox"/ closes or opens the toolbox window
(see <ref id="toolb" name="The Toolbox Window">). From version 1.3 on,
Ayam remembers the state of the toolbox in the saved preferences.

<item><tt/"Toggle TreeView"/ toggles object tree view and object listbox.
From version 1.3 on, Ayam remembers whether the tree view or the
object listbox is open in the saved preferences
(see also section <ref id="obj" name="Objects"> for more information
about both representations).

<item><tt>"Zap Ayam"</tt> iconifies all currently open windows of Ayam.
If one of the iconified windows is de-iconified later, all other zapped
windows will be de-iconified as well.
</itemize>

<label id="mmhelp">
The <tt/"Help"/ menu:
<itemize>
<item><tt/"Help"/, opens a web browser and displays the documentation,
the URL to display is taken from the <tt/"Docs"/ preference setting.

<item><tt/"Help on object"/, opens a web browser and displays
documentation about the currently selected type of object,
the URL to display is derived from the <tt/"Docs"/ preference setting,
this feature will not work with frame redirects e.g.
<tt>"http://www.ayam3d.org/"</tt>; use
<tt>"http://ayam.sourceforge.net/docs/"</tt> or a <tt>"file:"</tt>-URL
as base URL in the <tt/"Docs"/ preference setting instead!

<item><tt/"Show Shortcuts"/, displays some important shortcuts for modelling
actions, you may leave this window open when doing your first
steps in modelling with Ayam.

<item><tt/"About"/, displays some version, copyright,
and trademark information.

<item><tt/"Show Tooltips"/, enables tool tips (balloon help)
for various user interface elements (including the toolbox buttons).
</itemize>


<sect1>Anatomy of a View<label id="viewwin">
<p>
<figure loc="ht">
<eps file="pics/view.ps" height="7cm">
<img src="pics/view.gif">
<caption>A View Window</caption>
</figure>
<p>
The view window is split into a menu bar and a
OpenGL-widget, where interaction and drawing takes place.
The title of the view window gives information about
name, current type, and action of the view.

<sect1>The View Menu<label id="vm">
<p>
<label id="vmview">
Here are all meny entries of the <tt/"View"/ menu:
<itemize>
<item><tt/"Quick Render"/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"QRender"/ command
(see the preferences) will be called. Note that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Render"/: the scene is exported to a RIB using the
camera settings of the current view; then the <tt/"Render"/ command
(see the preferences) will be called. Note that the RIB export
will override the RiOption settings for image size and use the current
window size instead.
Also note that the environment variable <tt/SHADERS/ will be adapted
to the preference setting <tt/Shaders/ for rendering.

<item><tt/"Redraw"/: forces the OpenGL-widget to be drawn, this is
particularly useful if automatic redrawing of the view has been disabled.

<item><tt/"Export RIB"/ exports the scene to a RIB. This does exactly the
same as the main menu entry <tt>"File/Export/RenderMan RIB"</tt>, except that
the current view will already be selected in the dialog box.

<item><tt/"Open PPrev"/, <tt/"Close PPrev"/: those menu entries are just
available, if the compile time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
Permanent preview (PPrev) continuously writes a RIB stream to
a (fast) RenderMan renderer, a frame for each redraw operation
of the view window that was used to open the the preview. This way, the
RenderMan renderer immediately displays all changes in the scene.
This is a great way to test many different camera or light settings without
the need to manually start a rendering process and close the preview window
for each different setting.
As the RIB client library usually is not able to handle multiple open
RIB streams simultaneously, RIB-Export and direct rendering from view
windows are not available until the permanent preview window is closed.

<item><tt/"Create ShadowMaps"/: creates the shadow maps for the current scene.
See also section <ref id="shadowmaps" name="Using ShadowMaps">.

<item><tt/"Close"/: the View window will be removed.
</itemize>

<label id="vmtype">
The <tt/"Type"/ menu entries:
<itemize>
<item><tt/"Front"/

<item><tt/"Side"/

<item><tt/"Top"/

<item><tt/"Perspective"/

<item><tt/"Trim"/
</itemize>
may be used to change the type of the view, which restrains the scope
of certain modelling actions. See sections
<ref id="viewobj" name="View Object"> and
<ref id="vwsc" name="View Window Shortcuts and Actions">
for more information.

<label id="vmconf">
The <tt/"Configure"/ menu may be used to change preferences of the view.
Some preferences are outlined in greater detail in section
<ref id="vat" name="ViewAttrib">.
<itemize>
<item><tt/"Automatic Redraw"/, toggles whether the view should
be redrawn, whenever the scene changes. If this is disabled,
you can force a redraw using <tt>"View/Redraw"</tt>.

<item><tt/"Drawing Mode"/ determines whether the view should draw a wireframe
representation (<tt>"Drawing Mode/Draw"</tt>) or a shaded one
(<tt>"Drawing Mode/Shade"</tt>) or, new in Ayam 1.6, a representation
where the curves of the draw mode are drawn over the shaded
representation (<tt>"Drawing Mode/ShadeAndDraw"</tt>).

<item><tt/"Draw Selection only"/, if this is enabled, just the
currently selected objects (and their children) will be drawn.

<item><tt/"Draw Level only"/, if this is enabled, just the
objects of the current level (and their children) will be drawn.

<item><tt/"Draw Object CS"/, if this is enabled, small coordinate
systems (three colored lines) will be drawn at the base of each
objects coordinate system.

<item><tt/"Draw BGImage"/, if this is enabled, a background
image will be drawn.

<item><tt/"Set BGImage"/, may be used to set the current background
image of the view, which should be a TIFF file.
You can also set this image using the view attribute <tt/BGImage/.

<item><tt/"Draw Grid"/, if this is enabled the grid will be drawn.

<item><tt/"Use Grid"/, if this is enabled the grid will be used to
constrain modelling actions to grid coordinates.

<item><tt/"Set Gridsize"/, may be used to change the size of the grid
associated with this view. Another way to change the grid size is
to use the grid menu on the rightmost side, see below.

<item><tt/"Half Size"/, change width and height to the half of the
current values.

<item><tt/"Double Size"/, change width and height to the double of the
current values.

<item><tt/"From Camera"/, copy camera settings from the currently
selected camera object to the view.

<item><tt/"To Camera"/, copy camera settings to the currently
selected camera object from the view.

<item><tt/"Set FOV"/, lets you specify a field of view value
for the view, and adapts the zoom accordingly. This is just
working for perspective views, of course.

<item><tt/"Zoom to Object"/, adapt the camera settings, so that
the currently selected objects are centered in the view.

<item><tt/"Align to Object"/, align the view to the coordinate
system of the currently selected object or to the parent
object of the current level if no object is currently selected.

<item><tt/"Edit Local"/, if this is enabled modelling will take place
in local object space and not in world space. The grid will be
changed accordingly (interpreted as if defined in the local coordinate space).
See also section <ref id="editlocal" name="Editing in Local Space">.
</itemize>

The <tt/"Grid"/ menu may be used to change the current grid size:
<p>
On the right hand side in the menu bar there is a little icon
that displays the current grid size.
You may click on the icon to display a menu with predefined
grid size values.
Choosing one of the values 0.1, 0.25, 0.5, or 1.0 will set the
grid size of the view to the value and additionally
switch on drawing of the grid and snapping to the grid.
The last entry, however, will set the grid size to 0.0 and
switch off drawing and snapping to the grid.
If a gridsize other than 0.1, 0.25, 0.5, or 1.0 is in effect
for the view, a different icon with a small x will be displayed in the
menu instead.

<sect2>View Window Shortcuts and Actions<label id="vwsc">
<p>
Important keyboard commands of a view window are:
<itemize>
<item><tt/&lt;Left&gt;/, <tt/&lt;Up&gt;/, <tt/&lt;Right&gt;/,
<tt/&lt;Down&gt;/ rotate viewer around origin.

<item><tt/&lt;Add&gt;/, <tt/&lt;Sub&gt;/ (on the numeric keypad) zoom view.
</itemize>

Interactive actions modifying the camera, that is associated with the
view window, are:
<itemize>
<item>Using <tt/&lt;v&gt;/ you may move the view with your mouse.

<item>Using <tt/&lt;V&gt;/ you move the camera in the direction it is
looking. Note that this affects both, from and to setting of the
virtual camera. Furthermore, this movement will have no visible effect in
parallel views.

<item><tt/&lt;R&gt;/ (note the case!) starts rotating the virtual
camera around the point it is looking to.
<item>Rotating the view is also possible in any
modelling mode, when holding down the <tt/&lt;Alt&gt;/-key.

<item><tt/&lt;o&gt;/ starts zooming the view. Moving the mouse up
zooms in and moving the mouse down zooms out.

<item>Since Ayam 1.7 zooming the view into a rectangular region
defined through a mouse drag is also possible in any
modelling mode, when holding down the <tt/&lt;Shift&gt;/-key.
</itemize>
<p>
You may also move the view by dragging with the rightmost mouse
button and zoom the view with the middle mouse button.
<p>
If you have a wheel mouse and it is configured to send
Mouse4 and Mouse5 button events, Ayam will zoom the view
when you turn the wheel.
<p>
Using the menu entry <tt/"Zoom to Object"/ or the shortcut
<tt/&lt;Ctrl+o&gt;/ you can change the views from to and zoom
settings so that the selected objects will be displayed centered
in the view window. This is handy, if you are e.g. searching for
objects or simply lost in space.
<p>
Using the menu entry <tt/"Align to Parent"/ or
the shortcut <tt/&lt;Ctrl+a&gt;/ you can change the
views camera settings so that it is aligned to the
coordinate system of the currently selected object.
This is handy for modelling in local coordinate systems
(e.g. editing the points of a 2D curve defined in the
XY-plane that has been rotated around the Y-axis).
See also section <ref id="editlocal" name="Editing in Local Space">.

<sect1>Selecting Objects within a View<label id="objsel">
<p>
When the view windows action is <tt/"Pick"/ you can pick (select) objects
that appear within this view.
You can invoke this action by pressing <tt/&lt;Shift+p&gt;/
or make this action the default action using the preference
setting <tt>"Modelling/DefaultAction"</tt>.
This section describes techniques that you can use for selecting
one or more objects within a view.

<sect2>Selecting Individual Objects<label id="oneobjsel">
<p>
Selecting objects within a view is a straightforward operation that uses
standard methods. You will use the following two selection operations most
frequently:

<itemize>
<item>To select a single object within a view, move the cursor to the object
and click mouse button 1 (the leftmost one).
Once you select an object, any objects previously
selected are unselected automatically.

<item>To select an additional object, move the cursor to the object and
<tt/&lt;Control&gt;/+Click (again with the leftmost mouse button).
Previously selected objects remain selected, and
the newly picked object is added to the selection. Notice that the picked item
must belong to the same level as the previously selected objects. An
alternative method for selecting multiple objects is to drag a rectangle
around them. For more information see
<ref id="mulobjsel" name="Drag-selecting Multiple Objects">
</itemize>

<sect2>Drag-selecting Multiple Objects<label id="mulobjsel">
<p>
You can select multiple objects using the <tt/&lt;Control&gt;/+Click method
described in section <ref id="oneobjsel" name="Selecting Individual Objects">.
An additional method for selecting multiple objects is to drag a rectangle
around those objects. However only objects that belong to the current level
can be picked within a drag-selection. If you want to select multiple objects
that belong to another level you must change the current level by either
selecting it in the tree/listbox or by picking one object from that level
on a view.
<p>
The procedure for drag-selecting multiple objects also uses a standard method:

<enum>
<item>Imagine a rectangle that encloses only the objects you want to select.

<item>Click at one corner of the rectangle and, while continuing to press the
mouse button, drag until you have enclosed all the objects.

<item>Release the mouse button. All the valid objects inside or crossing the
rectangle are selected and any objects previously selected are unselected
automatically.
</enum>

<p>
Note that if you press <tt/&lt;Control&gt;/ during the drag-selection, objects
that are enclosed by the rectangle will be added to the current selection
instead of replacing it.

<sect2>Ambiguous Picking<label id="ambobjsel">
<p>
In some cases Ayam is unable to differentiate between the objects you have
selected and other nearby or related objects. This ambiguity can arise as
follows:

<itemize>
<item>Imagine a small square surrounding the cursor. When you click an object,
any other valid objects that fall inside this square are also considered to
be possible selections. For example, if you select an item that is positioned
very close to another one, Ayam may consider both items to be possible
selections.

<item>If your model is three-dimensional (which is likely to happen),
imagine a line that is perpendicular to the screen and that passes through
the cursor and into the model. When you pick an object, any objects that
intersect this line are considered to be possible candidates for selection.
</itemize>

<p>
<figure loc="ht">
<eps file="pics/ampick.ps" height="3cm">
<img src="pics/ampick.gif">
<caption>List of Ambiguous Candidates</caption>
</figure>

<p>
If your selection is ambiguous Ayam displays a window that contains a list of
the possible candidates for selection. When you click a name in the list,
the corresponding object is highlighted. Click <tt/"Ok"/ when you have
determined which object to select or <tt/"Cancel"/ to close the list and keep
the previous selection unchanged.
Since Ayam 1.11 you can also use a double click in the list of selection
candidates to select an object and close the dialog.
<p>
Notes:
<itemize>
<item>While the list of ambiguous candidates is opened you can not pick other
objects within the views.

<item>It is possible to use the <tt/"Zoom to Object"/ action (shortcut
<tt/&lt;Ctrl+o&gt;/) while the ambiguous select listbox is open to get
a better view of the temporarily selected object.

<item>The tolerance used to determine whether an object should be picked
or not can be adjusted (see <tt/"PickTolerance"/ in <ref id="hidprefs"
name="Hidden Preference Settings">).
</itemize>

<sect1>The Toolbox Window<label id="toolb">
<p>
<figure loc="ht">
<eps file="pics/tools.ps" height="8cm">
<img src="pics/tools.gif">
<caption>The Toolbox</caption>
</figure>
<p>
The toolbox window displays some buttons that start interactive
modelling actions, modelling tools, or create objects.
You can open and close it using the main menu entry
<tt>"Special/Toggle Toolbox"</tt>.
<p>
Note that in contrast to the keyboard shortcuts of the
view windows the buttons in the toolbox switch to the modelling
actions for all available views. For more information about
the actions see section <ref id="iac" name="Interactive Actions">.
<p>
The toolbox window may be configured by the user using the
hidden preference setting toolBoxList in the ayamrc file.
Using this setting you may select from certain groups of buttons
and change the order in which they appear in the toolbox window.
See section <ref id="hidprefs" name="Hidden Preference Settings"> for
more information.
<p>
The toolbox is also open for extension by scripts, see section
<ref id="scextoolbox" name="Script Examples (Toolbox Buttons)"> for
examples.
<p>
You may also resize the window to change from the vertical standard
layout to a horizontal one, optimizing the use of precious screen
space. After resizing, the toolbox will re-layout the buttons,
warning you if the space is too small for all buttons to display.
If the window is too big for the desired layout and the
preference setting <tt>"Misc/ToolBoxShrink"</tt> is switched on, the
toolbox will shrink wrap the window to match the space occupied by
the buttons.
Furthermore, using the preference setting <tt>"Misc/ToolBoxTrans"</tt>
the toolbox window can be made transient.
It will then (depending on the window manager or its configuration)
get a different or no decoration, no icon, and will always be iconified
when the main window gets iconified.

<sect1>Preferences<label id="prefs">
<p>

<figure loc="ht">
<eps file="pics/prefs.ps" height="8cm">
<img src="pics/prefs.gif">
<caption>Preferences Dialog</caption>
</figure><p>
The preferences dialog may be opened using
the main menu entry <tt>"Edit/Preferences"</tt> or the
shortcut <tt/&lt;Ctrl+p&gt;/.<p>
Use
<itemize>
<item><tt/"Ok"/ to close the preference editor and
apply all changes,

<item><tt/"Apply"/ to apply the changes, but
leave the editor open,

<item><tt/"Revert"/ to reset to the settings
that have been loaded on program startup (these
are not the factory defaults, to get back to the factory
defaults, restart Ayam with the command line option <tt/"-failsafe"/
or use the main menu entry <tt>"Special/Reset Preferences"</tt>!),

<item><tt/"Cancel"/ to close the dialog without applying changes
(done after the last press of <tt/"Apply"/).
</itemize>

Note that while the preference editor is open, AutoFocus is temporarily
turned off and changes to the  <tt/"AutoFocus"/ preference setting will
only be realized after the editor is closed.
<p>
The preferences are divided into five sections.

<sect2>The Main Preferences<label id="prefmain">
<p>
The <tt/"Main"/ section contains the most important application setup related
preference settings:
<itemize>
<item><tt/"Shaders"/ contains a number of paths (separated by <tt/":"/
on Unix and <tt/";"/ on Win32) where Ayam looks for compiled
shaders (e.g. files with the extension <tt/".slc"/ that have been compiled
with slc from BMRT). Using the <tt/"Add"/ button, you may add
another path, simply press it and select a file inside the directory
you want to add. Note that currently the filename of a compiled shader
may contain just two <tt/"."/ at maximum.
The environment variable SHADERS will be adapted to match the contents
of this preference setting, so that renderers started by Ayam see
exactly the same shaders as Ayam.

<item><tt/"Scan for Shaders!"/ initiates a rebuild of the internal
shaders database. All shaders in the directories specified by
the <tt/"Shaders"/ entry will be scanned and entered in that database.
Watch the console for error messages that may appear while scanning.
See also section <ref id="parseshd" name="Shader Parsing"> for more
information on scanning shaders.
</itemize>

The next sub-section contains GUI (user interface) related
settings.<label id="prefgui">
<itemize>
<item><tt/"Locale"/, sets a language for the balloon help texts,
the default value menu shows all currently available locales.
The value will have no effect until Ayam is restarted!

<item><tt/"AutoResize"/ toggles, whether the main window
should be resized horizontally according to the property GUI whenever
a new GUI is displayed.

<item><tt/"AutoFocus"/ controls whether Ayam should automatically
move the focus to a view or the main window, when the mouse pointer
enters it. Note that this may only work correctly, when a window
of Ayam already has the focus. Notice also, that moving the focus
to a window might also raise it (depending on your operating system
or window manager).

Note that while the preference editor is open, AutoFocus is temporarily
turned off and changes to the <tt/"AutoFocus"/ preference setting will
only be realized after the editor is closed.

<item><tt/"TwmCompat"/ changes, how Ayam tells the window manager
new geometries of windows. Might be useful, if you suffer from jumping
windows.

<item><tt/"ListTypes"/ determines, whether the type of an
object should be displayed in brackets in the tree view or listbox.

<item><tt/"MarkHidden"/ determines, whether hidden objects
should be marked (using a preceding exclamation mark)
in the tree view or object listbox.

<item><tt/"AutoSavePrefs"/, if this is switched on, Ayam will write
the preferences settings to the file ayamrc when the program quits.

<item><tt/"BakOnReplace"/, if this is switched on, Ayam will make
a backup copy of each scene file it loads via main menu
<tt>"File/Open"</tt> or via the most recently used list.

<item><tt/"AddExtensions"/, this option may be used to let Ayam
automatically add file name extensions to saved files (if they
do not have already a proper extension).

<item><tt/"LoadEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ on startup.

<item><tt/"NewLoadsEnv"/, if this is switched on, Ayam will load
the scene file specified by <tt/"EnvFile"/ also when the scene is
cleared using the main menu entry <tt>"File/New"</tt>.

<item><tt/"EnvFile"/; This file typically contains some view
objects to create a standard 2-, 3-, or 4-view working environment
and is automatically loaded upon startup of Ayam (if the preference option
<tt/"LoadEnv"/, see above, is switched on) and upon clearing the scene
using <tt>"File/New"</tt> (if the preference option
<tt/"NewLoadsEnv"/, see above, is switched on).

<item><tt/"Scripts"/ is a list of Tcl scripts that will
be executed on startup. The scripts have to be specified with full
path and filename. If non absolute paths are used they are relative
to the current directory of Ayam on application startup (which is typically
the directory where the Ayam executable resides).
Multiple entries have to be separated by a colon (:) on Unix and by
a semicolon (;) on Win32.

<item><tt/"Plugins"/ is a list of directories that contain custom
objects or plugins. Those directories will e.g. be searched for
custom objects when unknown object types are encountered while reading
Ayam scene files. If a matching custom object is found, it will be
automatically loaded into Ayam, so that scene loading may proceed without
an error. Multiple entries have to be separated
by a colon (:) on Unix and by a semicolon (;) on Win32.

<item><tt/"Docs"/ is an URL that points to the documentation in
HTML format.

<item><tt/"TmpDir"/ is the directory, where temporary RIBs are
created, e.g. when rendering directly from view windows.
</itemize>

<sect2>Modelling Preferences<label id="prefmodel">
<p>
The next section of the preferences, <tt/"Modelling"/,
contains modelling related settings:
<itemize>
<item><tt/"PickEpsilon"/ is used by the single point editing actions
to determine which point (vertice) of an object has been selected.
A smaller <tt/"PickEpsilon"/ means more exact picking.
The value of <tt/"PickEpsilon"/ should be positive. In older versions
of Ayam (prior to 1.8), a value of 0.0 was allowed. This is no longer the
case.

<item><tt/"LazyNotify"/ determines whether notification shall
occur on all mouse movements or just on release of the mouse button,
for the interactive modelling actions.
Notification is the mechanism used to inform objects that rely
on certain child objects (e.g. the Revolve custom object) about
changes of their child objects, so that the parent can adapt
to the child objects automagically.

<item><tt/"CompleteNotify"/ determines when notification of all objects
depending on references of changed objects takes place.
<itemize>
<item><tt/"Never"/ for manual control of complete notification,
<item><tt/"Always"/ complete notification is done whenever the
normal notification would be run,
<item><tt/"Lazy"/ complete notification runs
only after a modelling action finished.
</itemize>
Note that complete notify also updates objects that depend on
updated objects.

<item><tt/"EditSnaps"/ determines, whether points
should be snapped to the grid when a grid is defined and
in use for the single point modelling actions.

<item><tt/"Snap3D"/ controls, whether points that are snapped to
grid coordinates (in single point editing actions, when grids are active)
should be influenced in all three dimensions, or just the two dimensions
determined by the type of the view

<item><tt/"FlashPoints"/ controls flashing of editable points in
the single point modelling actions when they would be modified by
a click and drag action.
Note that a change of this preference option takes effect after the
current modelling action has been switched off and the single point
editing has been activated (again).

<item><tt/"DefaultAction"/ determines the modelling action
that should be active after a press of the <tt/&lt;Esc&gt;/ key.

<item><tt/"UndoLevels"/ determines the number of modelling steps
that should be saved in the undo buffer. Useful values range
from 2 to 50 (depending on how much memory you like to spend).
If you set <tt/"UndoLevels"/ to -1, the undo system will be disabled
completely.
For more information, see also the section
<ref id="undos" name="The Undo System">.
</itemize>

<sect2>Drawing Preferences<label id="prefdraw">
<p>
The preferences in the <tt/"Drawing"/ section let you specify
how objects are being drawn:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a NURBS curve
or NURBS patch using GLU.
Smaller tolerance settings lead to higher quality. Useful values
range from 1 to 100.
This setting has no effect for objects that override it
using a local tolerance setting different from 0.

<item><tt/"NPDisplayMode"/ sets the display mode for NURBS patches.
Either the control hull (or control polygon) is drawn (ControlHull), or
just the outlines of the polygons created by the tesselation
(OutlinePoly), or just the outlines of the patch (OutlinePatch).
Note that this setting just affects the drawing of patches if
the view is not in shaded mode.
Note also, that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<item><tt/"NCDisplayMode"/ sets the display mode for NURBS curves,
The control hull (control polygon) or the curve or a
combination of both may be displayed.
Note that this setting has no effect for objects that override it
using a local DisplayMode setting different from <tt/"Global"/.

<item><tt/"UseMatColor"/ determines, whether the shaded representation
uses the color defined by the material of an object for
rendering.

<item><tt/"Background"/, <tt/"Object"/, <tt/"Selection"/, <tt/"Grid"/,
<tt/"Tag"/, <tt/"Shade"/, and <tt/"Light"/ let you set colors that
will be used when drawing or shading.
</itemize>

<sect2>The RIB-Export Preferences<label id="prefrib">
<p>
The <tt/"RIB-Export"/ section of the preferences contains settings that
affect how RIBs are created.
<itemize>
<item><tt/"RIBFile"/ allows to set the file Ayam is exporting
RenderMan Interface Bytestreams (RIBs) to. Note that some
filenames have special meaning:
<p>
If you set <tt/"RIBFile"/ to <tt/"Scene"/ (this is the default)
the RIB file name will be derived from the name of
the currently loaded scene with the last extension replaced by
<tt/".rib"/. If you set <tt/"RIBFile"/ to <tt/"Scenefile"/, the leading
path will be stripped from the scene name additionally.
Use <tt/"Scenefile"/, if you render with shadow maps.
This way the scene will use relative paths to
load the shadow maps and you may move
the RIBs around more easily.
<p>
<tt/"Ask"/ is another special setting, that allows
to select a different filename each time you export a RIB file.
A file selection dialog will pop up, after the selection of the
view to export.
The same effect may be achieved by leaving <tt/"RIBFile"/ totally
empty!
<p>
If you set <tt/"RIBFile"/ to <tt/"rendrib"/,
libribout.a does not create a RIB file at all, but immediately pipes the
resulting byte stream into rendrib (the BMRT renderer) for rendering.
The same goes for <tt/"rgl"/.
Moreover, filenames that start with a pipe symbol <tt/"|"/ will
cause the program behind the pipe symbol to be started by libribout
and the written RIB to be piped into. This works e.g.
with Photorealistic RenderMan, try it out with <tt/"|render"/.
In the latter cases of direct rendering, you will probably want to set
up the RIB to render to the display (read leave the <tt/"Image"/
preference setting empty.
However, when you use these options of direct rendering, be warned, that
for the time of the rendering Ayam will be frozen (it will neither
respond to mouseclicks nor will it update any windows), until the
rendering is finished and the display window of the renderer is closed.

<item><tt/"Image"/ specifies the image file that will be created,
when you render the exported RIB file.
You may set it to <tt/"RIB"/, this will create image
files that are named as the exported RIB file (with the last
file extension replaced by <tt/".tif"/). Again, setting
it to <tt/"Ask"/ will cause a dialog box to appear,
each time you export to a RIB file.
<p>
Note that in contrast to the <tt/"RIBFile"/ option leaving the field
totally empty is not equal to entering <tt/"Ask"/ but generates
RIB files that will be set up to render to the display.

<item><tt/"ResInstances"/, if this is enabled all instance
objects are resolved (temporarily) before being written to the RIB file.

<item><tt/"CheckLights"/, if this is enabled Ayam will
check the current scene for lights before RIB export. If no lights or
no lights that are actually switched on are to be found in
the scene, a distant headlight will be added to the scene
automatically for RIB export.

<item><tt/"DefaultMat"/ determines a default material setting
that should be written in the top level of the RIB, so that it
is in effect for all objects, that are not connected to a material
object. Many RenderMan compliant renderers will not render the
objects at all, if no material is defined.
The default <tt/"matte"/, writes just a simple
<tt>RiSurface "matte"</tt> (without parameters) to the RIB.
The setting <tt/"default"/ looks for a material object named
<tt/"default"/ and writes it's complete shaders and attributes,
if it does not find such a material it falls back to <tt/"matte"/.
The setting <tt/"none"/ does not write any default material setting.

<item><tt/"RIStandard"/ determines whether Ayam
should omit all non standard RenderMan interface options and
attributes on RIB export.

<item><tt/"WriteIdent"/ determines, whether Ayam should
write special RiAttributes
(<tt>RiAttribute "identifier" &lsqb;"name"&rsqb;</tt>)
with the names of the objects to the RIB to aid in RIB file debugging.

<item><tt/"ShadowMaps"/ determines, whether shadow maps should
be used, when writing light sources. It is not sufficient
to switch this on to render using shadow maps, light sources
that shall use shadow maps have to be parameterized
as well, see section <ref id="shadowmaps" name="Using ShadowMaps">.
If <tt/"ShadowMaps"/ is set to <tt/"Automatic"/, the
exported RIBs will automatically render and use all shadow maps;
if it is set to <tt/"Manual"/, the shadow maps will be rendered on
user request only (using the view menu entry:
<tt>"View/Create ShadowMaps"</tt>). <tt/"Manual"/ should be used,
when rendering directly from view windows with shadow maps.

<item><tt/"ExcludeHidden"/ causes hidden objects not to be
exported to RIB files.

<item><tt/"RenderMode"/ allows to switch between two different methods
of forcing a renderer to render to the screen (via a RiDisplay statement
in the exported RIB, necessary for e.g. PRMan and RDC;
or via a command line argument, e.g. <tt>-d</tt> for rendrib from BMRT).

<item><tt/"QRender"/ determines the command that should be executed,
upon quick rendering a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"QRenderUI"/, enables the Rendering GUI for quick rendering,
see discussion of <tt/"RenderUI"/ below.

<item><tt/"QRenderPT"/, progress template for quick rendering,
see discussion of <tt/"RenderPT"/ below.

<item><tt/"Render"/ determines the command that should be executed,
upon normal rendering of a view, <tt>%s</tt> denotes the name of the RIB file.

<item><tt/"RenderUI"/ enables the renderer user interface (Rendering GUI),
which consists of a simple progress bar, a label that displays the
estimated or elapsed rendering time, a checkbutton to control
ringing the bell when the rendering is finished,
and a cancel button. This GUI is displayed
when a renderer is invoked directly from a view window
using the <tt/"Render"/ view menu entry (or the equivalent keyboard shortcut).
Proper work of this GUI depends on the existence of
two external programs: <tt/"cat"/ and <tt/"kill"/ (those programs
should be available on every Unix platform). If you do not have
those programs in your path, do not enable the RenderUI option.
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.
See also section <ref id="hidprefs" name="Hidden Preference Settings">.

<item><tt/"RenderPT"/ is a string that contains a progress output
template used by Ayam to determine the current percentage of completion
of the rendering for display in the Rendering GUI. The special symbol <tt/"%d"/
denotes the position of the percentage number in the output of the renderer.
For rendrib from BMRT2.6 this should be set to <tt/"R90000 %d"/ and
the special command line option <tt/"-Progress"/ should be used.
For rendrib from BMRT2.5 it should be set to <tt/"Done computing %d"/
and no special option has to be given to the renderer.
If the output of the renderer contains variable strings before
the progress number, a second variant of parsing the output using
regular expressions is available since Ayam 1.6. In this case, the
progress template should be a complete regexp command for Tcl
that parses the string contained in the variable named <tt/"string"/
and puts the parsed progress number into a variable named <tt/"progress"/.
Here is an example that works with Pixie-1.2.1, which outputs
strings like <tt/"fish.rib (222):  - 10.00 percent"/:
<code>
regexp -- {^.* - (\[0-9\]+)} string dummy percent
</code>

<item><tt/"SMRender"/, renderer to use for the rendering of shadow maps
using the view menu entry <tt>"View/Create ShadowMaps"</tt>,
<tt>%s</tt> denotes the name of the RIB file.

<item><tt/"SMRenderUI"/, enables the Rendering GUI for the rendering
of shadow maps, see discussion of <tt/"RenderUI"/ above.

<item><tt/"SMRenderPT"/, progress template for the rendering
of shadow maps, see discussion of <tt/"RenderPT"/ above.

<item><tt/"SMFileFormat"/, designates the file format of the shadow maps,
use <tt/"zfile"/ for RenderMan and <tt/"shadow"/ for Gelato.

<item><tt/"SMFileType"/, type of shadow maps to be created, currently
available types are <tt/"z"/ - normal shadow maps (for RenderMan
renderers and Gelato), <tt/"avgz"/ - Woo shadow maps (for Gelato only!),
and <tt/"volz"/ - volume shadow maps (for Gelato only!).

<item><tt/"SMChangeShaders"/, toggles, whether Ayam should automatically
prepend a "shader" to light shader names for lights that use shadow maps
upon RIB export. Not changing the shader names is necessary for Gelato.

<item><tt/"PPRender"/ is the name of the renderer to use for the
permanent preview feature (see also section <ref id="vm" name="View Menu">).
This setting is just available, if the compile
time option <tt/AYENABLEPPREV/ has been set.
This option is not set for the official Ayam binaries.
</itemize>

Note that you can set many renderer related preferences at once using the
select renderer tool via the main menu <tt>Special/Select Renderer</tt>
(see also section <ref id="mmspecial" name="Special Menu">). In fact,
using <tt>Special/Select Renderer</tt> first, then fine tuning your
renderer setup using the preferences editor is the suggested way.

<sect2>Miscellaneous Preferences<label id="prefmisc">
<p>
The (<tt/"Misc"/) section of the preferences contains the dreaded
miscellaneous settings.

The first sub-section deals with error message handling:
<itemize>
<item><tt/"RedirectTcl"/ controls, whether error messages
stemming from Tcl/Tk should be redirected to the console,
rather than be handled by Tcls sometimes annoying error
handling dialog box. However, this dialog box with the built in
stack trace can also become very handy, if you write and debug
Tcl scripts.

<item><tt/"Logging"/ determines, whether error messages should
be written to the file specified by <tt/"LogFile"/.
If this is enabled, you should clear the log manually from time
to time, as Ayam will always append to <tt/"LogFile"/.

<item><tt/"LogFile"/; see above.
</itemize>

The last sub-section contains miscellaneous user interface
related preferences:
<itemize>
<item><tt/"SaveAddsMRU"/; if this is switched on, saving to a file
will add that file to the most recently used files list in the
main menu for quick access.

<item><tt/"ToolBoxTrans"/; controls whether the toolbox window
should be declared as a transient window of the main window.
It will then, depending on the window manager or its configuration,
get a different or no decoration, no icon (or no entry in the
task bar on Windows), and will always be iconified
when the main window gets iconified.

<item><tt/"ToolBoxShrink"/; controls whether the toolbox window
should automatically shrink-wrap around the calculated layout
of the buttons after a resize operation.

<item><tt/"RGTrans"/; controls whether the RenderUI-windows
should be declared as a transient window of the main window.
See the discussion of <tt/"ToolBoxTrans"/ above for more information
about transient windows.

<item><tt/"HideTmpTags"/ may be used to hide tags that are marked
temporary (internal tag types do so) from the tag property GUI.

<item><tt/"TclPrecision"/; this is the precision Tcl handles floating
point numbers with. You may want to decrease this number to about 5
if any numbers in the entry fields are represented in an exact, but also
too lengthy and hard to read fashion, like 0.4999999 instead of 0.5.
Note that you may loose information in doing so. The default value used
by Tcl is 12 and results in no loss of information. The default value
used by Ayam is 6 and should result in a good balance between precision
and readability.

<item><tt/"SavePrefsGeom"/ controls when the geometry of the preferences
editor should be remembered by Ayam, <tt/"Never"/: the window is always
opened in standard size, centered on the screen; <tt/"WhileRunning"/:
the window width and position will be remembered as long as Ayam is
running; <tt/"Always"/: the window width and position will be remembered
in the saved preferences, thus, also surviving a restart of Ayam.
Note that the height of the preferences window will always be adapted
to the currently open preferences section, no matter how <tt/"SavePrefsGeom"/
is set.

<item><tt/"SMethod"/; is the sampling method used by the NURBS to PolyMesh
(tesselation) facility (based on GLU V1.3+). Five methods are available:
<tt/"DomainDistance"/ (the default) simply tesselates the NURBS into equally
sized pieces with regard to parametric space; <tt/"SParamU"/ and
<tt/"SParamV"/ control the number of sampling points in u and v direction
respectively per unit length.
This leads to different numbers of samples for knot vectors
of different length in parameter space!
The tesselation method <tt/"PathLength"/ ensures that no edge of a
polygon generated by the tesselation is longer than the value specified
by <tt/"SParamU"/ and the tesselation method <tt/"ParametricError"/
ensures that the distance between the tesselated surface and the original
surface is no point bigger than the value specified by <tt/"SParamU"/.
Note that <tt/"SParamU"/ is expressed in object space units for the
<tt/"PathLength"/ and <tt/"ParametricError"/ tesselation methods.
To overcome the limitations of the <tt/"DomainDistance"/ tesselation
method, Ayam 1.9 supports two new modes <tt/"NormalizedDomainDistance"/
and <tt/"AdaptiveDomainDistance"/, where <tt/"NormalizedDomainDistance"/
ensures that the tesselation creates the same number of sample
points (as given via <tt/"SParamU"/ and <tt/"SParamV"/) for any
knot vector and <tt/"AdaptiveDomainDistance"/ additionally adds
sample points dependend on the number of control points (width or
height of the patch) to provide a better adaptation to complex patches.
<item><tt/"SParamU"/; is a parameter for the sampling method above.
The default value for the sampling method <tt/"DomainDistance"/ is 10. Higher
values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"PathLength"/ is 30.
Smaller values lead to better quality and more tesselated polygons.
The default value for the sampling method <tt/"ParametricError"/ is 0.5.
Smaller values lead to better quality and more tesselated polygons.
<item><tt/"SParamV"/; is just available for the tesselation modes
<tt/"DomainDistance"/, <tt/"NormalizedDomainDistance"/, and
<tt/"AdaptiveDomainDistance"/.
</itemize>

<sect>Interactive Actions (Modelling)<label id="iac">
<p>
Before invoking any modelling action you should select
one or more objects using the main window or using the pick action!
<p>
Every action can be started with a key press (a shortcut) when
the keyboard focus is in a view window or by clicking on the associated
button in the toolbox window.
Using a keyboard shortcut starts that action in the current view only,
the other views are not affected. Starting an action from the
toolbox window will cause the action to be started in all
view windows that are currently open simultaneously.
<p>
It is perfectly ok to start and work with many different actions at
the same time in different views: you can have e.g. a view, where you move
objects, a second where you rotate objects and a third, where you pick
objects. The layout, drawing style, and grids may also differ between
the different views. Together with the feature, that you may change
the selection while actions are active and even pan and zoom views
(using the rightmost and middle mouse buttons respectively) while
actions are active and without breaking them, this is the key to
unsurpassed flexibility in modelling using Ayam.
<p>
To break an action, the <tt/&lt;Esc&gt;/ key may be used.
<p>
The default action for all views, which is also in effect after
use of the <tt/&lt;Esc&gt;/ key, is <tt/"None"/ or <tt/"Pick"/
(depending on the preference setting <tt>"Modelling/DefaultAction"</tt>).
See section
<ref id="objsel" name="Selecting Objects within a View">
for more information about picking objects.
<p>
Note that the modelling actions
are not available in perspective views.
<p>
If an action is in effect for a view, the views title will be changed
appropriately.
<p>
A modelling action is performed by clicking into the view with the
leftmost mouse button to mark a point in space or to pick a vertex
and then by dragging the mouse.
<p>
You may undo/redo the effects of a modelling action using <tt/&lt;Ctrl+z&gt;/
and <tt/&lt;Ctrl+y&gt;/ (see section
<ref id="undos" name="The Undo System"> for more information).
<p>
Grids are available to restrict the modelling actions to certain
points and help in exact modelling.
<p>
Also note that you may use the middle and rightmost mouse button
to zoom and move the view while modelling actions are active.
<p>
For actions that modify the camera of a view
please see section <ref id="vwsc" name="View Window Shortcuts and Actions">.

<sect1>Moving Objects or Selected Points
<p>
Using the modelling action <tt/"Move"/ (shortcut: <tt/&lt;m&gt;/)
you may move selected objects or the selected (tagged) points
of the selected objects.
<p>
Note that the objects/points will be moved in the XY-plane for
Front-views, the ZY-plane for Side-views, and the XZ-plane
for Top-views only, no matter how the view is rotated.

<sect1>Rotating Objects or Selected Points<label id="rotac">
<p>
Using the modelling action <tt/"Rotate"/ (shortcut: <tt/&lt;r&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects.
<p>
Note that if multiple objects are selected, each object is rotated
around the center of its own local coordinate system.
The axis of rotation is always parallel to the Z-axis in Front-views, the
Y-axis in Top-views, and the X-axis in Side-views.

<sect1>Rotating Objects or Selected Points around a Point
<p>
Using the modelling action <tt/"Rotate about"/ (shortcut: <tt/&lt;a&gt;/)
you may rotate objects or the selected (tagged) points
of the selected objects around a specified point in space.
The action requires a point to be specified using a single
click after the action has been started.
The point will then be marked by a little red cross.
If you want to rotate about a different point, you need to restart the
action (press <tt/&lt;a&gt;/ again).
<p>
After the first click, the action works the same way as
the Rotate action, except that it rotates around the specified point.
This also works with multiple selected objects.
Note that this action does not only change the Rotate_X(_Y,_Z)
properties of the selected objects, but also the Translate_X(_Y,_Z)
properties.
<p>
To avoid degenerated coordinates due to roundoff errors
it is highly suggested to use grids with this action.

<sect1>Scaling Objects or Selected Points<label id="scalac">
<p>
There are several different actions available to scale
objects or the selected (tagged) points of the selected objects:
<p>
The modelling action <tt/"Scale 3D"/ (shortcut: <tt/&lt;S&gt;/, note the
big S!) scales all three axes of the selected objects or
the selected (tagged) points of the selected objects
by the same factor.
<p>
The modelling action <tt/"Scale 2D"/ (shortcut: <tt/&lt;s&gt;/)
scales just two axes of the selected objects or
the selected (tagged) points of the selected objects. Those axes are
XY in a Front-view, ZY in a Side-view, and XZ in a Top-view.
<p>
The modelling actions <tt/"Scale X"/ (shortcut: <tt/&lt;x&gt;/),
<tt/"Scale Y"/ (shortcut: <tt/&lt;y&gt;/), and
<tt/"Scale Z"/ (shortcut: <tt/&lt;z&gt;/) scale only one axis
of the selected objects or
the selected (tagged) points of the selected objects.
<p>
The modelling action <tt/"Stretch 2D"/ (shortcut: <tt/&lt;Alt+s&gt;/)
works much like <tt/"Scale 2D"/ but the scale factor for each
axis may be different. Never start this action by a click
near one of the axes to be changed, as this will cause
very big scale factors for the other axis. Try it first with
a centered box by starting from one of the vertices,
then try it once starting on the X-axis.

<sect1>Selecting Points<label id="selac">
<p>
The modelling action <tt/"Select Points"/
(shortcut: <tt/&lt;t&gt;/; tag points)
may be applied to a NURBS curve, NURBS patch or objects
that support single point editing only. Objects draw the
selectable points using small rectangular handles.
Selected points will be drawn in dark red.
<p>
The selected points may be modified using the modelling actions
Move, Rotate, and Scale as discussed above.
Selected points always take precedence for those modelling actions.
<p>
After the pick (the selection of a point), the picked point
will be added to the list of selected points for the selected object.
If the selected point is already in that list
it will be removed from the list instead. Note that the list
of selected points will not be deleted from the object
until a de-select is performed using the shortcut <tt/&lt;D&gt;/.
<p>
Note that the list of selected points is not copied, if the object
is copied using the clipboard.
Undo and redo will destroy the list of selected points too!
<p>
However, it is perfectly legal to select some points, move them using
the move action, then switch to single point editing, edit
some other or even one of the selected points, switch back
to the selection action, add other points to the selection or delete some
points from the selection, switch to rotate, rotate the selected
points and so on.
<p>
You may also add a bigger number of points
to the selection using a click and drag operation. All points
that are inside the rectangular region defined by the click and drag
will be added to the selection.

<sect1>Editing Points<label id="editac">
<p>
To edit the points of an object three actions (<tt/"Edit"/,
 <tt/"Edit Weights"/, and <tt/"Direct Point Edit"/) are available.
All those actions may be applied to objects that support single point
editing only.
Objects mark themselves editable by drawing the editable points using
small rectangular handles if one of the single point editing action is
activated and the object is selected.
<itemize>
<item>The modelling action <tt/"Edit"/ (shortcut: <tt/&lt;e&gt;/)
works much like the move action, but it moves
single points instead of objects. In contrast to the move action,
you need to pick on the handle of the point you want to move.
Furthermore, it is not possible to move points of multiple selected
objects, only the first selected object is considered.
<p>
If a NURBS curve has multiple points, this action modifies all
points that make up the multiple point.

<item>The modelling action <tt/"Edit Weights"/ (shortcut: <tt/&lt;w&gt;/)
changes the w coordinate of a single point by dragging the mouse left
or right. The weights may be reset for all points
using the shortcut: <tt/&lt;W&gt;/. Furthermore, it is
not possible to edit the weights of multiple selected objects, only
the first selected object is considered.
<p>
If a NURBS curve has multiple points, this action modifies all
points that make up the multiple point.

<item>The modelling action <tt/"Direct Point Edit"/ (shortcut:
<tt/&lt;p&gt;/)
opens a small window where you may change the coordinates of the
selected point directly by entering numbers.
Note that the w coordinate setting will be ignored if the
picked point does not have weight information (is not homogenous).
Using the small menu on top of the coordinate window you may
determine whether editing takes place in local object or global
world space.
<p>
If a NURBS curve has multiple points, this action modifies all
points that make up the multiple point.
<p>
Notice that since Ayam 1.4 the direct point editing dialog may stay
open all the time. Furthermore, it is not necessary that the original
object stays selected, you may select other objects to e.g. infer new
point coordinates from their properties and apply them to the
original object.
However, certain actions like deleting objects, will also delete the
reference to the selected points. In this case you will have to select
the object and then a point to edit again. Furthermore notice that
the coordinate values displayed in the direct point editing window
will not update when the point is modified by another modelling
action. Simply click on the point again in a view where the
direct point editing action is active, to update the coordinate
values in the direct point editing dialog. This modelling action also
may only be applied to a single selected object.
</itemize>

<sect1>Snapping Points to the Grid<label id="snapac">
<p>
Since Ayam 1.11 there are two actions available that let
you snap points to the current grid of a view.
The actions are initiated using the shortcuts <tt/&lt;g&gt;/
and <tt/&lt;G&gt;/. If an object has selected (tagged)
points, only those points will be snapped to the grid,
otherwise all points of the object will be snapped to the grid.
If <tt/&lt;g&gt;/ is used, the snapping only occurs in
the modelling plane associated with the view (i.e. in 2D).
To snap all three coordinate values to the grid use <tt/&lt;G&gt;/.
Note that the snapping occurs also, if the view has the preference
option <tt/"Use Grid"/ turned off.

<sect1>Inserting or Deleting Points<label id="insdelac">
<p>
The modelling action <tt/"Insert Point"/ (shortcut: <tt/&lt;i&gt;/)
may be applied to NURBS and interpolating curves (objects of type
NCurve and ICurve) only.
A new control point will be inserted in the curve right
after the picked point. The new point will be inserted in the
middle between the selected point and the next point, changing
the shape of the curve. (It is also possible to insert control
points into certain types of NURBS curves without changing
their shape using knot insertion;
see the insert knot tool <ref id="insknt" name="The Insert Knot Tool">.)
<p>
The modelling action <tt/"Delete Point"/ (shortcut: <tt/&lt;d&gt;/)
may be applied to NURBS and interpolating curves (objects of type
NCurve and ICurve) only.
The selected control point will be deleted from the curve.
Deleting points from a curve with knot type custom
may currently lead to an incorrect knot sequence, please
check and correct the new sequence manually.

<sect1>Miscellaneous Actions<label id="miscac">
<p>
This section documents some special modelling actions.
<itemize>
<item>The modelling action <tt/"FindU"/ (shortcut: <tt/&lt;u&gt;/)
may be applied to NURBS curves (objects of type NCurve) only.
This action may be used to get the corresponding parametric
value u from a point on a curve. Pick a point on the curve
(not a control point!). If this
is done, the appropriate value for u is calculated, stored
in the global variable u, and additionally written to the console.
A small cross is drawn at the position of the picked point.
Remember to exactly pick a point on the curve or nearby, otherwise
the calculation may fail and no value will be written to the console.

<item>The modelling action <tt/"Split Curve"/ (shortcut <tt/&lt;c&gt;/)
may be applied to NURBS curves (objects of type NCurve) only.
Using this action you may split a NURBS curve into two new curves
at a point on the curve that may be specified by picking a point
on the curve.
Remember to exactly pick a point on the curve or nearby otherwise
the calculation of the parametric value for the split will fail.
The selected curve will be changed by this action, and
a new curve will be created. It is currently not possible to undo
the changes of a split!
</itemize>

<sect1>Editing in Local Space<label id="editlocal">
<p>
Normally, all editing takes place in world space and the input
plane of all modelling actions is constrained to the world
XY-, ZY-, or XZ-plane (depending on the type of view used).
<p>
However, if a view is aligned and switched to local, you can also
edit in local object space. This means you can e.g. edit a
two-dimensional parameter curve of a skin object where both objects
(curve and skin) are rotated and scaled arbitrarily
and make sure that the curve remains two-dimensional all the time.
<p>
All you need to do is to first select the curve and then press
<tt/&lt;Ctrl+a&gt;/ to align the view and then <tt/&lt;Ctrl+l&gt;/ to
make it local.
In practice, this means that the input plane of an aligned local view
will match the XY-, ZY-, or XZ-plane of the local object space,
depending on the type of the view (<tt/"Front"/, <tt/"Side"/, or <tt/"Top"/).
<p>
Furthermore, grids will also act as if defined in local object space.
Note that in contrast to their normal behaviour, grids can also be scaled
differently in X-window and Y-window coordinates in aligned local views
(if the local object space is deformed this way).

<sect>Objects and Properties<label id="obandprp">
<p>
This section informs you about the different object types of Ayam and
about the property GUIs that appear in the properties section of the
main window if a single object and a property have been selected.

<sect1>Standard Properties<label id="stdprop">
<p>
Most Ayam objects have standard properties. They are used
to control transformations and common attributes of objects.
The following sections describe the standard properties
<tt/"Transformations"/, <tt/"Attributes"/, <tt/"Material"/, <tt/"Shaders"/,
and <tt/"Tags"/.

<sect1>Transformations Property<label id="trap"><label id="transformationsprop">
<p>
Use this property to edit the location, orientation, and
size of an object.
<itemize>
<item><tt/"Reset All!"/ immediately resets all transformation
attributes to the default values.

<item><tt/"Translation_X (_Y, _Z)"/ is the displacement of the
object from the world origin in X (Y, Z) direction.

<item><tt/"Rotation_X (_Y, _Z)"/ is the angle (in degrees)
of the rotation of the object around the X (Y, Z) axis.
Read the next section for more information on how to use these
entries. Read it!

<item><tt/"Scale_X (_Y, _Z)"/ determines a scale factor that will be
applied to the object in the direction of the local X (Y, Z) axis.

<item><tt/"Quat0 (1, 2, 3)"/ the quaternion that is used to determine
the orientation of the object in space. This quaternion is not here
to be edited directly! The sole purpose of its appearance here
is to allow copying and pasting of rotations.
</itemize>

The transformations are applied to the object in the following order:
Scale, Rotation, Translation.

<sect2>Using the Rotation Attributes<label id="gimb">
<p>
The orientation of an object in space may be expressed using
so called Euler angles. This notation (simply three angles
determining a rotation about the axes of the coordinate system)
suffers from a phenomenon called gimbal lock.
<p>
To avoid gimbal locks, Ayam internally holds the orientation
of an object in a quaternion.
This quaternion not only holds information about the angles
but also about the order in which partial rotations occured.
<p>
It is important to know, that the values of the angles of
the rotation property must not be read in a way that
the object will first be rotated around X by x-angle degrees
then around Y y-angle degrees then around Z z-angle degrees.
In fact, no information about the order in which partial
rotations occured may be derived from that three values.
This implies, that e.g. the values 0 0 45 may denote
a different orientation than the very same values
0 0 45 (no joke)!
<p>
But how do you get the three entries to do what you want?
You either want to rotate the object around an axis by a given
amount or you want to undo a rotation or undo all rotations.
<p>
Rotating an object is easy, simply add the amount about
which you want to rotate the object to the value currently
displayed in the appropriate entry. If you want to rotate
about 45 degrees about X and the x-angle entry displays a 30,
enter 75.
Then press the apply button.
If you change multiple entries the rotations made will be
in the order X (if changed) then Y (if changed) then Z (if changed).
Do not change more than one entry at once until you exactly
know what you are doing.
<p>
Undoing a single rotation works in the same way, just use a subtraction
instead of an addition.
<p>
Undoing all rotations (resetting the object to its original state)
is simple too: enter 0 for all three entries at once,
then press apply.
<p>
If you want to copy the orientation of an object to other objects
using the property clipboard, make sure that you select all Rotation and
Quat property elements.

<sect1>Attributes Property<label id="attrs"><label id="attributesprop">
<p>
The attributes of an object contain currently:
<itemize>
<item><tt/"Objectname"/, the name of the object. It is also displayed
in the object listbox or tree and may be written to RIB streams.

<item><tt/"Hide"/, if this attribute is set this object is not drawn.
It may also be excluded from RIB export.

<item><tt/"Refcount"/, just displays how many objects
point to this object. Objects with a reference count different
from zero may not be deleted.
</itemize>

<sect1>Material Property<label id="matprop"><label id="materialprop">
<p>
The material property allows you to connect geometric objects
to material objects (see also section
<ref id="materialobj" name="Material Object">).
The material property GUI consist of the following elements:
<itemize>
<item><tt/"Clear Material!"/ immediately clears any connection
of the current object to its material.

<item><tt>"Add/Edit Material!"</tt> adds a material to the
current object (if it has none) and immediately selects
the new material object for editing. If the current object
already has a material, this material object is searched for
and selected for editing.

<item><tt/"Materialname"/ is the name of the material of this object.
If you change the name, the object will be disconnected from the
old material and connected to the new material.
An easier way to connect geometric objects to material objects is to simply
drop the geometric objects onto the material object using Drag-and-Drop
in the tree view.
</itemize>

<sect1>Shader Properties<label id="shd"><label id="atmosphereprop">
<label id="imagerprop"><label id="surfaceprop"><label id="displacementprop">
<label id="interiorprop"><label id="exteriorprop"><label id="lightshaderprop">
<p>
Shader properties are used to attach shaders of a certain type to objects.
The name of the property contains the type of the shader, e.g.
light shaders may be attached using a property named <tt/"LightShader"/ only.
Other types of shaders or shader properties are: <tt/"Surface"/,
<tt/"Displacement"/, <tt/"Interior"/, <tt/"Exterior"/, <tt/"Atmosphere"/,
and <tt/"Imager"/.
<p>
Each shader property GUI, even if no shader is attached to an object,
starts with the <tt/"Set new shader."/-button. This button allows
to select a new shader of the appropriate type.
If you press the <tt/"Set new shader."/-button, a dialog with a
list of shaders pops up. If this list is empty, Ayam
is probably not set up properly (or you simply do not have
shaders of the appropriate type). Check the preference setting
<tt>"Main/Shaders"</tt>.
After a new shader has been set, the arguments of the shader will be
parsed and a GUI will be generated to allow the arguments of the shader
to be filled with values.
<p>
The <tt/"Delete shader."/-button may be used to
delete the current shader from the selected object.
<p>
The <tt/"Default Values."/-button resets all arguments
of the shader to the default values.
See also section <ref id="workshd" name="Working with Shaders"> below.
<p>
All other elements of the shader property GUI depend on the currently
attached shader.

<sect2>Shader Parsing<label id="parseshd">
<p>
If no plugin is loaded, the official Ayam binaries use libslcargs
(from BMRT) to parse shaders that have been compiled with slc (the
shader compiler from BMRT). Parsing incorporates detecting the
type of the shader and detecting the names, types, and default values of
all shader arguments.
<p>
Note that currently, Ayam only works properly with shaders
that have at most two dots in their file name and that Ayam will simply
skip all array arguments (and emit a warning message) while parsing
a shader. Those array arguments consequently never appear in the
shader property GUIs and RIBs exported by Ayam. Also note that
default values for shader arguments of type color will be silently
clamped to the range 0-255.
<p>
Many shaders use array arguments to define transformation matrices.
If this is the case and you have access to the shader source code
you may want to modify those shaders to enable working with the
transformation matrix carrying shader arguments. To do this, just
change all definitions of transformation matrix carrying floating
point arrays to real matrices. If the shader contains a
<p>
<tt>"float a_matrix_parameter[16]"</tt>
<p>
change this to
<p>
<tt>"matrix a_matrix_parameter"</tt>.
<p>
Note that these changes of the shader argument definitions probably
also require changes of the shader source code that uses those arguments.
Ayam is able to deal with matrices because of their fixed size of 16
float values, and because libslcargs is able to deliver the default
values for a matrix (but not for an array!).
<p>
If Ayam has been compiled without a shader parsing library
(e.g. without libslcargs), Ayam will parse XML files created
by <tt/"sl2xml"/ from the K-3D project
(see <tt>"http://www.k-3d.org/"</tt>)
instead of compiled shaders.
The <tt/"Set new shader."/-button will in this case always
open a file requester, allowing you to select a XML file,
that has been created by sl2xml.
Furthermore, the <tt/"Default Values."/-button will not be available;
you have to use <tt/"Set new shader."/ instead.
<p>
From version 1.3 on, Ayam also supports shader parsing plugins to allow
parsing of shaders compiled with different shader compilers, see also
section <ref id="spplugins" name="Shader Parsing Plugins">.

<sect2>Working with Shaders<label id="workshd">
<p>
The <tt/"Default Values."/-button resets all arguments of the shader
to the default values.
Additionally, the compiled shader will be parsed again and the property GUI
will be adapted (new shader arguments will appear, removed shader arguments
will disappear).
Therefore, this button is quite handy if you have to deal with
changing shaders: just edit the shader, recompile it, then back
in Ayam just hit the <tt/"Default Values."/-button. Note that
this destroys your possibly carefully adjusted shader argument values.
<p>
If you want to keep the old shader argument values when a shader
changes, simply copy the shader property using the property clipboard
(main menu: <tt>"Edit/Copy Property"</tt>) before
you load the new default values and paste the property
back using <tt>"Edit/Paste Property"</tt> after loading of the
new default values.
Beware! This works properly only, if you do not change the type of
existing shader arguments and if no shader arguments are removed in
the new version of the shader!
<p>
You can also just copy certain parameter values (shader arguments
whose types do not change) by selecting them using double-clicks
on the parameter names in the shader property GUI and then use e.g.
<tt>"Edit/Copy Marked Prop"</tt>
(see also the description of the property clipboard in section
<ref id="propgui" name="Properties">).

<sect1>Tags Property<label id="tags"><label id="tagsprop">
<p>
Use this property to edit the tags of an object.
<p>
Tags provide an easy way to attach arbitrary information (e.g. additional
RenderMan interface attributes, special attributes for plugins or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.
<p>
The Tags property GUI consists of the following standard
elements:
<itemize>
<item><tt/"Remove all Tags!"/ immediately removes all tags
from the object.

<item><tt/"Remove Tag!"/ is a menu, that allows you
to select and remove a single tag from the object.

<item><tt/"Add Tag!"/ opens a small dialog box, where you
may enter a new tag type and value. Once you press the <tt/"Ok"/
button, a new entry will be added to the tags property, displaying
the new tag. Just click on the entry to get back to the dialog,
to remove the tag using <tt/"Clear"/ then <tt/"Ok"/, or to change
the type or value of the tag.
</itemize>
<p>
The next sub-sections describe the tag types currently available in Ayam
and the plugins distributed with Ayam.
Note that extensions and plugins may define their own types.

<sect2>RiAttribute Tag<label id="riatag">
<p>
The tag type <tt/"RiAttribute"/ can be used to attach
arbitrary RenderMan interface attributes to objects.
This is handy if you use a renderer with lots of RiAttributes
that differ from the standard RiAttributes.
<p>
<tt/"RiAttribute"/ tags attached to a geometric object override
<tt/"RiAttribute"/ tags possibly attached to the material object of this
geometric object.
<p>
In order to create a tag of type RiAttribute, the type string must be
<tt/"RiAttribute"/. The syntax of the value string is as following:
<p>
<tt/&lt;attrname&gt;,&lt;paramname&gt;,&lt;paramtype&gt;,&lt;param&gt;/
<p>
where attrname is the name of the attribute (e.g. "render") paramname
is the name of the parameter (e.g. "displacementbound") paramtype is a
single character defining the type of the parameter (it may be one of
<tt/f/ - float, <tt/g/ - float pair, <tt/i/ - integer, <tt/j/ - integer
pair, <tt/s/ - string, <tt/c/ - color, <tt/p/ - point) and finally
param is the value of the parameter itself (e.g. a float: "1.2", an
integer value: "3", a string: "on", a color: "1,1,1" or a point:
"0.4,0.5,1.0").
<p>
Some examples for valid RiAttribute tags:
<code>
RiAttribute render,truedisplacement,i,1
RiAttribute dice,numprobes,j,3,3
RiAttribute radiosity,specularcolor,c,0.5,0.5,0.5
</code>
Note that the <tt/"RiAttribute"/ tag handles just a single parameter at once.
Also note that <tt/"RiAttribute"/ tags may be created much more easily
using the menu entry <tt>"Special/Tags/Add RiAttribute"</tt>.
The database of RiAttributes for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>RiOption Tag<label id="riotag">
<p>
The tag type <tt/"RiOption"/ can be used to attach arbitrary RenderMan
interface options to objects. This is handy if you use a renderer with
lots of RiOptions that differ from the standard RiOptions.
However, they will be only used by the RIB exporter if they are attached
to the <tt/"Root"/ object!
The syntax is similar to the <tt/"RiAttribute"/ tag type, see above.
Note that RiOption tags may be created easily using the menu entry
<tt>"Special/Tags/Add RiOption"</tt>.
Tags created with this GUI will always be added to the <tt/"Root"/ object.
It does not have to be selected when the GUI is used.
Furthermore, the database of RiOptions for this GUI may be extended
by editing the ayamrc file, see section
<ref id="ayamrc" name="Ayamrc File">.

<sect2>TC (Texture Coordinates) Tag<label id="tctag">
<p>
The tag type <tt/"TC"/ can be used to attach texture coordinates to
objects or materials.
<p>
<tt/"TC"/ tags attached to a geometric object override
<tt/"TC"/ tags possibly attached to the material object of this
geometric object.
<p>
The <tt/"TC"/ tag always contains a list of eight comma separated
float values, that specify a mapping for four 2D points (a quadrilateral)
in texture space from the default values (0,0), (1,0), (0,1), and (1,1)
to the new specified values.
<p>
Examples:
<code>TC 0,0,10,0,0,10,10,10</code>
Changes the texture coordinate space so that more and smaller tiles
of a texture would be displayed on a primitive.

<code>TC 0,0,0,1,1,0,1,1</code>
Flips the texture coordinate space over two corners.
A shader normally generating vertical stripes will create
horizontal stripes now.

<code>TC 0,1,0,0,1,1,1,0</code>
Turns the texture coordinate space by 90 degrees.
A shader normally generating vertical stripes will create
horizontal stripes now.
<p>
Note that the exact behaviour of an object equipped with a TC tag
depends heavily on the shader and its use of the texture coordinates!
<p>
Note also that using TC tags you change the texture coordinates
of entire primitives only, if you want to change the texture coordinates
of sub-primitives (e.g. of single control points of a NURBS patch)
you would need to use a PV (Primitive Variable) tag instead.
<p>
To ease setting of TC tag values Ayam provides a special editor
as outlined in the next section.

<sect3>Texture Coordinate Editor<label id="tce">
<p>
The texture coordinate editor may be opened using the
main menu entry <tt>"Special/Tags/Edit TexCoords"</tt> and
lets you edit texture coordinate tags in an intuitive way.
<p>
For that, the current texture coordinates are displayed as a black
polygon in a canvas with regard to the original (default) values,
that are displayed in gray.
Small arrows point to positive s and t direction respectively.

<figure loc="ht">
<eps file="pics/tce.ps" height="6cm">
<img src="pics/tce.gif">
<caption>Texture Coordinate Editor</caption>
</figure>
<p>

The <tt/"RotateR"/ and <tt/"RotateL"/ buttons shift the coordinate
values between the four points. This results in a 90 degree
rotation of the texture space.
<p>
The <tt/"FlipS"/ and <tt/"FlipT"/ buttons flip the texture
coordinate values in s and t direction respectively. This is
useful, if you, for example, want to correct a texture mapping for
an image that appears upside down.
<p>
The next buttons allow to move (using <tt/"MoveS"/ and <tt/"MoveT"/)
and scale (using <tt/"ScaleS"/ and <tt/"ScaleT"/) the texture coordinates
by a specific amount that is given in the first entry field.
<p>
The <tt/"Load"/ and <tt/"Save"/ menu buttons allow you to:
<itemize>
<item>load the default texture coordinate values ((0,0), (1,0), (0,1), (1,1)),

<item>load texture coordinates from a selected BPatch object:
The xy coordinates of the four points of the selected BPatch
will be interpreted as st coordinates.
This allows for more complex transformations of the texture coordinates
e.g. rotations about an angle of 45 degrees. For that just create a
BPatch object, rotate it accordingly, then load the coordinates into
the texture coordinate editor.

<item>load TC tags from the selected object,

<item>save the texture coordinates to a BPatch object,

<item>save TC tags to a selected object. Note that it is not
possible to directly save the TC tag to multiple selected objects.
But you can use the property clipboard to copy the tag after saving
to a single object.
</itemize>
Note that the tag numbers in the menu entries count TC tags only.
<p>
The texture coordinate dialog is modeless, it may stay open
while you model. The <tt/"Dismiss"/ button closes the dialog.

<sect2>PV (Primitive Variable) Tag<label id="pvtag">
<p>
The tag type <tt/"PV"/ can be used to attach arbitrary data
to geometric primitives and even sub-primitives.
With the help of primitive variables you can e.g. attach your
own texture coordinates to a NURBS patch primitive or attach distinct
colors to the faces or even to single vertices of a polygonal mesh.
In the latter case, the data is properly interpolated by the renderer
before it is handed over to the shader.
<p>
When rendering, all data defined in a <tt/"PV"/ tag is handed over
to the surface shader that is attached to the respective geometric primitive
using additional shader parameters.
<p>
Note that Ayam does not check, whether your shader actually uses this data!
<p>
The syntax of the value string of a PV tag is as following:
<p>
<tt/&lt;name&gt;,&lt;detail&gt;,&lt;type&gt;,&lt;ndata&gt;,&lt;data&gt;/
<p>
where
<tt/"&lt;name&gt;"/ is the name of the primitive variable;
<tt/"&lt;detail&gt;"/ or storage class should be
<tt/"uniform"/, <tt/"varying"/, <tt/"vertex"/, or <tt/"constant"/;
<tt/"&lt;type&gt;"/ is a single character describing the type of the
data (see also the documentation of the <tt/"RiAttribute"/ tag above);
<tt/"&lt;ndata&gt;"/ is an integer number describing how many data
elements will follow; and
<tt/"&lt;data&gt;"/ is a comma separated list
consisting of a certain number of elements of type <tt/"&lt;type&gt;"/.
<p>
Examples:
<code>PV mycolor,constant,c,1,0,1,0</code>
adds a single color value (0,1,0), which is the same all over the primitive;
<code>PV mys,varying,f,4,0.1,0.2,0.3,0.4</code>
could be used to add a distinct float value to each corner point of a
four point NURBS patch (of order, width, and height 2).
<p>
Note that not all geometric objects currently honour PV tags
on RIB export. The geometric objects currently supporting PV tags
are: SDMesh, PolyMesh, PatchMesh, NURBPatch, and BPatch.
<p>
Furthermore, the number of data elements, which depends on the
detail or storage class, the type of geometric primitive, and the
configuration of the geometric primitive is not checked by Ayam.
Some RIB writing libraries, however, check the number and silently
omit the primitive variable if there are mismatches. Check your
RIB for the presence of the primitive variable after export,
especially, if you are adding or editing PV tags manually!

<sect2>RiHider Tag<label id="rihtag">
<p>
The tag type <tt/"RiHider"/ can be used to choose and parameterize
different algorithms for hidden surface removal.
RiHider tags have to be attached to the root object in order to be used.
The syntax of a RiHider tag is quite similar to a RiAttribute tag:
<tt/"&lt;type&gt;,&lt;parameterlist&gt;"/
where <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
<p>
Example
<p>
A RiHider tag could look like this:
<p>
<code>RiHider hidden,depthfilter,s,midpoint</code>

<sect2>RiDisplay Tag<label id="ridtag">
<p>
The tag type <tt/"RiDisplay"/ can be used to add more output
files of different type (e.g. containing depth-buffer information)
to the scene.
RiDisplay tags have to be attached to the root object in order to be used.
The syntax of a RiDisplay tag is as follows:
<tt/"&lt;name&gt;,&lt;type&gt;,&lt;mode&gt;,&lt;parameterlist&gt;"/,
where name is e.g. a file or device name, type specifies the
destination of the image data (e.g. screen or file), mode
specifies which information should be stored or displayed
(e.g. color values: rgb, or depth values: z),
and <tt/"&lt;parameterlist&gt;"/ is a comma separated list
of triplets consisting of name, type, and value of a parameter.
The name will be automatically changed to <tt/"+name"/ on RIB export
if it does not already start with a plus.
<p>
Example
<p>
A RiDisplay tag could look like this:
<code>RiDisplay imagez.tif,file,z</code>

<sect2>NoExport Tag<label id="noexporttag">
<p>
The tag type <tt/"NoExport"/ can be used to exclude certain objects
from exported RIBs. The value string of this tag is ignored. All
that counts is the presence of the tag. Child objects of objects
with the <tt/"NoExport"/ tag will also be excluded from the RIB.
Since Ayam 1.6, light objects also honour the <tt/"NoExport"/ tag.
Note that regardless of potentially present <tt/"NoExport"/ tags,
RIB archives will be created for all referenced objects all the
time (even if <tt/"NoExport"/ tags are added to all instances).

<sect2>SaveMainGeom Tag<label id="savemaingeomtag">
<p>
The tag type <tt/"SaveMainGeom"/ can be used to save the geometry
of the main window and the toolbox window (if open) with a scene
file. For that the scene saving code checks for the presence of
a <tt/"SaveMainGeom"/ tag for the root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <tt/"SaveMainGeom"/ tag for the root object
after replacing a scene and re-establishes the geometries of
main and toolbox window.

<sect2>TP (Tesselation Parameter) Tag<label id="tptag">
<p>
The tag type <tt/"TP"/ can be used to save tesselation parameters
to objects of type <tt/"NPatch"/. Those tesselation parameters
will be used when the NPatch object is tesselated for e.g. a
conversion to a PolyMesh object. The syntax of the TP tag is:
<tt>"&lt;tmethod&gt;,&lt;tparamu&gt;&lt;tparamv&gt;"</tt>
where <tt/"&lt;tmethod&gt;"/ is an integer value between 1 and 3, describing
which tesselation method to use (1 - ParametricError,
2 - PathLength, and 3 - DomainDistance) and <tt/"&lt;tparamu&gt;"/ and
<tt/"&lt;tparamv&gt;"/ are float values describing the respective parameter
value for the chosen tesselation method. The second parameter value
is ignored for the tesselation methods 1 and 2.
<p>
Note that the syntax of the <tt/"TP"/ tag changed in Ayam 1.9,
the old syntax only allowed one parameter.
<p>
TP tags may be easily created using the tesselation GUI, that can
be started with the main menu entry <tt>"Tools/NPatch/Tesselate"</tt>
(see also section <ref id="tesst" name="The Tesselation Tool">).
<p>
Example
<p>
A TP tag could look like this:
<code>TP 1,0.5,0.6</code>

<sect2>DC (Depth Complexity) Tag<label id="dctag">
<p>
The tag type <tt/"DC"/ is only used by the AyCSG CSG preview plugin
to store the depth complexity of CSG primitives.
The syntax of the DC tag is:
<tt>"&lt;dcval&gt;"</tt>
where <tt/"&lt;dcval&gt;"/ is a positive integer value describing the
depth complexity of the CSG primitive. See also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">
for more information regarding the depth complexity value.
<p>
Example
<p>
A DC tag (valid for e.g. a torus) could look like this:
<code>DC 2</code>

<sect2>NP (New Property) Tag<label id="nptag">
<p>
The tag type <tt/"NP"/ (new property) may be used to add new property
GUIs to single objects. The value of the tag is the name of a new
property. The necessary code to manage the property data and the
windows that make up the property GUI itself have to be present in
the Tcl context of Ayam before the user clicks on the new property in the
property list box.

<sect2>RP (Remove Property) Tag<label id="rptag">
<p>
The tag type <tt/"RP"/ (remove property) may be used to remove GUI access
to a property from single objects. The value of the tag is the name of the
property to be removed. The GUI access will be blocked by simply omitting
the property from the property listbox.
Note well: the property is still present and active in the objects themselves
and values may still be set using the scripting interface.

<sect2>NS (Notify Script) Tag<label id="nstag">
<p>
The tag type <tt/"NS"/ (notify script) may be used to add scripts
to an object, that will be run after the notification callback of
that object fired (because e.g. one of the children of the object changed).
<p>
Example
<p>
A simple NS tag could look like this:
<code>NS puts "notify callback fired"</code>

For security reasons, Ayam offers to disable all script tags when they
are found upon reading of scene files. To disable a tag, Ayam simply
changes its type from <tt/"NS"/ to <tt/"DNS"/ (disabled notify script).
It will not be executed then.
Disabled notify scripts may be enabled after careful inspection using
the main menu entry <tt>"Special/Enable Scripts"</tt>.

<sect2>UMM/VMM (U/V Min Max) Tag<label id="ummtag">
<p>
The tag types <tt/"UMM"/ (u min max) and <tt/"VMM"/ (v min max) may
be used to store additional parametric domain trimming values to
NURBS curve and NURBS patch objects. Note that the GLU NURBS display
modes do not honor those tags, but the RIB export does.
<p>
Example
<p>
An UMM tag could look like this:
<code>UMM 0.4,0.6</code>

<sect2>BP (Bevel Parameters) Tag<label id="bptag">
<p>
The tag type <tt/"BP"/ (bevel parameters) is used by all bevel
supporting tool objects to store their bevel information.
The syntax of the BP tag is:
<tt>"&lt;side,type,radius,revert&gt;"</tt>
where <tt/"&lt;side&gt;"/ is an integer value from 0 - 3
defining the side of the surface, where the bevel should be applied
to, <tt/"&lt;type&gt;"/ is an integer value from 0 - 4 defining
the type of the bevel, <tt/"&lt;radius&gt;"/ is a floating point
value defining the radius of the bevel, and <tt/"&lt;revert&gt;"/
is either 0 or 1 and may be used to revert the bevel.
<p>
Example
<p>
A BP tag could look like this:
<code>BP 0,0,0.1,0</code>

<sect2>Internal Tags
<p>
The following tags are of no general use. They are used
by Ayam internally only.

<sect3>OI (Object ID) Tag<label id="oitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between instance objects and
the original objects they are pointing to.
<p>
The tag type <tt/OI/ is not meant to be used by the end user.
Furthermore, changing the IDs manually avails to nothing as the
tags are rebuilt before every export/save operation.

<sect3>MI (Material ID) Tag<label id="mitt">
<p>
This tag is used by the RIB exporter and the scene storage
facility to establish links between material objects and
the objects they are assigned to.
<p>
The tag type <tt/MI/ is not meant to be used by the end user.
Furthermore, changing the IDs manually avails to nothing as the
tags are rebuilt before every export/save operation.

<sect2>List of Known Tags
<p>
This section contains a comprehensive list of tag names, that are
known since Ayam 1.10 and in the accompanying extensions (plugins).
<p>
<tt>"RiAttribute", "RiOption", "RiHider", "RiDisplay", "NoExport", "TC",
"PV", "SaveMainGeom", "TP", "MI", "OI", "DC", "TM", "NP", "RP", "NS", "DNS",
"UMM", "VMM", "BP", "IDR", "IIDR", "RIDR", "R3IDR", "CIDR", "CCIDR"</tt>
<p>
Documentation on those tags can be found in the sections above.

<sect1>Root Object<label id="rootobj">
<p>
There is always exactly one Root object in the scene.
This object is something special in that it cannot be deleted
or copied.
The Root object holds options global to the scene like RiOptions,
atmosphere and imager shaders. Furthermore, all currently open
view windows are child objects of the Root object.
<p>
If you hide the Root object, the little red/green/blue coordinate system
will not be drawn in any view.
<p>
The global scene options are documented in the following sections.

<sect2>RiOptions Property<label id="rio"><label id="rioptionsprop">
<p>
The RiOptions property carries RenderMan Interface options.
Both, standard and BMRT specific options may be set using this
property. For the sake of brevity only a short description of
the available options will be given here.
Please refer to the documentation of the RenderMan Interface
and the documentation of BMRT for more detailed information about the
options.
The RiOptions property consists of the following elements:
<itemize>
<item><tt/"Width"/, <tt/"Height"/, if greater than zero this value
will be used for the image size instead of the corresponding
dimension of the view window, but only for real RIB export operations,
not for the QuickRender and not for the Render actions in view windows.
QuickRender and Render actions will always use the dimensions of the
view window instead.

<item><tt/"StdDisplay"/, if this is enabled, a standard display
statement will be written to the RIB, which looks like this:

<code>Display "unnamed.tif" "file" "rgba"</code>

If you disable this option, be sure to add atleast one
RiDisplay tag to the root object (see also section
<ref id="ridtag" name="RiDisplay Tag">), otherwise your RIB will
not contain a Display statement. This option has no effect on
RIBs created by the QuickRender and Render actions in view windows.

<item><tt/"Variance"/, maximum allowed variance of two pixel values.
The default 0.0 causes no setting in the RIB. If the variance is > 0.0
no pixel samples setting will be written to the RIB. Various
sources discourage the use of variance based sampling, because
e.g. the number of samples actually taken (and therefore the rendering
time) might not easily be predicted anymore.

<item><tt/"Samples_X"/, <tt/"Samples_Y"/ number of samples taken per
pixel.

<item><tt/"FilterFunc"/, function used to filter final pixel values.

<item><tt/"FilterWidth"/, <tt/"FilterWidth"/ size of the filter.

<item><tt/"ExpGain"/, Exposure

<item><tt/"ExpGamma"/, Exposure Gamma

<item><tt/"RGBA_ONE"/, <tt/"RGBA_MIN"/, <tt/"RGBA_MAX"/,
<tt/"RGBA_Dither"/, specify quantisation and dithering

<item><tt/"MinSamples"/, <tt/"MaxSamples"/, minimum and maximum number
of samples per pixels.

<item><tt/"MaxRayLevel"/, maximum number of recursive rays.

<item><tt/"ShadowBias"/, minimum distance that one object has to
be in order to shadow another object.

<item><tt/"PRManSpec"/, toggles behaviour of BMRT's specular() function
between PRMan compatible (default) and RiStandard compatible.

<item><tt/"RadSteps"/, number of radiosity steps, the default 0 leads
to no radiosity calculations to be performed.

<item><tt/"PatchSamples"/, minimum number of samples per patch to
calculate the radiosity form factors for this patch.

<item><tt/"Textures"/, <tt/"Shaders"/, <tt/"Archives"/ and <tt/"Procedurals"/
are search paths for the renderer.

<item><tt/"TextureMem"/ and <tt/"GeomMem"/ determine how much
memory rendrib (from BMRT) should use at maximum to cache textures and
tesselated geometry.
</itemize>

<sect2>Imager, Atmosphere Property<label id="imager">
<p>
The Imager and Atmosphere properties let you define shaders for the
Root object, please refer to section
<ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Imager shaders are executed once for every rendered pixel,
they may e.g. be used to set a specific background color.
<p>
Atmosphere shaders are volume shaders that
may be used to implement global atmospheric
optical effects like fog.

<sect1>View Object<label id="viewobj">
<p>
Every view window (see also section
<ref id="viewwin" name="Anatomy of a View">)
has a corresponding view object as a child object of the root object.
You can change camera settings, the type of the view,
and other things related to the view using the properties of the view object.
Note that deleting the object that represents a view, will not
close the view window. You will just lose a way to configure it.
Please, do not mess with the objects in other ways (e.g. copy them),
you are asking for trouble otherwise!
<p>
Each view is associated with a virtual camera.
The type of the view determines the Up-vector of that camera.
If the type is "Top" the Up-vector corresponds to the world
Z-axis, else the world Y-axis.
The type of the view, additionally, determines the so called input plane
of the view. Interactive modelling actions in a view are limited to that
input plane (unless the view is switched to local modelling; available since
Ayam 1.4; see also section <ref id="editlocal" name="Editing in Local Space">).
The standard input planes are as following: Front - XY-plane,
Side - ZY-plane, Top - XZ-plane, Trim - XY-plane.
<p>
In perspective views no interactive modelling actions are possible,
but you may position the camera and pick objects.
<p>
Views of type <tt/"Trim"/ are very special. They are used to edit
trim curves of NURBPatch objects only. They display that trim curves as
normal NURBCurves when the current level is inside a NURBPatch.
The extensions of the patch in parameter-space are drawn as a rectangle.
The trim curves should completely lie inside this rectangle.
Note that picking of objects currently does not work in views of type
<tt/"Trim"/.
<p>
View objects act in special ways, when certain objects are dropped
onto them in the tree view:
<p>
When a camera object is dropped onto a view object
using Drag-and-Drop in the tree view
the camera settings of the camera object will
be copied to the views camera.
<p>
When a light object of type <tt/"Spot"/ is dropped onto a view object
using Drag-and-Drop in the tree view
the views camera will be changed, so that
the user looks along the light to see what objects of the scene
are lighted by the light object (this works best
with perspective views that have equal width and height).
<p>
Since Ayam 1.8 it is possible, to directly drag objects from the
tree view to a view window, for geometric objects, the view then
performs a zoom to object operation, for cameras and light sources
the views camera will be changed accordingly (see the description
of Drag-and-Drop with view objects above).

<sect2>Camera Property<label id="camp"><label id="cameraprop">
<p>
This section describes all elements of the <tt/"Camera"/ property:
<itemize>
<item><tt/"From"/ is the point where the camera (that is attached
to the view) is situated.
<item><tt/"To"/ is the point the camera is looking to.
<item><tt/"Up"/ is the up vector of the camera.
<item><tt/"Near"/ defines the near clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Near should always be positive for perspective views, and
smaller than far.
<item><tt/"Far"/ defines the far clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Far should always be bigger than near.
<item><tt/"Roll"/ defines an angle by which the camera is rotated
around the axis that is defined by the points from and to.
<item><tt/"Zoom"/ is a zoom factor.
</itemize>

Note that the up vector is not checked for erroneous values
(e.g. pointing in the direction of from-to) when applying the changes
of the <tt/"Camera"/ property.

<sect2>ViewAttrib Property<label id="vat"><label id="viewattribprop">
<p>
This section describes the elements of the <tt/"ViewAttrib"/ property:
<itemize>
<item><tt/"Type"/ specifies the type of the view. Front, Side, Top (all
parallel), Perspective and Trim (again parallel) may be selected.
<item><tt/"Width"/ and <tt/"Height"/ control the size of the view
window.
<item><tt/"Redraw"/ toggles automatic redrawing of the view.
If this is disabled, no drawing takes place in the view until an
explicit redraw is requested (using the view menu, or the shortcut
<tt>&lt;Ctrl+d&gt;</tt>).
<item><tt/"Shade"/ toggles shading of surfaces.
Note that the lighting is in no way an exact (or even similar)
representation of the light information you specified with Light objects!
Instead, a single light source, located at the camera origin
(a headlight), will be used!

<item><tt/"DrawSel"/ toggles drawing of selected objects. If this is
enabled, only the current selected objects will be drawn.
<item><tt/"DrawLevel"/ toggles drawing of the objects of the current
level only. If this is enabled, only the objects of the current
level will be drawn.
<item><tt/"Grid"/ is the grid size, 0.0 means no grid.
<item><tt/"DrawGrid"/ toggles drawing of the current grid.
<item><tt/"UseGrid"/ toggles, whether the current grid should be
used by the interactive modelling actions.
<item><tt/"Local"/ enables editing in local object space.
See also section <ref id="editlocal" name ="Editing in Local Space">.

<item><tt/"DrawBG"/ controls whether the background image should
be drawn.
<item><tt/"BGImage"/ is the name of a TIFF file, that will
be used as texture for the background image. Ayam will read
this image once when you apply the changes to the
<tt/"ViewAttrib"/ property
but reread
the image file if the notification callback of the view object
is invoked (e.g. using the main menu entry
<tt>"Tools/Force Notification"</tt>).
</itemize>

<sect1>Camera Object<label id="cameraobj">
<p>
Camera objects are used to temporarily save camera settings
of views.
Therefore, they has just have two properties
explained above, see sections <ref id="camp" name="Camera"> and
<ref id="attrs" name="Attributes Property">.
<p>
When a view object is dropped onto a camera object using Drag-and-Drop
in the tree view, the camera settings from the view will be copied
to the camera object.

<sect1>Box Object<label id="boxobj">
<p>
A solid box, centered at the origin of the object coordinate system.
This object will always be exported as solid primitive in RIBs;
consisting of six bilinear patches.

Since Ayam 1.8.2, a box object may be converted to three NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.

The following parameters further control the shape of a box:

<sect2>BoxAttrib Property<label id="bxp"><label id="boxattribprop">
<p>
<itemize>
<item><tt/"Width"/ is the width of the box (size of the box in
direction of the X axis of the objects coordinate system).
<item><tt/"Length"/ is the length of the box (size of the box in
direction of the Z axis of the objects coordinate system).
<item><tt/"Height"/ is the height of the box (size of the box in
direction of the Y axis of the objects coordinate system).
</itemize>

<sect1>Quadric Primitives<label id="qprim">
<p>
<figure loc="ht">
<eps file="pics/primitives.ps" height="7cm">
<img src="pics/primitives.gif">
<caption>Box, and Quadric Primitives</caption>
</figure>
<p>

<sect2>Sphere Object<label id="sphereobj">
<p>
A sphere, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple sphere (depending on the <tt/"Closed"/ parameter
of the SphereAttrib property) in RIBs.

Since Ayam 1.8.2, a sphere object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the sphere.

The following parameters further control the shape of a sphere:

<sect3>SphereAttr Property<label id="spattr"><label id="sphereattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and <tt/"ZMin"/, <tt/"ZMax"/ or
<tt/"ThetaMax"/ have other than the default values,
a single sphere will be written (in the worst case) as a
CSG hierarchy of two spheres, two cylinders and eight disks!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the sphere, default is 1.
<item><tt/"ZMin"/ may be used to chop the sphere off at a certain
place at Z.
<item><tt/"ZMax"/ may be used to chop the off at a certain
place at Z.
<item><tt/"ThetaMax"/ is the sweeping angle of the sphere default is 360.
</itemize>

<sect2>Disk Object<label id="diskobj">
<p>
A disk, centered at the origin of the object coordinate system.
This object will always be exported as simple disk in RIBs.

Since Ayam 1.8.2, a disk object may be converted to a NURBS patch
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the disk.

The following parameters further control the shape of a disk:

<sect3>DiskAttr Property<label id="dkp"><label id="diskattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the disk, default is 1.
<item><tt/"ZMin"/ displaces the disk along the Z axis, default is 0.
<item><tt/"ThetaMax"/ is the sweeping angle of the disk, default is 360.
</itemize>

<sect2>Cone Object<label id="coneobj">
<p>
A cone, centered at the origin of the object coordinate system,
with the base at the XY plane.
This object will be exported as solid primitive or as
simple cone (depending on the <tt/"Closed"/ parameter
of the ConeAttrib property) in RIBs.

Since Ayam 1.8.2, a cone object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cone.

The following parameters further control the shape of a cone:

<sect3>ConeAttr Property<label id="cnp"><label id="coneattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cone will be written (in the worst case) as a
CSG hierarchy of a cone, a disk and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cone at the base, default is 1.
<item><tt/"Height"/ is the height of the cone, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cone, default is 360.
</itemize>

<sect2>Cylinder Object<label id="cylinderobj">
<p>
A cylinder, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple cylinder (depending on the <tt/"Closed"/ parameter
of the RiCylinderAttr property) in RIBs.
Note that the OpenGL representation of this object
does not reflect the settings of the following parameters
of the CylinderAttrib property: <tt/"Closed"/ and
<tt/"ThetaMax"/.

Since Ayam 1.8.2, a cylinder object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the cylinder.

The following parameters further control the shape of a cylinder:

<sect3>CylinderAttr Property<label id="cyp"><label id="cylinderattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single cylinder will be written (in the worst case) as a
CSG hierarchy of a cylinder, two disks and two polygons!
But it may be used in CSG operations, safely.
<item><tt/"Radius"/ is the radius of the cylinder, default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the cylinder, default is 360.
</itemize>

<sect2>Torus Object<label id="torusobj">
<p>
A torus, centered at the origin of the object coordinate system.
A torus is a donut like shape, that results from sweeping
a small circle ( that has been displaced along X sufficiently )
around the Z axis.
This object will be exported as solid primitive or as
simple torus (depending on the <tt/"Closed"/ parameter
of the RiTorusAttr property) in RIBs.

Since Ayam 1.8.2, a torus object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the torus.

The following parameters further control the shape of a torus:

<sect3>TorusAttr Property<label id="top"><label id="torusattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"PhiMin"/, <tt/"PhiMax"/ or <tt/"ThetaMax"/ have different than the
default values,
a single torus will be written (in the worst case) as a
CSG hierarchy of a torus, two disks and two hyperboloids!
But it may be used in CSG operations, safely.
<item><tt/"MajorRad"/ is the radius of the torus, measured
from the Z axis to the center of the swept smaller circle, default is 0.75.
<item><tt/"MinorRad"/ is the radius of the swept circle, default is 0.25.
<item><tt/"PhiMin"/ determines an angle to limit the swept circle,
default is -180.
<item><tt/"PhiMax"/ determines an angle to limit the swept circle,
default is 180.
<item><tt/"ThetaMax"/ is the sweeping angle of the torus, default is 360.
</itemize>

<sect2>Paraboloid Object<label id="paraboloidobj">
<p>
A paraboloid, centered at the origin of the object coordinate system.
This object will be exported as solid primitive or as
simple paraboloid (depending on the <tt/"Closed"/ parameter
of the RiParaboloidAttr property) in RIBs.

Since Ayam 1.8.2, a paraboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the paraboloid.

The following parameters further control the shape of a paraboloid:

<sect3>ParaboloidAttr Property<label id="pap"><label id="paraboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that if this option is in use and
<tt/"ZMin"/, <tt/"ZMax"/ or <tt/"ThetaMax"/ have different
than the default values,
a single paraboloid will be written (in the worst case) as a
CSG hierarchy of a paraboloid, two disks and two bicubic patches!
But it may be used in CSG operations, safely.
<item><tt/"RMax"/ is the radius of the paraboloid at a Z of <tt/"ZMax"/,
default is 1.
<item><tt/"ZMin"/ determines the Z location of the base, default is -1.
<item><tt/"ZMax"/ determines the Z location of the top, default is 1.
<item><tt/"ThetaMax"/ is the sweeping angle of the paraboloid, default is 360.
</itemize>

<sect2>Hyperboloid Object<label id="hyperboloidobj">
<p>
A hyperboloid, centered at the origin of the object coordinate system.
This shape will be created by sweeping a line specified by two
points in space around the Z axis.
This object will be exported as solid primitive or as
simple hyperboloid (depending on the <tt/"Closed"/ parameter
of the RiHyperbAttr property) in RIBs.

Since Ayam 1.8.2, a hyperboloid object may be converted to NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>. This conversion
obeys all parameters of the hyperboloid.

The following parameters further control the shape of a hyperboloid:

<sect3>HyperboloidAttr Property<label id="hyp"><label id="hyperboloidattrprop">
<p>
<itemize>
<item><tt/"Closed"/ toggles whether the object should
be automatically sealed (closed) when exported to RIB.
Note that due to a bug in BMRT that is still present in V2.3.6
this option does not work properly when
<tt/"ThetaMax"/ has a different than the default value and the
hyperboloid has no displacement shader. In fact, using a displacement
shader with a km (amount of displacement) of 0.0 is a work-around
for this bug (found by T. E. Burge).
Also note that if this option is in use and
<tt/"ThetaMax"/ has a different than the default value,
a single hyperboloid will be written (in the worst case) as a
CSG hierarchy of a hyperboloid, two disks and two bilinear patches!
<item><tt/"P1_X"/, <tt/"P1_Y"/ and <tt/"P1_Z"/, define point one,
default is (0, 1, -0.5).
<item><tt/"P2_X"/, <tt/"P2_Y"/ and <tt/"P2_Z"/, define point two,
default is (1, 0, 0.5).
<item><tt/"ThetaMax"/ is the sweeping angle of the hyperboloid, default is 360.
</itemize>

<sect1>Level Object<label id="levelobj">
<p>
Level objects may be used to build object hierarchies and perform CSG
operations.
<p>
Ayam does not offer a layer concept, but by grouping objects using
levels and the hide/show tools, layer functionality may be emulated
to a certain extent.
<p>
Organizing the scene and working in levels also increases the speed
of object tree updates, as only the current level and its sub-levels
are subject to a tree update if the object hierarchy changes.
<p>
Note that child objects of a level inherit the levels transformations
attributes and shaders. Inheritance of e.g. transformations means:
If you have a NURBS patch in a level that is translated to (10,0,0),
the origin of the local coordinate system of the NURBS patch
will be situated at (10,0,0). If you decide to move the patch by a
value of 5 in X direction by setting a corresponding value in the
Transformations property of the patch object, the local coordinate
system of the patch will be placed at (15,0,0) in world coordinates.
<p>
Note also that since Ayam 1.12, Level objects provide their child
objects to their parent objects as a list. This means the following
hierarchy is now valid:
<code>
+-Skin
 +-Level
  | NCurve
  | NCurve
  | ICurve
  \ NCurve 
</code>
All NURBS curves and objects that may be converted to NURBS curves
(in this example: the ICurve) will be provided to the Skin by the
Level object. Transformation attributes of the Level will be added
to the provided objects. Objects that do not provide the wanted
type will be silently ignored.

<sect2>LevelAttr Property<label id="lep"><label id="levelattrprop">
<p>
Levels do not have many object type specific properties, you may just
modify the type of the level using the attribute <tt/"Type"/.
<p>
Levels of type <tt/"Level"/ just group objects and inherit attributes.
<p>
Levels of type <tt/"Union"/, <tt/"Intersection"/, and <tt/"Difference"/
are used to build CSG hierarchies. Additionally, they inherit attributes.
Note that Ayam is currently not able to correctly display the results
of CSG operations, all objects are always drawn completely, even though
a CSG operation cut parts away.
However, since Ayam 1.8 there is a plugin available that is able to
preview the results of CSG operations, see also section
<ref id="aycsg" name="CSG preview using the AyCSG plugin">.
<p>
The object hierarchy to cut away a part of a box using a sphere
looks like this:
<code>
+-Level_of_Type_Difference(Level)
 | Box
 \ Sphere
</code>
In contrast to the RenderMan interface, more than two objects
may be arguments of a CSG operation:
<code>
+-Level_of_Type_Difference(Level)
 | Box
 | Sphere
 \ Sphere
</code>
In this example, the two spheres would cut away parts of the box.
<p>
New solid primitives may be created with levels of type <tt/"Primitive"/.
Note that Ayam is not able to check, whether your new primitive obeys
the rule of total closeness. Furthermore, it is not necessary to
enclose normal child objects of CSG levels in primitive levels for
RIB export. This is done by Ayam automatically where needed.

<sect1>Material Object<label id="materialobj">
<p>
Material objects are used to attach RiAttributes and shaders to
geometric objects.
<p>
When geometric objects are dropped onto a material object using
Drag-and-Drop in the tree view they will be connected to this
material object.
<p>
When geometric objects are connected to a material object this material
object may not be deleted.

<sect2>RiAttributes Property<label id="riattrs"><label id="riattributesprop">
<p>
Using this property standard and BMRT specific attributes may be set.
Please refer to the documentation of the RenderMan interface
and the documentation of BMRT for more detailed information about the
RenderMan specific attributes.

<itemize>
<item><tt/"Color"/, the color of the object. If you set one of the
entries to a negative value (e.g. -1), the color will not be set at all
for this object.
<item><tt/"Opacity"/, the opacity of the object, the default
255 255 255 means the object is totally opaque. If you set one of the
entries to a negative value (e.g. -1), the opacity will not be set at all
for this object.
<item><tt/"ShadingRate"/, determines how often shaders are evaluated for
a sample.
<item><tt/"Interpolation"/, determines how return values computed
by the shaders are interpolated across a geometric primitive.
<item><tt/"Sides"/, determines how many sides of the surface of a
geometric primitive should be shaded.
<item><tt/"BoundCoord"/, sets the coordinate system in which the
displacement bound is expressed.
<item><tt/"BoundVal"/, displacement bound value.
<item><tt/"TrueDisp"/, toggles true displacements on or off. Default off.
<item><tt/"CastShadows"/, determines how the object casts shadows:
the default <tt/"Os"/ means the object casts shadows according to it's
opacity; <tt/"None"/ object does not cast any shadows; <tt/"Opaque"/
the object is completely opaque and casts shadows; <tt/"Shade"/
the object has a complex opacity pattern determined by it's surface
shader, that is used in shadow calculations.
<item><tt/"Camera"/, <tt/"Reflection"/, and <tt/"Shadow"/ toggle
visibility attributes.
</itemize>

<sect2>Surface, Displacement, Interior, Exterior Property<label id="matshader">
<p>
These properties let you define shaders for the material object, please
refer to section <ref id="shd" name="Shader Properties">
for information on how to deal with shader property GUIs.
<p>
Surface shaders may be used to procedurally encode lighting models and
textures. Displacement shaders may procedurally deform the object while
rendering. Interior and Exterior shaders are so called volume shaders
that may be used to capture special optical effects, encoding how light
is affected while passing through an object.

<sect2>MaterialAttr Property<label id="matattr"><label id="materialattrprop">
<p>
The MaterialAttr property contains attributes related to the
management of material objects:
<itemize>
<item><tt/"Materialname"/ denotes the name of the material. Note
that material names have to be unique in a scene. If two
materials with the same name exist, only the first material
created with this name is "registered" and thus may be connected
to geometric objects.
<item><tt/"Refcount"/ shows how many geometric objects are connected to
(are of) this material. Note that connected or referring geometric objects
not necessarily have to live in the scene, they may as well temporarily
reside in the object clipboard.
<item><tt/"Registered"/ displays whether this material may be
connected to geometric objects, see the discussion about material names above.
</itemize>

<sect1>Light Object<label id="lightobj">
<p>
Light objects let you bring light into your scenes.
<p>
In contrast to the light sources as defined in the RenderMan
interface, normal Ayam light sources are always global. This
means, regardless of the place of a light source in the scene
hierarchy, it will always light all other objects.
<p>
Note that you cannot preview the effect of a light source in
shaded Ayam views, currently. However it is possible to estimate
the effect of a spot light source by simply dropping it into
a perspective view window, the view will then show you the objects
lighted by the spot.
<p>
The behaviour of a light source object depends heavily on the type
of the light source.
There are four different light types available in Ayam:
<tt/"custom"/, <tt/"point"/, <tt/"distant"/ and <tt/"spot"/.
<p>
Custom Lights:<label id="cul">
<p>
Light sources of type custom use the attached light shader.
<p>
Note that Ayam is trying to guess from the names of the light shader
arguments to draw the light.
The names <tt/"from"/ and <tt/"to"/ denote location and destination
of the lightsource. You should not use these names for other things
in your light shaders!
<p>
Point-, Distant-, and Spotlights:<label id="pdsl">
<p>
These (standard) light sources have well defined parameters that
will be displayed in the <tt/"LightAttr"/ property.
Please refer to the RenderMan documentation for more information
about the standard light sources (see section
<ref id="secref" name="references">).

<sect2>LightAttr Property<label id="lip"><label id="lightattrprop">
<p>
Depending on the type of the light source, the light attribute
property contains different parameters. Parameters that
are not displayed will not be used on RIB export, consequently.
<p>
Using <tt/"Type"/ you can change the type of the light source.
When you change the type of a light source, the property GUI will
be adapted to show only the options available for the new light
source type, but only after you used the <tt/"Apply"/-button.
<p>
<tt/"IsOn"/ allows you to switch the light off or on. The default
value is on.
<p>
<tt/"IsLocal"/ controls whether the light source should light
just local objects (objects, that are defined in the same level
in the scene hierarchy as the light source object or below it) or
all objects in the scene.
The default is off, all objects in the scene are lighted!
The <tt/"IsLocal"/ attribute is ignored for lights that are
defined in the root level of the scene. Mind also that shadow maps
will always contain shadows from all objects in the scene,
regardless of local lights.
<p>
Using the light attribute <tt/"Shadows"/ you may determine
whether the lightsource should cast shadows.
The default is off, no shadows! Note that this option will not
magically enable shadows on renderers that create shadows by
shadow maps. It will merely be interpreted by raytracing
renderers like BMRT.
<p>
The attribute <tt/"Samples"/ determines the number of times to sample
an area light source, independent of pixel samples, the default value
is 1. This attribute is available for custom lights only!
<p>
<tt/"UseSM"/ determines, whether shadow maps should be created
and used for this light source. The resolution of the
shadow map may be determined by the attribute <tt/"SMRes"/. If
<tt/"SMRes"/ is 0, a default of 256 by 256 pixels will be used.
These options are for renderers that do not support raytraced
shadows like PRMan or Aqsis only.
<p>
For lights of type <tt/"Distant"/ the <tt/"Scale"/ attributes
of the <tt/"Transformations"/ property of the light
object may be used to scale the camera transformation
used for the creation of the corresponding shadow map.
Values of 1 for <tt/"Scale_X"/ and <tt/"Scale_Y"/ create
a shadow map that is sized 1 by 1 units in world space.
<p>
All other parameters that may appear in the <tt/"LightAttr"/
property are the standard parameters for the standard RenderMan
light sources: distant, point, and spot:
<itemize>
<item><tt/"From"/ and <tt/"To"/ denote position and target of the light
source as point in space. You may edit both points using standard
point editing actions (see also section
<ref id="iac" name="interactive actions">).
<item><tt/"Color"/ is the color of the light emitted by the light source.
<item><tt/"Intensity"/ is the intensity of the light emitted by the
light source. Note that the standard point and spot lights have
a quadratic falloff (with distance), that requires the intensity
to be set to quite high values in order to achieve some
illumination effect (e.g. around 30 for the standard distance of
<tt/"From"/ and <tt/"To"/ of a spot light).
<item><tt/"ConeAngle"/ is the angle of the beam of a spot light.
<item><tt/"ConeDAngle"/ (cone delta angle) is the angle that determines a
falloff area at the edge of the beam of a spot light.
<item><tt/"BeamDistrib"/ (beam distribution) determines, how the light
falls off in the beam of the spot light. Larger values result in narrower
lighted areas.
</itemize>

In order to ease the parameterisation of spot lights, you may drop the
light source object on to a view object (preferably one with a perspective
viewing transformation and with equal width and height) to see what objects
of the scene are actually lighted by the light object.

<sect2>Using ShadowMaps<label id="shadowmaps">
<p>
Using shadow maps requires the global preference setting
<tt>"RIB-Export/ShadowMaps"</tt> to be switched on.
Furthermore, for each light source for which a shadow map should be
created, the attributes <tt/"IsOn"/ and <tt/"UseSM"/ have to be
switched on.
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Automatic"</tt>,
Ayam will create a special version of the RIB on export, that creates
all shadow maps automatically. This is done, by rendering depth images
from the position of every light source that casts shadows.
Special light source shaders later pick up these depth images
and calculate shadows.
This approach implies, that the scene is rendered multiple times.
To reduce the size of the RIB, the objects to be rendered
are written to a second RIB file named <tt>"&lt;scene&gt;.obj.rib"</tt>.
This file is read from the main RIB several times via
<tt>"ReadArchive"</tt>. The RIB contains multiple frames which may
be rendered separately.
To help you picking the right frame number for the image (e.g.
to re-render just the image),
a comment with the frame number of the last frame (the image) will be
written as last statement to the RIB.
<p>
Because multiple files (RIBs and shadow maps) are used, it is suggested
to change the preference setting <tt>"RIB-Export/RIBFile"</tt> to
<tt>"Scenefile"</tt>. This will strip the leading absolute path component
from the filenames so that you may move the scene from one
system to another more easily.
<p>
If the preference setting <tt>"RIB-Export/ShadowMaps"</tt> is set to
<tt>"Manual"</tt>,
the exported scene will not render the shadow maps but rather
expects them to be present already. You can create them manually
(hence the name <tt>"Manual"</tt>) using the view menu entry
<tt>"View/Create ShadowMaps"</tt> or the main menu entry
<tt>"Special/RIB-Export/Create ShadowMaps"</tt>.
The manual approach has the advantage,
that the shadow maps will not be re-created each time you render
the scene.
<p>
Ayam supports three different methods for the creation of shadow maps
for certain types of light sources: point, distant, and spot:
<p>
The point method is used with
lights of type <tt>"Point"</tt> and custom lights that have a light
shader argument named "from".
Six shadow maps pointing in all possible axis aligned
directions and named <tt>"&lt;rib&gt;.point&lt;num&gt;_&lt;dir&gt;.shd"</tt>
(where <tt>"&lt;rib&gt;"</tt> is the name of the RIB,
<tt>"&lt;num&gt;"</tt> is the number of the light source that makes
use of shadow maps and <tt>"&lt;dir&gt;"</tt> is one of
<tt/"x+"/, <tt/"x-"/, <tt/"y+"/, <tt/"y-"/, <tt/"z+"/, or <tt/"z-"/)
will be created.
<p>
The distant method is used with lights of type <tt>"Distant"</tt>
and custom lights that have a light
shader argument named "from" and a light
shader argument named "to".
One shadow map is created and named
<tt>"&lt;rib&gt;.dist&lt;num&gt;.shd"</tt>.
By default, the size of the shadow map is 1 by 1 units in world space,
but this may be adapted using the scale transformation attributes of
the light object.
<p>
The spot method is used with lights of type <tt>"Spot"</tt>
and custom lights that have a light
shader argument named "from", a light
shader argument named "to", and a light shader argument named "coneangle".
One shadow map is created and named
<tt>"&lt;rib&gt;.spot&lt;num&gt;.shd"</tt>.
The spot method uses the cone angle (and additionally the delta cone
angle, if present) argument to determine the size of the shadow map
in world space.
<p>
If a light object of type <tt>"Spot"</tt>, <tt>"Distant"</tt> or
<tt>"Point"</tt> is used, Ayam automatically changes the name of the
exported light shader to <tt>"shadowspot"</tt>, <tt>"shadowdistant"</tt>,
and <tt>"shadowpoint"</tt> respectively. Additionally, the shader
will be parameterized to use the created shadow maps.
If the light source is of type <tt>"Custom"</tt>, no automatic renaming
and adjusting of the shader takes place. This means, you have
to make sure that the shader really uses the shadow maps, by
selecting the right shader and parameterizing it accordingly.
See the discussion above for the names of the shadow map files.
Those file names, most probably, will have to be entered as parameter
to the light shader.
<p>
For example, you will not get any shadows if you use a light source of
type <tt/"Custom"/ with the normal <tt/"distantlight"/ shader attached,
even though Ayam is able to create the necessary shadow maps. The
normal <tt/"distantlight"/ shader just makes no use of the shadow maps.
You have to manually switch to a shader that
makes use of the shadow maps (<tt/"shadowdistant"/ in this case) to get
shadows.
<p>
Here is a short example for a scene using a shadow map:
<enum>
<item>Go to the preferences (section <tt/"RIB-Export"/) and set
<tt/"ShadowMaps"/ to <tt>"Automatic"</tt>.
<item>Create two boxes.
<item>Open the <tt/"Transformations"/ property of the second box.
<item>Translate it by X: 0.0, Y: -1.0, Z: 0.0.
<item>Scale it by X: 4.0, Y:1.0, Z:4.0.
<item>Create a light source.
<item>Open the <tt/"LightAttr"/ property.
<item>Change the type to <tt/"Spot"/. Press <tt/"Apply"/.
<item>Now change the parameters of the spot light to <tt/"IsOn"/: Yes,
<tt/"Intensity"/: 18.0,
<tt/"UseSM"/: Yes, <tt/"ConeAngle"/: 45.0, <tt/"BeamDistrib"/: 3.0,
<tt/"From"/: -2, 2, 2, <tt/"To"/: 1, 0, -1;
leave all other parameters at their default values.
<item>Create a new view and make it perspective (Menu:
<tt>"Type/Perspective"</tt>).
<item>Export a RIB from that perspective view (Menu:
<tt>"View/Export RIB"</tt>).
<item>Render the RIB with a RenderMan compliant renderer, that uses
shadow maps, e.g. Photorealistic RenderMan (prman) or Aqsis.
</enum>

This scene is distributed with Ayam as an example scene named
<tt>"shadowmaps.ay"</tt>.
<p>
Note that for Aqsis you should add a RiHider hidden,depthfilter,s,midpoint
tag to your root object if shadow maps are in use. Other renderers might
require additional tweaking using shadow bias RiOption tags.
Please consult the documentation of your renderer on how to achieve
the best results using shadow maps.
<p>
Do not render directly from a view window to the display when the
<tt/"ShadowMaps"/ <tt/"RIB-Export"/ preference option is set to
<tt>"Automatic"</tt>.
Your renderer may not write image files when the command line option
to render directly to the display (-d for rendrib, or -fb for Aqsis) is
in use. Consequently, this may also inhibit writing of the shadow maps,
so that the resulting image will look wrong, or the renderer will render
the shadow map to the display and simply stop.

<sect2>Using AreaLights<label id="alob">
<p>
The common idealized standard light sources <tt/"Point"/, <tt/"Distant"/
and <tt/"Spot"/ have no own geometric extension in space.
This means, shadows resulting from such light sources will have sharp
borders which does not look too naturally.
Good looking soft shadows may be generated using area lights.
<p>
Area lights may be created by simply placing a single object as child
object of a <tt/"Custom"/ light object that has the <tt>"arealight"</tt>
shader attached:
<code>
+-AreaLight(Light)
 \ AreaLightGeometry(Sphere)
</code>
This child object determines the geometry of the lightsource.
According to L. Gritz, Spheres and Cylinders work best as area light
geometry for BMRT, because of special sampling code.
<p>
An example:
<itemize>
<item>Create a custom light object.
<item>Assign the arealight light shader to it.
<item>Create a sphere.
<item>Drag-and-Drop the sphere onto the Light object so that it becomes
a child of the light object.
<item>Transform the sphere object to your hearts content; the position
and size of the object determines the position and size of the lightsource!
</itemize>

There is an example scene named <tt>"arealight.ay"</tt> distributed with Ayam.

<sect1>NCurve (NURBS Curve) Object<label id="ncurveobj">
<p>
The NCurve object is the most used basic object for NURBS modelling
in Ayam because NURBS curves are used to build more complex smoothly
shaped surfaces using operations like extrude, revolve, sweep or skin.
NURBS curves can be open or closed and used to emulate Bezier and
B-Spline curves easily. In addition, for easier modelling, they
support multiple points as explained in the next section.

<sect2>Multiple Points<label id="ncurvemp">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A NURBS Curve with Multiple Points (big handles)</caption>
</figure>
<p>
The NURBS curves of Ayam support so called multiple points.
A multiple point is made of a number of different control points that have
the same coordinates.
Modelling actions will always modify all the control points that
make up a multiple point.
Multiple points will be drawn with a bigger handle than normal points
(see image above).
They may e.g. be used to create closed curves. Note that the control
points that make up a multiple point do not have to be consecutive
(in the control point vector of the NURBS curve).
Multiple points may be created using the collapse tool,
and split up again using the explode tool (see sections
<ref id="collt" name="The Collapse Tool"> and
<ref id="explt" name="The Explode Tool"> for more information regarding
those tools).
Note that even though you might have exploded some multiple points
Ayam will re-create them automatically on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
property if they still have identical coordinate values.
In other words, you should immediately edit the control
points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again!
You may also totally inhibit creation of multiple points for a
NURBS curve using the attribute <tt/"CreateMP"/.

<sect2>NCurveAttr Property<label id="ncattr"><label id="ncurveattrprop">
<p>
The first section of the NCurveAttr property contains curve specific
settings:<p>
<itemize>
<item><tt/"Type"/: This attribute replaces the <tt/"Closed"/
attribute since Ayam 1.9.
<p>
The type <tt/"Open"/ is for the standard open NURBS curve.
<p>
If the type is <tt/"Closed"/, the first and last control point of
the curve will be made identical. This will close the curve but
without any guaranteed continuity.
Such a closed curve will e.g. be created by the NURBS circle tool.
It is important to know, that identical start/end control points
alone can not guarantee that the curve is closed if the knot vector
is not clamped. If in doubt, use the clamp tool or a knot vector
of type NURB.
<p>
If the type is <tt/"Periodic"/, the last p control points of the curve
will be made identical to the first p where p is the degree of the
curve (read order-1). This will close the curve with guaranteed continuity.
Note that for a cubic spline (order 4) you will need atleast 6 control
points to make it periodic. It is important to know, that the multiple control
points alone can not guarantee that the curve is closed if the knot type
of the curve is Custom; if you really want a closed curve switch to knot type
B-Spline.
<p>
You may want to enable the creation of multiple points using the
<tt/"CreateMP"/ attribute (see below) for closed and periodic curves so that
single point editing actions modify all multiple control points.
<item><tt/"Length"/ is the number of control points of the curve.
<item><tt/"Order"/ is the order of the curve.
<item><tt/"Knot-Type"/: Using <tt/"Knot-Type"/ you may select from
NURB, Bezier, B-Spline and Custom knot sequences.
If the knot type is not Custom, the next setting
<tt/"Knots"/ will be ignored. Instead, knots of type NURB, Bezier or
B-Spline will be generated automatically.
<p>
How do the different knot types affect the curve?
<p>
The knot type NURB will generate knot values ranging from 0.0 to 1.0, where
the multiplicity of the knots at the ends will be of order of the curve.
This guarantees that the curve will touch the control points at the ends
of the curve. The curve is clamped.
<p>
The knot type Bezier will generate just 0.0 and 1.0 values. Note that
the order of the curve has to be equal to the length of the curve, if
Bezier knots are generated. Otherwise, the generated knot sequence is
illegal. The resulting curve looks and behaves exactly like a real
Bezier curve, interpolating it's ends and so on.
<p>
The knot type B-Spline will generate equidistant knot values
(without any multiple knots). The resulting curve looks
and behaves like a B-Spline curve.

<item><tt/"Knots"/ lets you enter your own custom knot sequences.
Note that <tt/"Knots"/ are not in use if <tt/"Knot-Type"/ is of type
NURB, B-Spline or Bezier!

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this curve. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.

<item><tt/"IsRat"/ informs you since Ayam 1.9, whether the curve
is rational (uses weight values different from 1.0).
</itemize>

The GLU-parameters control the appearance of the curve when
curve/surface display is enabled.
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a curve.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ determines how the curve should
be drawn. The control hull (control polygon) or the curve or a
combination of both may be displayed. The setting <tt/"Global"/
means, that the global preference setting
<tt>"Drawing/NCDisplayMode"</tt> should be used.

</itemize>

When changing more than one of the above values the changes will be
applied in the order of the values in the property. The
sum of the changed values should describe a valid NURBS curve.
It is perfectly legal to change the length of the curve,
it's order, and switch to a custom knot vector (be sure to actually
enter a valid new knot vector) at once. Ayam will check your changes
and fall back to certain default values if e.g. your knot sequence is wrong.
Check the console for any messages after pressing the <tt/"Apply"/ button!
<p>
When the curve type is changed using the NCurveAttr property
Ayam may also have to change the position of some control points
as follows:
<itemize>
<item>When the type is changed from open to closed, the last control
point is moved to be identical to the first one. In addition, if the
current knot type of the curve is B-Spline, it will be reset to knot type
NURB.
<item>When the type is changed from open or closed to periodic, the last
p control points will be moved to be identical to the first p, where
p is the degree of the curve (order-1). For a cubic curve (order 4),
consequently, the last three control points will be moved. In addition,
if the current knot type of the curve is NURB or Bezier it will be changed
to B-Spline automatically.
</itemize>

<sect1>NPatch (NURBS Patch) Object<label id="npatchobj">
<p>
The NPatch object allows to model NURBS surfaces in a direct way, e.g. by
modifying control points. Note that using NPatch objects should be seen as
last resort, only to be used when the flexibility of all the NURBS
surface creating tool objects is not high enough to achieve a certain shape.
<p>
Since Ayam 1.10, NPatch objects also support the concept
of multiple points, see section
<ref id="ncurvemp" name="Multiple Points">
for more information regarding this.

<sect2>NPatchAttr Property<label id="npattr"><label id="npatchattrprop">
<p>
The first section of the NPatchAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.

<item><tt/"Order_U"/ and <tt/"Order_V"/ set the orders of the patch.

<item><tt/"Knot-Type"/ and <tt/"Knots"/: For a discussion of the
<tt/"Knot-Type"/ and <tt/"Knots"/ parameters,
please see section <ref id="ncattr" name="NCurveAttr">.

<item><tt/"CreateMP"/ toggles, whether multiple points should be
created for this surface. See also the discussion in
section <ref id="ncurvemp" name="Multiple Points">.
This option is available since Ayam 1.10.

<item><tt/"IsRat"/ informs you since Ayam 1.9, whether the patch
is rational (uses weight values different from 1.0).
</itemize>

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.

<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn (<tt/"ControlHull"/), or just the outlines of the polygons
created by the tesselation (<tt/"OutlinePolygon"/), or just the
outlines of the patch (<tt/"OutlinePatch"/). The default setting
(<tt/"Global"/) means, that the value of the global preference setting
<tt>"Drawing/NPDisplayMode"</tt> should be used instead.
</itemize>

<sect1>Trim Curves<label id="trim">
<p>
Trim curves may be used to cut out certain parts of a NURBS patch.
They are simple 2D NURBS curves defined in the parametric space
of the associated NURBS patch. Trim curves have to be defined as child
objects of the NURBS patch object they belong to. In contrast to other
child objects, however, they do not inherit the transformation attributes
of the parent object. Trim curve editing should take place in views
of type <tt>Trim</tt>, that draw the boundaries of the parametric
space of the corresponding NURBS patch as rectangle, but otherwise
act as normal <tt>Front</tt> views.

Note that the direction of the trim curve determines which part of
the NURBS patch should be cut out. You can use the <tt/Revert/ tool
(<tt>Tools/NURBCurve</tt> menu) to easily change the direction
of a trim curve.

Some special restrictions apply to trim curves:
<itemize>
<item>All trim curves should entirely lie in the (u,v) parameter
space of the NURBS patch (remember the rectangle in the <tt>Trim</tt> view).
Note that this restriction does not apply to the control points,
but the curves! It is ok to have control points outside the
rectangle if the defined curve is inside the rectangle.

<item>The last point of a trim curve must be identical
to the first point.

<item>Trim loops (multiple trim curves that form loops) are possible too;
the last point of each curve in the loop must be identical to the first
point of the next curve in the loop and the first point of the first curve
of a loop must be identical to the last point of the last curve of that
loop.

<item>To mark a set of curves to be a loop, they must be placed in a level
object. The order of the curves in this level is the order of the loop.
The transformation attributes of this level object are fully ignored for
trimming.

<item>Drawing trimmed NURBS patches with certain implementations of
OpenGL may require a special trim curve (a rectangular piecewise linear
curve that encloses the whole NURBS patch) to be present. Such a curve
may be generated with the <tt/TrimRect/ tool. You can find this tool in
the <tt>Tools/Create</tt> menu. This curve is needed if you want to cut
out a hole with a single trim curve. This curve is generally not needed
if you want to render the patch with BMRT but it should not hurt if it
is present.

<item>If there are nested trim curves, their direction must alternate.

<item>Trim curves may not intersect each other or themself.
</itemize>
Note that Ayam is not checking whether your trim curves
follow these rules!
<p>
Warning: Certain OpenGL implementations may be easily crashed
drawing trimmed NURBS patches with trims that do not follow the
aforementioned rules! When in doubt or while heavy modelling,
switch to wireframe drawing and switch off shading temporarily
and you will be on the safe side.
<p>
Since Ayam 1.5 also NURBS curve providing objects are supported
as trim curves.

<sect1>BPatch (Bilinear Patch) Object<label id="bpatchobj">
<p>
A BPatch is a simple bilinear patch defined by four control
points. BPatch objects are e.g. used to build box objects, see
<ref id="boxobj" name="Box Object">).

<sect2>BPatchAttr Property<label id=bpattr><label id="bpatchattrprop">
<p>
The BPatchAttr property allows you to set the
four points defining the geometry of the patch:<p>
<itemize>
<item><tt/"P1_X"/, <tt/"P1_Y"/, <tt/"P1_Z"/, first point.
<item><tt/"P2_X"/, <tt/"P2_Y"/, <tt/"P2_Z"/, second point.
<item><tt/"P3_X"/, <tt/"P3_Y"/, <tt/"P3_Z"/, third point.
<item><tt/"P4_X"/, <tt/"P4_Y"/, <tt/"P4_Z"/, fourth point.
</itemize>

<sect1>PatchMesh Object<label id="patchmeshobj">
<p>
The PatchMesh object may be used to model with bilinear and
bicubic patch meshes.
The PatchMesh object may be converted to a NURBS patch
representation. However, this does not work for all possible
types of patch meshes (e.g. patch meshes with the basis types
Catmull-Rom, Hermite, or Custom).
The NURBS patch representation is also in use when
drawing the patch mesh (if the <tt/"DisplayMode"/ is not <tt/"ControlHull"/)
and when shading the patch mesh.
Consequently, there is currently no shaded representation of
patch meshes of basis type Catmull-Rom, Hermite or Custom.

<sect2>PatchMeshAttr Property<label id="pmattr"><label id="patchmeshattrprop">
<p>
The first section of the PatchMeshAttr property contains patch specific
settings:<p>
<itemize>
<item><tt/"Type"/ may be set to <tt/"Bilinear"/ or <tt/"Bicubic"/.
<item><tt/"Width"/ and <tt/"Height"/ control the dimensions of the patch.
<item><tt/"Close_U"/ and <tt/"Close_V"/ determine, whether the patch
mesh should be closed in u- and v-direction respectively.
<item><tt/"BType_U"/ and <tt/"BType_V"/ control the basis type
for bicubic patches. You may choose between the basis types:
<tt/"Bezier"/, <tt/"B-Spline"/, <tt/"Catmull-Rom"/,
<tt/"Hermite"/, and <tt/"Custom"/.
In the latter case (<tt/"Custom"/), additional parameters may be set.
Those are <tt/"Step_U"//<tt/"Step_V"/ (the stepsize of the basis) and
<tt/"Basis_U"//<tt/"Basis_V"/ the basis itself
(please see the RenderMan Companion for a discussion of basis types).
</itemize>
The parameters <tt/"BType_U"/ and <tt/"BType_V"/ and consequently
<tt/"Step_U"//<tt/"Step_V"/ and <tt/"Basis_U"//<tt/"Basis_V"/ are
only available to bicubic patch meshes.

The next parameters control the appearance of the patch for display
in Ayam:
<itemize>
<item><tt/"Tolerance"/ is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<tt>"Drawing/Tolerance"</tt> should be used.
<item><tt/"DisplayMode"/ sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<tt>"Drawing/DisplayMode"</tt> should be used.
</itemize>

<sect1>PolyMesh Object<label id="polymeshobj">
<p>
The PolyMesh object may be used to include objects that
have been modeled using the polygonal modelling paradigm
in Ayam scenes.
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The PolyMesh object is equivalent to the general points polygons
primitive of the RenderMan interface. This means, each PolyMesh
object may contain multiple general (convex or concave) polygons,
which in turn may consist of an outer loop and an arbitrary number
of inner loops that describe holes in the polygon. The loops use a point
indexing scheme to efficiently reuse coordinate values.
This general approach requires a so called tesselation to be carried
out, in order for the PolyMesh object to be shaded.
For the tesselation, Ayam uses routines of the GLU library.
<p>
Ayam is able to automatically create face normals for PolyMeshes.
They will be calculated while tesselating the PolyMesh and be
perpendicular to the plane determined by the first three vertices
of the outer loop of a polygon.
Furthermore, Ayam supports vertex normals (normals stored for every
control point).
<p>
Note that storing a bunch of triangles each in its own PolyMesh
object will lead to a real waste of memory. You may use the
merge tool (main menu <tt>"Tools/PolyMesh/Merge"</tt>) to merge
many PolyMesh objects into a single PolyMesh object.
<p>
Since Ayam 1.11, PolyMesh objects may be converted to SDMesh
objects. Note that no verification of the usability of the
mesh as base mesh for a subdivision surface is carried out.
Usually, such meshes have to be manifold and may not contain
T-junctions.

<sect2>PolyMeshAttr Property<label id="pomattr"><label id="polymeshattrprop">
<p>
The PolyMeshAttr GUI just displays some information about the
PolyMesh object:
<itemize>
<item><tt/"NPolys"/ the number of polygons.
<item><tt/"NControls"/ the total number of control points
defined.
<item><tt/"HasNormals"/ is 1 if the object uses vertex normals,
else it is 0.
</itemize>

<sect1>SDMesh Object<label id="sdmeshobj">
<p>
The SDMesh object may be used to include objects that
have been modeled using the subdivision modelling paradigm
in Ayam scenes.
<p>
There are no special modelling actions for this type of object, but
you may select and modify single points as you can do it with other
object types, e.g. curves.
<p>
The SDMesh object is equivalent to the Subdivision Mesh
primitive of the RenderMan interface. This means, each SDMesh
object may contain multiple faces with arbitrary number
of vertices that form a polygonal mesh. This polygonal mesh is
then successively refined using a subdivision scheme and, depending
on the number of refinement (or subdivision) steps, results in
a more or less smooth surface. There are several different
subdivision schemes, but the scheme currently supported
by most RenderMan compliant renderers is named "Catmull-Clark".
<p>
Tags may be specified for faces, edges, or vertices
to control the subdivision process (e.g. to create sharp corners or edges
in the resulting surface). All tags known from the RenderMan interface
(hole, crease, corner, and interpolateboundary) are supported by Ayam,
but they may currently not be changed by the user.
<p>
Furthermore, Ayam is currently not able to do the subdivision and
show the resulting smooth surface. All that is shown in wireframe and
shaded views is the original polygonal mesh.
<p>
Since Ayam 1.11, SDMesh objects may be converted to PolyMesh
objects. Note however that only the original unrefined control
polygon will be converted.

<sect2>SDMeshAttr Property<label id="sdmattr"><label id="sdmeshattrprop">
<p>
The SDMeshAttr GUI just displays some information about the
SDMesh object:
<itemize>
<item><tt/"Scheme"/, subdivision scheme, since Ayam 1.11 you
may choose between Catmull-Clark and Loop.
<item><tt/"NFaces"/, the number of faces.
<item><tt/"NControls"/, the total number of control points
defined.
</itemize>

<sect1>Instance Object<label id="instanceobj">
<p>
The term instance is unfortunately misleading (and can be very confusing
if you are accustomed to the terminology of object oriented programming),
but it is the term that seems to be used and understood by most
computer graphic artists. A better term would be link, as an instance
object has the same basic properties as a link in a Unix file system.
A link is just a pointer to an original file, the same goes for
an instance object: it is just a pointer to an original object (master).
A link can be placed anywhere on the file system,
an instance object can be placed anywhere in the hierarchy, and
additionally, it can be transformed (otherwise it would be pretty
useless).<p>
The sole purpose of instance objects is to save storage.
The amount of saved diskspace can be very high, but this depends
heavily on the scene. If there are no similar objects in the scene
you can hardly use instancing. Similar means "the same except for
the transformation property" in this context.
<p>
Some simple rules for instancing:
<itemize>
<item>No instances may be created of objects of the following types:
Root, View, Instance, Material, Light. Do not try to fool
Ayam and create instances of levels that contain aforementioned
types of objects, things will go awry! You may, however, put some instances
into a level object and create instances of this level
(this is sometimes called hierarchical instancing). But you may not
put instances of a level into the very same level (this would
be recursive instancing, which is not supported by Ayam).
<item>The original object may not be deleted from the scene
as long as there are instances of that object in the scene or in the
object clipboard.
</itemize>

If you cannot delete an object, and the error message tells
you something about a reference counter, then you were about
to violate the second rule. Clean the clipboard using
the menu <tt>"Special/Clipboard/Paste (Move)"</tt> and delete
or resolve all references.
<p>
Note that it is not possible to copy a master object and some instances
of it, so that the new instances point to the newly created master.
All copies of instance objects always point to the same master object.
However, it is possible to move instances using Drag-and-Drop in the tree
view or using the clipboard with <tt>"Edit/Cut"</tt> and then
<tt>"Special/Clipboard/Paste (Move)"</tt>.
<p>
You can resolve an instance object at any time using
the converter registered for objects of type <tt>Instance</tt> (simply
select the instance object and use the menu entry
<tt>"Tools/Convert"</tt>). To resolve all instance objects in a scene
to normal objects, you may use the main menu entry:
<tt>"Special/Instances/Resolve all Instances"</tt>.
<p>
The RIB export of instances does not use the RiInstance facility
of the RenderMan interface, but the ReadArchive mechanism.
This means, every original object in the scene will be written
in a separate archive (RIB file) on disk, and every instance will
cause that archive file to be read. You can change that behaviour
using the preference setting <tt/"ResInstances"/.
If <tt/"ResInstances"/ is enabled, all instances will be resolved
(temporarily) before being exported to RIB.
<p>
Ayam can also create instances automatically (see section
<ref id="ai" name="Automatic Instancing">).
<p>
To easily find the master object of an instance, just select the
instance, then use the main menu entry: <tt>"Edit/Master"</tt>.

<sect1>Clone Object<label id="cloneobj">
<p>
<figure loc="ht">
<eps file="pics/clone.ps" height="5cm">
<img src="pics/clone.gif">
<caption>Clone Object (blue) with Trajectory Curve (white)</caption>
</figure>
<p>
The Clone object allows you to easily create and control a number
of instances of a single object.
The instances will be created internally and transformed,
each by a certain amount. The Clone object may also be used for
symmetric (mirrored) modelling.
<p>
The original object, the object to be cloned, should be the first
child object of the Clone object.
If a second object is present as child of the Clone object
it is treated as trajectory (or path) curve, similar to the Sweep object
(see section <ref id="sweepobj" name="Sweep Object">).
<p>
Thus, the object hierarchy of a Clone object may look like this:
<code>
+-Clone
 | Cloned-Object
 \ [Trajectory(NCurve)]
</code>
If you use a trajectory curve to place the clones, you may want
to hide the parameter object and add a <tt/"NoExport"/ tag to it.
Otherwise the original object will appear twice, on the trajectory and
on its normal position. Note that the transformation attributes of
the parameter object will be completely overwritten when placing the
clones on the trajectory curve. If the parameter object has distinct
scale or rotation attributes it should be placed inside a level object
like this:
<code>
+-Clone
 +-Level
 |\-Cloned-Object with non-standard Scale/Rotation
 \ Trajectory(NCurve)
</code>
<p>
It is not possible to create clones from objects that may not
be master objects of instance objects (e.g. light objects, or
material objects). However, (since Ayam 1.7) it is possible to use
instances as parameter objects.
<p>
If an instance object is used as parameter object it should be placed
in a level and the <tt/"NoExport"/ tag should be added to the
level object (as you can not add tags to instance objects):
<code>
+-Clone
 +-Level with NoExport tag
 |\ Instance
 \ Trajectory(NCurve)
</code>
<p>
The following attributes further control the clone process:

<sect2>CloneAttr Property<label id="cloneattr"><label id="cloneattrprop">
<p>
<itemize>
<item><tt/"NumClones"/ the number of clones to create.
<item><tt/"Rotate"/ is only used, if a trajectory curve is present.
If it is enabled all clones will be aligned according to the normal of
the trajectory curve.
<item><tt/"Mirror"/ allows to choose between three different mirror
modes. If mirroring is enabled, for each child of the Clone object,
a mirrored counterpart will be created and all other parameters of
the Clone object will be ignored. Since Ayam 1.9, the original object(s)
and their mirrored counterparts will be provided by the Clone object,
and, additionally, the order of the mirrored objects will be reversed
so that it is possible to use a single Clone object in mirror mode
(with one or multiple NURBS curves as children) as parameter object
of e.g. a Skin object:
<code>
+-Skin
 +-Mirror(Clone)
  \ NCurve
</code>
<item><tt/"Translate_X"/, <tt/"Translate_Y"/, <tt/"Translate_Z"/,
<tt/"Rotate_X"/, <tt/"Rotate_Y"/, <tt/"Rotate_Z"/,
<tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/,
those attributes control the transformation of the instances created by
the Clone object. Note that the attributes specify difference values
between two instances: a clone is offset by <tt/"Translate_X"/,
<tt/"Translate_Y"/, and <tt/"Translate_Z"/ from the previous. It is also
rotated by <tt/"Rotate_X"/, <tt/"Rotate_Y"/, and <tt/"Rotate_Z"/ and scaled
by <tt/"Scale_X"/, <tt/"Scale_Y"/, <tt/"Scale_Z"/ in comparison
to the previous clone. However, those attributes never affect the first
clone.
<p>
Since Ayam 1.13 the transformation attributes are also used if a trajectory
curve is present. They are not in use when the mirror mode is activated.
</itemize>

<sect1>Revolve Object<label id="revolveobj">
<p>
<figure loc="ht">
<eps file="pics/revolve.ps" height="5cm">
<img src="pics/revolve.gif">
<caption>Revolve Object (left: Curve, right: Surface of Revolution)</caption>
</figure>
<p>
The Revolve object forms a surface of revolution from a NURBS curve.
<p>
The Revolve object has the generating NURBS curve as child object
and watches its changes and adapts to it automagically.
<p>
The axis of revolution is always the Y axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Y axis of the revolve
object itself). The generating curve should lie in the XY plane of this
coordinate system. If not, it will be squashed down to this plane!
<p>
The following simple experiment should make the last
statements more clear, during all steps watch the movements
of the revolution:<p>
<itemize>
<item>Create a NURBCurve. Select it.
<item>Create a Revolve tool object using the menu entry
(<tt>Tools/NURBCurve/Revolve</tt>).
<item>Select the Revolve object, and rotate it around Z. (The axis
of the revolution changes. The generating NURBS curve, as child object,
will also be rotated.)
<item>Now enter the Revolve object, select the child curve and
edit the control points (Note how the Revolution changes).
<item>Rotate the curve around Z (Note how the Revolution changes).
<item>Switch to a Side view, edit the generating curve here in Z
direction only (Revolution does not change!).
</itemize>

You may convert the current surface of revolution, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>RevolveAttr Property<label id="rep"><label id="revolveattrprop">
<p>
Using the parameter <tt/"ThetaMax"/ you can specify the
sweeping angle of the revolution just like with an ordinary
RenderMan quadric.

Since Ayam 1.8 the Revolve object supports a B-Spline mode,
that may be enabled by setting the new parameter <tt/"Sections"/
to a value higher than 2. In this mode, a circular B-Spline is
used as basis for the surface of revolution, instead of the
standard NURBS circle. Depending on the number of sections
choosen, the surface of revolution does not exactly interpolate
the parameter curve, but the surface may be edited more easily
after a possible conversion to an ordinary NURBS patch object,
because the control points will not be rational.
In addition to the number of sections, in B-Spline mode it is
possible to control the order of the surface of revolution
using the new parameter <tt/"Order"/. If <tt/"Order"/ is 0,
a standard value of 3 will be used.
Note that the B-Spline mode is currently only available for
full revolutions (<tt/"ThetaMax"/ should be 360.0).

The revolve object can automatically generate caps,
which are trimmed NURBS patches. Using the parameters
<tt/"UpperCap"/, <tt/"LowerCap"/, <tt/"StartCap"/, and <tt/"EndCap"/,
you determine whether such caps should be
generated, default is off (no caps).

If the side caps of a surface of revolution of an open
curve are not created correctly, (GLU
complains about "intersecting or misoriented trim curves"),
try to revert the revolved curve.

See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Extrude Object<label id="extrudeobj">
<p>
<figure loc="ht">
<eps file="pics/extrude.ps" height="4cm">
<img src="pics/extrude.gif">
<caption>Extrude Object (left: Curve, middle: normal Extrusion,
right: Extrusion with Caps)</caption>
</figure>
<p>
The extrude object forms an extrusion from a number of planar NURBS curves.
<p>
The first curve determines the outline and the other curves determine
holes in the extrusion object. Holes may be used by objects that form
e.g. letters.
<p>
The object has the generating NURBS curves as child objects,
watches them and adapts to them automagically.
<p>
Consequently, the object hierarchy of an Extrude object may look like this:
<code>
+-Extrude
 | Outline(NCurve)
 | [Hole1(NCurve)]
 \ [Hole2(NCurve)]
</code>
<p>
The extrude object can generate caps, if the generating
curves are closed. Cap generation may fail, if the outer
curve has weights and the curve itself leaves the convex
hull of the control polygon. Be careful when using curves
with weights!
<p>
The sharp corners between caps and extrusion may be beveled.
<p>
The axis of the extrusion is always the Z axis of the coordinate
system that is defined by the next higher
level in the object hierarchy (the Z axis of the extrude
object itself). The generating curves should lie in the XY plane of this
coordinate system. If not, they will be squashed down to this plane!
See section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve curves in the XY plane.
<p>
You may convert the current surface of extrusion, the caps, and bevels,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>ExtrudeAttr Property<label id="extrattr"><label id="extrudeattrprop">
<p>
Using the parameter <tt/"Height"/ you determine how
big in Z direction the extrusion should be. Note that
the height of the bevels will not be taken into account here,
if you have an extrusion with height 1.0 and you switch on
beveling (upper and lower) with radius 0.1 you end up
with an object that extends 1.2 units in Z direction.
<p>
The extrude object can automatically generate caps,
that are trimmed NURBS patches. Using <tt/"StartCap"/ and
<tt/"EndCap"/ you determine whether such caps should be generated,
default is off (no caps). Note that this feature does only work
properly, if the generating NURBS curves are closed and not self
intersecting, this is because the generating curves themselves are
used as trim curves for the caps. Warning, Ayam will not check whether
your curves conform to this criteria. Ayam, however, automatically
detects the correct orientation of the curves (and reverts them if
necessary).
<p>
Since Ayam 1.10 the bevel parameters of the extrude object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, and <tt/"BevelRadius"/ are no
longer available. They were replaced with new dynamic tag creating
bevel property GUI sections that are accessible through the new
command entries <tt/"Add Start Bevel!"/ and <tt/"Add End Bevel!"/
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect2>Using Holes and Bevels<label id="handb">
<p>
All curves forming holes in the extruded object must be defined inside
(geometrically) the first curve (the outline curve). Additionally,
they may not intersect each other or themself and you cannot have hole
curves inside hole curves. If there are bevels and caps, allow extra
spacing between the curves (for the bevels).
Ayam will not check whether your curves conform to these criteria!
<p>
With the direction of the curve you decide the direction of the
bevel as well (should it round outwards or inwards?).
If the bevels of the holes look wrong try to revert the generating
curves of the holes.
Note that beveling does not work well with open curves. You should always
use closed curves for beveling!
Beveling may lead to self intersecting trim curves in sharp corners of an
extrusion. Decrease the bevel radius or round the corners of the extruded
curve (using insertion of additional control points) if cap generation
fails due to self intersecting bevels.
<p>
Another special issue shall be noted: If there are holes, the
corresponding bevels will be scaled with the hole curve object
transformation values. Thus, to achieve equally sized bevels for outline
and holes, possible scale transformations should be carried out on the
hole curve control points, rather than on the hole curve object
transformation attributes.

<sect1>Sweep Object<label id="sweepobj">
<p>
<figure loc="ht">
<eps file="pics/sweep.ps" height="6cm">
<img src="pics/sweep.gif">
<caption>Sweep Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The sweep object forms a surface that results from
moving a NURBS curve (cross section or profile) along a second NURBS curve
(trajectory or path). The cross section may be scaled while sweeping
using a third curve, the scaling function. Sweeped surfaces may be closed in
the direction of the trajectory and, since Ayam 1.10, they may even be
periodic.
<p>
The sweep object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section,
the second is the trajectory, and the third curve represents
the scaling function.
<p>
The object hierarchy of a Sweep object, thus, may look like this:
<code>
+-Sweep
 | Cross_Section(NCurve)
 | Path(NCurve)
 \ [Scaling_Function(NCurve)]
</code>
<p>
Note that the <tt/"Translate"/ attributes of the cross section curve
will be fully ignored. All other transformation attributes
(of cross section and trajectory!) will be used to determine
place, orientation and size of the sweep object!
<p>
The cross section curve has to be defined in the YZ-plane of the
Sweep objects coordinate system but it also has to be defined in the
XY-plane of its own coordinate system. This means,
that a simple circular curve as e.g. created with the toolbox has to
be rotated by 90 degrees around the Y-axis using its transformation
attributes to follow these rules. Later editing of this curve has
to be done in a Side view (or in an aligned local Front view, if
the Sweep object itself is transformed somehow).
<p>
The scaling function is sampled for each section and the Y-component
of the coordinates of the current curve point will be used as
scale factor, that is applied to the cross section in Y- and Z-direction.
This implies, that e.g. a scaling function that does nothing should be
linear from (0,1,0) to (1,1,0).
<p>
<figure loc="ht">
<eps file="pics/ssweep.ps" height="5cm">
<img src="pics/ssweep.gif">
<caption>Sweep Object (blue) with Scaling Function (white)</caption>
</figure>
<p>
Here is a short example for the creation of a sweep:
<itemize>
<item>Create a circular B-Spline curve using the toolbox. (This will be our
cross section.)
<item>Rotate the curve by 90 degrees around the Y-axis. (Use the
<tt/"Transformations"/ property for that.)
<item>Create a simple NURBS curve using the toolbox. (This will be our
trajectory.)
<item>Select both curves. (Select the first curve, hold down
the <tt/"Shift"/ key and select the other curve.)
<item>Create the Sweep object using the toolbox.
<item>Now you may enter the Sweep object and modify
e.g. the second curve, the trajectory. (Press <tt/"e"/,
then drag some control points around.)
<item>To modify the cross section you would need to switch to a
view of type <tt/"Side"/. (Use the <tt/&lt;Ctrl+s&gt;/ shortcut while
the view has the input focus.)
</itemize>

Section <ref id="scexsweep" name="Easy Sweep"> has an example
script that automates creation and parameterisation of
a suitable cross section curve.
<p>
You may convert the current sweep, the bevels, and the caps, if there
are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.

<sect2>SweepAttr Property<label id="swp"><label id="sweepattrprop">
<p>
Since Ayam 1.10 the <tt/"Type"/ attribute controls, whether the
sweeped surface should be open, closed, or periodic in the direction
of the trajectory curve.
<p>
If <tt/"Interpolation"/ is enabled, all section curves
will be interpolated by the swept surface.
<p>
The third parameter, <tt/"Sections"/, determines how many
sections (in u direction) should be used, when generating the
sweep NURBS patch. The sweep NURBS patch has sections+1 control
points in u direction for open and closed types, and sections+3
control points for periodic types.
<p>
If <tt/"Rotate"/ is enabled, the cross sections will be
rotated so that they are always perpendicular to the trajectory,
this is the default.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
Sweep on both ends.
Note that this works properly only if the cross section
curve is closed and planar (defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for sweeps.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Birail1 Object<label id="birail1obj">
<p>
<figure loc="ht">
<eps file="pics/birail1.ps" height="5cm">
<img src="pics/birail1.gif">
<caption>Birail1 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail1 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves.
The object hierarchy of a Birail1 object, thus, looks like this:
<code>
+-Birail1
 | Cross_Section(NCurve)
 | Rail1(NCurve)
 \ Rail2(NCurve)
</code>
<p>
When the cross section touches the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curve will be parallel to the v
parametric dimension (height) and the direction of the rail curves will be
parallel to the u parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curve and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail1vc.ps" height="5cm">
<img src="pics/birail1vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail1 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail1 object. Mind the direction of the rail curves (R1 and R2)
with regard to the cross section curve (CS) and the fact that the
cross section curve touches the starting points of the rail curves.
<p>
Note that the cross section curve does not have to be two dimensional, and,
in contrast to the normal Sweep object, it also does not have to be
defined in a special plane. Also note that the precision with which the
resulting surface will interpolate the rail curves depends on the
number of sections choosen.
<p>
The Birail1 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current birailed surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following parameters further control the birailing process:

<sect2>Birail1Attr Property<label id="birail1p"><label id="birail1attrprop">
<p>
The parameter <tt/"Sections"/ determines how many
sections (in u direction) should be used, when generating the
birailed NURBS patch. The birailed NURBS patch always has sections+1 control
points in u direction.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g. defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Birail2 Object<label id="birail2obj">
<p>
<figure loc="ht">
<eps file="pics/birail2.ps" height="5cm">
<img src="pics/birail2.gif">
<caption>Birail2 Object (left: Curves, right: Resulting Swept Surface)</caption>
</figure>
<p>
The Birail2 object forms a surface by sweeping a cross section
(or profile) curve along two so called rail curves, while morphing it
into a second cross section (or profile) curve. The morphing process
may be controlled by a fifth parameter curve.
The object hierarchy of a Birail2 object, thus, looks like this:
<code>
+-Birail2
 | Cross_Section1(NCurve)
 | Rail1(NCurve)
 | Rail2(NCurve)
 | Cross_Section2(NCurve)
 \ [Interpolation_Control(NCurve)]
</code>
<p>
When the cross sections touch the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curves will be parallel to the v
parametric dimension (height) and the direction of the rail curves will be
parallel to the u parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curves and the number of sections, respectively.
<p>
<figure loc="ht">
<eps file="pics/birail2vc.ps" height="5cm">
<img src="pics/birail2vc.gif">
<caption>Valid Configuration of Parameter Curves (white) for Birail2 (blue)</caption>
</figure>
<p>
The image above shows a valid configuration of parameter curves for
the Birail2 object. Mind the direction of the rail curves (R1 and R2)
with regard to the two cross section curves (CS1 and CS2) and the
fact, that all curves touch at their respective end points.
<p>
Note that the cross section curves do not have to be two dimensional, and,
in contrast to the normal Sweep object, they also do not have to be
defined in a special plane. Furthermore, they do not have to be compatible
in terms of length, order, and knots. Incompatible curves will be made
compatible before birailing automatically; the height of the resulting
surface, however, is not easily predictable anymore in this case.
Also note that the precision with which the resulting surface will
interpolate the rail curves depends on the number of sections choosen.
<p>
If a fifth curve is present as parameter object, this curve will
control the morphing (interpolation) process. The y coordinate
of this curve at a specific point, which should have a value between
0 and 1, determines the ratio of control of the first cross section
(0) and the second cross section (1) over the interpolated curve.
Thus, a straight line running from point (0,0) to (1,1) will mimic
the standard linear interpolation that would be carried out if no
interpolation control curve were present. Note, however, that the
interpolation control curve has no influence on the first and last
copy of the respective cross section curve, unless the <tt/"InterpolCtrl"/
option is used (which is available since Ayam 1.10).
<p>
The Birail2 object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current birailed surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following parameters control the birailing process:

<sect2>Birail2Attr Property<label id="birail2p"><label id="birail2attrprop">
<p>
The parameter <tt/"Sections"/ determines how many sections (in u direction)
should be used, when generating the birailed NURBS patch. The birailed
NURBS patch always has sections+1 control points in u direction.
<p>
The parameter <tt/"InterpolCtrl"/ allows the interpolation controlling
curve full influence on the birailed surface.
If <tt/"InterpolCtrl"/ is not enabled, the first and last border of the
resulting surface will always exactly match the parameter curves (CS1 and
CS2 respectively), regardless of the interpolation control curve.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be
used to automatically create cap surfaces, that close the
birailed surface on the respective end.
Note that this only works properly if the cross section
curve is closed and planar (e.g. defined in the XY plane).
<p>
Since Ayam 1.10 bevels are available for birails.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Skin Object<label id="skinobj">
<p>
<figure loc="ht">
<eps file="pics/skin.ps" height="6cm">
<img src="pics/skin.gif">
<caption>Skin Object (left: Curves, right: Resulting Skinned Surface)</caption>
</figure>
<p>
The skin object forms a surface defined by a set of cross section curves,
where the first and last curve will always be interpolated by the surface
(this process is sometimes also called lofting). When only two parameter
curves are used the skin forms a so called ruled surface.
<p>
The complete template for the Skin object hierarchy, consequently,
looks like this:
<code>
+-Skin
 | C1(NCurve)
 | C2(NCurve)
 | [...
 \ Cn(NCurve)]
</code>
<p>
Note that in contrast to the build from curves tool,
the curves may be of arbitrary length and order. You may e.g.
easily skin a curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points.
If the curves are of different length or order, they will all be
converted internally until they are compatible. Be warned, that
this process may consume a considerable amount of time
because all unclamped curves have to be converted to
clamped ones; then, for every curve with low order degree elevation
has to be done; then a uniform knot vector has to be found; then all
curves have to be refined using this new knot vector; interpolation
adds another dimension of complexity... If you experience
lags when editing the child curves of a skin object try to switch
to lazy notification.
Since Ayam 1.9, a skin object will also use all the curves of a
tool object, that provides multiple curves, e.g. a clone object
in mirror mode.
<p>
The direction of the parameter curves will be parallel to the v
dimension (height) of the skinned surface. The number of the parameter
curves will define the u dimension (width) of the skinned surface.
<p>
Also note that the resulting patch may be quite complex, even though
the curves are not, if the orders or knot vectors of the curves do not
match.
For example, a skinned patch from two curves of length 4 but one with
order 4 and the other with order 2 will result in a patch with
a width of 2 and a height of 10!
<p>
The skin object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
<p>
You may convert the current skinned surface, the bevels, and the caps,
if there are any, to ordinary NURBS patches using the main menu entry
<tt>"Tools/Convert"</tt>.
<p>
The following parameters control the skinning process:

<sect2>SkinAttr Property<label id="skp"><label id="skinattrprop">
<p>
The first parameter <tt/"Interpolation"/ controls,
whether the inner curves should also be interpolated by the
skinning surface.<p>
The second parameter <tt/"Order_U"/ determines the order
of the resulting surface in u direction (the order in v direction is
determined by the curves). The order may not be higher than the
number of curves used. If the specified value is higher than the number
of curves, the order of the generated surface will be silently
set to the number of curves.
If <tt/"Order_U"/ is 0, a default value of 4 will be used.
<p>
Using the next parameter <tt/"Knot-Type_U"/, you can adapt the
type of the knot vector that should be used in the u direction of the
skinned surface. Note that this setting will have no effect if
interpolation is switched on because then a chord length parameterisation
will be used. If the knot type is Bezier and the specified
order (see above) does not exactly match the number of skinned curves,
then the order will be silently adapted to the number of skinned curves.
New in Ayam 1.7 is support for the knot type Custom, which creates
a chord length parameterisation, even if interpolation is not enabled.
<p>
The attributes <tt/"StartCap"/ and <tt/"EndCap"/ may be used
to automatically create cap surfaces to close the skinned surface
on both ends.
Note that this works only if the respective curves are closed and
planar (e.g. defined in the XY plane).
Furthermore, if the skin is not interpolating the respective parameter
curves (this may be the case if the <tt/"Knot-Type_U"/ parameter is set
to <tt/"B-Spline"/) the cap(s) will not be created in the right place.
The cap(s) will always be created in the position of the first (last)
parameter curve.
<p>
Since Ayam 1.10 bevels are available for skins.
They are accessible through the new command entries <tt/"Add Start Bevel!"/
and <tt/"Add End Bevel!"/ respectively. If one of those entries is used,
a bevel parameter tag is created and more options will be made available
in the property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in section
<ref id="bevelp" name="BevelAttr Property">.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Gordon Object<label id="gordonobj">
<p>
<figure loc="ht">
<eps file="pics/gordon-hood.ps" height="6cm">
<img src="pics/gordon-hood.gif">
<caption>Gordon Object (left: Curves, right: Resulting Gordon
Surface)</caption>
</figure>
<p>
The Gordon object forms a surface defined by two sets of intersecting
curves (a network of curves), where all curves will always be interpolated
by the surface (see image above). The image below shows the simplest
configuration of such a network, consisting of four parameter curves.
Note the arrangement and the direction of the curves.
Also note that this configuration is in fact equivalent to a Coons patch.
<p>
<figure loc="ht">
<eps file="pics/sgordon.ps" height="6cm">
<img src="pics/sgordon.gif">
<caption>Gordon Surface with Parameter Curves (white)</caption>
</figure>
<p>
The curves may be of arbitrary length and order. You may e.g.
use a curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points for the u parametric dimension. Note, however,
that in the general case only non-rational curves can be used
as parameter curves for a Gordon surface.
If the parameter curves are rational, the weight information
of the curves will simply be ignored.
However, since Ayam 1.13 there is a special case allowed: if
exactly four parameter curves are present, their weight
information will be used properly. Mind that for a correct
surface interpolation the curves weights have to match in the
respective end points.
<p>
The Gordon object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
Separation of the two sets of curves has to be done using an
empty level object. The first set of curves determines the u
direction and the second set of curves the v direction of the
Gordon surface. For the example surface in the image above, the
child objects of the Gordon object would have to look like this
in the Ayam object tree view:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 \ V2(NCurve)
</code>
<p>
The creation of a Gordon surface is computationally
expensive. It involves (interpolated) skinning of the two sets of
parameter curves, finding the intersection points of the two sets
of parameter curves, interpolating the matrix of intersection points,
making the three resulting surfaces compatible, and finally combining
the three surfaces into the resulting Gordon surface. If you experience lags
while editing the parameter curves of a Gordon surface, consider
switching to lazy notification.
<p>
In order to ease the computationally intensive intersection
detection for Ayam you may specify a third argument (separated
from the two sets of parameter curves by a second empty level object).
This third argument should be a NURBS patch object that describes
all intersection points (by its control points).
If present, this intersection patch always takes precedence over the
intersection points calculated internally.
You may want to add a <tt>"NoExport"</tt> tag to this patch. The object
hierarchy of a Gordon object using such a patch may look
like this:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | Level
 \ Intersections(NPatch)
</code>
<p>
The complete template for the Gordon object hierarchy, consequently,
is as follows:
<code>
+-Gordon
 | U1(NCurve)
 | U2(NCurve)
 | [...
 | Un(NCurve)]
 | Level
 | V1(NCurve)
 | V2(NCurve)
 | [...
 | Vn(NCurve)]
 | [Level
 \ Intersections(NPatch)]
</code>
<p>
The Gordon object watches the child objects and adapts to them
automatically via the notification mechanism.
<p>
You may convert the current Gordon surface to an ordinary NURBS
patch using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following parameters of the Gordon object further control
the creation of the Gordon surface:

<sect2>GordonAttr Property<label id="gop"><label id="gordonattrprop">
<p>
If the parameter <tt/"WatchCurves"/ is switched on, Ayam will
check for all four outer parameter curves, whether they touch in their
endpoints. If not, the endpoints will be corrected. Note that this
works only properly with clamped curves and objects that directly
contain editable control points (i.e. it works with NCurve and ICurve
objects, but not with Instance or ConcatNC objects). If Ayam can
determine which curve was modified last, the other curve that should
meet at the endpoint in question will be modified by <tt/"WatchCurves"/.
If Ayam finds no information on modifications, the U curves take
precedence (i.e. the V curves will be modified).
<p>
The parameters <tt/"Order_U"/ and <tt/"Order_V"/ determine the
desired order of the resulting surface in u and v direction.
However, depending on the number and configuration of curves used
in the u or v direction, it may not be possible to create a Gordon
surface of the desired order.
If <tt/"Order_U"/ or <tt/"Order_V"/ are 0, a default value
of 4 will be used.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Bevel Object<label id="bevelobj">
<p>
<figure loc="!ht">
<eps file="pics/bevel.ps" height="5cm">
<img src="pics/bevel.gif">
<caption>Bevel Object (left: Curve, right: Resulting Bevelled Surface)</caption>
</figure>
<p>
The bevel object forms a bevelled surface from a single parameter
curve.
Consequently, the template for the object hierarchy of a Bevel object
looks like this:
<code>
+-Bevel
 \ NCurve
</code>
<p>
Bevels are also available as properties of different tool objects
(e.g. Extrude or Sweep). In fact, Bevel objects use the same creation
algorithm as bevel properties but offer increased flexibility in terms of
e.g. material settings. Surfaces created from bevel properties always
share the material settings of the tool object. In contrast, Bevel
objects may have their own material settings. Bevel objects are
available in Ayam since version 1.10.
<p>
Note that the parameter curve of a Bevel object should be closed and
planar to achieve best results;
see section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve this. If the curve is closed or periodic,
the appropriate curve type should be set in the curve object,
otherwise the bevelled surface may expose defects.
<p>
The Bevel object watches the child object and adapts to it automatically
via the notification mechanism.
<p>
You may convert the current bevelled surface to an ordinary NURBS patch
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following parameters of the Bevel object further control
the creation of the bevelled surface:

<sect2>BevelAttr Property<label id="bevelp"><label id="bevelattrprop">
<p>
<itemize>
<item><tt/"BevelType"/ lets you choose between different shapes of bevels:
 <itemize>
 <item><tt/"Round"/ a quarter circle,

 <item><tt/"Linear"/ a straight bevel,

 <item><tt/"Ridge"/ a more complex ridged surface,

 <item><tt/"RoundCapped"/ a quarter circle followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point,

 <item><tt/"LinearCapped"/ a straight bevel followed by a cap made by placing
a single point in the center of the last bevel profile and extending the
beveled surface to this point.
 </itemize>

<item><tt/"BevelRadius"/ controls the size of the bevelled surface when seen
from the top of the parameter curve. Note that the size of the bevel is
expressed in units defined by the object coordinate system of the
controlling object. Scale values of the controlling object affect the
bevel size.

<item><tt/"BevelRevert"/ allows to revert the sense of the bevelled surface,
should it round inwards or outwards? The sense may also be controlled
using the direction of the parameter curve and, additionally, the sense
in a different dimension may also be affected by using negative values
for the bevel radius.
</itemize>
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"BevelAttr"/ property.
<p>
Note that the bevel types <tt/"RoundCapped"/ and <tt/"LinearCapped"/
lead to degenerated NURBS surfaces. If applied shaders or textures
look wrong, consider creation of real cap surfaces instead.

<sect1>Cap Object<label id="capobj">
<p>
<figure loc="!ht">
<eps file="pics/cap.ps" height="6cm">
<img src="pics/cap.gif">
<caption>Cap Object (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
The cap object forms a surface that fills a closed planar NURBS curve.
If multiple curves are present as child objects, the curves following
the first curve define holes in the cap surface similar to the
parameter curves of an extruded surface (see also section
<ref id="handb" name="Using Holes and Bevels">).
<p>
<figure loc="!ht">
<eps file="pics/gordoncap.ps" height="5cm">
<img src="pics/gordoncap.gif">
<caption>Cap from Non-Planar Curve (left: Curve, right: Resulting Cap Surface)</caption>
</figure>
<p>
Since Ayam 1.13 the cap object also supports the so called Gordon mode.
Here, only a single parameter curve may be present but, in contrast
to the standard mode of operation (Trim), in the Gordon mode the parameter
curve may be non-planar. Internally the cap object will split the
parameter curve into four sections and build a Gordon surface from
the four sections (see the image above for an example).
<p>
Consequently, the template for the object hierarchy of a Cap object
looks like this:
<code>
+-Cap
 | Outline(NCurve)
 | [Hole1(NCurve)]
 +-[Hole2(Level)
  | Part1(NCurve)
  \ Part2(NCurve)]
</code>
<p>
Note that, in Trim mode, the curves have to be planar and defined in
the XY plane; see section
<ref id="toxyt" name="The To XY Tool"> for information on
how to easily achieve this.
Furthermore, cap generation may fail, if the control points of the
first curve have weights and the curve leaves the convex hull of the
control polygon. Be careful when using weights!
<p>
The Cap object watches the child objects and adapts to them automatically
via the notification mechanism.
<p>
You may convert the current cap surface to an ordinary NURBS patch object
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following parameters control the cap creation process:

<sect2>CapAttr Property<label id="capp"><label id="capattrprop">
<p>
The attribute <tt/"Type"/ determines whether a trimmed NURBS surface
should be created (type <tt/"Trim"/), or an untrimmed Gordon surface
(type <tt/"Gordon"/), see also the general discussion about the cap
object above.
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/
of the <tt/"CapAttr"/ property.

<sect1>ICurve (Interpolating Curve) Object<label id="icurveobj">
<p>
The ICurve object creates an interpolating spline curve from n points
in space. The created curve is either a C2 cubic curve with n+2 control
points or a global interpolating rational (Global4D) curve with n control
points and with arbitrary order.
<p>
The global interpolation generates a bit smoother curves which look best
with an order of 3, your mileage may vary however.
<p>
<figure loc="!ht">
<eps file="pics/icurves.ps" height="7cm">
<img src="pics/icurves.gif">
<caption>Different ICurves</caption>
</figure>
<p>
The image above shows some interpolating curves, the left ones
are C2 cubic, the right ones Global4D, the upper open, and the lower
closed ones. The interpolation fidelity for the closed curves
could be increased considerably by adjusting the <tt/"IParam"/
parameter, see below.
<p>
In both interpolation modes chord length parameterisation will be used
to determine the knot vector of the interpolating curve.
<p>
This object makes use of the provide mechanism. It marks itself
as providing a NURBCurve (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g. revolve, sweep, extrude, and skin) are
able to work with an ICurve object instead of an object
of type NURBCurve.
<p>
You may convert the current ICurve to an ordinary NURBS curve
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following parameters control the interpolation process:

<sect2>ICurveAttr Property<label id="icp"><label id="icurveattrprop">
<p>
<itemize>
<item>Using <tt/"Length"/ you determine the number of points to interpolate.

<item>The curve can be closed with the parameter <tt/"Closed"/.

<item>The parameter <tt/"Mode"/ determines whether the curve should
be a C2 cubic curve (with n+2 control points (n+3 if the curve is
closed)) or a so called global interpolating curve
(with n control points (n+3 if the curve is closed)
and arbitrary order).

<item>The next parameter <tt/"Order"/ is used only if the mode is
Global4D. It determines the order of the interpolating curve. If the
specified order is bigger than the number of control points used
by the interpolating curve, then the order is silently changed to
match the number of control points.

<item>The parameter <tt/"IParam"/ is used to control the position
of the second and last-1 control point of the interpolating curve.
It scales the vectors used to position the aforementioned points.
You can try to change (decrease) this value, if you are not satisfied
with the shape of the curve near the first or last interpolated point.
This parameter has no effect on open curves when the mode is Global4D.

<item>See section <ref id="ncattr" name="NCurveAttr"> for a description
of the last attribute: <tt/"Tolerance"/.
</itemize>

<sect1>ConcatNC (Concatenate NURBS Curves) Object<label id="concatncobj">
<p>
<figure loc="ht">
<eps file="pics/concatnc.ps" height="5cm">
<img src="pics/concatnc.gif">
<caption>ConcatNC Object (blue) from a Linear Curve and 3 Instances (white)</caption>
</figure>
<p>
The ConcatNC object concatenates all child objects (which should be
NURBS curves or provide NURBS curves) to a single NURBS curve. Since
the ConcatNC object also provides a NURBS curve, it is possible to
use it as child object for another ConcatNC object (with possibly
different parameters) or as a parameter object for a tool object that
works with NURBS curves such as Revolve or Extrude.
<p>
How does the concatenation process work?
<p>
First, the orders of all parameter curves will be elevated to the maximum
order of all the parameter curves (see section
<ref id="elevt" name="elevate tool"> for more information on elevation)
and all curves will be clamped (see section
<ref id="clat" name="clamp tool"> for more information on clamping).
If <tt/"FillGaps"/ is enabled (see below), fillet curves will be
created for every gap between the parameter curves of the ConcatNC object.
If <tt/"Closed"/ and <tt/"FillGaps"/ are enabled, an additional fillet
is created to close the curve.
Then, the control points of all parameter curves and fillets are simply
copied into a new big control point vector, without checking for double
points. This means that for parameter curves that touch at their
respective ends, atleast double control points in the new concatenated
curve will result.
<p>
The knot sequence of the new concatenated curve will be of type
<tt/"NURBS"/ or a custom knot vector will be computed (depending
on the setting of <tt/"Knot-Type"/).
If <tt/"Knot-Type"/ is <tt/"NURBS"/, the shape of the concatenated curve
will differ from the parameter curves if any of the parameter curves has
a custom knot vector with non equidistant knots. If <tt/"Knot-Type"/ is
<tt/"Custom"/, the shape of the parameter curves will be preserved.
<p>
Attributes like display mode and tolerance for the new concatenated curve
are simply taken from the first parameter curve.
<p>
You may convert the current ConcatNC object to an ordinary NURBS curve
object using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following parameters further control the concatenation process:

<sect2>ConcatNCAttr Property<label id="concatncp"><label id="concatncattrprop">
<p>
<itemize>
<item>Using <tt/"Closed"/ you may create a closed concatenated curve.
If <tt/"FillGaps"/ (below) is enabled, an additional fillet will
be created for the last and the first child curve to close
the concatenated curve. If <tt/"FillGaps"/ (below) is not enabled,
the concatenated curve will be closed with the same algorithm
that is also used by the close curve tool (possibly changing
the shape again!).

<item><tt/"FillGaps"/, creates fillet curves for all gaps between
the child curves of the ConcatNC object. The fillet curves will be
cubic Bezier curves. The direction of the tangents in the endpoints of
the fillets and the gap enclosing curves will match, so that the
transition should be G1 continuous.

<item><tt/"Revert"/ the orientation of the concatenated curve will be
reversed.

<item><tt/"FTLength"/ determines a scale factor for the tangent vectors
of the fillets. A value of 1.0 leads to vectors that are as long as
the matching vectors in the control point arrays of the original curves.
A value of 0.3 is the default value. You may need to tweak this, if
you experience discontinuities in the transitions between original
curves and fillets, especially, if <tt/"Knot-Type"/ (see below) is set to
<tt/"Custom"/.

<item><tt/"Knot-Type"/ in fact toggles between two different modes
of concatenation. If <tt/"Knot-Type"/ is <tt/"NURB"/ a simple knot vector
with equidistant knots is generated, which leads to a concatenated curve,
that does not exactly preserve the shape of the original curves.
If <tt/"Knot-Type"/ is <tt/"Custom"/, the knot vector is composed from
the knot vectors of the original curves, and thus, their
shape may be preserved completely.
</itemize>

<sect1>ExtrNC (Extract NURBS Curve) Object<label id="extrncobj">
<p>
The ExtrNC object extracts a NURBS curve from a NURBS patch object,
for use as parameter object for other tool objects, like e.g.
Revolve. It also works with NURBS patch providing objects, so that
the following example hierarchy is valid:
<code>
--NPatch
+-Skin
 +-ExtrNC
 |\ Instance_of_NPatch(Instance)
 \ NCurve
</code>
Depending on the parameters of the ExtrNC object, the skin will have
one boundary in common with a boundary or an iso-curve of the NPatch
object.
<p>
The extraction process is controlled by the following attributes:

<sect2>ExtrNCAttr Property<label id="extrncp"><label id="extrncattrprop">
<p>
<itemize>
<item><tt/"Side"/ controls, which curve should be extracted.
Available values are <tt/"U0"/, <tt/"Un"/: extract boundary curve along
width; <tt/"V0"/, <tt/"Vn"/: extract boundary curve along
height; <tt/"U"/, <tt/"V"/ extract curve along width and height
respectively at specified parametric value (see below). The
options <tt/"U"/, <tt/"V"/ are implemented since Ayam 1.8.1!

<item><tt/"Parameter"/ controls the parametric value in u or v
direction in the parameter space of the NURBS patch object where the
curve should be extracted.

<item><tt/"PatchNum"/ allows to select a patch from a list of
patches delivered e.g. by a beveled extrude object as child
of the ExtrNC object.
This way it is possible to extract a curve from a bevel or cap
surface.
</itemize>
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>NCircle (NURBS Circle) Object<label id="ncircleobj">
<p>
The NCircle object is available since Ayam 1.12 and creates a
circular NURBS curve or a circular arc in the XY plane with
designated radius and start/end angles.
<p>
The following section describes the parameters of the circle or
arc.

<sect2>NCircleAttr Property<label id="ncircleattrprop">
<p>
<itemize>
<item><tt/"Radius"/ is the radius of the circle.
<item><tt/"TMin"/ controls the starting angle of the circle
or arc to be created. Negative values are allowed.
<item><tt/"TMax"/ controls the end angle of the circle
or arc to be created. Negative values are allowed.
</itemize>
<p>
See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>Text Object<label id="textobj">
<p>
<figure loc="!ht">
<eps file="pics/text-ayam.ps" height="4cm">
<img src="pics/text-ayam.gif">
<caption>Text Object set in Verdana</caption>
</figure>
<p>
Text objects may be used to easily create objects that form letters or
even whole words in very high quality. For that, they parse TrueType font
description files, extract the Bezier curves from the font description,
sort the curves, connect them properly and finally extrude them.
As with the Extrude objects, caps and bevels may be created automatically.
<p>
Parsing of TrueType font descriptions is quite tricky. For the sake
of brevity and ease of the implementation, Ayam does not support elaborate
TrueType features like kerning tables, that e.g. control distances between
certain letters (You are not going to typeset a book with Ayam anyway,
aren't you?). Therefore you might experience wrong letter distances
from time to time. If this happens, just create a Text object for each
letter, and arrange the objects as you like.
<p>
You may convert the current Text object to ordinary NURBS patches
using the main menu entry <tt>"Tools/Convert"</tt>.
<p>
The following attributes control the creation of the text objects.

<sect2>TextAttr Property<label id="textattr"><label id="textattrprop">
<p>
<itemize>
<item>Using <tt/"FontName"/ you specify a TrueType font description file.
Those files usually have the file name extension <tt/".ttf"/.
Only real TrueType font files, containing Bezier curve font descriptions,
are supported. There are also rastered, bitmap containing TrueType
font description files, those will not work.

<item>Using <tt/"String"/ you specify the letters to be created.
This entry (and the corresponding data structures) are Unicode clean.
This means you can put any Unicode letters into this entry. You should
of course make sure, that the specified letters are included in the
selected font file.

<item><tt/"Height"/ controls the height of the extruded object.

<item><tt/"Revert"/ reverts the sense of inside-outside detection
mechanism for the cap generation. Depending on the actual font description
file (or even letter) you may need to toggle this to get caps.

<item><tt/"UpperCap"/, <tt/"LowerCap"/, work like for the Extrude object
(see section <ref id="extrattr" name="ExtrudeAttr Property"> for a more
exhaustive description of those parameters).

<item><tt/"Add Start Bevel!"/, <tt/"Add End Bevel!"/:
Since Ayam 1.10 the bevel parameters of the text object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <tt/"LowerBevel"/,
<tt/"UpperBevel"/, <tt/"BevelType"/, <tt/"BevelRadius"/, and
<tt/"RevertBevels"/ are no longer available. They were replaced with
new dynamic tag creating bevel property GUI sections that are accessible
through the new command entries <tt/"Add Start Bevel!"/ and
<tt/"Add End Bevel!"/
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section <ref id="bevelp" name="BevelAttr Property">.
<p>
Just one note: for some fonts, the bevel radius has to be set to really
small values (about 0.0008) to get proper bevels and caps. This is
because of sharp corners in some letters that lead to self overlapping
borders of the bevel surfaces with high values for the bevel radius.
</itemize>

See section <ref id="npattr" name="NPatchAttr"> for a description
of the other two attributes <tt/"DisplayMode"/ and <tt/"Tolerance"/.

<sect1>RiInc Object<label id="riincobj">
<p>
RiInc objects may be used to include objects or whole scene parts into your
scenes that, for some reason, are just available as a piece of RIB.
<p>
The following attributes control the inclusion:

<sect2>RiIncAttr Property<label id="riincp"><label id="riincattrprop">
<p>
<itemize>
<item>Using <tt/"File"/ you specify the filename of the RIB to be included.
<item><tt/"Width"/, <tt/"Height"/, and <tt/"Length"/ specify
the size of a box, that will be drawn as a geometric representation of
the RIB.
</itemize>

<sect1>RiProc Object<label id="riprocobj">
<p>
RiProc objects may be used to include procedural objects or external
archives into your scenes.
<p>
The following attributes control the RiProc object:

<sect2>RiProcAttr Property<label id="riprocp"><label id="riprocattrprop">
<p>
<itemize>
<item><tt/"Type"/ defines the type of the procedural object which is
one of <tt/"DelayedReadArchive"/, <tt/"RunProgram"/, or
<tt/"DynamicLoad"/.
<item>Using <tt/"File"/ you specify the filename of the RIB archive,
program, or dynamic shared object (depending on the type of the
procedural object).
<item>Using <tt/"Data"/ additional arguments may be supplied to
procedural objects of type <tt/"RunProgram"/ and <tt/"DynamicLoad"/.
<item><tt/"MinX"/, <tt/"MaxX"/, <tt/"MinY"/, <tt/"MaxY"/, <tt/"MinZ"/,
and <tt/"MaxZ"/ specify the size of the bounding box of the objects that
the procedural will create or the archive contains.
</itemize>

<sect1>Script Object<label id="scriptobj">
<p>
Script objects are the most flexible object type of Ayam.
They may be used to create new objects, modify existing objects,
or realise mechanisms like constraints.
<p>
Theoretically, the scripts can use any functionality from Tcl and
the Tcl scripting interface of Ayam (see also section
<ref id="script" name="The Tcl Scripting Interface">). However,
certain script object types may impose special constraints.
<p>
For security reasons, if scene files containing script objects are
loaded, Ayam will raise a warning offering to temporarily disable all
script objects that will be read. The script objects will be disabled
using the <tt/"Active"/ script object property and may be enabled
after inspection of the script code manually or using the main menu
entry <tt>"Special/Enable Scripts"</tt>.
<p>
The script of a script object will be run each time it is modified
and each time the notification callback of the object is called
(e.g. because one of the children of the script object changed).
As long as the script of a script object is executed, Ayam will
not process any events except for checking whether the script emergency
hotkey <tt/&lt;Ctrl+Shift+c&gt;/, that may also be used to
escape from infinite loops in the Ayam console, is pressed.
Calling commands and procedures that lead to the processing of
events or that are slow because they manipulate or update the
GUI of Ayam should be avoided. In particular, the following
procedures and commands should not be used: uS, uCR, uCL, sL, selOb,
plb_update, cutOb, copOb, delOb, undo!
<p>
Since Ayam 1.8.2 script objects may also create their own property
GUIs for e.g. script parameters. This may be accomplished by adding
tags of type <tt>"NP"</tt> with the name of the new property as
value to the script object. The script itself is responsible for data
management and property GUI creation.
<p>
Since Ayam 1.9 the parameters set via the property GUI may be
comfortably saved with scene files by just adding the following
comment as first line to the script:
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
where arrayname designates the name of the global Tcl array
the property GUI elements operate with.
<p>
The binary and source distributions of Ayam contain several example
scripts for script objects in the <tt>"ayam/bin/scripts"</tt> and
<tt>"ayam/src/scripts"</tt> directories, respectively. In addition,
there are example scene files using script objects in the
<tt>"ayam/scn/scripts"</tt> directory.
<p>
The next section discusses the available script object types and
additional controlling parameters.

<sect2>ScriptAttr Property<label id="scriptattr"><label id="scriptattrprop">
<p>
<itemize>
<item>If <tt/"Active"/ is disabled, the script will not be run.

<item><tt/"Type"/ is the type of the script object.
Three types of script objects are currently available:
 <itemize>
 <item><tt/"Run"/, the script will be run and no special action will
take place.

 <item><tt/"Create"/, the script will be run and will create and
parameterise a single new object. After running the script, the new
created object will automatically be copied into the internal data
structure of the script object. The script object will look like
and act as an object of the type that the script created.
If the script creates e.g. a NURBCurve object, the script object may
be used as parameter object of a tool object that needs a NURBCurve,
e.g. a Sweep:
<code>
+-Sweep
 | Cross_Section(Script)
 \ Path(NCurve)
</code>
The newly created object has to be selected by the script code
for parameterisation and copying. The selection should be done
using the new scripting interface command <tt/"hSL"/ (hidden select last).
Consequently, the most simple example script for a script object
of type <tt/"Create"/ looks like this:
<code>
crtOb NCurve
hSL
</code>

 <item><tt/"Modify"/, if the script object has child objects,
these child objects will be copied into the internal data
structure of the script object. A selection of the copied objects
will be established, then the script will be run. Usually, the
script modifies one of the selected objects (moves control points,
adds tags, or does something similar). Note that the original
child objects will not be modified.
If certain actions in the script shall be restricted to
one of the child objects of the script object, the
<tt/"withOb"/ command may be used to accomplish this easily.
The script object will look like and act as an object of the type
of the first child object of the script object.
If the script object has e.g. a NURBCurve object as first child, the
script object may be used as parameter object of a tool object that
needs a NURBCurve, e.g. a Sweep:
<code>
+-Sweep
 +-Cross_Section(Script)
 | \ NCurve
 \ Path(NCurve)
</code>
A simple example script for a script object of type <tt/"Modify"/ that
needs a single NURBS curve as child object may look
like this:
<code>
revert
</code>
Note: In order to make this work for objects providing NURBS curves
(interpolating curves or instances of NURBS curves) the code has to
look like this:
<code>
convOb -inplace; revert
</code>
</itemize>


<item><tt/"Script"/ is the script code. The corresponding widget
is a standard Tcl text widget that allows to directly edit the code.
It is also possible to edit the code in an external editor and
copy it to the script object using the operating system clipboard
and the <tt/"Paste (Replace)"/ context menu entry of the text widget.
If the first line of the script is a comment like
<code>
# Ayam, save array: &lt;arrayname&gt;
</code>
then the global Tcl array <tt>&lt;arrayname&gt;</tt> will be saved with
the script object to Ayam scene files.
</itemize>

<sect1>Custom Objects<label id="customobj">
<p>
Custom objects are plugins that extend the Ayam capabilities by
defining totally new types of e.g. geometric objects. This may
be done easily, because the Ayam core is written in a modelling
paradigm independent way.
<p>
A simple example of a custom object is the CSphere, which implements
a simple sphere and has a new property named <tt/"CSphereAttr"/.
This property contains all parameters of a simple RenderMan Interface
quadric sphere. A more complex example would be the MetaObj custom
object. It is possible, but not planned for now, to integrate
the T-Spline modelling paradigm into Ayam this way.
<p>
Since a custom object has total control over properties and representations,
you should refer to the documentation of the respective custom object for
more information regarding its properties.
<p>
One custom object is already distributed with Ayam. This Metaball
custom object is documented in the next section:

<sect1>Metaball Object<label id="metaobjobj"><label id="metacompobj">
<p>
<figure loc="ht">
<eps file="pics/meta.ps" height="5cm">
<img src="pics/meta.gif">
<caption>A Metaball Object from Six Meta Components</caption>
</figure>
<p>
A metaball object is a custom object (see also section
<ref id="customobj" name="Custom Object">).
It allows you to model with implicit surfaces in realtime.
<p>
To start modelling you should first create a <tt>"MetaObj"</tt> object
using the menu entry
<tt>"Create/Custom Object/MetaObj"</tt> (if this menu entry is not
available, you have to load the <tt>"metaobj"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<tt>"Create/Custom Object/MetaObj"</tt> creates a so called meta world with a
single meta component (a sphere) in it. The meta world is represented
by a <tt>"MetaObj"</tt> object and the component by a <tt>"MetaComp"</tt>
object which is a child of the <tt>"MetaObj"</tt> object.
<p>
The complete template for the MetaObj object hierarchy, consequently,
looks like this:
<code>
+-MetaWorld(MetaObj)
 | C1(MetaComp)
 | [...
 \ Cn(MetaComp)]
</code>
<p>
Meta components live only in a meta world, therefore it makes no sense
to create <tt>"MetaComp"</tt> objects in other places except as a
child of a <tt>"MetaObj"</tt> object. Type, parameters, and
transformation attributes of the meta components define the function
of an implicit surface. The <tt>"MetaObj"</tt> object, that represents
the meta world, evaluates this function on a regular three-dimensional
grid and creates a polygonal representation for a specific function
value (the so called threshold value).
<p>
This process may be further parameterized using the <tt/"MetaObjAttr"/
property:

<sect2>MetaObjAttr Property<label id="moattr"><label id="metaobjattrprop">
<p>
<itemize>
<item>With the parameter <tt/"NumSamples"/ you specify the resolution of the
three-dimensional regular grid, on which the implicit function is
evaluated, in each dimension.
A higher number of samples results in better quality but more polygons
are created and more CPU power and memory are needed. For modelling
you should set this to a lower value of about 40. For final rendering
you may increase this to about 160.

<item><tt/"IsoLevel"/, defines the threshold value for that a polygonal
representation of the implicit function should be created. Normally, you
should not need to change this value.

<item>To show the actual bounds of the meta world, you may enable
the <tt>"ShowWorld"</tt> parameter.
</itemize>

New in Ayam 1.5 is an adaptive calculation mode of the implicit
surface. It may be switched on using the new attribute
<tt>"Adaptive"</tt>. In the adaptive calculation mode, Ayam tries
to vary the resolution of the resulting polygonal mesh according to
the features of the implicit surface in order
to capture fine details, even though a coarse grid is used.
This is not done using a successively refined grid but by a
refinement of the triangles created by the original algorithm
(see also XXXX).
You may control the adaptation process using three parameters:
<tt>"Flatness"</tt>, <tt>"Epsilon"</tt>, and <tt>"StepSize"</tt>.
If <tt>"Adaptive"</tt> is set to <tt>"automatic"</tt>, Ayam will
not use the adaptive calculation while a modelling action is in
progress. This mode has been introduced, because the adaptive mode
may consume a considerable amount of CPU resources.
<p>
While modelling with meta balls you may add other <tt/"MetaComp"/ objects
to the <tt/"MetaObj"/ object and parameterize them.
A <tt/"MetaComp"/ object has the following properties.

<sect2>MetaCompAttr Property<label id="mcattr"><label id="metacompattrprop">
<p>
<itemize>
<item><tt/"Formula"/ specifies the type of the meta component.
The following types are available: Metaball, Torus, Cube, Heart, and
Custom. The latter gives you the possibility to use your own formulas.

<item>With the parameter <tt/"Negative"/ you define a component with a
negative effect on the implicit function value.
Negative components are not visible on their own but they are useful
for modelling holes. Just try it.
</itemize>

The other parameter are specific to the type of the component:

<sect2>Metaball<label id="mbcp">
<p>
<itemize>
<item><tt/"Radius"/ sets the radius of the metaball
<item><tt/"EnergyCoeffA"/, <tt/"EnergyCoeffB"/, and <tt/"EnergyCoeffC"/
are some parameters for the metaball formula.
Usually you can leave those parameters at their default values.
If you change them, be careful.
</itemize>

<sect2>Torus<label id="mtcp">
<p>
<itemize>
<item><tt/"Ri"/ the inner radius of the torus
<item><tt/"Ro"/ the outer radius if the torus
<item><tt/"Rotate"/ rotates the torus about 90 degree
</itemize>

<sect2>Cube<label id="mucp">
<p>
<itemize>
<item><tt/"EdgeX"/, <tt/"EdgeY"/, and <tt/"EdgeZ"/, let you define the
sharpness of the edges of the cube
</itemize>

<sect2>Custom<label id="cucp">
<p>
<itemize>
<item><tt/"Expression"/ is a piece of Tcl script, that represents your
own custom formula for a meta component. The expression may call any
Tcl commands to calculate a field value from the current grid position,
which is given in the global variables <tt>"x"</tt>, <tt>"y"</tt>, and
<tt>"z"</tt>.
The expression has to return the field value in the global variable
<tt>"f"</tt>.
Here is an example for a custom expression:
<code>
set f [expr {pow($x,4)+pow($y,4)+pow($z,4)}]
</code>
Note that those expressions are called many times
and since they are programmed in Tcl, this can be quite slow.
You should use any tricks (like the curly braces
in the expr-statement above) to speed up the expression.
</itemize>

<sect>NURBS Modelling Tools<label id="nmtool">
<p>
This section describes NURBS curve and surface related modelling
tools, which you can find in the <tt/"Tools"/ menu of the main window.

<sect1>The Closed BSpline Tool<label id="cbspt">
<p>
<figure loc="ht">
<eps file="pics/multip.ps" height="5cm">
<img src="pics/multip.gif">
<caption>A Closed B-Spline</caption>
</figure>
<itemize>
<item>Arguments: Number of control points (i).
<item>Operation: This tool creates a closed cubic B-Spline curve with
i+3 control points in the XY plane. The control points are arranged
in a circle of radius 1 centered around the origin. This gives the curve
a circular appearance (see image above) but it is not a true circle:
If few control points are used, the radius of the circular curve
is clearly smaller than 1. Furthermore, the parameterisation and
curvature of the closed B-Spline are not exactly as one would
expect from a circle.
However, you can use the NURBCircle tool (see below) to create a true
circle instead.
<item>Note: i must be atleast 3. The first three control
points of the new curve will be identical to the last three.
Additionally, the curve will be marked as periodic and the generation
of multiple points will be enabled, so that point
edit actions know that they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

<sect1>The NURBCircle Tool<label id="ncirct">
<p>
<figure loc="ht">
<eps file="pics/ncircle.ps" height="5cm">
<img src="pics/ncircle.gif">
<caption>A NURBS Circle</caption>
</figure>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBCircle tool creates a full circular NURBS curve
of radius 1 in the XY plane located at the origin.
<item>Note: The NURBS curve created by the NURBCircle tool is rational
(uses weights). This means, editing the curve (e.g. moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished). Use a closed B-Spline
created with the Closed BSpline Tool (see above) if you want to edit
the curve further.
You can use this circle to easily create a NURBS-torus by moving
the circle along X and then revolving it. The amount of movement
determines the radius of the torus, whereas the radius of the circle
determines the thickness.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
</itemize>

<sect1>The NURBCircleArc Tool<label id="ncircat">
<p>
<itemize>
<item>Arguments: angle of the arc in degrees
<item>Operation: The NURBCircle tool creates a circular NURBS curve
arc of radius 1, with the specified angle, in the XY plane,
located at the origin.
<item>Note: The NURBS curve created by the NURBCircleArc tool is rational
(uses weights). This means, editing the curve (e.g. moving control points)
may lead to unpredicted results (the curve does not behave exactly
as wished).
</itemize>

<sect1>The TrimRect Tool<label id="trrt">
<p>
<itemize>
<item>Arguments: None
<item>Operation: The TrimRect tool creates a two-dimensional piecewise
linear NURBS curve of rectangular shape in the XY plane, that fits in
the (u,v) parameter space of a NURBS patch, for use as trim curve.
<item>Note: To fit the curve to the parameter space of a NURBS patch,
the NURBS patch object should be selected or the current level should be
inside the NURBS patch.
If no NURBS patch object is selected and the current level is not inside
a NURBS patch, a curve with the coordinates (-1,-1), (-1,1), (1,1),
and (1,-1) will be created instead.
Additionally, the created curve will be marked as closed and the generation
of multiple points will be enabled, so that point edit actions know that
they may need to move two points.
See also section <ref id="ncurvemp" name="Multiple Points">.
See section <ref id="trim" name="Trim Curves"> for a more
detailed discussion of trim curves and how to use the rectangular
curve created by the TrimRect tool.
</itemize>

<sect1>The NURBSphere Tool<label id="nspt">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a half circle NURBS curve
and revolves it about the Y axis thus forming a sphere of radius 1.
<item>Note: The NURBS curve is deleted afterwards.
</itemize>

<sect1>The NURBSphere2 Tool<label id="nsp2t">
<p>
<itemize>
<item>Arguments: None.
<item>Operation: The NURBSphere tool creates a Cobb-NURBSphere,
consisting of 6 NURBPatches.
<item>Note: The NURBPatches are of high order (5).
</itemize>

<sect1>The Revolve Tool<label id="revt">
<p>
<itemize>
<item>Arguments: The revolve tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Revolve object, and moves
the selected objects to it.
<item>Note: See section <ref id="revolveobj" name="Revolve Object">
for more information regarding the revolve object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Extrude Tool<label id="extt">
<p>
<itemize>
<item>Arguments: The extrude tool takes the selected objects from
the selection.
<item>Operation: The tool creates an Extrude object, and moves
the selected objects to it.
<item>Note: See section <ref id="extrudeobj" name="Extrude Object">
for more information regarding the extrude object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Sweep Tool<label id="swpt">
<p>
<itemize>
<item>Arguments: The sweep tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Sweep object, and moves
the selected objects to it.
<item>Note: See section <ref id="sweepobj" name="Sweep Object">
for more information regarding the sweep object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Cap Tool<label id="capt">
<p>
<itemize>
<item>Arguments: The cap tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Cap object, and moves
the selected objects to it.
<item>Note: See section <ref id="capobj" name="Cap Object">
for more information regarding the Cap object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Birail1 Tool<label id="bi1t">
<p>
<itemize>
<item>Arguments: The birail1 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail1 object, and moves
the selected objects to it.
<item>Note: See section <ref id="birail1obj" name="Birail1 Object">
for more information regarding the Birail1 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Birail2 Tool<label id="bi2t">
<p>
<itemize>
<item>Arguments: The birail2 tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Birail2 object, and moves
the selected objects to it.
<item>Note: See section <ref id="birail2obj" name="Birail2 Object">
for more information regarding the Birail2 object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Gordon Tool<label id="gort">
<p>
<itemize>
<item>Arguments: The gordon tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Gordon object, and moves
the selected objects to it.
<item>Note: See section <ref id="gordonobj" name="Gordon Object">
for more information regarding the Gordon object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Skin Tool<label id="skit">
<p>
<itemize>
<item>Arguments: The skin tool takes the selected objects from
the selection.
<item>Operation: The tool creates a Skin object, and moves
the selected objects to it.
<item>Note: See section <ref id="skinobj" name="Skin Object">
for more information regarding the Skin object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Revert Tool<label id="revertt">
<p>
<itemize>
<item>Arguments: The revert tool takes all NURBS curves and
ICurves from the selection.
<item>Operation: The direction of the selected NURBS curves will be
reversed.
<item>Note: The direction of a NURBCurve is shown as
a small arrow at the end of the curve.
</itemize>

<sect1>The Concat Tool<label id="conct">
<p>
<itemize>
<item>Arguments: The concat tool takes two NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be concatenated
and a new third curve will be created.
<item>Note: If one of the curves has weights, the resulting curve
will have weights too. If the knot type of the first curve
is <tt/"Custom"/, it will be converted to <tt/"NURB"/, otherwise the
knot type of the new curve will be that of the first selected curve.
Due to those changes of the knot values, the resulting curve might
differ from the original curves.
See also section <ref id="concatncobj" name="ConcatNC Object">.
The original NURBS curves will not be deleted by this tool.
</itemize>

<sect1>The Split Tool<label id="splitt">
<p>
<figure loc="ht">
<eps file="pics/splitnc.ps" height="4cm">
<img src="pics/splitnc.gif">
<caption>Split Tool (left: original curve, right: resulting split curves for t=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The split curves tool takes a single NURBS curve from
the selection and additionally requests a parametric value.
<item>Operation: The selected NURBS curve will be split into two
new NURBS curves at the designated parametric value. The splitting process
involves application of knot insertion, so that both new curves will
get a custom knot vector.
<item>Note: The original selected NURBS curve will be changed and
form the first of the two new curves, so you may want to keep a copy
of it somewhere.
</itemize>

<sect1>The Trim Tool<label id="trimt">
<p>
<figure loc="ht">
<eps file="pics/trimnc.ps" height="4cm">
<img src="pics/trimnc.gif">
<caption>Trim Tool (left: original curve, right: resulting trimmed curve for umin=0.1, umax=0.5)</caption>
</figure>
<itemize>
<item>Arguments: The trim curves tool takes all selected NURBS curves from
the selection and additionally requests two parametric values.
<item>Operation: The selected NURBS curves will be trimmed to the
designated parametric range (umin, umax).
<item>Note: The trimming process involves the application of knot insertion
so that the curves will get a custom knot vector.
</itemize>

<sect1>The Elevate Tool<label id="elevt">
<p>
<figure loc="ht">
<eps file="pics/elevate.ps" height="4cm">
<img src="pics/elevate.gif">
<caption>Successive Application of Elevate Tool (Order 3 (left), 4 (middle),
5 (right))</caption>
</figure>
<itemize>
<item>Arguments: The elevate tool takes a number of NURBS curves from
the selection and additionally requests an integer value.
<item>Operation: The order of the selected NURBS curves will be raised
by the specified integer value without changing the shape of the curve.
<item>Note: If the knot vector of the curve is not clamped, it
will be clamped automatically. The knot type of the curve will
be changed to custom. New control points will be added and the position
of old control points may be changed in the progress.
</itemize>

<sect1>The Refine Tool<label id="refit">
<p>
<figure loc="ht">
<eps file="pics/refine.ps" height="4cm">
<img src="pics/refine.gif">
<caption>Successive Application of Refine Tool</caption>
</figure>
<itemize>
<item>Arguments: The refine tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
refined by inserting a knot in the middle of each inner knot interval
without changing the shape of the curve.
<item>Note: Because a new knot is inserted in the middle of
each interval, knot vectors of type NURB and B-Spline will
not change in type. See the image above for an example of a
successive refinement of a simple NURBS curve. Note that the shape
of the curve does not change, but the position of
certain control points does.
If you want to refine a curve with new control points and not
change the position of existing control points, use the NCAttribute
property GUI instead (simply increase the length of the curve
by oldlength-1).
Also note that for periodic curves the refine tool just inserts
control points into all control point intervals except for the
first (last) p intervals (where p is the degree of the curve).
The shape of the curve will be changed in this case.
</itemize>

<sect1>The Coarsen Tool<label id="coart">
<p>
<figure loc="ht">
<eps file="pics/coarsen.ps" height="4cm">
<img src="pics/coarsen.gif">
<caption>Successive Application of Coarsen Tool</caption>
</figure>
<itemize>
<item>Arguments: The coarsen tool takes a number of NURBS curves from
the selection.
<item>Operation: Every second control point in the control vectors of
the selected NURBS curves will be deleted.
<item>Note: For periodic curves the coarsen tool will not remove
control points from the first (last) p intervals (where p is the degree
of the curve).
For closed curves, the coarsen tool will not remove the last point.
The coarsen tool will also remove knot values from curves with
custom knot vectors.
</itemize>

<sect1>The Clamp Tool<label id="clat">
<p>
<figure loc="ht">
<eps file="pics/clampnc.ps" height="4cm">
<img src="pics/clampnc.gif">
<caption>Clamp Tool (left: original curve, right: clamped curve)</caption>
</figure>
<itemize>
<item>Arguments: The clamp tool takes a number of NURBS curves from
the selection.
<item>Operation: The knot vectors of the selected NURBS curves will be
changed using knot insertion so that the first and the last knot
have a multiplicity equal to the order of the curve,
without changing the shape of the curve. The curve will
interpolate the first and the last control point afterwards.
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
</itemize>

<sect1>The Insert Knot Tool<label id="insknt">
<p>
<figure loc="ht">
<eps file="pics/inskn.ps" height="4cm">
<img src="pics/inskn.gif">
<caption>Left: original curve, Right: a knot has been inserted 1 time at t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS curves from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected curves, without changing the
shape of the curve(s).
<item>Note: The knot type of the curves will be changed to <tt/"Custom"/.
The point selection will be removed from the original objects.
</itemize>

<sect1>The Remove Knot Tool<label id="remknt">
<p>
<figure loc="ht">
<eps file="pics/remkn.ps" height="4cm">
<img src="pics/remkn.gif">
<caption>Remove Knot Tool (left: original curve, right: the knot at t=0.5 has been removed 1 time)</caption>
</figure>
<itemize>
<item>Arguments: The remove knot tool takes a number of NURBS curves from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be removed i
times from the knot vector of the selected curves.
<item>Note: The tool tries to work without changing the shape of the
curves, however, this is not guaranteed.
The point selection will be removed from the original objects.
</itemize>

<sect1>The Plot Curvature Tool<label id="plotcurt">
<p>
<figure loc="ht">
<eps file="pics/plotcur.ps" height="4cm">
<img src="pics/plotcur.gif">
<caption>Curvature Plot (top) of simple NURBS curve (bottom)</caption>
</figure>
<itemize>
<item>Arguments: The plot curvature tool takes a number of NURBS curves from
the selection and requests three additional values: the number of data
points, the width value and the height value.
<item>Operation: A new NURBS curve, depicting the curvature of the selected
NURBS curve, will be created for each of the selected
NURBS curves. The curvature plots will have a length defined by the
number of data points and will be scaled to the specified width
and by the specified height value. See also the image above.
</itemize>

<sect1>The Shift Closed B-Spline Tool<label id="shiftclbspt">
<p>
<figure loc="ht">
<eps file="pics/shiftclsbsp.ps" height="4cm">
<img src="pics/shiftclsbsp.gif">
<caption>Shift Closed B-Spline Tool (left: Closed B-Spline Curve, right: Shifted Curve)</caption>
</figure>
<itemize>
<item>Arguments: The shift closed B-Spline tool takes a number of
NURBS curves, that should be closed B-Splines, from the selection and
requests one additional integer parameter.
<item>Operation: The control points of the curve(s) will be shifted, so that
the second control point will be the first after this operation.
The shifting process will be repeated according to the integer parameter i
given.
<item>Note: Eventually selected points will still be selected after this
operation. See also the image above.
</itemize>

<sect1>The To XY Tool<label id="toxyt">
<p>
<figure loc="ht">
<eps file="pics/toxy.ps" height="5cm">
<img src="pics/toxy.gif">
<caption>To XY Tool (left: original curve, right: modified curve)</caption>
</figure>
<itemize>
<item>Arguments: The To XY tool takes a number of
NURBS curves from the selection. The NURBS curves should be planar.
<item>Operation: The control points of the curve(s) will be rotated,
so that they are in the XY plane of the respective object space defined by
the NURBS curve object(s). Additionally, the rotation attributes of
the NURBS curve object(s) will be changed so that the curve does not
change its orientation with regard to other objects or the world space.
See also the image above, where the left curve, planar but not defined
in the XY plane will be changed, so that it is defined in the XY plane
(mind the two different object coordinate systems in conjunction with
the world coordinate system in the middle).
<item>Note: A reverse operation, apart from undo, would be to apply the current
transformation attributes to the control points of the curves.
</itemize>

<sect1>The Make Compatible Tool<label id="makecompt">
<p>
<figure loc="ht">
<eps file="pics/makecomp.ps" height="4cm">
<img src="pics/makecomp.gif">
<caption>Make Compatible Tool (left: Original Curves, right: Compatible Curves)</caption>
</figure>
<itemize>
<item>Arguments: The Make Compatible tool takes a number of
NURBS curves from the selection.
<item>Operation: The curves will be made compatible, so that they
are of the same order and defined on the same knot vector.
<item>Note: This tool does not change the geometry of the curves.
However, since clamping, degree elevation, and knot insertion may be
used on the curves, their order, knot vectors, and control points
may be changed.
The point selection will be removed from the original objects.
</itemize>

<sect1>The Rescale Knots to Range Tool<label id="resckrt">
<p>
<itemize>
<item>Arguments: The rescale knots to range tool takes a number of
NURBS curves from the selection and requests a range (two float values).
<item>Operation: The knot vectors of the curves will be scaled, so that
their first and last values match the given range.
<item>Note: The knot type of the curve has to be <tt/"Custom"/!
This tool does not change the geometry of the curves.
</itemize>

<sect1>The Rescale Knots to Mindist Tool<label id="resckmt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS curves from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the curves will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots).
<item>Note: The knot type of the curve has to be <tt/"Custom"/!
This tool does not change the geometry of the curves.
</itemize>

<sect1>The Collapse Points Tool<label id="collt">
<p>
<itemize>
<item>Arguments: The collapse tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) control points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The selected control points will be made a
single multiple point, all points will get the coordinate values
of the last tagged point.
</itemize>

<sect1>The Explode Points Tool<label id="explt">
<p>
<itemize>
<item>Arguments: The explode tool expects a selected NURBS curve
or NURBS patch and a number of selected (tagged) multiple points
(see section <ref id="selac" name="Selecting Points"> for information
on how to select (tag) control points).
<item>Operation: The points forming the selected multiple points will
be made to simple points again and may be edited separately.
<item>Note: Even though you might have exploded some multiple points
Ayam will re-create them on several occasions like reading
of a scene, inserting/deleting points, and applying the NCurveAttr
or NPatchAttr property if all single control points of the multiple
point(s) still have identical coordinate values (and the <tt/"CreateMP"/
option of the curve or patch object is activated). You should immediately
edit the control points (move them apart) after exploding to avoid that
they automatically collapse to a multiple point again!
</itemize>

<sect1>The Swap UV Tool<label id="swapuvt">
<p>
<itemize>
<item>Arguments: The swap uv tool takes a number of NURBS patches,
BPatch, or PatchMesh objects from the selection.
<item>Operation: The u and v dimension of the selected objects will
be swapped without changing the shape of the patches.
</itemize>

<sect1>The Elevate UV Tool<label id="elevuvt">
<p>
<itemize>
<item>Arguments: The elevate uv tool takes a number of NURBS patches from
the selection and additionally requests two integer values.
<item>Operation: The order of the selected NURBS patches will be raised
by the specified integer values without changing the shape of the patches.
<item>Note: If the knot vector of the patch is not clamped, it
will be clamped automatically. The knot type of the patch will
be changed to <tt/"Custom"/. New control points will be added and the position
of old control points may be changed in the progress.
The point selection will be removed from the original object.
</itemize>

<sect1>The Revert U Tool<label id="revertut">
<p>
<itemize>
<item>Arguments: The revert u tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the u dimension (width).
</itemize>

<sect1>The Revert V Tool<label id="revertvt">
<p>
<itemize>
<item>Arguments: The revert v tool takes a number of NURBS patches
or BPatch or PatchMesh objects from the selection.
<item>Operation: The control point arrays of the selected objects
will be reversed in the v dimension (height).
</itemize>

<sect1>The Patch Clamp Tool<label id="clanpt">
<p>
<figure loc="ht">
<eps file="pics/clampnp.ps" height="4cm">
<img src="pics/clampnp.gif">
<caption>Patch Clamp Tool (left: Original Patch with B-Spline Knot Vectors, right: Clamped Patch)</caption>
</figure>
<itemize>
<item>Arguments: The patch clamp tool takes a number of NURBS patches from
the selection.
<item>Operation: The knot vectors of a selected NURBS patch will be
changed using knot insertion so that the first and the last knot
(in each direction) have a multiplicity equal to the order of the patch
(in the respective direction).
<item>Note: The shape of the patch will not change but the position of some
control points will. The patch interpolates the first and the last control
point afterwards. The knot types of the patch will be changed to type
<tt/"Custom"/.
The point selection will be removed from the original object.
There are also tools available that clamp a patch in u- or
v-direction only.
</itemize>

<sect1>The Patch Rescale Knots to Range Tool<label id="resckrnpt">
<p>
<itemize>
<item>Arguments: The patch rescale knots to range tool takes a number of
NURBS patches from the selection and requests a range.
<item>Operation: The knot vectors of the patches will be scaled, so that
their first and last values match the given range. Trim curves, if
present, will also be scaled to match the new range.
<item>Note: The knot types of the patch have to be <tt/"Custom"/!
This tool does not change the geometry of the patches.
</itemize>

<sect1>The Patch Rescale Knots to Mindist Tool<label id="resckmnpt">
<p>
<itemize>
<item>Arguments: The rescale knots to mindist tool takes a number of
NURBS patches from the selection and request a minimum distance value.
<item>Operation: The knot vectors of the patches will be scaled, so that
no two knots have a distance smaller than the given minimum distance
(except for multiple knots).
<item>Note: The knot types of the patch have to be <tt/"Custom"/!
This tool does not change the geometry of the patches.
</itemize>

<sect1>The Patch Insert Knot Tool<label id="insknnpt">
<p>
<figure loc="ht">
<eps file="pics/insknnp.ps" height="5cm">
<img src="pics/insknnp.gif">
<caption>Left: original patch, Right: a knot has been inserted 1 time at t=0.5</caption>
</figure>
<itemize>
<item>Arguments: The insert knot tool takes a number of NURBS patches from
the selection and requests two additional values, a parametric value t
and an integer value i.
<item>Operation: The specified knot (t) will be inserted i
times into the knot vector of the selected patches, without changing the
shape of the patches.
<item>Note: The knot type of the patch will be changed to <tt/"Custom"/.
This tool does not change the geometry of the patches.
The point selection will be removed from the original object.
</itemize>

<sect1>The Patch Split Tool<label id="splitnpt">
<p>
<itemize>
<item>Arguments: The patch split tool takes a number of NURBS patches from
the selection and requests a parametric value t.
<item>Operation: The patches will be split at the parametric value t
into two patches using knot insertion. The original patch will be
modified and a new patch will be created.
The point selection will be removed from the original object.
</itemize>

<sect1>The Extract Patch Tool<label id="extrnpt">
<p>
<itemize>
<item>Arguments: The extract patch tool takes a number of NURBS patches from
the selection and requests four parametric values: umin, umax, vmin, and vmax.
<item>Operation: Sub-patches will be extracted from the selected NURBS patch
objects, defined by the specified parametric values, and new NURBPatch objects
will be created. The original selected NURBPatch objects will not be changed.
</itemize>

<sect1>The Split to Curves Tool<label id="sptct">
<p>
<itemize>
<item>Arguments: The split to curves tool takes a single NURBS patch from
the selection.
<item>Operation: The selected NURBS patch will be split into NURBS curves,
along direction u or v.
<item>Note: The original NURBS patch object is not deleted.
</itemize>

<sect1>The Build from Curves Tool<label id="bfct">
<p>
<itemize>
<item>Arguments: The build from curves tool takes a number of NURBS curves from
the selection.
<item>Operation: The selected NURBS curves will be parsed, all curves
that are of equal length or longer than the first selected curve
will be used to form a new NURBS patch of the following dimensions:
Width: length of the first selected curve,
Height: number of used curves.
The order in u direction (Order_U) will be equal to the number of used curves
for numbers of two to four and four for bigger numbers of used curves.
The knot type in u direction (Knot-Type_U) will always be NURB.
Other parameters (Order_V, Knot-Type_V, Knots_V) are taken from
the first curve.
<item>Note: The original NURBS curves objects are not deleted.
</itemize>

<sect1>The Extract NC Tool<label id="extnct">
<p>
<itemize>
<item>Arguments: The Extract NC tool takes the selected objects from
the selection.
<item>Operation: The tool creates a ExtrNC object, and moves
the selected objects to it.
<item>Note: See section <ref id="extrncobj" name="ExtrNC Object">
for more information regarding the ExtrNC object.
This tool uses the object clipboard to move the objects so that the
original clipboard contents are lost when this tool finishes.
</itemize>

<sect1>The Tesselation Tool<label id="tesst">
<p>
<figure loc="ht">
<eps file="pics/tgui.ps" height="3cm">
<img src="pics/tgui.gif">
<caption>GUI of Tesselation Tool</caption>
</figure>
<itemize>
<item>Arguments: The tesselation tool takes all NURBS patches and
NURBS patch providing objects from the selection.
<item>Operation: A modal dialog box (see image above) will pop up,
that allows to select a tesselation method via a drop-down menu
and to tune the corresponding tesselation parameter(s) using a slider and
an entry widget. The initial method and parameter values will be derived
from the TP tag of the first of the selected objects (if it has such a tag).
<p>
The selected or provided NURBS patches will be tesselated with the
chosen method and parameters.
The PolyMesh objects created by the tesselation will immediately be
displayed in all view windows instead of the original objects.
Whenever tesselation method or parameters are changed, the tesselation
will be recomputed and displayed, thus, allowing an immediate estimation
of the tesselation quality.
<p>
If the preference option <tt>"Modelling/LazyNotify"</tt> is enabled,
updates of the tesselation that normally occur while dragging the
slider(s) will be deferred until the mouse button is released.
<p>
If the <tt/"Ok"/ button is pressed to close the tesselation tool, all
selected objects will be replaced by their tesselated
counterparts; if <tt/"Cancel"/ is used, all selected objects remain
unchanged.
<p>
If the check box <tt/"SaveToTag"/ is activated, closing the tesselation
tool using <tt/"Cancel"/ will also add a <tt/"TP"/ tag containing
the currently selected method and parameter value to all selected
objects. This tag will be evaluated later, when the respective
objects will be converted to PolyMesh objects. Since Ayam 1.11 the
conversion mechanism of objects keeps the <tt/"TP"/ tags, so that you
may e.g. save tesselation parameters for a sphere or a revolve object.
<item>Note: The tesselation tool will block most other parts of Ayam
while it is running. It is, however, possible to adjust view parameters
while the tesselation tool is open, to examine the tesselation result
more closely or from different viewing angles. The initial values of the
parameter slider bounds may be changed by simply entering values
that are out of bounds into the entry widget, then pressing the
<tt/&lt;Tab&gt;/ key. The resolution of the slider is calculated
automatically from the resolution of the value entered in the entry
widget.
</itemize>

See section
<ref id="prefmisc" name="Miscellaneous Preferences">
for a more extensive discussion of the tesselation methods
and their parameter(s).

<sect>The Tcl Scripting Interface<label id="script">
<p>
The scripting interface is mainly a bunch of Tcl procedures
and Tcl commands that a big part of Ayam uses internally.
<p>
Using Tcl, you could directly modify the code Ayam consists
of. This is, however, not recommended for good reasons.
So watch out for already existing procedures and commands when
implementing your own!
Using procedures and commands not listed in this documentation
is dangerous too. Implementation and interfaces of that
commands may change unnoticed in future versions.
<p>
The scripting interface may be used directly from the console
of Ayam. You can, of course, also write procedures in your own
Tcl script files, that may be loaded at any time into Ayam using
the console and the Tcl command <tt/"source"/.
You can also arrange for a script to be executed automatically
on startup using the preference setting <tt>"Main/Scripts"</tt>.
<p>
Note that most of the scripting interface commands listed in this
documentation work in the background, without changing anything to
the Ayam GUI and Ayam view windows, for the sake of execution speed.
If you want your changes to become visible you have to update the
various parts of the GUI explicitly
(see also section <ref id="sciupd" name="Updating the GUI">).
<p>
If you want your changes to be undoable, you have to arrange for
this manually too
(see the documentation of the undo command:
<ref id="scundo" name="Undo">).
<p>
From scripts it may be necessary to check wether an error occured
during the execution of a command. All commands return
TCL_OK in any case so checking their return value avails to nothing,
but they set the global Tcl variable <tt>ay_error</tt> to a value
higher than 1 if an error occured. You need to set it to zero before
and check it after the operation in question to see whether the
operation performed successfully:
<code>
proc myProc { } {
  set ::ay_error 0
  copOb
  if { $::ay_error > 1 } {
    ayError 2 "myProc" "Error copying object!"
  }
}
</code>

<sect1>Global Variables
<p>
Several global variables exist in the Ayam Tcl context, that may be useful
for scripts.

<sect2>The global array ay<label id="ayarray">
<p>
The global array <tt/"ay"/ holds application state variables.
Furthermore, you can find the paths to important widgets
(e.g. the tree widget for the object hierarchy or the currently
active view) in this array.
Use <tt/"parray ay"/ in the console to see what is there.
More documentation to come.

<sect2>The global array ayprefs<label id="ayprefs">
<p>
The global array <tt/"ayprefs"/ holds preferences data.
The complete array is saved in the <tt/"ayamrc"/ file upon exit,
so be careful when adding new entries.
You can reset your <tt/"ayamrc"/ file anytime using the command line
option <tt/"-failsafe"/.
Use <tt/"parray ayprefs"/ in the console to see what is there.
More documentation to come.

<sect1>Index of Procedures and Commands
<p>
This section provides documentation on the most important
scripting interface commands and procedures of Ayam sorted
by category.

<sect2>Getting Help on Scripting Interface Commands<label id="schelp">
<p>
Since Ayam 1.8.2 a scripting interface command named <tt/"help"/ is available,
that displays the help of scripting interface commands using a web
browser (similar to the <tt/"Help on Object"/ feature):
<itemize>
 <item>Synopsis: <tt/"help command"/
 <item>Description: Fire up a web browser and display the help for
the designated Ayam scripting interface command.
 <item>Example: <tt/"help help"/ displays the help of the help command.
</itemize>

<sect2>Creating Objects<label id="crtob">
<p><label id="sccrtob">
To create new objects the <tt/"crtOb"/ command can be used.
<itemize>
 <item>Synopsis: <tt/"crtOb type [args]"/
 <item>Description: New objects may be created with the command <tt/"crtOb"/,
type may be derived from the type name, as displayed in the tree view.<p>

Depending on the type, further arguments may (or have to) be given,
other types expect objects to be selected:<p>
  <itemize>
  <item><tt/"NCurve"/: NURBS curves accept a single integer as length of
the new curve, the length defaults to 4. Example:
<tt/"crtOb NCurve -length 10; uS; rV"/
  <item><tt/"NPatch"/: NURBS patches accept two integers as width and
height of the new patch, width and height both default to 4. Example:
<tt/"crtOb NPatch -width 2 -height 2; uS; rV"/
  <item><tt/"Level"/: Levels must be given an additional argument
determining the type of the new level, this argument may be one of:
<tt/"0"/ (level), <tt/"1"/ (union), <tt/"2"/ (intersection),
<tt/"3"/ (difference), <tt/"4"/ (primitive).
 <item><tt/"Material"/: Materials must be given an additional
argument giving the name of the new material. Example:
<tt/"crtOb Material default; uS; rV"/
 <item><tt/"Instance"/: creates an instance of the selected object.
 <item>...
 </itemize>
 <item>Example: Create a sphere and update the GUI:
<tt/"crtOb Sphere; uS; rV"/.
</itemize>

<sect2>Manipulating the Selection<label id="selob">
<p>
These commands are probably the most important ones, because many other
scripting interface commands operate on selected objects only:
<p><label id="scselob">
selOb - select object(s):
<itemize>
 <item>Synopsis: <tt/"selOb [index]"/
 <item>Description: Use this command to set or clear the current
selection, index may be an ordered list of indizes, a single index or empty.
If no index is given, the current selection will be cleared.
 <item>Examples: <tt/"selOb"/ clears the current selection, <tt/"selOb 0"/
selects the first object in the current level, <tt/"selOb 0 1"/ selects
the first two objects in the current level.
</itemize>

<p><label id="scwithob">
withOb - execute a command on certain selected object(s):
<itemize>
 <item>Synopsis: <tt/"withOb index [do] command"/
 <item>Description: Use this command to execute command on a
single object (designated by index) from a multiple selection
without changing the selection state of any objects.
 <item>Example: <tt>"withOb 2 {movOb 0 1 0}"</tt> moves the third
object from multiple selected objects. All objects stay selected.
</itemize>

<p><label id="scsl">
sL - select last object:
<itemize>
 <item>Synopsis: <tt/"sL"/
 <item>Description: Select the last object in the current level
and update the GUI. This command is often called in a sequence
after creating a new object like this:
<code>
# create object
crtOb NCurve
# update tree
uCR
# select new object
sL
</code>
</itemize>

<p><label id="schsl">
hSL - hidden select last object:
<itemize>
 <item>Synopsis: <tt/"hSL"/
 <item>Description: Select the last object in the current level
but do not update the GUI. This command is mainly for use in script
objects script code.
</itemize>

<sect2>Manipulating Properties<label id="sciprop">
<p>
Since Ayam 1.9 two new commands are implemented that ease
the manipulation of property values:

<p><label id="scgetproperty">
getProperty - get single property value
<itemize>
 <item>Synopsis: <tt/"getProperty propname(elemname) varname"/
 <item>Description: This command gets a single property element
named elemname from the property named propname of the currently
selected object and writes the result into the variable named varname.
 <item>Notes: In contrast to many other helper commands, the variable
varname does not have to be global.
This command runs more slowly than accessing the data array
that is associated with a property and calling the appropriate get-procedure
directly. See below for more information regarding direct access of
property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be retrieved in the variable <tt/"r"/ easily using the command
<tt/"getProperty SphereAttr(Radius) r"/
</itemize>

<p><label id="scsetproperty">
setProperty - set single property value
<itemize>
 <item>Synopsis: <tt/"setProperty propname(elemname) value"/
 <item>Description: This command sets a single property element
named elemname of the property named propname for the currently
selected object to the new value given in value.
 <item>Notes: This command runs more slowly than accessing the data array
that is associated with a property and calling the appropriate set-procedure
directly. See below for more information regarding direct access of
property values.
 <item>Example: Given that a single Sphere object is selected, its
radius may be set to the new value <tt/"3.0"/ easily using the command
<tt/"setProperty SphereAttr(Radius) 3.0"/
</itemize>
<p>
Direct (fast) access of property values:
<p>
Every property has a corresponding global array, where the data
of the property is saved.
This global array only holds useful data when the respective
property GUI is active, or when it has been filled explicitly by
the so called get-property callback.
The data may be transferred back to the selected object using
the so called set-property callback.
The names of the array and the callbacks may be inferred from another global
array that is named like the property itself, e.g. for the tags
property the following global array <tt/"Tags"/ is defined:
<code>
array set Tags {
arr   tagsPropData
sproc setTagsp
gproc getTagsp
w     fTagsAttr
}
</code>
The entry arr designates the name of the global property data array.
If sproc or gproc are empty (<tt/""/), a standard callback
named <tt/"setProp"/ or <tt/"getProp"/ should be used to get
or set the property values. Otherwise sproc and gproc designate
the set-property and get-property callbacks respectively.
<p>
The following global arrays and callbacks to get or set the data
exist:
<itemize>
 <item>property, array, get-property callback, set-property callback
 <item>Transformations, transfPropData, getTrafo, setTrafo
 <item>Attributes, attrPropData, getAttr, setAttrp
 <item>Material, matPropData, getMat, setMat
 <item>Tags, tagsPropData, getTagsp, setTagsp
 <item>list incomplete, more to come...
</itemize>


<sect2>Clipboard Operations<label id="sciclip">
<p>
These commands operate the object clipboard:
<p><label id="sccopob">
copOb - copy object:
<itemize>
 <item>Synopsis: <tt/"copOb"/
 <item>Description: Copy the selected object(s) to the object clipboard.
</itemize>
<p><label id="sccutob">
cutOb - cut object:
<itemize>
 <item>Synopsis: <tt/"cutOb"/
 <item>Description: Move the selected object(s) into the object clipboard.
</itemize>
<p><label id="scpasob">
pasOb - paste object:
<itemize>
 <item>Synopsis: <tt/"pasOb"/
 <item>Description: Copy the selected object(s) from the object
clipboard to the current level.
</itemize>
<p><label id="scdelob">
delOb - delete object:
<itemize>
 <item>Synopsis: <tt/"delOb"/
 <item>Description: Delete the selected object(s) from the scene.
</itemize>
<p><label id="sccmovob">
cmovOb - paste (move) object:
<itemize>
 <item>Synopsis: <tt/"cmovOb"/
 <item>Description: Move the objects from the object
clipboard to the current level.
</itemize>

<p>
The following commands operate the property clipboard,
which is totally independent from the object clipboard.
<p><label id="scpclip_copy"><label id="sccopyprop">
pclip_copy/copyProp - copy a property to the property clipboard
<itemize>
 <item>Synopsis: <tt/"pclip_copy mode"/ or <tt/"copyProp mode"/
 <item>Description: Copy the currently selected
property from the currently selected
object to the property clipboard.
If mode is 0, omit all marked entries, if mode is 1 copy just
marked entries.
Note that you may call this procedure also using the shortcut
<tt/"copyProp"/.
</itemize>

<p><label id="scpclip_paste"><label id="scpasteprop">
pclip_paste/pasteProp - paste a property
<itemize>
 <item>Synopsis: <tt/"pclip_paste"/ or <tt/"pasteProp"/
 <item>Description: Copy the property from the property clipboard
to the currently selected object.
Note that you may call this procedure also using the shortcut
<tt/"pasteProp"/.
</itemize>

<sect2>Hierarchy Operations<label id="scihier">
<p>
These commands manipulate the current level of Ayam:
<p><label id="scgodown">
goDown:
<itemize>
 <item>Synopsis: <tt/"goDown index"/
 <item>Description: Enter the object determined by index. If index is 0
and the current level is inside some other object (not the root)
the parent level will be entered instead.
</itemize>

<p><label id="scgoup">
goUp:
<itemize>
 <item>Synopsis: <tt/"goUp"/
 <item>Description: Go one level up in the object hierarchy.
</itemize>

<p><label id="scgotop">
goTop:
<itemize>
 <item>Synopsis: <tt/"goTop"/
 <item>Description: Go to the top level of the object hierarchy.
</itemize>

<sect2>Transformations<label id="scitrafo">
<p>
These commands transform objects or selected points of objects:
<p><label id="scmovob">
movOb - move objects:
<itemize>
 <item>Synopsis: <tt/"movOb dx dy dz"/
 <item>Description: Move the selected object(s) by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p><label id="scrotob">
rotOb - rotate objects:
<itemize>
 <item>Synopsis: <tt/"rotOb dx dy dz"/
 <item>Description: Rotate the selected object(s) by dx degrees around the
objects X axis, then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

<p><label id="scscalob">
scalOb - scale objects:
<itemize>
 <item>Synopsis: <tt/"scalOb dx dy dz"/
 <item>Description: Scale the selected object(s) by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

<p><label id="scmovsel">
movSel - move selected points:
<itemize>
 <item>Synopsis: <tt/"movSel dx dy dz"/
 <item>Description: Move the selected points by dx in direction of the
objects X axis, by dy in direction of the objects Y axis and by dz in
direction of the objects Z axis.
</itemize>

<p><label id="scrotsel">
rotSel - rotate selected points:
<itemize>
 <item>Synopsis: <tt/"rotSel dx dy dz"/
 <item>Description: Rotate the selected points by dx degrees around the
objects X axis then by dy degrees around objects Y axis and then by dz degrees
around the objects Z axis. Note the order of the rotations!
</itemize>

<p><label id="scscalsel">
scalSel - scale selected points:
<itemize>
 <item>Synopsis: <tt/"scalSel dx dy dz"/
 <item>Description: Scale the selected points by a factor of dx in
direction of the objects X axis, by a factor of dy in
direction of the objects Y axis and by a factor of dz in
direction of the objects Z axis.
<item>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently!
</itemize>

<p><label id="scdelegtrafo">
delegTrafo - delegate transformations:
<itemize>
 <item>Synopsis: <tt/"delegTrafo"/
 <item>Description: delegates the transformations associated
with the selected objects to their child objects. Additionally,
the transformations of the selected objects will be reset to the
default values.
</itemize>

<p><label id="scapplytrafo">
applyTrafo - apply transformations:
<itemize>
 <item>Synopsis: <tt/"applyTrafo sel&verbar;all"/
 <item>Description: applies the transformations encoded in the
transformation attributes of the selected objects to the points
(either all points, or just the selected ones if there are any)
of those objects.
Additionally, the transformations of the selected objects will
be reset to the default values.
</itemize>

<sect2>Manipulating Shaders<label id="scishaders">
<p>
These commands operate the shader properties:
<p><label id="scshaderset">
shaderSet:
<itemize>
 <item>Synopsis: <tt/"shaderSet shadertype [varname]"/
 <item>Description: Set the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. If varname is not given, the shader in question
is deleted from the object instead.
</itemize>

<p><label id="scshaderget">
shaderGet:
<itemize>
 <item>Synopsis: <tt/"shaderGet shadertype varname"/
 <item>Description: Get the shader of type shadertype for the selected
object. Type may be one of <tt/"surface"/, <tt/"displacement"/,
<tt/"light"/, <tt/"imager"/, <tt/"atmosphere"/, <tt/"exterior"/
or <tt/"interior"/. The shader will be written to an array
pointed to by varname.
</itemize>

<sect2>Manipulating Tags<label id="scitags">
<p>
These commands may be used to modify the tags of an object:
<p><label id="scaddtag">
addTag:
<itemize>
 <item>Synopsis: <tt/"addTag type value"/
 <item>Description: Add a tag with type-string type and value-string
value to the currently selected objects(s).
It is legal to deliver <tt>""</tt> as value parameter. This is e.g.
needed for the <tt/"NoExport"/ tag.
</itemize>

<p><label id="scdeltags">
delTags:
<itemize>
 <item>Synopsis: <tt/"delTags type"/
 <item>Description: Delete all tags of type-string type from
the currently selected objects(s).
If type is <tt/"all"/, all tags are deleted from the
currently selected objects(s).
</itemize>

<p><label id="scgettags">
getTags:
<itemize>
 <item>Synopsis: <tt/"getTags tvname vvname"/
 <item>Description: Get all tags from
the currently selected objects and put them as lists into two
variables named tvname for the tag type-strings and vvname for the tag
value-strings.
</itemize>

<p><label id="scsettags">
setTags:
<itemize>
 <item>Synopsis: <tt/"setTags tags"/
 <item>Description: Clear all tags from the currently selected object
and set new tags. The tag type-strings are taken from the list elements
with even index numbers
and the tag value-strings from the list elements with odd index numbers.
</itemize>

<sect2>Manipulating NURBS Curves and Surfaces<label id="scinurbs">
<p>
These are more specialized commands to change NURBS curve and surface
properties:
<p><label id="scclampnc">
clampNC - clamp NURBS curve:
<itemize>
 <item>Synopsis: <tt/"clampNC"/
 <item>Description: Clamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve will be changed to <tt/"Custom"/ and
the knots will have o equal values at start and end (where o is the
order of the curve).
See also section <ref id="clat" name="The Clamp Tool">.
</itemize>

<p><label id="scelevatenc">
elevateNC - elevate NURBS curve:
<itemize>
 <item>Synopsis: <tt/"elevateNC n"/
 <item>Description: Elevate the order of the selected NURBS curves
without changing the shape of the curves by n.
The knot type of the elevated curves will be changed to <tt/"Custom"/.
See also section <ref id="elevt" name="The Elevate Tool">.
</itemize>

<p><label id="scinsknnc">
insknNC - insert knot into NURBS curve:
<itemize>
 <item>Synopsis: <tt/"insknNC u r"/
 <item>Description: Insert a new knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curves) r times. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the curve and n is the length of the curve.
The knot type of the curves will always be changed to custom but
the shape of the curves will not change!
See also section <ref id="insknt" name="The Insert Knot Tool">.
</itemize>

<p><label id="scremknnc">
remknNC - remove knot from NURBS curve:
<itemize>
 <item>Synopsis: <tt/"remknNC u r"/
 <item>Description: Remove a knot at the position
specified by u (u must be in the valid range of the knot vector
of the selected curve) r times from the curve. Note that the
shape of the curve may be changed by this tool.
See also section <ref id="remknt" name="The Remove Knot Tool">.
</itemize>

<p><label id="screfinenc">
refineNC - refine NURBS curve:
<itemize>
 <item>Synopsis: <tt/"refineNC [{u1 u2 un}]"/
 <item>Description: Refine the knot vector of the selected NURBS curve
without changing the shape of the curve with n new knots {u1 u2 un}.
Or, if no list of new knots is given: add a new knot into each interval
in the old knot vector.
The knot type of the refined curve may be changed to <tt/"Custom"/.
See also section <ref id="refit" name="The Refine Tool">.
</itemize>

<p><label id="sccoarsennc">
coarsenNC - coarsen NURBS curve:
<itemize>
 <item>Synopsis: <tt/"coarsenNC"/
 <item>Description: Remove every second control point from the
selected NURBS curves.
See also section <ref id="coart" name="The Coarsen Tool">.
</itemize>

<p><label id="screvert">
revert - revert curves:
<itemize>
 <item>Synopsis: <tt/"revert"/
 <item>Description: Revert the direction of the selected NURBS curves
and interpolating curves.
</itemize>

<p><label id="screscaleknnc">
rescaleKnNC - rescale knots of NURBS curves:
<itemize>
 <item>Synopsis: <tt/"rescaleKnNC [-r rmin rmax|-d mindist]"/
 <item>Description: Rescale the knot vector(s) of the selected NURBS curve(s)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. Scaling to a minimum
distance ensures that all knots (except for multiple knots) have a distance
bigger than mindist afterwards. The knot type of the curve has to be
<tt/"Custom"/!
This operation does not change the shape of the curve.
</itemize>

<p><label id="scsplitnc">
splitNC - split NURBS curve
<itemize>
 <item>Synopsis: <tt/"splitNC u"/
 <item>Description: splits the selected NURBS curve at designated parametric
value into two curves, creating one new curve and modifying the original
selected curve.
</itemize>

<p><label id="sctrimnc">
trimNC - trim NURBS curve
<itemize>
 <item>Synopsis: <tt/"trimNC umin umax"/
 <item>Description: trims the selected NURBS curve to the designated
parametric range (umin-umax), modifying the original selected curve.
</itemize>

<p><label id="scclampnpu">
clampNPU - clamp NURBS patch in u-direction:
<itemize>
 <item>Synopsis: <tt/"clampNPU"/
 <item>Description: Clamp the u-direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
u-direction). See also section <ref id="clanpt" name="The Patch Clamp Tool">.
</itemize>

<p><label id="scclampnpv">
clampNPV - clamp NURBS patch in v-direction:
<itemize>
 <item>Synopsis: <tt/"clampNPV"/
 <item>Description: Clamp the v-direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <tt/"Custom"/ and the knots will have o
equal values at start and end (where o is the order of the patch in
v-direction). See also section <ref id="clanpt" name="The Patch Clamp Tool">.
</itemize>

<p><label id="screscaleknnp">
rescaleKnNP - rescale knots of NURBS patches:
<itemize>
 <item>Synopsis: <tt/"rescaleKnNP [-r[u|v] rmin rmax|-d[u|v] mindist]"/
 <item>Description: Rescale the knot vector(s) of the selected NURBS patch(es)
to the range <tt>[0.0, 1.0]</tt> (if no argument is present) or to the range
<tt>[rmin, rmax]</tt> if the <tt/"-r"/ argument is given or to the minimum
distance mindist if the <tt/"-d"/ argument is used. The <tt/"-ru"/, <tt/"-rv"/,
<tt/"-du"/, and <tt/"-dv"/ variants scale only the designated dimension.
Scaling to a minimum distance ensures that all knots (except for multiple
knots) have a distance bigger than mindist afterwards. Trim curves, if
present, will also be scaled to match the new range.
The knot types of the patch have to be <tt/"Custom"/!
This operation does not change the shape of the patch.
See also sections
<ref id="resckrnpt" name="The Patch Rescale Knots to Range Tool">
and
<ref id="resckmnpt" name="The Patch Rescale Knots to Mindist Tool">.
 <item>Example: <tt/"rescaleKnNP -ru 0.2 0.3"/ scales the u knot vector
of the selected NURBS patch objects to the new range (0.2, 0.3).
</itemize>

<p><label id="scinsknnpu">
insknNPU - insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknNPU u r"/
 <item>Description: Insert a new knot in u-direction at the position
specified by u, r times. u must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector U as follows: <tt/U[p] <= u <= U[n]/, where
p is the degree (order-1) of the patch in u-direction and n is the
width of the patch.
The u knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change!
See also section <ref id="insknnpt" name="The Patch Insert Knot Tool">.
</itemize>

<p><label id="scinsknnpv">
insknNPV - insert knot into NURBS patch:
<itemize>
 <item>Synopsis: <tt/"insknNPV v r"/
 <item>Description: Insert a new knot in v-direction at the position
specified by v, r times. v must be in the valid range of the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector V as follows: <tt/V[p] <= v <= V[n]/, where
p is the degree (order-1) of the patch in v-direction and n is the
height of the patch.
The v knot type of the patches will always be changed to <tt/"Custom"/ but
the shape of the patches will not change!
See also section <ref id="insknnpt" name="The Patch Insert Knot Tool">.
</itemize>

<p><label id="scsplitnpu">
splitNPU - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitNPU u"/
 <item>Description: Splits the selected NURBPatch objects into two patches
at parametric value u.

See also section <ref id="splitnpt" name="The Patch Split Tool">.
</itemize>

<p><label id="scsplitnpv">
splitNPV - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitNPV v"/
 <item>Description: Splits the selected NURBPatch objects into two patches
at parametric value v.
See also section <ref id="splitnpt" name="The Patch Split Tool">.
</itemize>

<p><label id="scextrnp">
extrNP - extract NURBS patch:
<itemize>
 <item>Synopsis: <tt/"extrNP umin umax vmin vmax"/
 <item>Description: Extracts a sub-patch from the selected NURBPatch
objects. The sub-patch is specified by the parametric values umin, umax,
vmin, and vmax which have to be in the respective valid knot range.
See also section <ref id="extrnpt" name="The Extract Patch Tool">.
</itemize>

<p><label id="scsplitnp">
splitNP - split NURBS patch:
<itemize>
 <item>Synopsis: <tt/"splitNP (u|v)"/
 <item>Description: splits the selected NURBPatch into NURBS curves,
along parametric dimension u or v.
See also section <ref id="splitt" name="The Split Tool">.
</itemize>

<p><label id="scbuildnp">
buildNP - build NURBS patch:
<itemize>
 <item>Synopsis: <tt/"buildNPatch"/
 <item>Description: builds a NURBPatch from the selected NURBS curves.
See also section <ref id="bfct" name="The Build from Curves Tool">.
</itemize>


<sect2>Manipulating Points<label id="scipoints">
<p>
Use these two commands to read or manipulate single points of arbitrary
objects.
Note that the exact arguments needed depend on the type of the selected
object, e.g. a NURBS curve requires just one index parameter (indexu),
whereas a NURBS patch requires two index parameters (indexu and indexv).

<p><label id="scgetpnt">
getPnt:
<itemize>
 <item>Synopsis: <tt/"getPnt [-trafo|-p] indexu [indexv] varx vary varz [varw]"/
 <item>Description: Get a control point of the currently selected object
and write the coordinate values into the variables varx, vary, varz, and
varw.
If the special argument <tt/"-trafo"/ is given, the coordinates
will additionally be transformed by the values given in the objects
Transformation property.
If the argument <tt/"-p"/ is given, the <tt/"indexu"/ and <tt/"indexv"/
values are interpreted as parametric values of a NURBS curve or surface
and the corresponding point on the curve or surface is delivered in
varx, vary, and varz.
<item>Examples: <tt/"getPnt 1 x y z w"/ gets the coordinate
values of the second point of the selected NURBS curve and writes
the values to the variables <tt/"x y z w"/. <tt/"getPnt -p 0.5 x y z w"/
gets the curve point at parametric value <tt/"0.5"/ and writes
the values to the variables <tt/"x y z w"/.
</itemize>

<p><label id="scsetpnt">
setPnt:
<itemize>
 <item>Synopsis: <tt/"setPnt indexu [indexv] x y z [w]"/
 <item>Description: Set a control point of the
currently selected object to the coordinates x, y, z, and w.
 <item>Example: <tt/"setPnt 1 0.0 0.2 0.3 1.0"/ sets the coordinate
values of the second point of the selected NURBS curve object to
<tt/"0.0 0.2 0.3 1.0"/.
</itemize>


<sect2>Updating the GUI<label id="sciupd">
<p>
These commands update various parts of the Ayam user interface:
<p><label id="scrv">
rV - redraw all views:
<itemize>
 <item>Synopsis: <tt/"rV"/
 <item>Description: Redraws all currently open views, except for
iconified views and views where automatic redraw has been turned off.
</itemize>

<p><label id="scus">
uS - update select:
<itemize>
 <item>Synopsis: <tt/"uS [update_prop maintain_selection]"/
 <item>Description: Update the object listbox or tree view after a change
to the object hierarchy.<p>

If update_prop is 0 no update of the property GUIs will take place.
If maintain_selection is 1 the old selection will be established again.
If both arguments are omitted update_prop defaults
to 1 and maintain_selection to 0.
 <item>Deficiencies: uS completely removes the object tree from
the tree widget and rebuilds
it, which can be a very time consuming operation (depending on the complexity
of the scene). There are some options to speed this process up:
 <itemize>
 <item>If there were just changes to the current level (and below)
the global array entry <tt/"ay(ul)"/ (UpdateLevel) may be set
to the current level before calling <tt/"uS"/. This will not remove
and update the complete scene but just the part below <tt/"ay(ul)"/.
Example:
<code>global ay; set ay(ul) $ay(CurrentLevel); uS;</code>.
 <item>If objects have been created and thus just need to be
added to the current level of the object tree view, the command
<tt/"uCR"/ may be used instead of <tt/"uS"/.
 <item>If just names or types of objects of the current level changed,
the command <tt/"uCL cl"/ may be used instead of <tt/"uS"/.
 </itemize>
</itemize>

<p><label id="scucl">
uCL - update current level:
<itemize>
 <item>Synopsis: <tt/"uCL mode [args]"/
 <item>Description: Update only the current level of the object listbox
or tree view after changes. See also the discussion of <tt/"uS"/ above.
The parameter <tt/"mode"/ may be "cl" or "cs", where "cl" is the normal
operation mode, and "cs" just clears the selection.
</itemize>

<p><label id="scucr">
uCR - update current level after create:
<itemize>
 <item>Synopsis: <tt/"uCR"/
 <item>Description: Update only the current level of the object listbox
or tree view after objects have been created and need to be added to
the current level. See also the discussion of <tt/"uS"/ above.
</itemize>

<p><label id="scplb_update">
plb_update - property listbox update:
<itemize>
 <item>Synopsis: <tt/"plb_update"/
 <item>Description: Clear the current property GUI, ask the currently
selected object for a list of properties and insert them in the
property listbox, then rebuild the property GUI of the property
with the same index in the property listbox
as the property selected before plb_update was started (this is not
necessarily a property of the same type).
</itemize>

<sect2>Custom Objects<label id="scicust">
<p>
This command manages custom objects (plugins):
<p><label id="scio_lc">
io_lc - load custom:
<itemize>
 <item>Synopsis: <tt/"io_lc filename"/
 <item>Description: Load the custom object (plugin) from file filename.
Note that it is currently not possible to unload a custom object from
Ayam.
</itemize>

<sect2>Applying Commands to a Number of Objects<label id="scifall">
<p>
There are two commands that help to apply arbitrary commands
to a number of objects, forAll and forAllT:
<p><label id="scforall">
forAll:
<itemize>
 <item>Synopsis: <tt>"forAll recursive command"</tt>
 <item>Description: The forAll command executes command for all
objects that have been selected currently, or for every object
of the current level if nothing has been selected. If recursive
is 1 then forAll will recurse into every object (if it has child objects)
before the execution of command. Note that forAll will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu first.
 <item>Deficiencies:
 <itemize>
  <item>A recursive forAll will
e.g. also descend into NURBS patches (if they have trim curves) and apply
the command to the trim curves, which might not exactly be what you
want. Use <tt>"forAllT"</tt> in this case.
  <item>The command will not have access to global arrays unless
e.g. one of the following construct is in use:<p>

<tt>"forAll 0 &lcub; uplevel &num;0 &lcub; commands &rcub; &rcub;"</tt><p>
<tt>"forAll 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAll"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<p><label id="scforallt">
forAllT:
<itemize>
 <item>Synopsis: <tt>"forAllT type recursive command"</tt>
 <item>Description: forAllT works the same way as forAll, with an
additional type check. The command will not be executed if the type of the
current object does not match the argument type. Note that forAllT will run
slowly if a property GUI is displayed. You can make it run faster
by de-selecting the property using e.g. the property context menu first.<p>

Note that the type strings will be converted to lowercase before
comparison, so that it is legal to use forAllT e.g. this way:
<p><tt>"forAllT ncurve 0 &lcub;puts $i&rcub;"</tt><p>
 <item>Deficiencies:
 <itemize>
  <item>The command will not have access to global arrays unless
e.g. one of the following constructs is in use:<p>
<tt>"forAllT ncurve 0 &lcub;uplevel &num;0 &lcub;commands&rcub; &rcub;"</tt><p>
<tt>"forAllT ncurve 0 &lcub; global arrayname; commands &rcub;"</tt><p>
  <item>It is not possible to use commands that change the object
hierarchy (e.g. deleting or inserting objects). The commands
may just modify existing objects. Since Ayam 1.9 <tt>"forAllT"</tt>
correctly maintains the current selection.
 </itemize>
</itemize>

<sect2>Scene IO<label id="scio">
<p>
These commands help to load scenes from and save them to Ayam scene
files:
<p><label id="scnewscene">
newScene:
<itemize>
 <item>Synopsis: <tt>"newScene"</tt>
 <item>Description: clears the current scene.
</itemize>

<p><label id="screplacescene">
replaceScene:
<itemize>
 <item>Synopsis: <tt>"replaceScene filename"</tt>
 <item>Description: clears the current scene, then loads a new scene
from filename.
</itemize>

<p><label id="scinsertscene">
insertScene:
<itemize>
 <item>Synopsis: <tt>"insertScene filename"</tt>
 <item>Description: inserts a scene from filename.
</itemize>

<p><label id="scsavescene">
saveScene:
<itemize>
 <item>Synopsis: <tt>"saveScene filename"</tt>
 <item>Description: saves the current scene to filename.
</itemize>

<sect2>RIB Export<label id="scribex">
<p>
This command allows to export the current scene to a RenderMan
Interface Bytestream (RIB):

<p><label id="scwrib">
wrib - RIB export:
<itemize>
 <item>Synopsis:
<tt>"wrib -file filename [-image imagename] [-smonly|-selonly]"</tt>
 <item>Description: exports the current scene to a RIB file designated
by <tt/"filename"/. If the argument <tt/"-image"/ is given, the RIB file
will create an image file named <tt/"imagename"/ upon rendering. The export
will use the camera transformation from the currently selected Camera
object. To use the camera transformations of the camera associated
with a view window use the corresponding Togl callback for the view
like this instead: <tt>.view1.f3D.togl wrib -file filename.rib</tt>.
If the argument <tt/"-smonly"/ is provided, a RIB to render shadow maps
will be created and the argument of <tt/"-image"/ will be ignored.
If the argument <tt/"-selonly"/ is given, only the selected (geometric)
objects will be exported, which will result in a RIB file not
suitable for rendering (no setup, camera transformation, or lights
are in it) but for inclusion into other scenes via RiArchive.
</itemize>

<sect2>Reporting Errors<label id="scierr">
<p>
This command is for error reporting from scripts:

<p><label id="scayerror">
ayError:
<itemize>
 <item>Synopsis: <tt>"ayError code place detail"</tt>
 <item>Description: This command reports errors or warnings.
You should always use ayError instead of puts because the error
reporting mechanism of Ayam features compression of repeated
messages and logging to files. Code should be one of: 1: warning, 2:
error, 3: flush messages, 4: unspecified output.
There are more codes defined (see ayam.h, look for Return/Error Codes)
but they are not needed in the Tcl script context.
Place should describe the procedure where the error occured.
Detail is the string to be output.
</itemize>

<sect2>Miscellaneous<label id="scimisc">
<p>
Miscellaneous commands:

<p><label id="scgettype">
getType:
<itemize>
 <item>Synopsis: <tt>"getType varname"</tt>
 <item>Description: This command writes the type of the
selected object into the variable varname. The types are
the well known strings that are displayed in the hierarchy list box
if the objects are not named (NPatch, NCurve, Sphere, etc.).
</itemize>

<p><label id="sctmpget">
tmpGet:
<itemize>
 <item>Synopsis: <tt>"tmpGet tmpdir varname"</tt>
 <item>Description: This command calculates a name for a temporary
file in tmpdir and puts the complete name into varname.
</itemize>

<p><label id="schaschild">
hasChild:
<itemize>
 <item>Synopsis: <tt>"hasChild"</tt>
 <item>Description: This command returns 0 if the selected object
has no child objects, otherwise it returns 1.
</itemize>

<p><label id="scundo">
undo:
<itemize>
 <item>Synopsis: <tt>"undo [redo|save opname|clear]"</tt>
 <item>Description:
 <itemize>
  <item>If called without arguments, this command performs the undo
  operation.
  <item>If the argument is <tt/"redo"/, this command performs the redo
  operation.
  <item>If the argument is <tt/"save"/, the currently selected objects
  are saved to the undo buffer for future undo operations. The name
of the now following modelling operation has to be provided in a second
argument.
This name will be displayed in the default console prompt, to inform the
user about which operation would be undone/redone, if undo/redo would be
used.
  <item>If the argument is <tt/"clear"/, the undo buffer is cleared.
 </itemize>
</itemize>
See also section <ref id="undos" name="The Undo System">.

<p><label id="scconvob">
convOb:
<itemize>
 <item>Synopsis: <tt>"convOb [-inplace]"</tt>
 <item>Description: This command calls the registered converter
for the selected object(s). If the option <tt>"-inplace"</tt> is
used the new object(s) will replace the old object(s).
</itemize>

<p><label id="scforcenot">
forceNot:
<itemize>
 <item>Synopsis: <tt>"forceNot"</tt>
 <item>Description: This command calls the registered notification
callback for the selected object(s) and their parents, or if no object
is selected for all objects of the scene.
</itemize>

<p><label id="scaddtoproc">
addToProc:
<itemize>
 <item>Synopsis: <tt>"addToProc procedure addition"</tt>
 <item>Description: This command adds the code from addition to
the procedure procedure.
 <item>Note: This command uses the introspection facilities of
Tcl and works only correctly for procedures, that end with
a single <tt>"return;"</tt> statement.
</itemize>

<sect1>Scripting Interface Examples
<p>
Here are some complete example scripts for the Ayam Tcl scripting interface.
<p>
You may copy and paste all examples directly from the documentation
into the console of Ayam.

<sect2>Moving Objects<label id="scexmov">
<p>
The following example script shows how to move a selected object
to a specified position in space.
<code>
proc placeOb { x y z } {
  global transfPropData

  # copy Transformations-property data to
  # global array "transfPropData"
  getTrafo

  # set array values according to procedure parameters
  set transfPropData(Translate_X) $x
  set transfPropData(Translate_Y) $y
  set transfPropData(Translate_Z) $z

  # copy Transformations-property data from
  # global array "transfPropData" to selected object
  setTrafo
}
# placeOb
</code>
In order to move all selected objects to 1 1 1 you may enter the
following into the console:
<code>
forAll 0 {placeOb 1 1 1}
</code>
But perhaps you would rather like a small GUI for that?
No problem, the following snippet adds an entry to the custom
menu that opens a small requester for the x-, y-, and z-values and
calls the <tt/"placeOb"/ procedure (defined above) with them:
<code>
global ay
$ay(cm) add command -label "Place Object" -command {
 runTool {x y z} {"X:" "Y:" "Z:"} "forAll 0 {placeOb %0 %1 %2}"
 plb_update; rV
}
</code>
The trailing <tt/"plb_update; rV"/ command ensures that the GUI is updated
properly and all views display the new position of the moved objects.

<sect2>Moving NURBS points<label id="scexnurb">
<p>
The following example script snippet shows how to move control points
of a NURBS curve.
<code>
# first, we create a new NURBS curve with 30 control points
set len 30
crtOb NCurve -length $len
# update selection
uS
# select last object (the newly created curve)
sL
# prepare moving
set i 0
set r 3.0
set angle 0
set angled [expr 3.14159265/2.0]
while { $i < $len } {

    set x [expr $r*cos($angle)]
    set y [expr $r*sin($angle)]
    set z [expr $i/3.0]

    # move control point to new position
    setPnt $i $x $y $z 1.0

    set angle [expr $angle + $angled]
    incr i
}
# redraw all views
rV
</code>
Now use this as path for a Sweep.
For instance, using the next small script.

<sect2>Easy Sweep<label id="scexsweep">
<p>
The following example script shows how to easily create a
sweep from a selected path curve (avoiding the manual and lengthy creation
and parameterisation of a suitable cross section).
<code>
proc easySweep { } {
 # first, we create a sweep object
 crtOb Sweep

 # now, we need to move the selected curve (path) to
 # the sweep and create a cross-section curve there too
 # for that, we move the currently selected curve to the clipboard
 cutOb
 uS

 # how does the current level look like?
 getLevel a b

 # enter the Sweep (the last object in the current level)
 goDown [expr [llength $a]-1]
 uS

 # now, we create a new curve (a closed B-Spline suitable as cross section)
 crtClosedBS 8
 uS

 # how does the current level look like?
 getLevel a b

 # select last object (the newly created curve)
 selOb [expr [llength $a]-1]

 # now, we rotate and scale the curve
 rotOb 0 90 0
 scalOb 0.25 0.25 1.0

 # move trajectory back (we use "cmovOb" and _not_ "pasOb", because we
 # really move (and not copy) the curve
 cmovOb
 # go up to where we came from
 goUp

 # update GUI
 uS
 sL
 # redraw all views
 rV
}
# easySweep
</code>

Run this pocedure by selecting a NURBS curve object, then type
into the console:
<code>
easySweep
</code>

You may add this command to the main menu as well:
<code>
global ay
$ay(cm) add command -label "Easy Sweep" -command {
 easySweep
}
</code>
After running the above script you should have a new menu
entry <tt>"Custom/Easy Sweep"</tt> that calls the <tt>easySweep</tt>
procedure.

<sect2>Toolbox Buttons<label id="scextoolbox">
<p>
Here is another example that shows how you may add buttons
to the toolbox.
myImage should be an image created e.g. from a GIF file of
the size 25 by 25 pixels.
<code>
global ay

# create an image from a GIF file:
image create photo myImage -format gif -file /home/user/giffile

set b .tbw.f.mybutton

# if the button not already exists:
if { ![winfo exists $b] } {

  # create it:
  button $b -padx 0 -pady 0 -image myImage -command myCommand

  # tell Ayam about the new button:
  # you can use linsert, to insert the button in a specific
  # place or just append to the end of the list
  lappend ay(toolbuttons) mybutton

  # display the button:
  # from now on, it will be under the
  # automatic toolbox layout management
  toolbox_layout
}
</code>

This example shows that a) buttons have to be created in the
frame <tt/".tbw.f"/
b) Ayam manages a list of all buttons in the global array ay
in <tt/"ay(toolbuttons)"/, the order in that list is the order
in which buttons appear in the toolbox c) automatic layout
management is carried out by the procedure <tt/"toolbox_layout"/.
<p>
Adding buttons with just text is a little bit more involved,
as the sizes of the new buttons often do not fit well in the
icon button scheme with its constant button size.
<p>
Here is an example that adds two buttons to the bottom of the
toolbox spanning the whole window (this works best with the
standard toolbox layout of 4 by 12 buttons):
<code>
# create a frame:
set f [frame .tbw.f.fcollex]

# calculate the row number below the last row:
set row [expr [lindex [grid size .tbw.f] 1] + 1]

# now display the frame at calculated row, spanning the whole window:
grid $f -row $row -column 0 -columnspan [lindex [grid size .tbw.f] 0]\
     -sticky we
# create two buttons inside the frame:
button $f.b1 -width 5 -text "Coll." -command { collMP; rV; }
button $f.b2 -width 5 -text "Expl." -command { explMP; rV; }
pack $f.b1 $f.b2 -side left -fill x -expand yes
</code>

<sect>Import and Export<label id="impex">
<p>
This section contains the documentation of all import and export
modules of Ayam.
<p>
Note that manual loading of an import or export plugin is no longer
necessary since Ayam 1.13. Simply use the main menu entries
<tt>"File/Open"</tt> and <tt>"File/Save as"</tt> (or the corresponding
keyboard shortcuts) and specify a filename with the appropriate
extension. Ayam will automatically load the matching plugin and
open the import (or export) options dialog with the <tt/"FileName"/
option already set.

<sect1>Mops Import<label id="impmops">
<p>
In older versions of Ayam, Mops scenes could be imported using the main
menu entry: <tt>"File/Import Mops"</tt>. Since Ayam 1.13 Mops import is
a plugin named <tt>"mopsi"</tt>. After loading the plugin, Mops scenes
may be imported using the main menu entry <tt>"File/Import/Mops"</tt>.
<p>
Ayam is able to import most elements of a Mops scene except for
RiAttributes attached to arbitrary geometric objects,
because attributes and shaders are managed by material objects in Ayam.
However, if a Mops object has a surface or displacement shader,
a material object with the shaders from the Mops object
and its RiAttributes will be automatically created and linked with
the geometric object while importing. Only Mops objects
with surface or displacement shaders are considered because
otherwise a material object would have to be created for every
imported Mops object.
The material objects are named <tt/"mat0"/, <tt/"mat1"/ and so on.
Make sure, that the current scene in Ayam does not contain material
objects with those names, otherwise Mops import will not be able to
create material objects for the scene to import.
<p>
The import options <tt>"ResetDM"</tt> and
<tt>"ResetST"</tt> control, whether GLU display mode
and tolerance settings (see sections
<ref id="ncattr" name="NCurveAttr">, and
<ref id="npattr" name="NPatchAttr"> for more information about
display mode and tolerance) of NURBS primitives should be reset
to using global preference values (the default in Ayam)
instead of using the values from the Mops scene file.

<sect1>AutoCAD DXF Import<label id="impdxf">
<p>
The <tt>"dxfio"</tt> plugin allows to import AutoCAD DXF (drawing exchange
format) files into Ayam with the help of the Dime library (from Systems in
Motion, AS).
<p>
Start importing a DXF file using the main menu entry
<tt>"File/Import/AutoCAD DXF"</tt>
(if this menu entry is not available, you have to load the
<tt>"dxfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The DXF import supports reading of the following entities:
3DFACE, ARC, CIRCLE, ELLIPSE, LINE, SOLID, TRACE, BLOCK, INSERT,
POLYLINE, LWPOLYLINE, SPLINE. Entities not listed here will
be silently ignored.
<p>
3DFACE entities are imported as PolyMesh objects if only the first
three points are unique (the entity describes a triangle) or the face
is planar else as BPatch objects.
<p>
ARC, CIRCLE and ELLIPSE entities will be read as NCircle objects with
corresponding <tt/"TMin"/, <tt/"TMax"/ parameters (for arcs and ellipses)
and scale transformation values (for ellipses) set.
<p>
POLYLINE entities are completely supported: Polylines will be imported as
NURBCurve objects; PolyMeshes and PolyFaceMeshes
will be imported as PolyMesh objects; B-Spline and Bezier surfaces
will be imported as NURBPatch objects.
<p>
LINE, LWPOLYLINE and SPLINE entities will be imported as NURBCurve objects.
<p>
SOLID and TRACE entities are imported as BPatch objects.
<p>
BLOCK and INSERT entities will be converted to appropriate master (referenced)
and instance objects (references).
<p>
Bulges and extrusions are not supported.
<p>
Note that the entire DXF file is read into memory before any geometry is
created.
<p>
The DXF import may be controlled via different options:<label id="impdxfopt">
<itemize>
<item><tt>"FileName"</tt> is the path and name of the DXF file to import.
<item><tt>"ReadCurves"</tt> if this is disabled, no freeform curves will
be imported.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
imported objects.
<item><tt/"ReadLayers"/:
By default, all entities from all layers will be imported.
Using the <tt/"ReadLayers"/ import option, a single layer or a range
of layers may be selected for import.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of imported
NURBS curves so that the distances between different knots are not smaller
than the given value. Using a value of 1.0e-04 leads to NURBS that may be
safely drawn using GLU. The default value 0.0 means no scaling.
<item><tt/"ErrorLevel"/: controls how many messages will be printed
to the Ayam console while importing. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, Dime is reading the DXF file; from 50 to 100 percent,
the dxfio plugin is converting the DXF entities to Ayam objects.
</itemize>

<sect1>RenderMan Interface Bytestream (RIB) Import<label id="imprib">
<p>
Using the RRIB (Read RIB) plugin you may import RenderMan Interface
Bytestreams into Ayam.
Start importing a RIB using the menu entry
<tt>"File/Import/RenderMan RIB"</tt>
(if this menu entry is not available, you have to load the
<tt>"rrib"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The RRIB plugin supports import of the following geometric
primitives:
<itemize>
<item>Quadrics (Sphere, Disk, Cylinder, Cone, Paraboloid, Hyperboloid, Torus)
<item>bilinear and bicubic patches and patch meshes
<item>NURBS patches (with trim curves)
<item>(general) polygons and (general) polygon meshes
<item>subdivision meshes (with all tags)
</itemize>

Furthermore, the plugin supports reading of CSG, object-instances,
archives, light sources (including area-lights), arbitrary linear
transformations (except shear transformations!), arbitrary
RiOptions and RiAttributes, shaders (except transformation
shaders and without array arguments!), (since Ayam 1.7)
arbitrary primitive variables (e.g. varying or vertex), and
(since Ayam 1.9) procedural objects and delayed read archives.
<p>
The RRIB plugin does not support reading of curves, implicit surfaces
(blobby models) and other calls to the RenderMan Interface that are not
so much useful for a RIB import like e.g. RiMakeTexture.
Unsupported geometric primitives and other calls to the RenderMan Interface
are silently ignored.
<p>
The RIB import may be controlled via different options:<label id="rribopt">
<itemize>
<item><tt/"ScaleFactor"/, determines a global scale factor to be applied
to all imported objects.
<item><tt/"ReadFrame"/, specifies the number of the frame in the RIB
to read. A value of -1 means, all frames are to be read. If you specify
a frame number and this frame does not show up in the RIB as
<tt/"FrameBegin &lt;yournumber&gt;"/ nothing will be
imported!
<item><tt/"ReadCamera"/: if this is switched on, a Camera object will
be created when the RIB plugin encounters a <tt/"WorldBegin"/. You may drag
this camera object onto a perspective View object in Ayam after import
to see through the camera of the imported RIB.
<item><tt/"ReadOptions"/, controls, whether RiOptions are
to be imported from the RIB to the scene. Note that those
RiOptions will overwrite the current global settings in the Ayam scene.
<item><tt/"ReadLights"/, if this is enabled the lights from the
RIB will be imported.
<item><tt/"ReadMaterial"/, controls, whether material objects
are to be created for the imported objects. All material objects
are created in a special level named <tt/"Materials"/ in the top level
of the scene. The plugin tries to keep the number of generated
material objects as low as possible by comparing with already
existing materials in this level. This also works with material
objects that exist before the RRIB plugin is invoked (as long as
they reside in this special level).
<item><tt/"ReadPartial"/, this option is useful if you want to
import partial RIBs (e.g. archives) that do not
contain a <tt/"WorldBegin"/.
Be careful with this option (i.e. use it only if reading of a RIB fails),
as it switches reading of all types of objects on, regardless of
the RIB structure.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS patches and trim curves so that the distances between different
knots are not smaller than the given value. Using a value of 1.0e-04 leads
to NURBS that may be safely drawn using GLU. The default value 0.0 means
no scaling.
<item><tt/"ErrorLevel"/, this option controls how many error messages
should be printed to the Ayam console while reading the RIB. Available
values are: <tt/"Silence"/ no output except for severe errors,
<tt/"Errors"/ all error messages should be printed,
<tt/"Warnings"/, all error and warning messages should be printed,
and finally <tt/"All"/ all messages, even informative,
should be printed.
Note that in the case of serious syntactic errors of the RIB file
more informative error messages are printed to the stderr channel
of Ayam (which is not redirected to the Ayam console).
</itemize>

Note that for NURBS patches and bicubic patch meshes, points of type
"P" will be promoted to "Pw". Trimming of NURBS patches by clamping
the knot ranges is not supported (however, since Ayam 1.9 UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values).
Furthermore, objects of type (general) polygon and polygon mesh will
be promoted to general polygon meshes.
Object-instances are resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
Procedural objects will not be evaluated, instead, RiProc objects
will be created, that carry all arguments and create the same
sequence of RIB requests upon export as was read upon import.

<sect1>RenderMan Interface Bytestream (RIB) Export<label id="exprib">
<p>
RenderMan Interface Bytestream (RIB) export is the most important export
module of Ayam and in fact justifies its existence. All features of the
Ayam object and scene structure are supported (hierarchy, CSG, instances,
materials, lights).
Furthermore, Ayam also supports rendering in multiple passes for
shadow maps and permanent previews (where a RenderMan renderer is directly
coupled to an Ayam view window).

The documentation on RIB export is spread over the Ayam documentation,
this section gives some general information and otherwise just points
to the real documentation sections.

RIB export is always available, it does not need a plugin to be loaded.
The corresponding main menu entry is <tt>"File/Export/RenderMan RIB"</tt>
and the keyboard shortcut is <tt/&lt;Ctrl+E&gt;/.
To control the RIB export and rendering, many options exist that are
documented in section <ref id="prefrib" name="RIB export preferences">.

There are also some special ways to export RIBs available in the
main menu: <tt>"Special/RIB-Export"</tt>, this is documented in
section <ref id="mmspecial" name="Special Menu">.

Ayam can not only export scenes as RIB but also call various
RenderMan renderers to directly render the exported RIB files to
the screen or to an image file.
Documentation on how to export/render directly from a view window
can be found in section <ref id="vmview" name="The View Menu">.

<sect1>Wavefront OBJ Import<label id="impwav">
<p>
Since Ayam 1.8.3 a Wavefront OBJ (version 3.0) import facility is available
and since Ayam 1.13 it is a plugin (objio) that needs to be loaded
before import.
The corresponding main menu entry is
<tt>"File/Import/Wavefront OBJ"</tt>.
<p>
Wavefront OBJ import supports reading of polygonal faces with vertex
normals and texture coordinates (read as primitive variable tags) and
freeform curves and surfaces (NURBS) with trim curves and with
texture coordinates (read as primitive variable tags).
<p>
Freeform curves and surfaces of basis type bmatrix, cardinal and taylor
are currently not supported. Also, import of special curves and
points (e.g. curve on surface) is currently not supported. Furthermore,
trimming of freeform curves and surfaces by clamping their knot ranges
is not supported (however, since Ayam 1.9, UMM/VMM
tags will be created, that contain the new knot minimum and maximum
values). No material and grouping information will be imported.
Unsupported statements will be silently ignored.
<p>
The following options further control the import process:
<itemize>
<item><tt>"FileName"</tt> is the name of the Wavefront OBJ file (version 3.0)
<item><tt>"MergeFaces"</tt> controls, whether consecutive polygonal
faces should be merged into a single PolyMesh object for import.
<item><tt>"MergePVTags"</tt> controls, whether the PV tags of PolyMesh
objects should be merged as well if they are subject to automatic
merging (see above).
<item><tt>"ReadCurves"</tt> if this is disabled, no freeform curves will
be imported. This option does not influence reading of trim curves!
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. Using a value of 1.0e-04 leads
to NURBS that may be safely drawn using GLU. The default value 0.0 means
no scaling.
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
imported objects.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates.
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 100 percent, the objio plugin is reading lines from the
Wavefront OBJ file and creating Ayam objects.
</itemize>
<p>
Wavefront OBJ import expects the file to be syntactically correct.
The plugin is not very good in detecting and reporting errors. If the
import fails, use third party tools first (e.g. a demo version of Okino
Graphics PolyTrans(R)), to check whether the Wavefront OBJ file is
valid at all.
<p>
Furthermore, note that Ayam supports Wavefront version 3.0 syntax only,
files that use older syntax will not be imported correctly.

<sect1>Wavefront OBJ Export<label id="expwav">
<p>
Since Ayam 1.7, it is possible to export scenes or objects to the Wavefront
OBJ format (version 3.0). Since Ayam 1.13, Wavefront OBJ export is a plugin
(objio) that needs to be loaded before export.
The corresponding main menu entry is
<tt>"File/Export/Wavefront OBJ"</tt>.
The Wavefront export currently supports the following
objects:
<itemize>
<item>NCurve and objects that may be converted to NCurve
objects (ICurve, ConcatNC, ExtrNC)
<item>NPatch (with trim curves) and objects that may be converted
to NPatch objects (BPatch, PatchMesh, Revolve, Sweep, Extrude, Skin,
Cap, Gordon, Birail1, Birail2, Text); since Ayam 1.8.3 also Quadrics
will be automatically converted to NURBS surfaces and exported
<item>PolyMesh and objects that may be converted to PolyMesh objects
(MetaObj), faces with holes are not supported by the Wavefront OBJ
format and will be tesselated to triangles for export automatically
<item>Box
<item>Instance, Clone; both will be resolved to normal objects for export
as Wavefront OBJ does not support referenced geometry
<item>Level, CSG operations are not supported and will be written
as normal Level objects, transformations will be delegated
to the child objects
</itemize>

Since the Wavefront OBJ format does not support separate transformation
attributes, all transformation attributes will be used to transform the
coordinate values (the control points) of the exported objects.
The hierarchy of the Ayam scene will be squashed.
CSG operations are fully ignored, all objects will be written
as if combined by the union operator.
<p>
The Wavefront OBJ export, currently, ignores all material information.
Only the pure geometry information is written to the OBJ file.
Since Ayam 1.8.3, however, texture coordinates from primitive variable
tags can be exported.
Since Ayam 1.9, UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
<p>
The following parameters, additionally, control the Wavefront OBJ export:
<itemize>
<item><tt>"FileName"</tt> is the filename of the Wavefront OBJ file;
<item><tt>"WriteSelected"</tt> exports only the currently selected object(s);
<item><tt>"TessPoMesh"</tt> automatically tesselates all PolyMesh objects
to triangles for export;
<item><tt>"WriteCurves"</tt> writes all NURBS curves and NURBS curve providing
objects to the exported file (This option does
not influence the export of trim curves.);
<item><tt/"ScaleFactor"/ allows to apply a scaling factor to all
exported objects;
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates.
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 100 percent, the objio plugin is writing the Ayam objects
to the Wavefront OBJ file.
</itemize>

<sect1>3DMF (Apple) Import<label id="imp3dmf">
<p>
Using the MFIO plugin you may import scenes from the 3DMF format
(version 1.0 only!) from Apple. Start importing a 3DMF file using the
menu entry <tt>"File/Import/Apple 3DMF"</tt> (if this menu entry is not
available, you have to load the <tt>"mfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
Import supports the following primitives:
<itemize>
<item>Polyline, Triangle, TriGrid, Polygon, general Polygon, Box,
<item>NURBS curve, NURBS surface (with trim curves),
<item>Ellipsoid, Cylinder, Cone, Disk, and Torus.
</itemize>

The following transformations are supported:
<itemize>
<item>Scale,
<item>Translate,
<item>Rotate, RotateQuaternion, RotateAxis (if axis is X, Y, or Z).
</itemize>
Furthermore, the import plugin reads the structure of the scene from Container
objects. Reference objects will be resolved to normal objects while importing.
Instances may be easily created again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
Support for import of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect1>3DMF (Apple) Export<label id="exp3dmf">
<p>
Using the MFIO plugin you may export scenes to the 3DMF format (version
1.0 only!) from Apple. Start exporting to a 3DMF file using the menu entry
<tt>"File/Export/Apple 3DMF"</tt> (if this menu entry is not available, you
have to load the <tt>"mfio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The MFIO export supports the following primitives:
<itemize>
<item>NURBS curve and NURBS surface (with trim curves) including all
NURBS curve/surface providing objects, such as ICurve, Skin etc.,
<item>Sphere, Disk, Cone, Cylinder, Torus,
<item>Box, and PolyMesh.
</itemize>

All transformations are supported and will be written as
Translate, Rotate, and Scale transformations, respectively.
All Instance objects will be resolved for export.
Level objects (regardless of type) will be written as Container objects.
If an object has a material, the color and opacity of the material
will be written as DiffuseColor and TransparencyColor, if the red
component has a value different from -1.
<p>
Support for export of lights, camera attributes as well as
material attributes other than material color and opacity is currently
not available.

<sect1>3DM (Rhino) Import<label id="imprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that may import
scenes from the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio - OpenNURBS IO)
by Robert McNeel & Associates.
<p>
Start importing from a Rhino 3DM file using the menu entry
<tt>"File/Import/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The import functionality of the onio plugin currently covers
import of all NURBS and BRep objects and objects that may
be converted to NURBS using the OpenNURBS toolkit
(those are: PolylineCurve, PolyCurve, LineCurve, ArcCurve,
CurveOnSurface, RevSurface, SumSurface, and PlaneSurface).
References will be resolved. Names will be imported, but
converted to an ASCII representation. Since Ayam 1.8.3
Mesh objects will be imported to PolyMesh objects, texture
coordinates will be read and appropriate PV tags will be
created for them.
<p>
The import process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/:
The <tt/"ScaleFactor"/ option allows to apply a scaling factor to all
imported objects.
<item><tt/"Accuracy"/:
The <tt/"Accuracy"/ import option controls the tolerance
of OpenNURBS internal operations, in this case the value is
mostly used for conversion operations to the NURBS form.
<item><tt/"ReadCurves"/:
If the <tt/"ReadCurves"/ import option is switched off, no curves will be
imported. This option does not influence the import of trim curves.
<item><tt/"ReadLayers"/:
By default, all objects from all layers will be imported.
Using the <tt/"ReadLayers"/ import option, a single layer or a range
of layers may be selected for import.
<item><tt/"IgnoreFirstTrim"/:
Another import option is <tt/"IgnoreFirstTrim"/, this is useful
if the first bounding trim loop of NURBS surfaces should be ignored.
This trim loop is often not needed, because it encloses the whole
surface that is not trimmed further in many cases. Importing this
trim loop will often just make the Ayam scene more complex than needed.
<item><tt/"RescaleKnots"/ allows to rescale the knot vectors of
NURBS curves, patches, and trim curves so that the distances between different
knots are not smaller than the given value. Using a value of 1.0e-04 leads
to NURBS that may be safely drawn using GLU. The default value 0.0 means
no scaling.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates.
<item><tt/"Progress"/: displays the progress of the import;
from 0 to 50 percent, OpenNURBS is reading the 3DM file into memory;
from 50 to 100 percent, the onio plugin is converting the 3DM objects
to Ayam objects.
</itemize>

<sect1>3DM (Rhino) Export<label id="exprhino">
<p>
Since version 1.8.2 Ayam contains a plugin named onio that may export scenes
to the Rhino 3DM file format using the OpenNURBS toolkit
(hence the name of the plugin onio - OpenNURBS IO)
by Robert McNeel & Associates.
<p>
Start exporting to a Rhino 3DM file using the menu entry
<tt>"File/Export/Rhino 3DM"</tt>
(if this menu entry is not available, you have to load the
<tt>"onio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
The export functionality of the onio plugin currently covers
export of all boxes, quadrics, NURBS, instances, clones, script
objects (of type <tt/"Create"/ or <tt/"Modify"/) and objects that
may be converted to NURBS curves or surfaces.
Even though export of planar cap surfaces of various
tool objects is supported, the export of general trimmed NURBS
patches is not well supported. This is because of a missing feature
(pushing up 2D trim curves to 3D curves for arbitrary NURBS
surfaces) in the OpenNURBS toolkit. Since Ayam 1.9, a coarse
polygonal 3D representation of the 2D trim curves will be
created automatically, so that now general trimmed NURBS patches
may be exported, albeit with lower quality and bigger file size
as would be necessary.
Since Ayam 1.9, UMM/VMM tags are used to trim the knot vectors of
exported NURBS objects.
Since Ayam 1.8.3, also PolyMesh objects may be exported.
<p>
The export process is controlled by the following options:
<itemize>
<item><tt/"ScaleFactor"/:
The <tt/"ScaleFactor"/ option allows to apply a scaling factor to all
exported objects.
<item><tt/"Accuracy"/:
The <tt/"Accuracy"/ option controls the tolerance of internal
OpenNURBS operations (currently those are:
pushing up 2D trim curves to 3D curves and
checking NURBS surfaces for planarity).
<item><tt/"WriteSelected"/: exports only the selected objects. 
<item><tt/"ObeyNoExport"/: ignores all objects with <tt/"NoExport"/ tags. 
<item><tt/"IgnoreHidden"/: ignores all hidden objects. 
<item><tt/"WriteCurves"/: If the <tt/"WriteCurves"/ option is disabled,
no curves will be written to the exported Rhino file. This option does
not influence the export of trim curves.
<item><tt/"QuadAsBRep"/: If the <tt/"QuadAsBRep"/ option is enabled
spheres, cylinders, cones, and torii will not be exported as collection
of NURBS surfaces (as converted by Ayam) but as BRep objects (as converted
by the OpenNURBS toolkit).
However, not all features of the quadric objects will be translated in
this case:
The BRep sphere does not support ZMin, ZMax, and ThetaMax.
The BRep cylinder does not support ThetaMax (base caps will
be created if the cylinder is closed).
The BRep cone does not support ThetaMax (a base cap will be
created, if the cone is closed).
The BRep torus does not support PhiMin, PhiMax, and ThetaMax.
The <tt/"QuadAsBRep"/ option has no effect on the export of disks,
hyperboloids, and paraboloids. Those will always be exported as NURBS
surfaces.
<item><tt>"TopLevelLayers"</tt> controls whether the top level objects
in the Ayam scene to be exported should be interpreted as layers.
If this option is enabled, objects that are not in one of those levels
will be written to the default layer. Furthermore, top level object names
will become layer names.
<item><tt>"STagName"</tt> controls the name of the PV tag to be used
for the s component of the texture coordinates, and
<item><tt>"TTagName"</tt> controls the name of the PV tag to be used
for the t component of the texture coordinates.
<item><tt/"Progress"/: displays the progress of the export;
from 0 to 50 percent, the onio plugin is converting the Ayam objects
to 3DM objects; from 50 to 100 percent OpenNURBS is writing the 3DM file.
</itemize>
<p>
Since the Rhino 3DM file format does not support hierarchy and
transformation attributes per object, the hierarchy of the Ayam scene
will be squashed and all transformation attributes will be applied to
the control points of the objects for export. CSG operations are fully
ignored, all objects will be written as if combined by the union operator.
Furthermore, all instance objects will be resolved to normal objects. All
objects will be written to the first layer, the default layer (unless the
<tt>"TopLevelLayers"</tt> option is used). Object names will be written
as well. Names of level objects will be prepended to the names of their
child objects. The object hierarchy:
<code>
+-Arm(Level)
 | MySphere(Sphere)
 \ MyCylinder(Cylinder)
</code>
for instance, leads to two objects in the Rhino file
named <tt>"Arm/MySphere"</tt> and <tt>"Arm/MyCylinder"</tt>.
<p>

<sect1>X3D (Web3D) Import<label id="impx3d">
<p>
Since version 1.13 Ayam contains a plugin named <tt>"x3dio"</tt> that may
import scenes from the XML based X3D file format published by the Web3D
Consortium. The XML parser used in this plugin is based on Expat and SCEW.
<p>
Binary and compressed versions of X3D, as well as VRML files are not
supported! Only pure XML files are read by the <tt>"x3dio"</tt> plugin.
<p>
Start importing from a Web3D X3D file using the menu entry
<tt>"File/Import/Web3D X3D"</tt>
(if this menu entry is not available, you have to load the
<tt>"x3dio"</tt> plugin using the menu entry
<tt>"File/Load Plugin"</tt> first).
<p>
<sect2>X3D Element Support
<p>
The import functionality of the <tt>"x3dio"</tt> plugin currently covers
import of the following elements:
<itemize>
<item>Geometry3D: Box, Sphere, Cylinder, Cone, IndexedFaceSet,
IndexedTriangleSet, IndexedTriangleStripSet, IndexedTriangleFanSet,
IndexedLineSet.

Cylinders with just one cap are imported as two objects (a Cylinder and
a Disk). Otherwise the <tt>"Closed"</tt> attribute is set according to
the cap information.

<item>Geometry2D:
Arc2D, ArcClosed2D, Circle2D, Disk2D, Polyline2D.

Arcs and Circles are imported as NCircle objects.
Closed arcs and Polylines are imported as NURBS curves.
Disks with an inner radius > 0.0 are imported as Hyperboloids (otherwise
as Disks).

<item>NURBS: NurbsCurve, NurbsCurve2D, NurbsPatchsurface,
TrimmedNurbsPatchsurface, Contour2D, ContourPolyline2D.

<item>Light sources:

<item>Non geometric: Transformation, Shape, Group.
</itemize>
<p>
Unsupported elements will be silently ignored. Prototyping and
dynamic scenes as well as scripts are not supported.
<p>
Shape elements that contain more than one geometric elements will
be imported as level objects.

<sect2>X3D Attribute Support
<p>
The <tt>"solid"</tt> attribute is always ignored.
<p>
The DEF and USE attributes are supported for all elements, however,
the corresponding master-instance relationships are completely
resolved upon import. Instances of objects may be easily created
again using Automatic Instancing
(see section <ref id="ai" name="Automatic Instancing">).
<p>
The DEF attributes may be converted to object names.

<sect2>X3D Import Options
<p>

<sect1>X3D (Web3D) Export<label id="expx3d">
<p>
Since version 1.13 Ayam contains a plugin named x3dio that may export
scenes to the XML based X3D file format published by the Web3D Consortium.
The XML parser is based on Expat and SCEW.
<p>

<sect>Miscellaneous
<p>
<sect1>The Undo System<label id="undos">
<p>
Using the undo system you may correct mistakes you made while modelling.
However, it is currently not possible to undo any changes to the object
hierarchy, including clipboard and Drag-and-Drop operations.
If you delete an object, it is gone! If you, accidentally, move
an object using Drag-and-Drop, undo will not help!
Only changes to objects are undoable. This includes changes
made by modelling actions, changes made using property GUIs, but also changes
to views (type changes or changes to the camera settings associated
with a view).
<p>
The undo system works by storing copies of the different
states of changed objects in an undo buffer. The storage space occupied by
the undo buffer may be adjusted using the preferences
(<tt>"Prefs/Modelling/UndoLevels"</tt>). Note that a value of -1 for
UndoLevels completely disables the undo system.
You may step backward through the saved states using
<tt/&lt;Ctrl+z&gt;/ (undo) but also forward using <tt/&lt;Ctrl+y&gt;/ (redo).
<p>
Several actions will completely clear the undo buffer (no undo is
possible after those actions):
Delete Object, New Scene, Open (Replace) Scene, and Close View.
<p>
Note that undo/redo will also modify objects that currently reside in the
object clipboard if they have saved states in the undo buffer.

<sect1>Ayamrc File<label id="ayamrc">
<p>
To customize Ayam the ayamrc file may be used.
This file is either pointed to by the environment
variable <tt>AYAMRC</tt> or is determined as following:
<itemize>
<item>On Unix it is <tt>"&tilde;/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
<item>On Win32 platforms (Windows95-2000) it is
<tt>"&dollar;(HOME)/ayamrc"</tt> if the environment variable
<tt>HOME</tt> exists, else <tt>"&dollar;(TEMP)/ayamrc"</tt>.<p>
<item>On Mac OS X Aqua (not X11!) it is
<tt>"&tilde;/Library/Preferences/.ayamrc"</tt>, where <tt>"&tilde;"</tt>
denotes the home directory of the current user.
</itemize>

The ayamrc file is read on each start of Ayam and saved again on exit
(if the preference setting <tt>"Main/AutoSavePrefs"</tt> is enabled).
<p>
The ayamrc file contains:
<enum>
<item>preference settings (including some hidden settings that require
just occasional tweaking and are not reachable using the GUI preference
editor)
<item>position and size of the main window and the toolbox window
<item>keyboard shortcuts to menu entries and modelling actions
<item>RiOption and RiAttribute databases
</enum>

You may edit the file by hand, but keep in mind, that the file will be
parsed by Tcl. Should you, for some reason, destroy your ayamrc so that
Ayam does not start correctly anymore you may start Ayam with the command
line option <tt>"-failsafe"</tt>.
When the application is left the next time, or the main menu entry
<tt>"Save Prefs"</tt> is invoked a correct ayamrc will be created again.
All preference settings will be reset to factory defaults, however!<p>
Another way to reset the ayamrc is to  simply delete it using the
main menu entry <tt>"Special/Reset Preferences"</tt>.


<sect2>Changing Keyboard Shortcuts
<p>
You may adapt the shortcuts used in the GUI to your special needs using
the ayamrc file. Note that if you do that the GUI (the menu entries)
will adapt to your changes but certainly neither this documentation nor
the tutorials!
Ayam does not check for clashes! This means, the last set binding
for a key will be used.
On Unix, the output of the program <tt/xev/ and the
manual page for the <tt/bind/ command of Tk provide helpful
information about which strings may be used to describe
key presses.
You can also use the Ayam console for this, just enter:
<code>
toplevel .keytest
bind .keytest <Key> {puts %K}
</code>
Now you can activate the new toplevel window and type on your keyboard
while the Ayam console prints the names of the keys.

For your convenience, the special string <tt/"Ctrl"/ will be replaced by
<tt/"Control"/ before a shortcut is handed to the <tt/bind/ command.

Example:
<code>
set aymainshortcuts(Prefs) {Ctrl-p}
</code>
sets the keyboard shortcut for opening of the preferences editor
to <tt/&lt;Ctrl+p&gt;/.
See the ayamrc file itself for a complete listing of available shortcuts.

<sect2>Hidden Preference Settings<label id="hidprefs">
<p>
The ayamrc file currently contains the following adjustable hidden
preference settings:
<itemize>

<item><tt/"Balloon"/: time in ms until the tooltip window appears
(default: 1500 - 1.5s)

<item><tt/"EFlush"/: time in ms between two flushes of the error message buffer
(default: 2000 - 2s)

<item><tt/"toolBoxList"/: a list of sections or groups of buttons
describing the appearance of the toolbox window (default, using all
available sections: <tt>{trafo trafo2 solids misco nurbs toolobjs points
nctools1 nctools2 camera misc}</tt>)

<item><tt/"Kill"/: name of a program that kills other processes and accepts
a process id as argument (used by the Rendering GUI)
(default: <tt>"kill"</tt>) (a setting of <tt>"kill"</tt> will be
automatically replaced by <tt>"kill.exe"</tt> on Win32)
On the Win32 platform you may also use an internal kill command
<tt>"w32kill"</tt> that has been introduced in Ayam 1.4.

<item><tt/"Cat"/: name of a program that can read from and write to
a pipe (used by the Rendering GUI) (default: <tt>"cat"</tt>)
(a setting of <tt>"cat"</tt> will be
automatically replaced by <tt>"cat.exe"</tt> on Win32)

<item><tt/"KeepNTmpFiles"/: how many
incarnations of the scene in RIB form (which actually may be split
in more than one file due to e.g. instances) created by Direct
Rendering should be kept on disk (default: 5)

<item><tt/"Wpclip_pastetosel"/: should
<tt>"Special/Clipboard/Paste Property to Selected"</tt> raise a warning
requester? (default: 1 - yes)

<item><tt/"DailyTips"/: a list of strings that appear as tips
on startup in the console

<item><tt/"PickTolerance"/: the tolerance used to determine whether an object
should be picked or not (default: 5); this setting determines the size
of a rectangular area around the picked point in pixels, all objects that
are inside or touch this area are considered picked

<item><tt/"MaxTagLen"/: the maximum number of characters to be displayed
in the buttons in the Tag Property GUI (default: 30)

<item><tt/"Wait"/: set this to <tt/"waitPid"/ if you want to enable
the work around for zombie processes created by the Rendering GUI.
This is e.g. necessary for the Linux platform.

<item><tt/"Prompt"/: controls the prompt for the console. If
set to an empty string a default of
<code>
\[Undo:$ay(undoo)/Redo:$ay(redoo)\].../[file tail [pwd]]&gt;
</code>
will be used, which displays the name of the operations that you can
undo and redo and the last component of the current
directory of Ayam.
You may e.g. change this to <tt/"[pwd]&gt;"/
to see just the full path name of the current directory.
If you want to display the value of a
variable in the prompt (e.g. designating the current level in
the scene hierarchy) you need to bind a write-trace to that variable,
that calls the procedure <tt/"update_prompt"/. This write-trace
may e.g. be established using a small script like this:
<tt/"trace variable &lt;vname&gt; update_prompt"/.
<item><tt/"BackupExt"/: is the file name extension to be used for backup
files. Default values are <tt>"&tilde;"</tt> for Unix and
<tt>".bak"</tt> for Win32.

<item><tt/"SelXOR_R"/, <tt/"SelXOR_G"/, <tt/"SelXOR_B"/: determine
a color value that is used for drag selection rectangles.
Note that the color is not used directly but combined with the
color value of already drawn pixels by XOR. The default values
are 255 for the red, 128 for the green, and 0 for the blue component.

<item><tt/"IconGamma"/: this setting may be used to adapt the contrast
of all icons (in view menu and toolbox) to your display gamma. If you
are on a SGI it is recommended to set this to about "0.7".

<item><tt/"AddViewParams"/ allows to add custom parameters to the
view OpenGL widget creation, like e.g. <tt/"-stereo true"/.

<item><tt/"AskScriptDisable"/ controls the warning dialog that
appears if scenes with script objects or tags are loaded.

<item><tt/"WarnUnknownTag"/ controls the warning messages for
unknown tag types.

<item><tt/"FixX11Menu"/ enables a workaround for non-sticky menus
on X11 (displaced menus do not stay open). This option is enabled
by default and not used on the Win32 platform.

<item><tt/"SafeAutoFocus"/ disables AutoFocus
(see section <ref id="prefgui" name="preference settings">)
when certain dialog windows are open, so that they do not get
shuffled under other windows by accidental mouse movements on systems
where the window manager does only auto raise.
This option is enabled by default on Win32.

<item><tt/"UseInternalFD"/ switches to an internal file dialog for loading
of plugins. This option is only used on MacOSX/Aqua (not X11!), because
there the normal file dialog will not enter application bundle directory
structures. This option is enabled by default on MacOSX/Aqua.

<item><tt/"SwapMB"/, <tt/"SwapMBSC"/ allow to swap mouse buttons 2 and 3
on MacOSX/Aqua (not X11!) for specified mouse bindings (<tt/"SwapMBSC"/),
because on MacOSX/Aqua, traditionally, the naming of the
middle and rightmost mouse button is reversed compared to X11/Win32.
This option is enabled by default on MacOSX/Aqua and allows to use
the same set of mouse bindings (the same ayamrc file) for X11 and
Aqua without sacrificing user experience. The middle mouse button,
by default, zooms the view, and the right one moves the view.

<item><tt/"CursorEnd"/, this option is enabled by default. If switched
on, the first click into the console will move the cursor to the input
prompt, ready for command input, instead of moving the cursor to the
point of the click.

<item><tt/"PrepDiaCap"/, this option prepends the title of a message box
that is normally displayed in the window frame of the message box to the
message in the box. This may be necessary because on some systems the title
string might be displayed in an unreadable font or not at all.
On Mac OS X Aqua (not X11!) this option is enabled by default.
On all other systems this option is disabled by default.

<item><tt/"LineWidth"/, line width used for drawing the lines of
unselected objects (blue lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"SelLineWidth"/, line width used for drawing the lines of
selected objects (white lines in standard color configuration).
The default value is 1.0. Ayam is not checking, whether the specified
value is supported by the OpenGL implementation used.

<item><tt/"ALFileTypes"/, <tt/"ALPlugins"/ two lists that describe
file name extensions and corresponding plugins that import and export
files of the type designated by the file name extensions.

</itemize>

<sect2>RiOption and RiAttributes Database<label id="rioptdb">
<p>
Using your ayamrc file, you may also adapt the database of RiOptions and
RiAttributes to your rendering system.
<p>
You can then easily add those options and attributes
to your scenes using tags and the main menu entries
<tt>"Special/Tags/Add RiOption"</tt> and
<tt>"Special/Tags/Add RiAttribute"</tt>,
see also sections
<ref id="riatag" name="RiAttribute Tag"> and
<ref id="riotag" name="RiOption Tag">.
<p>
The syntax for a new RiOption is quite simple as the following example shows:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug" } } }
</code>
This snippet sets the section <tt>"runtime"</tt> and adds a single
option, <tt>"verbosity"</tt>, to it. The option is declared to be of type
string using <tt>"s"</tt> and provided with a list of default values:
<tt>"{ "silent" "normal" "stats" "debug" }"</tt>.

To add another option to this section, say the option <tt>"op"</tt>
which shall be an integer value you have to change the aforementioned
snippet to:
<code>
set riopt(runtime) { { verbosity s { "silent" "normal" "stats" "debug"} }
 { op i }
}
</code>
As you can see, it is not mandatory to provide default values.
But be careful with the brackets!

Available types of parameters are:
<itemize>
<item>i: a scalar integer value
<item>j: a pair of integer values
<item>f: a scalar float value
<item>g: a pair of float values
<item>s: a string value
<item>p: a point in space (simply three float values), the default
values (if provided) are three float values in curly braces, such as
<tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
<item>c: a color, the default values (if provided) are three float
values in curly braces, such as <tt>{{0.0 0.0 0.0}{1.0 1.0 1.0}}</tt>
</itemize>

<sect1>Environment Variables<label id="envvars">
<p>
This section documents the environment variables used by Ayam.
<itemize>
<item><tt>"AYAMRC"</tt>: designates the full filename of the ayamrc file.
<item><tt>"HOME"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> is not set).
<item><tt>"TEMP"</tt>: path to the ayamrc file (used on Win32 if
<tt>"AYAMRC"</tt> and <tt>"HOME"</tt> are not set); also initial value of the
<tt>"TmpDir"</tt> preference setting (used on Win32 if no ayamrc file exists,
that specifies <tt>"TmpDir"</tt>).
<item><tt>"AYNOSPLASH"</tt>: if this variable is set to 1, the splash
screen will not be shown
<item><tt>"BROWSER"</tt>: filename of the preferred WWW browser (used to
display the documentation URL)
<item><tt>"NETSCAPE"</tt>: (if <tt>"BROWSER"</tt> does not exist) filename
of the Netscape WWW browser (used to display the documentation URL)
<item><tt>"SHADERS"</tt>: initial value of <tt>"Shaders"</tt> preference
setting (used if no ayamrc file exists).
</itemize>

<sect1>Repair Ayam<label id="repayam">
<p>
Since Ayam 1.8.2 an external Tcl script named <tt>"repairAyam.tcl"</tt> is
provided that may be used to repair the application state of Ayam
should it be stuck e.g. in an endless loop of Tcl error messages.
<p>
On Unix systems <tt>"repairAyam"</tt> may be started from any
shell simply by typing <tt>"./repairAyam.tcl"</tt> or
<tt>"wish repairAyam.tcl"</tt> (without the quotes)
on the command prompt; if the script detects that it is running on Unix
and not in Ayam it will send itself to the Tcl interpreter Ayam is
running in using the Tk send command. On Mac OS X Aqua (not X11!)
AppleScript events will be used instead of the Tk send command.
If this does not work as expected <tt>"repairAyam.tcl"</tt> may still
be run via the Ayam console (as on Win32).
<p>
On Win32 you have to start <tt>"repairAyam.tcl"</tt> from the Ayam console
using the command: <tt>"source scripts/repairAyam.tcl"</tt> or using
the consoles context menu: <tt>"Console/Load File"</tt>.
<p>
The script <tt>"repairAyam.tcl"</tt> should be considered a last resort
to help you save your modified objects!
<p>
The script will close all views, clean up the application state variables,
reset the mouse cursor and the console prompt, and try to update important
main window widgets. Since Ayam 1.9 it will also clear the console and
try to break potential endless loops running e.g. in the console or
in script objects.
<p>
After running <tt>"repairAyam.tcl"</tt> you should immediately save
the scene (or just the important objects you were editing, possibly using
<tt>"Special/Save Selected"</tt>) to a scratch file and restart Ayam.

<sect1>Shader Parsing Plugins<label id="spplugins">
<p>
Since Ayam 1.3, the following plugins are provided to allow
parsing of shaders: <tt/"ayslb"/ for Air, <tt/"ayslx"/ for Aqsis,
<tt/"ayso"/ for RDC, <tt/"ayslo"/ for PRMan, <tt/"ayslo3d"/ for 3Delight,
(since Ayam 1.6) <tt/"aysdr"/ for Pixie, and (since Ayam 1.11)
<tt/"aygso"/ for Gelato.
<p>
After loading of one of the aforementioned plugins, Ayam will
be able to parse shaders compiled with the shader compiler
of the respective renderer.
<p>
A shader parsing plugin may be loaded
automatically on startup of Ayam using one of the provided Tcl scripts:
<tt/"loadayslb.tcl"/, <tt/"loadayslo.tcl"/, <tt/"loadayslo3d.tcl"/,
<tt/"loadayslx.tcl"/, <tt/"loadayso.tcl"/, <tt/"loadaysdr.tcl"/,
and <tt/"loadaygso.tcl"/.
To automatically load a plugin simply add the appropriate
script to the preference setting
<tt>"Main/Scripts"</tt> using the <tt>"Add"</tt> button in the
preferences editor.
<p>
Additionally, those scripts may be further adapted to
set a different <tt/"Shaders"/ preference setting or to immediately
scan for shaders after loading of the plugin. For that, just remove
the leading hash-marks (&num;) from the corresponding lines in the script.
Changing the scripts is not necessary if you load the shader parsing plugin
automatically on startup of Ayam, as the loading of the scripts will
happen before the Ayam startup sequence executes the initial shader scanning
pass.
<p>
However, the standard behavior of the loading script while manually
loading of such a plugin requires you to adapt the shaders search path
manually and to scan manually for shaders too.
Both actions may be carried out using the preferences editor. Scanning
for shaders may also be started using the main menu:
<tt>"Special/Scan Shaders"</tt>.
<p>
To better accomodate the fast changing world of RenderMan renderers,
since Ayam 1.11 all shader parsing plugins are Ayam version independent.
This allows to distribute updated shader parsing plugins without
updating Ayam too and thus in a higher frequency.

<sect1>Automatic Instancing<label id="ai">
<p>
Automatic Instancing is available via the main menu entry:
<tt>"Special/Instances/Automatic Instancing"</tt>.
Automatic Instancing creates instances from all instantiable
objects from the current level and below,
using a simple algorithm that recursively compares
objects. The comparison of materials and tags may be turned off in the
small dialog that pops up after selection of the menu entry
<tt>"Special/Instances/Automatic Instancing"</tt>.
<p>
The algorithm is able to create instances of grouping objects
too (objects with child objects, e.g. levels or tool-objects
like revolve).
However, in order for two grouping objects to be instantiated
not only all child objects and the grouping objects
have to be instantiable, but the child objects also
have to be in the right order. It is not sufficient,
that for every child of the potential master, a matching
child of the potential instance exists.
Instantiation of grouping objects may drastically decrease
the total number of objects in a scene.
<p>
Note that before the automatic instantiation starts, all currently
existing instances will be resolved!
After instantiation some statistics will be displayed in the console.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Automatic Instancing of
Hierarchically Organized Objects", in: Kunii T.L. (ed.): Spring
Conference on Computer Graphics (SCCG 2001) Conference Proceedings, Budmerice,
Slovakia, 25-28 April 2001, ISBN 80-223-1606-7</it>

<sect1>Importance Driven Rendering (IDR)<label id="idr">
<p>
The importance driven rendering plugin may be used to drastically
reduce rendering times while developing a scene.
It works in three main steps:
<enum>
<item>Importance values are assigned to elements of the scene.
<item>Two rendering passes are started according to the
assigned importance values. Elements of different importance
values are mutually masked out using <tt>"RiMatte"</tt> statements.
<item>The resulting partial images are composed to a single
resulting image, which is then displayed.
</enum>
The parameterisation of the two rendering passes ensures, that
the total rendering time is lower than the rendering time of
a single pass with high quality.
<p>
Many options exist to assign importance and parameterize the
rendering passes:
<p>
Elements of the scenes may be geometric objects, regions in image space,
or regions in object space.
Importance values are currently just binary values.
Assignment may take place manually (using IDR tags) or half-automatic
by derivation of importance from currently selected or changed
objects. To avoid inconsistency in the resulting images, importance
values may be propagated between (geometrically or hierarchically) near
objects, or between objects that are related (e.g. from a material to a
geometric object).
<p>
Parameterisation of the two rendering passes currently includes selection of
a different renderer and the possibility to reduce rendering resolution and
shading rate. To further reduce rendering times for raytracing
renderers, the size of the region to render may be automatically adapted to
the elements of the current importance value (including an optimisation
run that balances renderer startup times and times needed to render
regions not originally occupied by two regions to merge).
<p>
Furthermore, caching of partial images is possible. However, the implementation
of this feature is not very sophisticated at the moment, as it
uses the Unix text tool <tt>"diff"</tt> to decide whether two RIB streams are
identical and hence need no re-rendering.

To start using IDR:
<enum>
<item>load a scene (e.g. the cactus example scene),
<item>load the IDR plugin (menu <tt>"File/Load Plugin"</tt>),
<item>open the IDR control window using the main menu
<tt>"Custom/Open IDR"</tt>,
<item>set the assign mode to <tt>"Selection"</tt>,
<item>select an object in the scene (e.g. the object named <tt>"Pot"</tt>),
<item>then press the <tt>"Render!"</tt> button.
</enum>
Compare the rendering time with a full render from the view window.

IDR requires that atleast the renderer of the second rendering pass
honours RiMatte! Since rgl does not honour RiMatte, it is sometimes
necessary to simply exclude objects of different importance value.
No wrong images are to be expected from this, as rgl does not calculate
other than local lighting effects.

More information about this subject can be found in:<p>
<it>Schultz, R., and Schumann, H.: "Importance Driven
Rendering - Using Importance Information in the Rendering Process",
in: Hamza M., Sarfraz M. (ed.): Computer Graphics and Imaging (CGIM 2001)
Conference Proceedings, Honolulu, Hawaii, 13-16 August 2001,
ISBN 0-88986-303-2</it>

<sect1>CSG preview using the AyCSG plugin<label id="aycsg">
<p>
<figure loc="ht">
<eps file="pics/csgex.ps" height="5cm">
<img src="pics/csgex.gif">
<caption>CSG preview example (left without, right with CSG)</caption>
</figure>
<p>
The AyCSG plugin may be used to resolve and preview CSG operations.
For this, the plugin uses image based CSG rendering algorithms provided
by the OpenCSG library. The OpenCSG library, currently, supports
the Goldfeather and the SCS algorithm. The latter only works
properly with convex primitives. Since both, Goldfeather and SCS, are
image based rendering algorithms, there is no limit in geometric object
types that may be used in CSG hierarchies. You may e.g. use Quadrics, NURBS,
and Metaballs in every possible combination. You just have to make sure,
that every CSG primitive describes a closed space.
<p>
In order for the CSG rendering algorithms to work properly, the depth
complexity (convexity) of a primitive must be known.
The depth complexity of a primitive determines the maximum number
of forward oriented surfaces any ray through this primitive would pass.
A regular sphere has a depth complexity of 1, a torus of 2, but do
not confuse depth complexity with genus, they are different values!
A 3D representation of the letter A e.g. has a genus of
1 but a depth complexity of 3.
The depth complexity of a primitive should be stored in a <tt/"DC"/ tag.
A torus would e.g. get a tag named <tt/"DC"/ with the value <tt/"2"/.
If no <tt/"DC"/ tag is present for a primitive, a default value for
the depth complexity of <tt/"1"/ will be used.
If you fail to correctly specify the depth complexity, rendering
errors, like missing parts of surfaces, will occur.
<p>
Note that the correct operation of AyCSG not only depends on the
depth complexity but also the winding order of the OpenGL primitives
(triangles or quads) used for drawing of the CSG primitives. The
winding order has to be consistent in a scene, so that the rendering
algorithm can decide what is inside and what is outside by looking
at a single OpenGL primitive. For all quadric primitives of Ayam
the winding order is always consistent. However, for NURBS patches
the winding order depends on the orientation of the patch dimensions.
If NURBS patches are used in CSG operations you, consequently, may
need to revert the patches (e.g. using the <tt/"RevertU"/ tool,
see <ref id="revertut" name="Revert U tool">).
If the winding order of some of the primitives in a CSG hierarchy
is not right, the respective primitives will not be effective
in the CSG operations to the extent that the rendered image becomes
completely empty.
<p>
The AyCSG rendering obeys the <tt>"Draw Selection only"</tt> and
<tt>"Draw Level only"</tt> view options as well as the hide attribute
of objects. If the CSG rendering fails for complete complex scenes,
you might still get a preview of the important CSG using objects by
selecting them and enabling the <tt>"Draw Selection only"</tt> view
option.
<p>
Also note that CSG rendering requires fast graphics hardware
(the more fillrate, the better). Furthermore, your OpenGL subsystem
has to support the PBuffers extension and, depending on the
rendering options chosen, a stencil buffer. Speedups may be
achieved using the <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt> extensions (if available to you).
<p>
Once the AyCSG plugin is loaded successfully you can render the CSG
preview in any view window using the keyboard shortcut
<tt>&lt;Ctrl+Shift+c&gt;</tt> or using the new button in the menu
bar of every view window. If you hold down <tt>&lt;Shift&gt;</tt>
while pressing the button the view will continually render CSG
(the button stays pressed to signify this) until you click onto
the button again.
<p>
The AyCSG plugin supports the following options, that are available
through the main menu entry <tt>"Custom/AyCSG Preferences"</tt>:
<itemize>
<item><tt/"Algorithm"/ allows to switch between the Goldfeather and
SCS algorithm. Note again that the SCS algorithm only works correctly
for convex primitives. The <tt/"Automatic"/ setting chooses one
of the algorithms based on whether concave primitives (depth complexity
&gt; 1) are present or not.
<item><tt/"DCSampling"/ determines a depth complexity sampling
strategy. Quoting from the OpenCSG documentation, the following options
are available:
<p>
<tt/"NoDCSampling"/: Does not employ the depth complexity. This essentially
makes the algorithm O(n&sup2;), but with low constant costs.
<p>
<tt/"OcclusionQuery"/: Uses occlusion queries to profit implicitly from
depth complexity without calculating it. This is especially useful for the
SCS algorithm where this strategy is applied at shape level, resulting in
a O(n*k') algorithm (where k' <= k), without significant constant overhead.
This strategy requires hardware occlusion queries, i.E., the OpenGL
extension <tt>"GL_ARB_occlusion_query"</tt> or
<tt>"GL_NV_occlusion_query"</tt>.
<p>
<tt/"DCSampling"/: Calculates the depth complexity k using the stencil
buffer. This makes the algorithm O(n*k), but with high constant costs.
In case of the Goldfeather algorithm, the literature denotes this as
layered Goldfeather algorithm.
<item><tt/"CalcBBS"/ determines whether bounding boxes should be
calculated and used for speed up (not working at the moment).
</itemize>

See also:
<it>Kirsch F. and Doellner J.: "Rendering Techniques for Hardware-Accelerated
Image-Based CSG", in: Skala V. (ed.): Journal of WSCG'04, 221-228,
ISSN 1213-6972</it>

<sect1>Increasing drawing speed<label id="incds">
<p>
In case of sluggish response of the user interface of Ayam
(not accounting for long tree update operations) several
things to increase drawing speed can be done:
<itemize>
<item>Hide objects or complete object hierarchies
using <tt/"Hide"/ in the <tt/"Tools"/ menu.
<item>Disable drawing of true NURBS curves/surfaces, if you can. Use the
ControlHull display modes.
<item>If you need to see curves/surfaces, try to increase the
(GLU) sampling tolerance of the objects (use a value of about 60.0).
<item>Switch the primary modelling view to draw just the selected
object(s) or the current level.
<item>Iconify views you do not need, they will not be redrawn then.
<item>Switch off automatic redrawing of slow redrawing (e.g. shaded)
views, and control their redraw by pressing <tt/&lt;Ctrl+d&gt;/ manually.
<item>Do not create unnecessary caps, they are trimmed NURBS patches
that render very slowly.
<item>Disable <tt/"UseMatColor"/.
</itemize>

<sect1>Restrictions and Implementation Deficiencies<label id="defi">
<p>
Due to the way Ayam is implemented, several restrictions and
deficiencies exist:
<itemize>
<item>Almost all strings in Ayam (scene file names, object names,
material names) are restricted to be 7 bit ASCII. If the scene is
not transported to other systems 8 bit ASCII should be fine, however.
<item>The maximum scene depth depends on the maximum stack size of the
operating system Ayam is running on (due to the use of recursion almost
everywhere traversing the scene, e.g. for drawing).
<item>Ayam internally operates on double precision math, however,
no control over roundoff error in lengthy calculations exists.
Saving of scene files only uses the precision dictated by the current
standard C library. Using of double precision numbers via the
Tcl scripting interface or the GUI also can reduce precision due to
double-string-double-conversions (whose precision can be adjusted
by the user via the <tt/"TclPrecision"/ preference setting, however). 
<item>Materials may only be assigned to complete objects, not to
certain parts of objects.
<item>Undo/Redo are not possible for scene structure changes.
<item>Selected points do not survive Undo/Redo/Saving.
<item>There are no acceleration structures for e.g. drawing and object
tree updates. This limits the number of objects that Ayam can handle
simultaneously without big lags in redraws or after scene structure
changes to about 1000. However, Ayam objects should be high-level objects,
not single polygons, anyway.
</itemize>

Ayam user interface deficiencies:
<itemize>
<item>Ayam is a multi toplevel window application. Unfortunately,
many people are trained to the "one toplevel window per application"
paradigm. Furthermore, window managers get worse and worse in application
support for e.g. focus control.
<item>Application state is often communicated via window title
strings only. But certain window systems do not display those
titles well.
</itemize>

<sect1>How can you help?
<p>
<enum>
<item>Write/translate tutorials.
<item>Implement custom objects. This will be discussed a bit more later on.
<item>Donate source to improve several critical parts of the modeler,
some ideas are: better (more exact) lighting simulation (is this
possible to do with OpenGL at all?),
transformation widgets, import/export plugins,
true support for subdivision surfaces, lift some deficiencies (see above).
The project page of Ayam on SourceForge lists some more tasks and
you are always welcome to discuss the matter in the public forum
or in the feature request tracker.
<item>Debug the MF3D code, which is currently not working
well with binary files from different byte-order platforms.
<item>Donate money by registering ShellyLib.
ShellyLibs source will be converted to a first high level custom object
that creates objects of type seashell for Ayam. This object,
however, will be Shareware!
</enum>

You can help by implementing more different high level custom objects like
Trees, Landscape, Sky, XSplines or whatever you can think of.
Note that the license of Ayam does not prevent you from implementing your
custom object as shareware or even commercial software. However, free
software is preferred for obvious reasons.

But please do me a favour and do not implement objects like
simple triangles or polygons. This would be something that really is
not intended by me, and it would surely show the limits of the current
design of all code operating on the scene structure.
Ayam objects should be high-level objects!

Reading the last paragraph you might think that I am a bit biased
against polygonal models. I am not. Polygonal models are the only
way to preview complex geometry using hardware accelerated graphics,
for the moment. But even while RenderMan supports rendering of
polygonal models their use as a primitive is not recommended for
good reasons. In other words, use polygonal models in the modeler
as quick representation of your higher level objects, but please,
if you are going to actually render something, do not use that
polygonal representation.
If you want to go a complete polygonal way instead, voila, there
are good modelers out there.

<sect1>References<label id="secref">
<p>
Suggested reading:
<itemize>
<item>Advanced RenderMan: Creating CGI for Motion Pictures by
Tony Apodaca and Larry Gritz (Morgan-Kaufmann, 1999)
<item>The RenderMan Companion: A Programmer's Guide
to Realistic Computer Graphics by Steve Upstill (Addison-Wesley,
1989)
<item>Textures and Modelling: A Procedural Approach by Ebert,
Musgrave, Peachey, Perlin, and Worley (Academic Press, 1994)
</itemize>

WWW resources:
<itemize>
<item>Ayam Tutorial #1:
<tt>http://www.ayam3d.org/tut1/tutorial1.html</tt>
<item>The Ayam FAQ: <tt>http://www.ayam3d.org/faq.html</tt>
<item>The RenderMan Repository: <tt>http://www.renderman.org/</tt>
<item>The RenderMan Academy: <tt>http://www.rendermanacademy.com/</tt>
</itemize>

<sect1>Acknowledgements
<p>
First of all, I would like to express a big "Thank you!"
to Bernd (Pink) Sieker. He is the first real Mops user
and beta tester, who urged me during the last years
via E-Mail and on IRC to fix this particular bug, add some
essential features, move the lights again etc. pp. in countless
iterations.
Bernd, without your help I surely would not be that far, thanks!

Furthermore, I would like to thank the following people:
<itemize>
<item>Hynek Schlawack: Ayam Makefile configuration GUI
<item>Florian Kirsch: OpenCSG
<item>Bertrand Coconnier: implementation of object picking
<item>Hermann Birkholz: initial implementation of the tree widget, shadow map
support, AI, and IDR
<item>Frank (Copper) Pagels: MetaBalls custom object, TTF parser,
providing a lot of good music
<item>Stephen Echavia: Icons
<item>Larry Gritz: BMRT
<item>Benjamin Bederson, Brian Paul et. al.: The Togl Widget
<item>Jeffrey Hobbs: tkMegaWidget set
<item>Jan Nijtmans: Tcl/Tk PlusPatches, tcl2c, Wrap
<item>Thomas E. Burge: The Affine Toolkit
<item>Apple, Duet Development Corp.: 3DMF parser
<item>Mark J. Kilgard: GLUT
<item>Les A. Piegl and Wayne Tiller: The NURBS Book
<item>W. T. Hewitt and D. Yip: The NURBS Procedure Library
<item>Philippe Lavoie: The NURBS++ Library
<item>Everyone involved in the development of Tcl/Tk, OpenGL, The RenderMan
Interface
</itemize>

OpenGL (R) is a registered trademark of Silicon Graphics, Inc.

The RenderMan (R) Interface Procedures and Protocol are:
Copyright 1988, 1989, 2000 Pixar
All Rights Reserved

RenderMan (R) is a registered trademark of Pixar

The Affine Libraries and Tools are
Copyright (c) 1995, 1996, 1997, 1998 Thomas E. Burge
All rights reserved.

Affine (R) is a registered trademark of Thomas E. Burge.

TIFF Software is
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.

Dime is
Copyright (c) 1998-1999 Systems In Motion, SA
All rights reserved.

AutoCAD (R)  is a registered trademark of Autodesk, Inc.

DXF (R) is a registered trademark of Autodesk, Inc.


<sect>Index
<p>
<ref id="index0" name=" 0 ">
<ref id="indexa" name=" A ">
<ref id="indexb" name=" B ">
<ref id="indexc" name=" C ">
<ref id="indexd" name=" D ">
<ref id="indexe" name=" E ">
<ref id="indexf" name=" F ">
<ref id="indexg" name=" G ">
<ref id="indexh" name=" H ">
<ref id="indexi" name=" I ">
<ref id="indexj" name=" J ">
<ref id="indexk" name=" K ">
<ref id="indexl" name=" L ">
<ref id="indexm" name=" M ">
<ref id="indexn" name=" N ">
<ref id="indexo" name=" O ">
<ref id="indexp" name=" P ">
<ref id="indexq" name=" Q ">
<ref id="indexr" name=" R ">
<ref id="indexs" name=" S ">
<ref id="indext" name=" T ">
<ref id="indexu" name=" U ">
<ref id="indexv" name=" V ">
<ref id="indexw" name=" W ">
<ref id="indexx" name=" X ">
<ref id="indexy" name=" Y ">
<ref id="indexz" name=" Z ">
<p>
<label id="index">
<label id="index0">0
<itemize>
<item>3DM: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>3DMF: <ref id="imp3dmf" name="3DMF (Apple) Import">,
<ref id="exp3dmf" name="3DM (Apple) Export">
</itemize>

<label id="indexa">A
<itemize>
<item>About: <ref id="mmhelp" name="main menu entry">
<item>Action: <ref id="iac" name="interactive actions">
<item>Active: <ref id="scriptattr" name="script attribute">
<item>Accuracy: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="exprhino" name="3DM (Rhino) export option">
<item>Adaptive: <ref id="moattr" name="MetaObj attributes">
<item>AddExtensions: <ref id="prefgui" name="preference setting">
<item>addToProc: <ref id="scaddtoproc" name="scripting interface command">
<item>AddViewParams: <ref id="hidprefs" name="hidden preference setting">
<item>ALFileTypes, ALPlugins: <ref id="hidprefs" name="hidden preference setting">
<item>Algorithm: <ref id="aycsg" name="AyCSG plugin option">
<item>Align to Parent: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
<item>Apply: <ref id="propgui" name="apply property GUI">
<item>applyTrafo: <ref id="scapplytrafo" name="scripting interface command">
<item>Archives: <ref id="rio" name="RenderMan interface option">
<item>Area Light: <ref id="alob" name="creation of">
<item>Array: <ref id="cloneobj" name="Clone object">
<item>AskScriptDisable: <ref id="hidprefs" name="hidden preference setting">
<item>Atmosphere: <ref id="imager" name="property">
<item>Attributes: <ref id="attrs" name="attributes property">,
<ref id="riattrs" name="RenderMan/BMRT attributes property">
<item>AutoFocus: <ref id="prefgui" name="preference setting">
<item>Automatic Instancing: <ref id="mmspecial" name="main menu entry">
<item>Automatic Redraw: <ref id="vmconf" name="view menu entry">
<item>AutoResize: <ref id="prefgui" name="preference setting">
<item>AutoSavePrefs: <ref id="prefgui" name="preference setting">
<item>Attribute: <ref id="riatag" name="RiAttribute tag type">
<item>ayamrc: <ref id="ayamrc" name="Ayamrc File">
<item>ayError: <ref id="scayerror" name="scripting interface command">
</itemize>

<label id="indexb">B
<itemize>
<item>Background: <ref id="prefdraw" name="preference setting">
<item>Background Image: <ref id="vat" name="view attribute">
<item>BackupExt: <ref id="hidprefs" name="hidden preference setting">
<item>BakOnReplace: <ref id="prefmain" name="preference setting">
<item>Basis_U, Basis_V: <ref id="pmattr" name="PatchMesh attribute">
<item>BeamDistrib: <ref id="lip" name="light attribute">
<item>Bevel: <ref id="bevelobj" name="Bevel object">,
<ref id="handb" name="using bevels">
<item>BevelRadius, BevelRevert, BevelType: <ref id="bevelp" name="bevel attribute">
<item>BGImage: <ref id="vat" name="view attribute">
<item>bicubic/bilinear PatchMesh:
<ref id="patchmeshobj" name="PatchMesh object">
<item>Birail1: <ref id="birail1obj" name="Birail1 object">
<item>Birail2: <ref id="birail2obj" name="Birail2 object">
<item>Bound: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>BoundCoord: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Box: <ref id="boxobj" name="Box object">
<item>BPatch: <ref id="bpatchobj" name="BPatch object">
<item>BType_U, BType_V: <ref id="pmattr" name="PatchMesh attribute">
<item>Build: <ref id="bfct" name="build from curves tool">
<item>buildNP: <ref id="scbuildnp" name="scripting interface command">
</itemize>

<label id="indexc">C
<itemize>
<item>CalcBBS: <ref id="aycsg" name="AyCSG plugin option">
<item>Camera: <ref id="cameraobj" name="Camera object">,
<ref id="camp" name="view property">
<item>Cap: <ref id="capobj" name="Cap object">
<item>CastShadows: <ref id="riattrs" name="RenderMan/BMRT attribute">
<item>Chamfer: <ref id="bevelobj" name="Bevel object">,
<item>CheckLights: <ref id="prefrib" name="preference setting">
<item>Center All Points: <ref id="mmspecial" name="main menu entry">
<item>Circle: <ref id="ncirct" name="NURBS circle tool">,
<ref id="ncircleobj" name="NCircle object">
<item>Clamp: <ref id="clat" name="clamp tool">
<item>clampNC: <ref id="scclampnc" name="scripting interface command">
<item>clampNPU, clampNPV: <ref id="scclampnpu" name="scripting interface command">
<item>Clipboard: <ref id="sciclip" name="scripting interface commands">
<item>Clone: <ref id="cloneobj" name="Clone object">
<item>Close: <ref id="treecontm" name="tree context menu entry">
<item>Closed: <ref id="spattr" name="sphere attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="top" name="torus attribute">,
<ref id="pap" name="paraboloid attribute">,
<ref id="hyp" name="hyperboloid attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="icp" name="ICurve attribute">,
<ref id="concatncp" name="ConcatNC attribute">
<item>Closed BSpline: <ref id="cbspt" name="closed BSpline tool">
<item>Close_U, Close_V: <ref id="pmattr" name="PatchMesh attribute">
<item>coarsenNC: <ref id="sccoarsennc" name="scripting interface command">,
<ref id="coart" name="coarsen tool">
<item>Collapse: <ref id="collt" name="Collapse tool">,
<ref id="treecontm" name="tree context menu entry">
<item>Color: <ref id="riattrs" name="RenderMan/BMRT attribute">,
<ref id="lip" name="light attribute">
<item>CompleteNotify: <ref id="prefmodel" name="preference setting">
<item>copOb: <ref id="sccopob" name="scripting interface command">
<item>Copy: <ref id="mmedit" name="main menu entry">
<item>Copy Property: <ref id="mmedit" name="main menu entry">,
<ref id="propgui" name="copying properties">
<item>Concat: <ref id="conct" name="Concat tool">
<item>ConcatNC: <ref id="concatncobj" name="ConcatNC object">
<item>Cone: <ref id="mmcreate" name="main menu entry">,
<ref id="coneobj" name="Cone object">
<item>ConeAngle, ConeDAngle: <ref id="lip" name="light attribute">
<item>Console: <ref id="cons" name="what is">
<item>Convert: <ref id="mmtools" name="main menu entry">
<item>convOb: <ref id="scconvob" name="scripting interface command">
<item>Coons Patch: <ref id="gordonobj" name="Gordon object">
<item>Create: <ref id="mmcreate" name="create menu">
<item>CreateMP: <ref id="ncattr" name="NURBCurve attribute">
<item>Create ShadowMaps: <ref id="mmspecial" name="main menu entry">,
<ref id="vmview" name="view menu entry">
<item>crtOb: <ref id="sccrtob" name="scripting interface command">
<item>CSG: <ref id="levelobj" name="Level object">,
<ref id="aycsg" name="AyCSG CSG preview plugin">
<item>CursorEnd: <ref id="hidprefs" name="hidden preference setting">
<item>Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Custom: <ref id="cul" name="light type">,
<ref id="mmcustom" name="custom menu">
<item>Custom Object: <ref id="customobj" name="what is">
<item>Cut: <ref id="mmedit" name="main menu entry">
<item>cutOb: <ref id="sccutob" name="scripting interface command">
<item>Cylinder: <ref id="cylinderobj" name="Cylinder object">
</itemize>

<label id="indexd">D
<itemize>
<item>Data: <ref id="riprocp" name="riproc attribute">
<item>DC: <ref id="dctag" name="tag type">
<item>DCSampling: <ref id="aycsg" name="AyCSG plugin option">
<item>DefaultAction: <ref id="prefmodel" name="preference setting">
<item>DefaultMat: <ref id="prefrib" name="preference setting">
<item>DelayedReadArchive: <ref id="riprocp" name="riproc attribute">
<item>delegTrafo: <ref id="scdelegtrafo" name="scripting interface command">
<item>Delete: <ref id="mmedit" name="main menu entry">,
<ref id="insdelac" name="delete points">
<item>delOb: <ref id="scdelob" name="scripting interface command">
<item>Difference: <ref id="levelobj" name="Level object">
<item>Direct Editing: <ref id="editac" name="edit points">
<item>Disk: <ref id="diskobj" name="Disk object">
<item>Displacement: <ref id="matshader" name="shader">
<item>Display: <ref id="ridtag" name="RiDisplay tag type">
<item>DisplayMode: <ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">
<item>Distant: <ref id="pdsl" name="light type">
<item>DNS: <ref id="nstag" name="tag type">
<item>Docs: <ref id="prefgui" name="preference setting">
<item>Double Size: <ref id="vmconf" name="view menu entry">
<item>DrawGrid, DrawLevel, DrawSel, DrawBG:
<ref id="vat" name="view attribute">
<item>Draw Selection only: <ref id="vmconf" name="view menu entry">
<item>Draw Level only: <ref id="vmconf" name="view menu entry">
<item>Draw BGImage: <ref id="vmconf" name="view menu entry">
<item>Draw Grid: <ref id="vmconf" name="view menu entry">
<item>Draw Object CS: <ref id="vmconf" name="view menu entry">
<item>DXF: <ref id="impdxf" name="DXF import plugin">
<item>DynamicLoad: <ref id="riprocp" name="riproc attribute">
</itemize>

<label id="indexe">E
<itemize>
<item>Edit: <ref id="editac" name="edit points">,
<ref id="mmedit" name="edit menu">
<item>Edit Local: <ref id="vmconf" name="view menu entry">,
<ref id="editlocal" name ="Editing in Local Space">
<item>EditSnaps: <ref id="prefmodel" name="preference setting">
<item>Elevate: <ref id="elevt" name="elevate tool">
<item>elevateNC: <ref id="scelevatenc" name="scripting interface command">
<item>Elevate UV: <ref id="elevuvt" name="elevate uv tool">
<item>Enable Scripts: <ref id="mmspecial" name="main menu entry">
<item>EndCap: <ref id="extrattr" name="extrude attribute">,
<ref id="rep" name="revolve attribute">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">,
<ref id="birail1p" name="birail1 attribute">,
<ref id="birail2p" name="birail2 attribute">
<item>EnvFile: <ref id="prefgui" name="preference setting">
<item>Environment Variables: <ref id="envvars" name="Environment Variables">
<item>Epsilon: <ref id="moattr" name="MetaObj attributes">
<item>ErrorLevel: <ref id="rribopt" name="RIB import option">
<item>ExcludeHidden: <ref id="prefrib" name="preference setting">
<item>Expand: <ref id="treecontm" name="tree context menu entry">
<item>ExpGain, ExpGamma: <ref id="rio" name="RenderMan interface option">
<item>Explode: <ref id="explt" name="Explode tool">
<item>Export: <ref id="exprhino" name="3DM (Rhino) export">,
<ref id="exprib" name="RIB Export">,
<ref id="exp3dmf" name="3DMF (Apple) export">,
<ref id="expwav" name="OBJ (Wavefront) export">
<item>Export RIB: <ref id="mmfile" name="main menu entry">
<item>Expression: <ref id="mcattr" name="MetaComp attribute">
<item>Exterior: <ref id="matshader" name="shader">
<item>ExtrNC: <ref id="extrncobj" name="ExtrNC object">,
<ref id="extnct" name="Extract NC tool">
<item>extrNP: <ref id="scextrnp" name="scripting interface command">,
<ref id="extrnpt" name="extract patch tool">
<item>Extrude: <ref id="extrudeobj" name="Extrude object">,
<ref id="extt" name="Extrude tool">
</itemize>

<label id="indexf">F
<itemize>
<item>FAQ: <ref id="secref" name="Ayam FAQ WWW reference">
<item>Far: <ref id="camp" name="camera property">
<item>File: <ref id="mmfile" name="file menu">,
<ref id="riincp" name="riinc attribute">,
<ref id="riprocp" name="riproc attribute">
<item>FillGaps: <ref id="concatncp" name="ConcatNC attribute">
<item>FilterFunc: <ref id="rio" name="RenderMan interface option">
<item>FilterWidth: <ref id="rio" name="RenderMan interface option">
<item>FindU: <ref id="miscac" name="modelling action">
<item>FixX11Menu: <ref id="hidprefs" name="hidden preference setting">
<item>FlashPoints: <ref id="prefmodel" name="preference setting">
<item>Flatness: <ref id="moattr" name="MetaObj attributes">
<item>FontName: <ref id="textattr" name="Text attribute">
<item>forAll, forAllT: <ref id="scforall" name="scripting interface command">
<item>Force Notification: <ref id="mmtools" name="main menu entry">
<item>forceNot: <ref id="scforcenot" name="scripting interface command">
<item>Formula: <ref id="mcattr" name="MetaComp attribute">
<item>From: <ref id="camp" name="camera property">,
<ref id="lip" name="light attribute">
<item>From Camera: <ref id="mmspecial" name="main menu entry">,
<ref id="vmconf" name="view menu entry">
<item>Front: <ref id="vmtype" name="view menu entry">
<item>FTLength: <ref id="concatncp" name="ConcatNC attribute">
</itemize>

<label id="indexg">G
<itemize>
<item>getPnt: <ref id="scgetpnt" name="scripting interface command">
<item>getProperty: <ref id="scgetproperty" name="scripting interface command">
<item>getType: <ref id="scgettype" name="scripting interface command">
<item>Gimbal Lock: <ref id="gimb" name="avoiding Gimbal Locks">
<item>goDown: <ref id="scgodown" name="scripting interface command">
<item>goTop: <ref id="scgotop" name="scripting interface command">
<item>Gordon: <ref id="gordonobj" name="Gordon object">
<item>goUp: <ref id="scgoup" name="scripting interface command">
<item>Grid: <ref id="vat" name="view attribute">
<ref id="prefdraw" name="drawing preference setting">
</itemize>

<label id="indexh">H
<itemize>
<item>Half Size: <ref id="vmconf" name="view menu entry">
<item>HandleSize: <ref id="prefmodel" name="preference setting">
<item>hasChild: <ref id="schaschild" name="scripting interface command">
<item>Height: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="Box attribute">,
<ref id="cnp" name="Cone attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="extrattr" name="Extrude attribute">,
<ref id="vat" name="View attribute">,
<ref id="textattr" name="Text attribute">
<item>Help: <ref id="mmhelp" name="main menu entry">,
<ref id="schelp" name="scripting interface command">
<item>Help on object: <ref id="mmhelp" name="main menu entry">
<item>Hidden Preferences: <ref id="hidprefs" name="Hidden Preference Settings">
<item>Hide: <ref id="mmtools" name="main menu entry">,
<ref id="attrs" name="attribute">
<item>Hide All: <ref id="mmtools" name="main menu entry">
<item>Hider: <ref id="rihtag" name="RiHider tag type">
<item>HideTmpTags: <ref id="prefmisc" name="preference setting">
<item>Highlight Material: <ref id="mmtools" name="main menu entry">
<item>Hole: <ref id="handb" name="using holes">
<item>hSL: <ref id="schsl" name="scripting interface command">
<item>Hyperboloid: <ref id="hyperboloidobj" name="Hyperboloid object">
</itemize>

<label id="indexi">I
<itemize>
<item>IconGamma: <ref id="hidprefs" name="hidden preference setting">
<item>ICurve: <ref id="icurveobj" name ="ICurve object">
<item>IDR: <ref id="idr" name="IDR plugin">
<item>IgnoreFirstTrim: <ref id="imprhino" name="3DM (Rhino) import option">
<item>IgnoreHidden: <ref id="exprhino" name="3DM (Rhino) export option">
<item>IgnoreNormals: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>Image: <ref id="prefrib" name="preference setting">
<item>Imager: <ref id="imager" name="property">
<item>Import: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="imp3dmf" name="3DMF (Apple) import">,
<ref id="impmops" name="Mops Import">,
<ref id="imprib" name="RIB Import">,
<ref id="impwav" name="Wavefront OBJ Import">
<item>Importance Driven Rendering: <ref id="idr" name="IDR plugin">
<item>Insert: <ref id="mmfile" name="main menu entry">,
<ref id="insdelac" name="insert points">
<item>insKnNC: <ref id="scinsknnc" name="scripting interface command">
<item>insKnNPU: <ref id="scinsknnpu" name="scripting interface command">
<item>insKnNPV: <ref id="scinsknnpv" name="scripting interface command">
<item>Insert Knot: <ref id="insknt" name="insert knot tool">
<item>insertScene: <ref id="scinsertscene" name="scripting interface command">
<item>Instance: <ref id="instanceobj" name ="Instance object">
<item>Instant Apply: <ref id="propgui" name="instant apply facility">
<item>Intensity: <ref id="lip" name="light attribute">
<item>Interior: <ref id="matshader" name="shader">
<item>Interpolation: <ref id="attrs" name="RenderMan/BMRT attribute">,
<ref id="icurveobj" name="interpolating curve">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">
<item>InterpolCtrl: <ref id="birail2p" name="Birail2 attribute">
<item>Intersection: <ref id="levelobj" name="Level object">
<item>Invert Selection: <ref id="mmspecial" name="main menu entry">
<item>IParam: <ref id="icp" name="ICurve attribute">
<item>IsLocal: <ref id="lip" name="light attribute">
<item>IsoLevel: <ref id="moattr" name="MetaObj attribute">
<item>IsOn: <ref id="lip" name="light attribute">
<item>IsRat: <ref id="ncattr" name="NURBCurve attribute">,
<ref id="npattr" name="NURBPatch attribute">
</itemize>

<label id="indexj">J
<itemize>
<item>.
</itemize>

<label id="indexk">K
<itemize>
<item>Knots: <ref id="ncattr" name="NURBCurve attribute">
<item>Knot-Type: <ref id="ncattr" name="NURBCurve attribute">,
<ref id="concatncp" name="ConcatNC attribute">
<item>Knot-Type_U: <ref id="skp" name="skin attribute">
</itemize>

<label id="indexl">L
<itemize>
<item>Last (None): <ref id="mmtools" name="main menu entry">
<item>LazyNotify: <ref id="prefmodel" name="preference setting">
<item>Length: <ref id="bxp" name="box attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="icp" name="ICurve attribute">
<item>Level: <ref id="levelobj" name="Level object">
<item>Light: <ref id="lightobj" name="Light object">,
<ref id="prefdraw" name="preference setting">
<item>LightAttr: <ref id="lip" name="property">
<item>LightShader: <ref id="lightobj" name="light">
<item>ListTypes: <ref id="prefgui" name="preference setting">
<item>LoadEnv: <ref id="prefgui" name="preference setting">
<item>Load Plugin: <ref id="mmfile" name="main menu entry">
<item>Local: <ref id="vat" name="view attribute">,
<ref id="editlocal" name ="Editing in Local Space">
<item>Locale: <ref id="prefgui" name="preference setting">
<item>Loft: <ref id="skinobj" name="Skin object">
<item>LogFile: <ref id="prefgui" name="preference setting">
<item>Logging: <ref id="prefgui" name="preference setting">
<item>LowerBevel: <ref id="extrattr" name="extrude attribute">,
<ref id="textattr" name="text attribute">
<item>LowerCap: <ref id="rep" name="revolve attribute">,
<ref id="textattr" name="text attribute">
</itemize>

<label id="indexm">M
<itemize>
<item>MajorRad: <ref id="top" name="torus attribute">
<item>Make Compatible: <ref id="makecompt" name="NURBCurve tool">
<item>MarkHidden: <ref id="prefgui" name="preference setting">
<item>Master: <ref id="mmedit" name="edit menu entry">
<item>Material: <ref id="materialobj" name="Material object">,
<ref id="mmedit" name="edit menu entry">
<item>Materialname: <ref id="matattr" name="material object attribute">,
<ref id="matprop" name="material property attribute">
<item>MaxRayLevel: <ref id="rio" name="RenderMan interface option">
<item>MaxTagLen: <ref id="hidprefs" name="Hidden Preference Settings">
<item>MaxX, MaxY, MaxZ: <ref id="riprocp" name="riproc attribute">
<item>Menu: <ref id="mm" name="main menu">,
<ref id="vm" name="view menu">
<item>Merge: <ref id="mmtools" name="Merge PolyMesh tool">
<item>MergeFaces <ref id="impwav" name="Wavefront OBJ import option">
<item>MergePVTags <ref id="impwav" name="Wavefront OBJ import option">
<item>MetaObj, MetaComp: <ref id="metaobjobj" name="MetaObj object">
<item>MFIO Plugin:
<ref id="imp3dmf" name="3DMF (Apple) import">,
<ref id="exp3dmf" name="3DMF (Apple) export">
<item>MinorRad: <ref id="top" name="torus attribute">
<item>MinSamples, MaxSamples: <ref id="rio" name="RenderMan interface option">
<item>MinX, MinY, MinZ: <ref id="riprocp" name="riproc attribute">
<item>Mirror: <ref id="cloneattr" name="Clone attribute">
<item>Mode: <ref id="icp" name="ICurve attribute">
<item>Mops Import: <ref id="impmops" name="Import of Mops Scenes">
<item>Move: <ref id="vwsc" name="view action">,
<ref id="iac" name="move object">
<item>movOb: <ref id="scmovob" name="scripting interface command">
<item>movSel: <ref id="scmovsel" name="scripting interface command">
<item>Multiple Point: <ref id="ncurvemp" name="Multiple Points">
</itemize>

<label id="indexn">N
<itemize>
<item>NCDisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="ncattr" name="NURBCurve attribute">
<item>NCircle: <ref id="ncircleobj" name="NCircle object">
<item>Near: <ref id="camp" name="camera property">
<item>Negative: <ref id="mcattr" name="MetaComp attribute">
<item>New: <ref id="mmfile" name="main menu entry">
<item>NewLoadsEnv: <ref id="prefgui" name="preference setting">
<item>newScene: <ref id="scnewscene" name="scripting interface command">
<item>NoExport: <ref id="noexporttag" name="tag type">
<item>NP: <ref id="nptag" name="tag type">
<item>NPDisplayMode: <ref id="prefdraw" name="preference setting">,
<ref id="npattr" name="NURBPatch attribute">
<item>NS: <ref id="nstag" name="tag type">
<item>NumClones: <ref id="cloneattr" name="Clone attribute">
<item>NumSamples: <ref id="moattr" name="MetaObj attribute">
<item>NURBCircle: <ref id="ncirct" name="NURBS circle tool">
<item>NURBCurve: <ref id="ncurveobj" name="NCurve object">
<item>NURBPatch: <ref id="npatchobj" name="NPatch object">
<item>NURBS: <ref id="scinurbs" name="scripting interface commands">
<item>NURBSphere: <ref id="nspt" name="NURBS sphere tool">
</itemize>

<label id="indexo">O
<itemize>
<item>ObeyNoExport: <ref id="exprhino" name="3DM (Rhino) export option">
<item>OBJ: <ref id="impwav" name="Wavefront OBJ import">,
<ref id="expwav" name="Wavefront OBJ export">
<item>Object: <ref id="prefdraw" name="preference setting">
<item>Objectname: <ref id="attrs" name="attribute">
<item>Objects: <ref id="obj" name="tree/listbox">,
<ref id="objsel" name="selection within a view">
<item>OI: <ref id="oitt" name="tag type">
<item>Open: <ref id="mmfile" name="main menu entry">,
<ref id="treecontm" name="tree context menu entry">
<item>OpenNURBS: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>Optimize: <ref id="mmtools" name="Optimize PolyMesh tool">
<item>OptimizeCoords: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeFaces: <ref id="mmtools" name="Optimize PolyMesh tool option">
<item>OptimizeNew: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Option: <ref id="riotag" name="RiOption tag type">
<item>Order: <ref id="ncattr" name="NURBCurve attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="icp" name="ICurve attribute">,
<ref id="rep" name="Revolve attribute">
<item>Order_U: <ref id="skp" name="skin attribute">
</itemize>

<label id="indexp">P
<itemize>
<item>P1, P2: <ref id="hyp" name="hyperboloid attribute">
<item>Paraboloid: <ref id="paraboloidobj" name="Paraboloid object">
<item>Parameter: <ref id="extrncp" name="ExtrNC attribute">
<item>pasOb: <ref id="scpasob" name="scripting interface command">
<item>Paste: <ref id="mmedit" name="main menu entry">
<item>Paste (Move): <ref id="mmspecial" name="main menu entry">
<item>Paste Property: <ref id="mmedit" name="main menu entry">
<item>PatchMesh: <ref id="patchmeshobj" name="PatchMesh object">
<item>PatchNum: <ref id="extrncp" name="ExtrNC attribute">
<item>PatchSamples: <ref id="rio" name="RenderMan interface option">
<item>Perspective: <ref id="vmtype" name="view menu entry">
<item>PhiMin, PhiMax: <ref id="top" name="torus attribute">
<item>Pick: <ref id="objsel" name="pick objects within a view">
<item>PickEpsilon: <ref id="prefmodel" name="preference setting">
<item>Plot Curvature: <ref id="plotcurt" name="plot curvature tool">
<item>Point: <ref id="pdsl" name="light type">
<item>PolyMesh: <ref id="polymeshobj" name="PolyMesh object">
<item>PPRender: <ref id="prefrib" name="preference setting">
<item>Preferences: <ref id="prefs" name="Preferences">,
<ref id="hidprefs" name="Hidden Preference Settings">
<item>PrepDiaCap: <ref id="hidprefs" name="hidden preference setting">
<item>Procedurals: <ref id="rio" name="RenderMan interface option">
<item>Prompt: <ref id="hidprefs" name="hidden preference setting">
<item>Properties: <ref id="propgui" name="property GUI">
<item>Primitive: <ref id="levelobj" name="Level object">
<item>Primitive Variable (PV): <ref id="pvtag" name="tag type">
<item>PRManSpec: <ref id="rio" name="RenderMan interface option">
</itemize>

<label id="indexq">Q
<itemize>
<item>QuadAsBRep: <ref id="exprhino" name="3DM (Rhino) export option">
<item>QRender: <ref id="prefrib" name="preference setting">
<item>QRenderPT, QRenderUI: <ref id="prefrib" name="preference setting">
<item>Quat: <ref id="trap" name="transformations property">
<item>Quick Render: <ref id="vm" name="view menu entry">
</itemize>

<label id="indexr">R
<itemize>
<item>Radius: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="ncircleattrprop" name="NCircle attribute">,
<ref id="mcattr" name="MetaComp attribute">
<item>RadSteps: <ref id="rio" name="RenderMan interface option">
<item>ReadCurves: <ref id="impwav" name="Wavefront OBJ import/export option">,
<ref id="imprhino" name="3DM (Rhino) import option">
<item>ReadFrame, ReadCamera, ReadOptions, ReadLights, ReadMaterial,
ReadPartial: <ref id="rribopt" name="RIB import option">
<item>ReadLayers: <ref id="imprhino" name="3DM (Rhino) import option">
<item>Rebuild: <ref id="treecontm" name="tree context menu entry">
<item>RedirectTcl: <ref id="prefmisc" name="preference setting">
<item>Redo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">
<item>Redraw: <ref id="vm" name="view menu entry">,
<ref id="incds" name="speeding up">,
<ref id="vat" name="view attribute">
<item>Refcount: <ref id="attrs" name="attribute">
<item>Reference Counter: <ref id="instanceobj" name="Instance Object">,
<ref id="materialobj" name="Material Object">
<item>References: <ref id="secref" name="references">
<item>refineNC: <ref id="screfinenc" name="scripting interface command">,
<ref id="refit" name="refine tool">
<item>remKnNC: <ref id="scremknnc" name="scripting interface command">
<item>Remove Knot: <ref id="remknt" name="remove knot tool">
<item>RemoveMerged: <ref id="mmtools" name="Merge PolyMesh tool option">
<item>Render: <ref id="vm" name="view menu entry">,
<ref id="prefrib" name="preference setting">
<item>Renderer: <ref id="mmspecial" name="select a different renderer">
<item>RenderMode: <ref id="prefrib" name="preference setting">
<item>RenderPT, RenderUI: <ref id="prefrib" name="preference setting">
<item>Repair Ayam: <ref id="repayam" name="Tcl helper script">
<item>Replace: <ref id="mmspecial" name="main menu entry">
<item>replaceScene: <ref id="screplacescene" name="scripting interface command">
<item>Rescale Knots to Mindist: <ref id="resckmt" name="NURBCurve tool">
<item>Rescale Knots to Range: <ref id="resckrt" name="NURBCurve tool">
<item>rescaleKnNC: <ref id="screscaleknnc" name="scripting interface command">
<item>RescaleKnots: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="imprib" name="RIB import option">,
<ref id="impwav" name="Wavefront OBJ import option">,
<item>Reset: <ref id="propgui" name="reset property GUI">
<item>ResetDM, ResetST: <ref id="impmops" name="Mops import option">
<item>Reset Preferences: <ref id="mmspecial" name="main menu entry">
<item>ResInstances: <ref id="prefrib" name="preference setting">
<item>Resolve all Instances: <ref id="mmspecial" name="main menu entry">
<item>Revert: <ref id="revertt" name="Revert tool">,
<ref id="concatncp" name="ConcatNC attribute">,
<ref id="textattr" name="Text attribute">,
<ref id="screvert" name="scripting interface command">
<item>RevertBevels: <ref id="textattr" name="Text attribute">
<item>RevertU, RevertV: <ref id="revertut" name="Revert U tool">,
<ref id="revertvt" name="Revert V tool">
<item>Revolve: <ref id="revolveobj" name="Revolve object">,
<ref id="revt" name="Revolve tool">
<item>RGBA_ONE, RGBA_MIN, RGBA_MAX, RGBA_Dither:
<ref id="rio" name="RenderMan interface option">
<item>RGTrans: <ref id="prefmisc" name="preference setting">
<item>Rhino: <ref id="imprhino" name="3DM (Rhino) Import">,
<ref id="exprhino" name="3DM (Rhino) Export">
<item>RiAttribute: <ref id="riattrs" name="property">,
<ref id="riatag" name="tag type">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIB import: <ref id="imprib" name="RIB Import">
<item>RIBFile: <ref id="prefrib" name="preference setting">
<item>RiDisplay: <ref id="ridtag" name="tag type">
<item>RiHider: <ref id="rihtag" name="tag type">
<item>RiInc: <ref id="riincobj" name="RiInc object">
<item>RiOption: <ref id="riotag" name="tag type">
<item>RiOptions: <ref id="rio" name="RenderMan interface options property">,
<ref id="rioptdb" name="RiOption and RiAttributes Database">
<item>RIStandard: <ref id="prefrib" name="preference setting">
<item>RMax: <ref id="pap" name="paraboloid attribute">
<item>Roll: <ref id="camp" name="camera property">
<item>Root: <ref id="rootobj" name="Root object">
<item>Rotate: <ref id="vwsc" name="view action">,
<ref id="rotac" name="rotate object">,
<ref id="swp" name="sweep attribute">,
<ref id="cloneattr" name="Clone attribute">
<item>Rotation: <ref id="trap" name="transformations property">,
<ref id="gimb" name="using the transformations property">
<item>rotOb: <ref id="scrotob" name="scripting interface command">
<item>rotSel: <ref id="scrotsel" name="scripting interface command">
<item>RP: <ref id="rptag" name="tag type">
<item>Ruled surface: <ref id="skinobj" name="Skin object">,
<item>RunProgram: <ref id="riprocp" name="riproc attribute">
<item>rV: <ref id="scrv" name="scripting interface command">
</itemize>

<label id="indexs">S
<itemize>
<item>SafeAutoFocus: <ref id="hidprefs" name="hidden preference setting">
<item>Samples: <ref id="lip" name="light attribute">
<item>Samples_X: <ref id="rio" name="RenderMan interface option">
<item>Samples_Y: <ref id="rio" name="RenderMan interface option">
<item>Save: <ref id="mmfile" name="main menu entry">
<item>Save as: <ref id="mmfile" name="main menu entry">
<item>Save Prefs: <ref id="mmfile" name="main menu entry">
<item>SaveAddsMRU: <ref id="prefmisc" name="preference setting">
<item>SaveMainGeom: <ref id="savemaingeomtag" name="tag type">
<item>SavePrefsGeom: <ref id="prefmisc" name="preference setting">
<item>saveScene: <ref id="scsavescene" name="scripting interface command">
<item>Scale: <ref id="trap" name="transformations property">,
<ref id="scalac" name="scale object">
<item>ScaleFactor: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="exprhino" name="3DM (Rhino) export option">,
<ref id="impwav" name="Wavefront OBJ import option">,
<ref id="expwav" name="Wavefront OBJ export option">,
<ref id="rribopt" name="RIB import option">
<item>scalOb <ref id="scscalob" name="scripting interface command">
<item>scalSel <ref id="scscalsel" name="scripting interface command">
<item>Scan Shaders: <ref id="mmspecial" name="main menu entry">
<item>Script: <ref id="scriptobj" name="Script object">
<item>Scripts: <ref id="prefgui" name="preference setting">
<item>SDMesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Sections: <ref id="swp" name="sweep attribute">,
<ref id="rep" name="Revolve attribute">,
<ref id="birail1p" name="Birail1 attribute">,
<ref id="birail2p" name="Birail2 attribute">
<item>Select: <ref id="obj" name="select objects with the tree/listbox">,
<ref id="objsel" name="select objects within a view">,
<ref id="selac" name="select points">
<item>Selected Objects: <ref id="mmspecial" name="main menu entry">
<item>Select Renderer: <ref id="mmspecial" name="main menu entry">
<item>Selection: <ref id="prefdraw" name="preference setting">
<item>selOb: <ref id="scselob" name="scripting interface command">
<item>SelXOR_R, SelXOR_G, SelXOR_B:
<ref id="hidprefs" name="hidden preference setting">
<item>Set BGImage: <ref id="vmconf" name="view menu entry">
<item>Set Gridsize: <ref id="vmconf" name="view menu entry">
<item>Set FOV: <ref id="vmconf" name="view menu entry">
<item>setPnt: <ref id="scsetpnt" name="scripting interface command">
<item>setProperty: <ref id="scsetproperty" name="scripting interface command">
<item>Shade: <ref id="prefdraw" name="preference setting">,
<ref id="vmconf" name="view menu entry">
<item>Shader: <ref id="shd" name="properties">
<item>Shader Parsing: <ref id="spplugins" name="shader parsing plugins">
<item>Shaders: <ref id="prefmain" name="preference setting">,
<ref id="rio" name="RenderMan interface option">,
<ref id="scishaders" name="scripting interface commands">
<item>ShadingRate: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>ShadowBias: <ref id="rio" name="RenderMan interface option">
<item>ShadowMaps: <ref id="prefrib" name="preference setting">,
<ref id="shadowmaps" name="using shadowmaps">
<item>Shadows: <ref id="lip" name="light attribute">
<item>Shift Closed B-Spline:
<ref id="shiftclbspt" name="shift closed B-Spline tool">
<item>Show: <ref id="mmtools" name="main menu entry">
<item>Show All: <ref id="mmtools" name="main menu entry">
<item>Show Shortcuts: <ref id="mmhelp" name="main menu entry">
<item>Show Tooltips: <ref id="mmhelp" name="main menu entry">
<item>Side: <ref id="vmtype" name="view menu entry">,
<ref id="extrncp" name="ExtrNC attribute">
<item>Skin: <ref id="skinobj" name="Skin object">,
<ref id="skit" name="Skin tool">
<item>sL: <ref id="scsl" name="scripting interface command">
<item>SMChangeShaders: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMFileFormat: <ref id="prefrib" name="preference setting">
<item>SMFileType: <ref id="prefrib" name="preference setting">
<item>SMethod: <ref id="prefmisc" name="preference setting">
<item>SMRender, SMRenderUI, SMRenderPT: <ref id="prefrib" name="preference setting">
<item>SMRes: <ref id="lip" name="light attribute">
<item>Snap Points to Grid: <ref id="snapac" name="modelling action">
<item>Snap3D: <ref id="prefmodel" name="preference setting">
<item>SParamU, SParamV: <ref id="prefmisc" name="preference setting">
<item>Special: <ref id="mmspecial" name="special menu">
<item>Sphere: <ref id="sphereobj" name="Sphere object">,
<ref id="nspt" name="NURBS sphere tool">
<item>Split: <ref id="sptct" name="split to curves tool">,
<ref id="mmtools" name="split polymesh tool">
<item>Split Curve: <ref id="miscac" name="modelling action">
<item>splitNC: <ref id="scsplitnc" name="scripting interface command">
<item>splitNP: <ref id="scsplitnp" name="scripting interface command">
<item>Spot: <ref id="pdsl" name="light type">
<item>STagName: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="impwav" name="Wavefront OBJ import option">
<item>StartCap: <ref id="extrattr" name="extrude attribute">,
<ref id="rep" name="revolve attribute">,
<ref id="swp" name="sweep attribute">,
<ref id="skp" name="skin attribute">,
<ref id="birail1p" name="birail1 attribute">,
<ref id="birail2p" name="birail2 attribute">
<item>StdDisplay: <ref id="rio" name="RenderMan interface option">
<item>Step_U, Step_V: <ref id="pmattr" name="PatchMesh attribute">
<item>StepSize: <ref id="moattr" name="MetaObj attributes">
<item>Stretch: <ref id="scalac" name="stretch object">
<item>String: <ref id="textattr" name="Text attribute">
<item>Subdivision Mesh: <ref id="sdmeshobj" name="SDMesh object">
<item>Surface: <ref id="matshader" name="shader">
<item>SwapMB: <ref id="hidprefs" name="hidden preference setting">
<item>Swap UV: <ref id="swapuvt" name="swap uv tool">
<item>Sweep: <ref id="sweepobj" name="Sweep object">,
<ref id="swpt" name="Sweep tool">
</itemize>

<label id="indext">T
<itemize>
<item>Tag: <ref id="prefdraw" name="preference setting">
<item>Tags: <ref id="tags" name="tags property">,
<ref id="scitags" name="scripting interface commands">
<item>TC: <ref id="tctag" name="tag type">
<item>TclPrecision: <ref id="prefmisc" name="preference setting">
<item>Tesselate: <ref id="tesst" name="tesselation tool">
<item>TessPoMesh <ref id="expwav" name="Wavefront OBJ export option">
<item>Text: <ref id="textobj" name="Text object">
<item>Textures: <ref id="rio" name="RenderMan interface option">
<item>Texture Coordinates: <ref id="tctag" name="tag type">,
<ref id="tce" name="texture coordinate editor">
<item>ThetaMax: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cnp" name="cone attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="top" name="torus attribute">,
<ref id="pap" name="paraboloid attribute">,
<ref id="hyp" name="hyperboloid attribute">,
<ref id="rep" name="revolve attribute">
<item>Threshold: <ref id="moattr" name="MetaObj attributes">
<item>TMin, TMax: <ref id="ncircleattrprop" name="NCircle attribute">
<item>TmpDir: <ref id="prefgui" name="preference setting">
<item>To: <ref id="camp" name="camera property">,
<ref id="lip" name="light attribute">
<item>To Camera: <ref id="vmconf" name="view menu entry">
<item>Toggle Toolbox: <ref id="mmspecial" name="main menu entry">
<item>Toggle TreeView: <ref id="mmspecial" name="main menu entry">
<item>Tolerance: <ref id="prefdraw" name="preference setting">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="ncattr" name="NURBCurve attribute">,
<ref id="npattr" name="NURBPatch attribute">
<item>Toolbox: <ref id="toolb" name="toolbox window">
<item>ToolBoxShrink: <ref id="prefmisc" name="preference setting">
<item>ToolBoxTrans: <ref id="prefmisc" name="preference setting">
<item>Tools: <ref id="mmtools" name="tools menu">
<item>Top: <ref id="vmtype" name="view menu entry">
<item>TopLevelLayers: <ref id="exprhino" name="3DM (Rhino) export option">
<item>Torus: <ref id="torusobj" name="Torus object">
<item>To XY: <ref id="toxyt" name="To XY tool">
<item>TP: <ref id="tptag" name="tag type">
<item>Transformations: <ref id="trap" name="transformations property">
<item>Translation: <ref id="trap" name="transformations property">
<item>Tree View: <ref id="treeview" name="Tree View">
<item>Trim: <ref id="vmtype" name="view menu entry">
<item>Trim Curve: <ref id="trim" name="using trim curves">
<item>trimNC: <ref id="sctrimnc" name="scripting interface command">
<item>TrimRect: <ref id="trrt" name="TrimRect tool">
<item>TrueDisp: <ref id="attrs" name="RenderMan/BMRT attribute">
<item>TTagName: <ref id="imprhino" name="3DM (Rhino) import option">,
<ref id="impwav" name="Wavefront OBJ import/export option">
<item>TwmCompat: <ref id="prefgui" name="preference setting">
<item>Type: <ref id="levelobj" name="level attribute">,
<ref id="lip" name="light attribute">,
<ref id="pmattr" name="patchmesh attribute">,
<ref id="vat" name="view attribute">,
<ref id="scriptattr" name="script attribute">,
<ref id="riprocp" name="riproc attribute">,
<ref id="capattrprop" name="cap attribute">,
<ref id="ncurveattrprop" name="ncurve attribute">
</itemize>

<label id="indexu">U
<itemize>
<item>uCL: <ref id="scucl" name="scripting interface command">
<item>uCR: <ref id="scucr" name="scripting interface command">
<item>UMM: <ref id="ummtag" name="tag type">
<item>Undo: <ref id="undos" name="The Undo System">,
<ref id="mmedit" name="main menu entry">,
<ref id="scundo" name="scripting interface command">
<item>UndoLevels: <ref id="prefmodel" name="preference setting">
<item>Union: <ref id="levelobj" name="Level object">
<item>UpperBevel: <ref id="extrattr" name="extrude attribute">,
<ref id="textattr" name="text attribute">
<item>UpperCap: <ref id="rep" name="revolve attribute">,
<ref id="textattr" name="text attribute">
<item>Up Vector: <ref id="camp" name="camera property">
<item>uS: <ref id="scus" name="scripting interface command">
<item>UseGrid: <ref id="vat" name="view attribute">,
<ref id="vmconf" name="view menu entry">
<item>UseInternalFD: <ref id="hidprefs" name="hidden preference setting">
<item>UseMatColor: <ref id="prefdraw" name="preference setting">
<item>UseSM: <ref id="lip" name="light attribute">
</itemize>

<label id="indexv">V
<itemize>
<item>Variance: <ref id="rio" name="RenderMan interface option">
<item>View: <ref id="viewobj" name="object">,
<ref id="viewwin" name="Anatomy of a View">
<item>ViewAttrib: <ref id="vat" name="property">
<item>VMM: <ref id="ummtag" name="tag type">
</itemize>

<label id="indexw">W
<itemize>
<item>WarnUnknownTag: <ref id="hidprefs" name="hidden preference setting">
<item>Wavefront OBJ import: <ref id="impwav" name="Wavefront OBJ import">
<item>Wavefront OBJ export: <ref id="expwav" name="Wavefront OBJ export">
<item>Weight: <ref id="iac" name="single point weight editing">
<item>Width: <ref id="rio" name="RenderMan interface option">,
<ref id="bxp" name="box attribute">,
<ref id="npattr" name="NURBPatch attribute">,
<ref id="pmattr" name="PatchMesh attribute">,
<ref id="vat" name="view attribute">
<item>withOb: <ref id="scwithob" name="scripting interface command">
<item>wrib: <ref id="scwrib" name="scripting interface command">
<item>WriteCurves: <ref id="impwav" name="Wavefront OBJ import/export option">,
<ref id="exprhino" name="3DM (Rhino) export option">
<item>WriteIdent: <ref id="prefrib" name="preference setting">
<item>WriteSelected: <ref id="exprhino" name="3DM (Rhino) export option">,
<ref id="expwav" name="Wavefront OBJ export option">
</itemize>

<label id="indexx">X
<itemize>
<item>X3D: <ref id="impx3d" name="X3D (Web3D) Import">,
<ref id="expx3d" name="X3D (Web3D) Export">
</itemize>

<label id="indexy">Y
<itemize>
<item>.
</itemize>

<label id="indexz">Z
<itemize>
<item>Zap Ayam: <ref id="mmspecial" name="main menu entry">
<item>ZMin, ZMax: <ref id="spattr" name="sphere attribute">,
<ref id="dkp" name="disk attribute">,
<ref id="cyp" name="cylinder attribute">,
<ref id="pap" name="paraboloid attribute">
<item>Zoom: <ref id="camp" name="camera property">,
<ref id="vwsc" name="view action">
<item>Zoom to Object: <ref id="vmconf" name="view menu entry">,
<ref id="vwsc" name="view action">
</itemize>


</article>

