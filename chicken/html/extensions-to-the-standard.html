<html><head><title>CHICKEN User's Manual - Extensions to the standard</title></head><body>
<p></p><a name='Extensions to the standard'><h1>Extensions to the standard</h1></a><p>[2.1] Identifiers may contain special characters if delimited with <tt>| ... |</tt>.</p><p>[2.3] The brackets <tt>[ ... ]</tt> are provided as an alternative syntax for <tt>( ... )</tt>.  A number of reader extensions is provided. See <a href='non-standard-read-syntax.html' class='internal'>Non standard read syntax</a>.</p><p>[4] Numerous non-standard macros are provided. See  <a href='non-standard-macros-and-special-forms.html' class='internal'>Non standard macros and special forms</a> for more information.</p><p>[4.1.4] Extended DSSSL style lambda lists are supported. DSSSL formal argument lists are defined by the following grammar:</p><pre>&lt;formal-argument-list&gt; ==&gt; &lt;required-formal-argument&gt;*
                           [(#!optional &lt;optional-formal-argument&gt;*)]
                           [(#!rest &lt;rest-formal-argument&gt;)]
                           [(#!key &lt;key-formal-argument&gt;*)]
&lt;required-formal-argument&gt; ==&gt; &lt;ident&gt;
&lt;optional-formal-argument&gt; ==&gt; &lt;ident&gt;
                             | (&lt;ident&gt; &lt;initializer&gt;)
&lt;rest-formal-argument&gt; ==&gt; &lt;ident&gt;
&lt;key-formal-argument&gt; ==&gt; &lt;ident&gt;
                          | (&lt;ident&gt; &lt;initializer&gt;)
&lt;initializer&gt; ==&gt; &lt;expr&gt;</pre><p>When a procedure is applied to a list of actual arguments, the formal and actual arguments are processed from left to right as follows:</p><ul><li>Variables in required-formal-arguments are bound to successive actual arguments starting with the first actual argument. It shall be an error if there are fewer actual arguments than required-formal-arguments.</li><li>Next, variables in optional-formal-arguments are bound to any remaining actual arguments. If there are fewer remaining actual arguments than optional-formal-arguments, then variables are bound to the result of the evaluation of initializer if one was specified or otherwise to <tt>#f</tt>. The initializer is evaluated in an environment in which all previous formal arguments have been bound.</li><li>If there is a rest-formal-argument, then it is bound to a list of all remaining actual arguments. The remaining actual arguments are also eligible to be bound to keyword-formal-arguments. If there is no rest-formal-argument and there are no keywords, the it shall be an error if there are any remaining actual arguments.</li><li>If <tt>#!key</tt> was specified in the formal-argument-list, there shall be an even number of remaining actual arguments. These are interpreted as a series of pairs, where the first member of each pair is a keyword specifying the argument name, and th corresponding value. It shall be an error if the first member of a pair is not a keyword. It shall be an error if the argument name is not the same as a variable in a keyword-formal-argument, unless there is a rest-formal-argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument, then the variable is bound to the result of evaluating initializer if one was specified or <tt>#f</tt>. The initializer is evaluated in an environment in which all previous formal arguments have been bound. </li></ul><p>It shall be an error for an <tt>&lt;ident&gt;</tt> to appear more than once in a formal-argument-list.</p><p>Example:</p><pre>((lambda x x) 3 4 5 6)       =&gt; (3 4 5 6)
((lambda (x y #!rest z) z)
 3 4 5 6)                    =&gt; (5 6)
((lambda (x y #!optional z #!rest r #!key i (j 1)) 
    (list x y z i: i j: j))
 3 4 5 i: 6 i: 7)            =&gt; (3 4 5 i: 6 j: 1)</pre><p>[4.1.6] <tt>set!</tt> for unbound toplevel variables is allowed. <tt>set! (PROCEDURE ...) ...)</tt> is supported, as CHICKEN implements <a href='http://srfi.schemers.org/srfi-17/srfi-17.html' class='external'>SRFI-17</a>. [4.2.1] The <tt>cond</tt> form supports <a href='http://srfi.schemers.org/srfi-61' class='external'>SRFI-61</a>.</p><p>[4.2.2] It is allowed for initialization values of bindings in a <tt>letrec</tt> construct to refer to previous variables in the same set of bindings, so</p><pre>(letrec ((foo 123)
         (bar foo) )
  bar)</pre><p>is allowed and returns <tt>123</tt>.</p><p>[4.2.3] <tt>(begin)</tt> is allowed in non-toplevel contexts and evaluates to an unspecified value.</p><p>[4.2.5] Delayed expressions may return multiple values.</p><p>[5.2.2] CHICKEN extends standard semantics by allowing internal definitions everywhere, and not only at the beginning of a body. A set of internal definitions is equivalent to a <tt>letrec</tt> form enclosing all following expressions in the body:</p><pre>(let ((foo 123))
  (bar)
  (define foo 456)
  (baz foo) )</pre><p>expands into</p><pre>(let ((foo 123))
  (bar)
  (letrec ((foo 456))
    (baz foo) ) )</pre><p>[5.2] <tt>define</tt> with a single argument is allowed and initializes the toplevel or local binding to an unspecified value. CHICKEN supports <em>curried</em> definitions, where the the variable name may also be a list specifying a name and a nested lambda list. So</p><pre>(define ((make-adder x) y) (+ x y))</pre><p>is equivalent to</p><pre>(define (make-adder x) (lambda (y) (+ x y)))</pre><p>[6] CHICKEN provides numerous non-standard procedures. See the manual sections on library units for more information.</p><p>[6.2.4] The special IEEE floating-point numbers <em>+nan</em>, <em>+inf</em> and <em>-inf</em> are supported, as is negative zero.</p><p>[6.3.4] User defined character names are supported. See <tt>char-name</tt>. Characters can be given in hexadecimal notation using the <em>#\xXX</em> syntax where <em>XX</em> specifies the  character code. Character codes above 255 are supported and can be read (and are written) using the <em>#\uXXXX</em> and <em>#\UXXXXXXXX</em> notations.</p><p>Non-standard characters names supported are <tt>#\tab</tt>, <tt>#\linefeed</tt>, <tt>#\return</tt>, <tt>#\alarm</tt>, <tt>#\vtab</tt>, <tt>#\nul</tt>, <tt>#\page</tt>, <tt>#\esc</tt>, <tt>#\delete</tt> and <tt>#\backspace</tt>.</p><p>[6.3.5]  CHICKEN supports special characters preceded with a backslash <em>\</em> in quoted string constants. <em>\n</em> denotes the newline-character, <em>\r</em> carriage return, <em>\b</em> backspace, <em>\t</em> TAB, <em>\v</em> vertical TAB, <em>\a</em> alarm, <em>\f</em> formfeed, <em>\xXX</em> a character with the code <tt>XX</tt> in hex and  <em>\uXXXX</em> (and <em>\UXXXXXXXX</em>) a unicode character with the code <tt>XXXX</tt>. The latter is encoded in UTF-8 format.</p><p>The third argument to <tt>substring</tt> is optional and defaults to the length of the string.</p><p>[6.4] <tt>force</tt> called with an argument that is not a promise returns that object unchanged.  Captured continuations can be safely invoked inside before- and after-thunks of a <tt>dynamic-wind</tt> form and execute in the outer dynamic context of the <tt>dynamic-wind</tt> form.</p><p><strong>Implicit</strong> non-multival continuations accept multiple values by discarding all but the first result. Zero values result in the continuation receiving an unspecified value. Note that this slight relaxation of the behaviour of returning mulitple values to non-multival continuations does not apply to explicit continuations (created with <tt>call-with-current-continuation</tt>).</p><p>[6.5] The second argument to <tt>eval</tt> is optional and defaults to the value of <tt>(interaction-environment)</tt>. <tt>scheme-report-environment</tt> and <tt>null-environment</tt> accept an optional 2nd parameter: if not <tt>#f</tt> (which is the default), toplevel bindings to standard procedures are mutable and new toplevel bindings may be introduced.</p><p>[6.6] The <em>tilde</em> character (<tt>~</tt>) is automatically expanded in pathnames. Additionally, if a pathname starts with <tt>$VARIABLE...</tt>, then the prefix is replaced by the value of the given environment variable.</p><p>[6.6.1] if the procedures <tt>current-input-port</tt> and <tt>current-output-port</tt> are called with an argument (which should be a port), then that argument is selected as the new current input- and output-port, respectively.  The procedures <tt>open-input-file</tt>, <tt>open-output-file</tt>, <tt>with-input-from-file</tt>, <tt>with-output-to-file</tt>, <tt>call-with-input-file</tt> and <tt>call-with-output-file</tt> accept an optional second (or third) argument which should be one or more keywords, if supplied. These arguments specify the mode in which the file is opened. Possible values are the keywords <tt>#:text</tt>, <tt>#:binary</tt> or <tt>#:append</tt>.</p><p>Previous: <a href='deviations-from-the-standard.html' class='internal'>Deviations from the standard</a></p><p>Next: <a href='non-standard-read-syntax.html' class='internal'>Non standard read syntax</a></p>
</body></html>