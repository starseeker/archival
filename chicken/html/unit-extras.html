<html><head><title>CHICKEN User's Manual - Unit extras</title></head><body>
<p> </p><a name='Unit extras'><h1>Unit extras</h1></a><p>This unit contains a collection of useful utility definitions.  This unit is used by default, unless the program is compiled with the <tt>-explicit-use</tt> option.</p><a name='Lists'><h2>Lists</h2></a><a name='alist-ref'><h3>alist-ref</h3></a><pre>[procedure] (alist-ref KEY ALIST [TEST [DEFAULT]])</pre><p>Looks up <tt>KEY</tt> in <tt>ALIST</tt> using <tt>TEST</tt> as the comparison function (or <tt>eqv?</tt> if no test was given) and returns the cdr of the found pair, or <tt>DEFAULT</tt> (which defaults to <tt>#f</tt>).</p><a name='alist-update!'><h3>alist-update!</h3></a><pre>[procedure] (alist-update! KEY VALUE ALIST [TEST])</pre><p>If the list <tt>ALIST</tt> contains a pair of the form <tt>(KEY . X)</tt>, then this procedure replaces <tt>X</tt> with <tt>VALUE</tt> and returns <tt>ALIST</tt>. If <tt>ALIST</tt> contains no such item, then <tt>alist-update!</tt> returns <tt>((KEY . VALUE) . ALIST)</tt>. The optional argument <tt>TEST</tt> specifies the comparison procedure to search a matching pair in <tt>ALIST</tt> and defaults to <tt>eqv?</tt>.</p><a name='atom?'><h3>atom?</h3></a><pre>[procedure] (atom? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is not a pair. This is identical to <tt>not-pair?</tt> from <a href='unit-srfi-1.html' class='internal'>Unit srfi-1</a> but kept for historical reasons.</p><a name='rassoc'><h3>rassoc</h3></a><pre>[procedure] (rassoc KEY LIST [TEST])</pre><p>Similar to <tt>assoc</tt>, but compares <tt>KEY</tt> with the <tt>cdr</tt> of each pair in <tt>LIST</tt> using <tt>TEST</tt> as the comparison procedures (which defaults to <tt>eqv?</tt>.</p><a name='butlast'><h3>butlast</h3></a><pre>[procedure] (butlast LIST)</pre><p>Returns a fresh list with all elements but the last of <tt>LIST</tt>.</p><a name='chop'><h3>chop</h3></a><pre>[procedure] (chop LIST N)</pre><p>Returns a new list of sublists, where each sublist contains <tt>N</tt> elements of <tt>LIST</tt>. If <tt>LIST</tt> has a length that is not a multiple of <tt>N</tt>, then the last sublist contains the remaining elements.</p><PRE>
(chop '(1 2 3 4 5 6) 2) =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> ((1 2) (3 4) (5 6))
(chop '(a b c d) 3)     =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> ((a b c) (d))
</PRE>
<a name='compress'><h3>compress</h3></a><pre>[procedure] (compress BLIST LIST)</pre><p>Returns a new list with elements taken from <tt>LIST</tt> with corresponding true values in the list <tt>BLIST</tt>.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> <B><FONT COLOR="#0000FF">nums</FONT></B> '(99 100 110 401 1234))
(compress (map odd? nums) nums)      =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (99 401)
</PRE>
<a name='flatten'><h3>flatten</h3></a><pre>[procedure] (flatten LIST1 ...)</pre><p>Returns <tt>LIST1 ...</tt> concatenated together, with nested lists removed (flattened).</p><a name='intersperse'><h3>intersperse</h3></a><pre>[procedure] (intersperse LIST X)</pre><p>Returns a new list with <tt>X</tt> placed between each element.</p><a name='join'><h3>join</h3></a><pre>[procedure] (join LISTOFLISTS [LIST])</pre><p>Concatenates the lists in <tt>LISTOFLISTS</tt> with <tt>LIST</tt> placed between each sublist. <tt>LIST</tt> defaults to the empty list.</p><PRE>
(join '((a b) (c d) (e)) '(x y)) =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (a b x y c d x y e)
(join '((p q) () (r (s) t)) '(-))  =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (p q - - r (s) t)
</PRE>
<p><tt>join</tt> could be implemented as follows:</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">join</FONT></B> lstoflsts #!optional (lst '()))
  (apply append (intersperse lstoflists lst)) )
</PRE>
<a name='shuffle'><h3>shuffle</h3></a><pre>[procedure] (shuffle LIST)</pre><p>Returns <tt>LIST</tt> with its elements sorted in a random order.</p><a name='tail?'><h3>tail?</h3></a><pre>[procedure] (tail? X LIST)</pre><p>Returns true if <tt>X</tt> is one of the tails (cdr's) of <tt>LIST</tt>.</p><a name='String-port extensions'><h2>String-port extensions</h2></a><a name='call-with-input-string'><h3>call-with-input-string</h3></a><pre>[procedure] (call-with-input-string STRING PROC)</pre><p>Calls the procedure <tt>PROC</tt> with a single argument that is a string-input-port with the contents of <tt>STRING</tt>.</p><a name='call-with-output-string'><h3>call-with-output-string</h3></a><pre>[procedure] (call-with-output-string PROC)</pre><p>Calls the procedure <tt>PROC</tt> with a single argument that is a string-output-port.  Returns the accumulated output-string.</p><a name='with-input-from-string'><h3>with-input-from-string</h3></a><pre>[procedure] (with-input-from-string STRING THUNK)</pre><p>Call procedure <tt>THUNK</tt> with the current input-port temporarily bound to an input-string-port with the contents of <tt>STRING</tt>.</p><a name='with-output-to-string'><h3>with-output-to-string</h3></a><pre>[procedure] (with-output-to-string THUNK)</pre><p>Call procedure <tt>THUNK</tt> with the current output-port temporarily bound to a string-output-port and return the accumulated output string.</p><a name='Formatted output'><h2>Formatted output</h2></a><a name='printf'><h3>printf</h3></a><pre>[procedure] (fprintf PORT FORMATSTRING ARG ...)
[procedure] (printf FORMATSTRING ARG)
[procedure] (sprintf FORMATSTRING ARG ...)
[procedure] (format FORMATSTRING ARG ...)</pre><p>Simple formatted output to a given port (<tt>fprintf</tt>), the value of <tt>(current-output-port) </tt> (<tt>printf</tt>) or a string (<tt>sprintf</tt>/<tt>format</tt>).  The <tt>FORMATSTRING</tt> can contain any sequence of characters. The character `~' prefixes special formatting directives:</p><table><tr><td><pre>~%</pre><p>write newline character</p></td></tr><tr><td><pre>~N</pre><p>the same as <tt>~%</tt></p></td></tr><tr><td><pre>~S</pre><p>write the next argument</p></td></tr><tr><td><pre>~A</pre><p>display the next argument</p></td></tr><tr><td><pre>~\n</pre><p>skip all whitespace in the format-string until the next non-whitespace character</p></td></tr><tr><td><pre>~B</pre><p>write the next argument as a binary number</p></td></tr><tr><td><pre>~O</pre><p>write the next argument as an octal number</p></td></tr><tr><td><pre>~X</pre><p>write the next argument as a hexadecimal number</p></td></tr><tr><td><pre>~C</pre><p>write the next argument as a character</p></td></tr><tr><td><pre>~~</pre><p>display `~'</p></td></tr><tr><td><pre>~!</pre><p>flush all pending output</p></td></tr><tr><td><pre>~?</pre><p>invoke formatted output routine recursively with the next two arguments as format-string and list of parameters</p></td></tr></table><pre></pre><a name='Hash tables'><h2>Hash tables</h2></a><p>CHICKEN implements SRFI-69. For more information,  see <a href='http://srfi.schemers.org/srfi-69/srfi-69.html' class='external'>SRFI-69</a>.</p><p>A setter for <tt>hash-table-ref</tt> is defined, so</p><PRE>
(<B><FONT COLOR="#A020F0">set!</FONT></B> (hash-table-ref HT KEY) VAL)
</PRE>
<p>is equivalent to</p><PRE>
(hash-table-set! HT KEY VAL)
</PRE>
<p>As an extension to SRFI-69, <tt>hash-table-update!</tt> and <tt>hash-table-update!/default</tt> return the new value (after applying the update procedure).</p><a name='Queues'><h2>Queues</h2></a><a name='list->queue'><h3>list->queue</h3></a><pre>[procedure] (list-&gt;queue LIST)</pre><p>Returns <tt>LIST</tt> converted into a queue, where the first element of the list is the same as the first element of the queue. The resulting queue may share memory with the list and the list should not be modified after this operation.</p><a name='make-queue'><h3>make-queue</h3></a><pre>[procedure] (make-queue)</pre><p>Returns a newly created queue.</p><a name='queue?'><h3>queue?</h3></a><pre>[procedure] (queue? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a queue, or <tt>#f</tt> otherwise.</p><a name='queue->list'><h3>queue->list</h3></a><pre>[procedure] (queue-&gt;list QUEUE)</pre><p>Returns <tt>QUEUE</tt> converted into a list, where the first element of the list is the same as the first element of the queue. The resulting list may share memory with the queue object and should not be modified.</p><a name='queue-add!'><h3>queue-add!</h3></a><pre>[procedure] (queue-add! QUEUE X)</pre><p>Adds <tt>X</tt> to the rear of <tt>QUEUE</tt>.</p><a name='queue-empty?'><h3>queue-empty?</h3></a><pre>[procedure] (queue-empty? QUEUE)</pre><p>Returns <tt>#t</tt> if <tt>QUEUE</tt> is empty, or <tt>#f</tt> otherwise.</p><a name='queue-first'><h3>queue-first</h3></a><pre>[procedure] (queue-first QUEUE)</pre><p>Returns the first element of <tt>QUEUE</tt>. If <tt>QUEUE</tt> is empty an error is signaled</p><a name='queue-last'><h3>queue-last</h3></a><pre>[procedure] (queue-last QUEUE)</pre><p>Returns the last element of <tt>QUEUE</tt>. If <tt>QUEUE</tt> is empty an error is signaled</p><a name='queue-remove!'><h3>queue-remove!</h3></a><pre>[procedure] (queue-remove! QUEUE)</pre><p>Removes and returns the first element of <tt>QUEUE</tt>. If <tt>QUEUE</tt> is empty an error is signaled</p><a name='queue-push-back!'><h3>queue-push-back!</h3></a><pre>[procedure] (queue-push-back! QUEUE ITEM)</pre><p>Pushes an item into the first position of a queue, i.e. the next <tt>queue-remove!</tt> will return <tt>ITEM</tt>.</p><a name='queue-push-back-list!'><h3>queue-push-back-list!</h3></a><pre>[procedure] (queue-push-back-list! QUEUE LIST)</pre><p>Pushes the items in item-list back onto the queue, so that <tt>(car LIST)</tt> becomes the next removable item.</p><a name='Sorting'><h2>Sorting</h2></a><a name='merge'><h3>merge</h3></a><pre>[procedure] (merge LIST1 LIST2 LESS?)
[procedure] (merge! LIST1 LIST2 LESS?)</pre><p>Joins two lists in sorted order. <tt>merge!</tt> is the destructive version of merge. <tt>LESS?  </tt> should be a procedure of two arguments, that returns true if the first argument is to be ordered before the second argument.</p><a name='sort'><h3>sort</h3></a><pre>[procedure] (sort SEQUENCE LESS?)
[procedure] (sort! SEQUENCE LESS?)</pre><p>Sort <tt>SEQUENCE</tt>, which should be a list or a vector. <tt>sort!</tt> is the destructive version of sort.</p><a name='sorted?'><h3>sorted?</h3></a><pre>[procedure] (sorted? SEQUENCE LESS?)</pre><p>Returns true if the list or vector <tt>SEQUENCE</tt> is already sorted.</p><a name='Random numbers'><h2>Random numbers</h2></a><a name='random'><h3>random</h3></a><pre>[procedure] (random N)</pre><p>Returns an exact random integer from 0 to <tt>N</tt>-1.</p><a name='randomize'><h3>randomize</h3></a><pre>[procedure] (randomize [X])</pre><p>Set random-number seed. If <tt>X</tt> is not supplied, the current time is used. On startup (when the <tt>extras</tt> unit is initialized), the random number generator is initialized with the current time.</p><a name='Input/Output extensions'><h2>Input/Output extensions</h2></a><a name='make-input-port'><h3>make-input-port</h3></a><pre>[procedure] (make-input-port READ READY? CLOSE [PEEK])</pre><p>Returns a custom input port. Common operations on this port are handled by the given parameters, which should be procedures of no arguments. <tt>READ</tt> is called when the next character is to be read and should return a character or <tt>#!eof</tt>. <tt>READY?</tt> is called when <tt>char-ready?</tt> is called on this port and should return <tt>#t</tt> or <tt>#f</tt>.  <tt>CLOSE</tt> is called when the port is closed. <tt>PEEK</tt> is called when <tt>peek-char</tt> is called on this port and should return a character or <tt>#!eof</tt>. if the argument <tt>PEEK</tt> is not given, then <tt>READ</tt> is used instead and the created port object handles peeking automatically (by calling <tt>READ</tt> and buffering the character).</p><a name='make-output-port'><h3>make-output-port</h3></a><pre>[procedure] (make-output-port WRITE CLOSE [FLUSH])</pre><p>Returns a custom output port. Common operations on this port are handled by the given parameters, which should be procedures.  <tt>WRITE</tt> is called when output is sent to the port and receives a single argument, a string.  <tt>CLOSE</tt> is called when the port is closed and should be a procedure of no arguments. <tt>FLUSH</tt> (if provided) is called for flushing the output port.</p><a name='pretty-print'><h3>pretty-print</h3></a><pre>[procedure] (pretty-print EXP [PORT])
[procedure] (pp EXP [PORT])</pre><p>Print expression nicely formatted. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p><a name='pretty-print-width'><h3>pretty-print-width</h3></a><p>(Parameter) Specifies the maximal line-width for pretty printing, after which line wrap will occur.</p><a name='read-file'><h3>read-file</h3></a><pre>[procedure] (read-file [FILE-OR-PORT [READER [MAXCOUNT]]])</pre><p>Returns a list containing all toplevel expressions read from the file or port <tt>FILE-OR-PORT</tt>. If no argument is given, input is read from the port that is the current value of <tt>(current-input-port)</tt>. After all expressions are read, and if the argument is a port, then the port will not be closed. The <tt>READER</tt> argument specifies the procedure used to read  expressions from the given file or port and defaults to <tt>read</tt>. The reader procedure will be called with a single argument (an input port). If <tt>MAXCOUNT</tt> is given then only up to <tt>MAXCOUNT</tt> expressions will be read in.</p><a name='read-line'><h3>read-line</h3></a><a name='write-line'><h3>write-line</h3></a><pre>[procedure] (read-line [PORT [LIMIT]])
[procedure] (write-line STRING [PORT])</pre><p>Line-input and -output. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt> and <tt>(current-output-port)</tt>, respectively. if the optional argument <tt>LIMIT</tt> is given and not <tt>#f</tt>, then <tt>read-line</tt> reads at most <tt>LIMIT</tt> characters per line.</p><a name='read-lines'><h3>read-lines</h3></a><pre>[procedure] (read-lines [PORT [MAX]])</pre><p>Read <tt>MAX</tt> or fewer lines from <tt>PORT</tt>. <tt>PORT</tt> defaults to the value of <tt>(current-input-port)</tt>. <tt>PORT</tt> may optionally be a string naming a file.</p><a name='read-string'><h3>read-string</h3></a><a name='read-string!'><h3>read-string!</h3></a><a name='write-string'><h3>write-string</h3></a><pre>[procedure] (read-string [NUM [PORT]])
[procedure] (read-string! NUM STRING [PORT [START]])
[procedure] (write-string STRING [NUM [PORT]]</pre><p>Read or write <tt>NUM</tt> characters from/to <tt>PORT</tt>, which defaults to the value of <tt>(current-input-port)</tt> or <tt>(current-output-port)</tt>, respectively.  If <tt>NUM</tt> is <tt>#f</tt> or not given, then all data up to the end-of-file is read, or, in the case of <tt>write-string</tt> the whole string is written. If no more input is available, <tt>read-string</tt> returns the empty string. <tt>read-string!</tt> reads destructively into the given <tt>STRING</tt> argument, but never more characters that would fit into <tt>STRING</tt>. If <tt>START</tt> is given, then the read characters are stored starting at that position. <tt>read-string!</tt> returns the actual number of characters read.</p><a name='read-token'><h3>read-token</h3></a><pre>[procedure] (read-token PREDICATE [PORT])</pre><p>Reads characters from <tt>PORT</tt> (which defaults to the value of <tt>(current-input-port)</tt>) and calls the procedure <tt>PREDICATE</tt> with each character until <tt>PREDICATE</tt> returns false. Returns a string with the accumulated characters.</p><a name='with-error-output-to-port'><h3>with-error-output-to-port</h3></a><pre>[procedure] (with-error-output-to-port PORT THUNK)</pre><p>Call procedure <tt>THUNK</tt> with the current error output-port temporarily bound to <tt>PORT</tt>.</p><a name='with-input-from-port'><h3>with-input-from-port</h3></a><pre>[procedure] (with-input-from-port PORT THUNK)</pre><p>Call procedure <tt>THUNK</tt> with the current input-port temporarily bound to <tt>PORT</tt>.</p><a name='with-output-to-port'><h3>with-output-to-port</h3></a><pre>[procedure] (with-output-to-port PORT THUNK)</pre><p>Call procedure <tt>THUNK</tt> with the current output-port temporarily bound to <tt>PORT</tt>.</p><a name='Strings'><h2>Strings</h2></a><a name='conc'><h3>conc</h3></a><pre>[procedure] (conc X ...)</pre><p>Returns a string with the string-represenation of all arguments concatenated together. <tt>conc</tt> could be implemented as</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">conc</FONT></B> . args)
  (apply string-append (map -&gt;string args)) )
</PRE>
<a name='->string'><h3>->string</h3></a><pre>[procedure] (-&gt;string X)</pre><p>Returns a string-representation of <tt>X</tt>.</p><a name='string-chop'><h3>string-chop</h3></a><pre>[procedure] (string-chop STRING LENGTH)</pre><p>Returns a list of substrings taken by <em>chopping</em> <tt>STRING</tt> every <tt>LENGTH</tt> characters:</p><PRE>
(string-chop <B><FONT COLOR="#BC8F8F">&quot;one two three&quot;</FONT></B> 4)  =<B><FONT COLOR="#A020F0">=&gt;</FONT></B>  (<B><FONT COLOR="#BC8F8F">&quot;one &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;two &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;thre&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;e&quot;</FONT></B>)
</PRE>
<a name='string-chomp'><h3>string-chomp</h3></a><pre>[procedure] (string-chomp STRING [SUFFIX])</pre><p>If <tt>STRING</tt> ends with <tt>SUFFIX</tt>, then this procedure returns a copy of its first argument with the suffix removed, otherwise returns <tt>STRING</tt> unchanged. <tt>SUFFIX</tt> defaults to <tt>"\n"</tt>.</p><a name='string-compare3'><h3>string-compare3</h3></a><pre>[procedure] (string-compare3 STRING1 STRING2)
[procedure] (string-compare3-ci STRING1 STRING2)</pre><p>Perform a three-way comparison between the <tt>STRING1</tt> and <tt>STRING2</tt>, returning either <tt>-1</tt> if <tt>STRING1</tt> is lexicographically less than <tt>STRING2</tt>, <tt>0</tt> if it is equal, or <tt>1</tt> if it s greater. <tt>string-compare3-ci</tt> performs a case-insensitive comparison.</p><a name='string-intersperse'><h3>string-intersperse</h3></a><pre>[procedure] (string-intersperse LIST [STRING])</pre><p>Returns a string that contains all strings in <tt>LIST</tt> concatenated together.  <tt>STRING</tt> is placed between each concatenated string and defaults to <tt>" "</tt>.</p><PRE>
(string-intersperse '(<B><FONT COLOR="#BC8F8F">&quot;one&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;two&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;three&quot;</FONT></B>)
</PRE>
<p>is equivalent to</p><PRE>
(apply string-append (intersperse '(<B><FONT COLOR="#BC8F8F">&quot;one&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;two&quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;three&quot;</FONT></B>))
</PRE>
<a name='string-split'><h3>string-split</h3></a><pre>[procedure] (string-split STRING [DELIMITER-STRING [KEEPEMPTY]])</pre><p>Split string into substrings separated by the given delimiters. If no delimiters are specified, a string comprising the tab, newline and space characters  is assumed. If the parameter <tt>KEEPEMPTY</tt> is given and not <tt>#f</tt>, then empty substrings are retained:</p><PRE>
(string-split <B><FONT COLOR="#BC8F8F">&quot;one  two  three&quot;</FONT></B>) =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (<B><FONT COLOR="#BC8F8F">&quot;one&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;two&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;three&quot;</FONT></B>)
(string-split <B><FONT COLOR="#BC8F8F">&quot;foo:bar::baz:&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;:&quot;</FONT></B> #t) =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (<B><FONT COLOR="#BC8F8F">&quot;foo&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;bar&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;baz&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)
</PRE>
<a name='string-translate'><h3>string-translate</h3></a><pre>[procedure] (string-translate STRING FROM [TO])</pre><p>Returns a fresh copy of <tt>STRING</tt> with characters matching <tt>FROM</tt> translated to <tt>TO</tt>.  If <tt>TO</tt> is omitted, then matching characters are removed. <tt>FROM</tt> and <tt>TO</tt> may be a character, a string or a list. If both <tt>FROM</tt> and <tt>TO</tt> are strings, then the character at the same position in <tt>TO</tt> as the matching character in <tt>FROM</tt> is substituted.</p><a name='string-translate*'><h3>string-translate*</h3></a><pre>[procedure] (string-translate* STRING SMAP)</pre><p>Substitutes elements of <tt>STRING</tt> according to <tt>SMAP</tt>. <tt>SMAP</tt> should be an association-list where each element of the list is a pair of the form <tt>(MATCH \. REPLACEMENT)</tt>. Every occurrence of the string <tt>MATCH</tt> in <tt>STRING</tt> will be replaced by the string <tt>REPLACEMENT</tt>:</p><PRE>
(string-translate*
  <B><FONT COLOR="#BC8F8F">&quot;&lt;h1&gt;this is a \&quot;string\&quot;&lt;/h1&gt;&quot;</FONT></B>
  '((<B><FONT COLOR="#BC8F8F">&quot;&lt;&quot;</FONT></B> . <B><FONT COLOR="#BC8F8F">&quot;&amp;lt:&quot;</FONT></B>) (<B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B> . <B><FONT COLOR="#BC8F8F">&quot;&amp;gt;&quot;</FONT></B>) (<B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> . <B><FONT COLOR="#BC8F8F">&quot;&amp;quot;&quot;</FONT></B>)) )
<B><FONT COLOR="#A020F0">=&gt;</FONT></B>  <B><FONT COLOR="#BC8F8F">&quot;&amp;lt;h1&amp;gt;this is a &amp;quot;string&amp;quot;&amp;lt;/ht&amp;gt;&quot;</FONT></B>
</PRE>
<a name='substring=?'><h3>substring=?</h3></a><pre>[procedure] (substring=? STRING1 STRING2 [START1 [START2 [LENGTH]]])
[procedure] (substring-ci=? STRING1 STRING2 [START1 [START2 [LENGTH]]])</pre><p>Returns <tt>#t</tt> if the strings <tt>STRING1</tt> and <tt>STRING2</tt> are equal, or <tt>#f</tt> otherwise. The comparison starts at the positions <tt>START1</tt> and <tt>START2</tt> (which default to 0), comparing <tt>LENGTH</tt> characters (which defaults to the minimum of the remaining length of both strings).</p><a name='substring-index'><h3>substring-index</h3></a><pre>[procedure] (substring-index WHICH WHERE [START])
[procedure] (substring-index-ci WHICH WHERE [START])</pre><p>Searches for first index in string <tt>WHERE</tt> where string <tt>WHICH</tt> occurs.  If the optional argument <tt>START</tt> is given, then the search starts at that index.  <tt>substring-index-ci</tt> is a case-insensitive version of <tt>substring-index</tt>.</p><a name='Combinators'><h2>Combinators</h2></a><a name='any?'><h3>any?</h3></a><pre>[procedure] (any? X)</pre><p>Ignores it's argument and always returns <tt>#t</tt>. This is actually useful sometimes.</p><a name='constantly'><h3>constantly</h3></a><pre>[procedure] (constantly X ...)</pre><p>Returns a procedure that always returns the values <tt>X ...</tt> regardless of the number and value of its arguments.</p><PRE>
(constantly X) &lt;<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (<B><FONT COLOR="#A020F0">lambda</FONT></B> args X)
</PRE>
<a name='complement'><h3>complement</h3></a><pre>[procedure] (complement PROC)</pre><p>Returns a procedure that returns the boolean inverse of <tt>PROC</tt>.</p><PRE>
(complement PROC) &lt;<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (<B><FONT COLOR="#A020F0">lambda</FONT></B> (x) (not (PROC x)))
</PRE>
<a name='compose'><h3>compose</h3></a><pre>[procedure] (compose PROC1 PROC2 ...)</pre><p>Returns a procedure that represents the composition of the argument-procedures <tt>PROC1 PROC2 ...</tt>.</p><PRE>
(compose F G) &lt;<B><FONT COLOR="#A020F0">=&gt;</FONT></B> (<B><FONT COLOR="#A020F0">lambda</FONT></B> args
                      (call-with-values
                         (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (apply G args))
                         F))
</PRE>
<p><tt>(compose)</tt> is equivalent to <tt>values</tt>.</p><a name='conjoin'><h3>conjoin</h3></a><pre>[procedure] (conjoin PRED ...)</pre><p>Returns a procedure that returns <tt>#t</tt> if its argument satisfies the predicates <tt>PRED ...</tt>. &lt;enscript highlight=scheme&gt; ((conjoin odd? positive?) 33)   =&rArr;  #t ((conjoin odd? positive?) -33)  =&rArr;  #f &lt;/enscript&gt;</p><a name='disjoin'><h3>disjoin</h3></a><pre>[procedure] (disjoin PRED ...)</pre><p>Returns a procedure that returns <tt>#t</tt> if its argument satisfies any predicate <tt>PRED ...</tt>. &lt;enscript highlight=scheme&gt; ((disjoin odd? positive?) 32)    =&rArr;  #t ((disjoin odd? positive?) -32)   =&rArr;  #f &lt;/enscript&gt;</p><a name='each'><h3>each</h3></a><pre>[procedure] (each PROC ...)</pre><p>Returns a procedure that applies <tt>PROC ...</tt> to its arguments, and returns the result(s) of the last procedure application. For example</p><PRE>
(each pp eval)
</PRE>
<p>is equivalent to</p><PRE>
(<B><FONT COLOR="#A020F0">lambda</FONT></B> args 
  (apply pp args)
  (apply eval args) )
</PRE>
<p><tt>(each PROC)</tt> is equivalent to <tt>PROC</tt> and <tt>(each)</tt> is equivalent to <tt>noop</tt>.</p><a name='flip'><h3>flip</h3></a><pre>[procedure] (flip PROC)</pre><p>Returns a two-argument procedure that calls <tt>PROC</tt> with its arguments swapped: &lt;enscript highlight=scheme&gt; (flip PROC) &hArr; (lambda (x y) (PROC y x)) &lt;/enscript&gt;</p><a name='identity'><h3>identity</h3></a><pre>[procedure] (identity X)</pre><p>Returns its sole argument <tt>X</tt>.</p><a name='project'><h3>project</h3></a><pre>[procedure] (project N)</pre><p>Returns a procedure that returns its <tt>N</tt>th argument (starting from 0).</p><a name='list-of'><h3>list-of</h3></a><pre>[procedure] (list-of PRED)</pre><p>Returns a procedure of one argument that returns <tt>#t</tt> when applied to a list of elements that all satisfy the predicate procedure <tt>PRED</tt>, or <tt>#f</tt> otherwise.</p><PRE>
((list-of even?) '(1 2 3))   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #f
((list-of number?) '(1 2 3)) =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #t
</PRE>
<a name='noop'><h3>noop</h3></a><pre>[procedure] (noop X ...)</pre><p>Ignores it's arguments, does nothing and returns an unspecified value.</p><a name='o'><h3>o</h3></a><pre>[procedure] (o PROC ...)</pre><p>A single value version of <tt>compose</tt> (slightly faster). <tt>(o)</tt> is equivalent to <tt>identity</tt>.</p><a name='Binary searching'><h2>Binary searching</h2></a><a name='binary-search'><h3>binary-search</h3></a><pre>[procedure] (binary-search SEQUENCE PROC)</pre><p>Performs a binary search in <tt>SEQUENCE</tt>, which should be a sorted list or vector.  <tt>PROC</tt> is called to compare items in the sequence, should accept a single argument and return an exact integer: zero if the searched value is equal to the current item, negative if the searched value is <em>less</em> than the current item, and positive otherwise. Returns the index of the found value or <tt>#f</tt> otherwise.</p><p>Previous: <a href='unit-eval.html' class='internal'>Unit eval</a></p><p>Next: <a href='unit-srfi-1.html' class='internal'>Unit srfi-1</a></p>
</body></html>