<html><head><title>CHICKEN User's Manual - Unit library</title></head><body>
<p> </p><a name='Unit library'><h1>Unit library</h1></a><p>This unit contains basic Scheme definitions. This unit is used by default, unless the program is compiled with the <tt>-explicit-use</tt> option.</p><a name='Arithmetic'><h2>Arithmetic</h2></a><a name='add1'><h3>add1</h3></a><a name='sub1'><h3>sub1</h3></a><pre>[procedure] (add1 N)
[procedure] (sub1 N)</pre><p>Adds/subtracts 1 from <tt>N</tt>.</p><a name='bitwise-and'><h3>bitwise-and</h3></a><a name='bitwise-ior'><h3>bitwise-ior</h3></a><a name='bitwise-xor'><h3>bitwise-xor</h3></a><a name='bitwise-not'><h3>bitwise-not</h3></a><a name='arithmetic-shift'><h3>arithmetic-shift</h3></a><pre>[procedure] (bitwise-and N1 ...)
[procedure] (bitwise-ior N1 ...)
[procedure] (bitwise-xor N1 ...)
[procedure] (bitwise-not N)
[procedure] (arithmetic-shift N1 N2)</pre><p>Binary integer operations. <tt>arithmetic-shift</tt> shifts the argument <tt>N1</tt> by <tt>N2</tt> bits to the left. If <tt>N2</tt> is negative, than <tt>N1</tt> is shifted to the right. These operations only accept exact integers or inexact integers in word range (32 bit signed on 32-bit platforms, or 64 bit signed on 64-bit platforms).</p><a name='bit-set?'><h3>bit-set?</h3></a><pre>[procedure] (bit-set? N INDEX)</pre><p>Returns <tt>#t</tt> if the bit at the position <tt>INDEX</tt> in the integer <tt>N</tt> is set, or <tt>#f</tt> otherwise. The rightmost/least-significant bit is bit 0.</p><a name='fixnum?'><h3>fixnum?</h3></a><pre>[procedure] (fixnum? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a fixnum, or <tt>#f</tt> otherwise.</p><a name='fx+'><h3>fx+</h3></a><a name='fx-'><h3>fx-</h3></a><a name='fx*'><h3>fx*</h3></a><a name='fx/'><h3>fx/</h3></a><a name='fxmod'><h3>fxmod</h3></a><a name='fxneg'><h3>fxneg</h3></a><a name='fxmin'><h3>fxmin</h3></a><a name='fxmax'><h3>fxmax</h3></a><a name='fx='><h3>fx=</h3></a><a name='fx>'><h3>fx></h3></a><a name='fx<'><h3>fx<</h3></a><a name='fx>='><h3>fx>=</h3></a><a name='fx<='><h3>fx<=</h3></a><a name='fxand'><h3>fxand</h3></a><a name='fxior'><h3>fxior</h3></a><a name='fxxor'><h3>fxxor</h3></a><a name='fxnot'><h3>fxnot</h3></a><a name='fxshl'><h3>fxshl</h3></a><a name='fxshr'><h3>fxshr</h3></a><pre>[procedure] (fx+ N1 N2)
[procedure] (fx- N1 N2)
[procedure] (fx* N1 N2)
[procedure] (fx/ N1 N2)
[procedure] (fxmod N1 N2)
[procedure] (fxneg N)
[procedure] (fxmin N1 N2)
[procedure] (fxmax N1 N2)
[procedure] (fx= N1 N2)
[procedure] (fx&gt; N1 N2)
[procedure] (fx&lt; N1 N2)
[procedure] (fx&gt;= N1 N2)
[procedure] (fx&lt;= N1 N2)
[procedure] (fxand N1 N2)
[procedure] (fxior N1 N2)
[procedure] (fxxor N1 N2)
[procedure] (fxnot N)
[procedure] (fxshl N1 N2)
[procedure] (fxshr N1 N2)</pre><p>Arithmetic fixnum operations. These procedures do not check their arguments, so non-fixnum parameters will result in incorrect results. <tt>fxneg</tt> negates its argument.</p><p>On division by zero, <tt>fx/</tt> and <tt>fxmod</tt> signal a condition of kind <tt>(exn arithmetic)</tt>.</p><p><tt>fxshl</tt> and <tt>fxshr</tt> perform arithmetic shift left and right, respectively.</p><a name='flonum?'><h3>flonum?</h3></a><a name='fp+'><h3>fp+</h3></a><a name='fp-'><h3>fp-</h3></a><a name='fp*'><h3>fp*</h3></a><a name='fp/'><h3>fp/</h3></a><a name='fpneg'><h3>fpneg</h3></a><a name='fpmin'><h3>fpmin</h3></a><a name='fpmax'><h3>fpmax</h3></a><a name='fp='><h3>fp=</h3></a><a name='fp>'><h3>fp></h3></a><a name='fp<'><h3>fp<</h3></a><a name='fp>='><h3>fp>=</h3></a><a name='fp<='><h3>fp<=</h3></a><pre>[procedure] (flonum? X)
[procedure] (fp+ X Y)
[procedure] (fp- X Y)
[procedure] (fp* X Y)
[procedure] (fp/ X Y)
[procedure] (fpneg X)
[procedure] (fpmin X Y)
[procedure] (fpmax X Y)
[procedure] (fp= X Y)
[procedure] (fp&gt; X Y)
[procedure] (fp&lt; X Y)
[procedure] (fp&gt;= X Y)
[procedure] (fp&lt;= X Y)</pre><p>Arithmetic floating-point operations. In safe mode, these procedures throw a type error with non-float arguments (except <tt>flonum?</tt>, which returns <tt>#f</tt>).  In unsafe mode, these procedures do not check their arguments.  A non-flonum argument in unsafe mode can crash the system.</p><a name='signum'><h3>signum</h3></a><pre>[procedure] (signum N)</pre><p>Returns <tt>1</tt> if <tt>N</tt> is positive, <tt>-1</tt> if <tt>N</tt>  is negative or <tt>0</tt> if <tt>N</tt> is zero. <tt>signum</tt> is exactness preserving.</p><a name='finite?'><h3>finite?</h3></a><pre>[procedure] (finite? N)</pre><p>Returns <tt>#f</tt> if <tt>N</tt> is negative or positive infinity, and <tt>#f</tt> otherwise.</p><a name='File Input/Output'><h2>File Input/Output</h2></a><a name='current-output-port'><h3>current-output-port</h3></a><pre>[procedure] (current-output-port [PORT])</pre><p>Returns default output port.  If <tt>PORT</tt> is given, then that port is selected as the new current output port.</p><p>Note that the default output port is not buffered. Use <a href='http://galinha.ucpel.tche.br/Unit posix#Setting the file buffering mode' class='external'><tt>set-buffering-mode!</tt></a> if you need a different behaviour.</p><a name='current-error-port'><h3>current-error-port</h3></a><pre>[procedure] (current-error-port [PORT])</pre><p>Returns default error output port. If <tt>PORT</tt> is given, then that port is selected as the new current error output port.</p><p>Note that the default error output port is not buffered. Use <a href='http://galinha.ucpel.tche.br/Unit posix#Setting the file buffering mode' class='external'><tt>set-buffering-mode!</tt></a> if you need a different behaviour.</p><a name='flush-output'><h3>flush-output</h3></a><pre>[procedure] (flush-output [PORT])</pre><p>Write buffered output to the given output-port. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p><a name='port-name'><h3>port-name</h3></a><pre>[procedure] (port-name PORT)</pre><p>Fetch filename from <tt>PORT</tt>. This returns the filename that was used to open this file.  Returns a special tag string, enclosed into parentheses for non-file ports.</p><a name='port-position'><h3>port-position</h3></a><pre>[procedure] (port-position PORT)</pre><p>Returns the current position of <tt>PORT</tt> as two values: row and column number.  If the port does not support such an operation an error is signaled. This procedure is currently only available for input ports.</p><a name='set-port-name!'><h3>set-port-name!</h3></a><pre>[procedure] (set-port-name! PORT STRING)</pre><p>Sets the name of <tt>PORT</tt> to <tt>STRING</tt>.</p><a name='Files'><h2>Files</h2></a><a name='delete-file'><h3>delete-file</h3></a><pre>[procedure] (delete-file STRING)</pre><p>Deletes the file with the pathname <tt>STRING</tt>. If the file does not exist, an error is signaled.</p><a name='file-exists?'><h3>file-exists?</h3></a><pre>[procedure] (file-exists? STRING)</pre><p>Returns <tt>STRING</tt> if a file with the given pathname exists, or <tt>#f</tt> otherwise.</p><a name='rename-file'><h3>rename-file</h3></a><pre>[procedure] (rename-file OLD NEW)</pre><p>Renames the file or directory with the pathname <tt>OLD</tt> to <tt>NEW</tt>. If the operation does not succeed, an error is signaled.</p><a name='String ports'><h2>String ports</h2></a><a name='get-output-string'><h3>get-output-string</h3></a><pre>[procedure] (get-output-string PORT)</pre><p>Returns accumulated output of a port created with <tt>(open-output-string)</tt>.</p><a name='open-input-string'><h3>open-input-string</h3></a><pre>[procedure] (open-input-string STRING)</pre><p>Returns a port for reading from <tt>STRING</tt>.</p><a name='open-output-string'><h3>open-output-string</h3></a><pre>[procedure] (open-output-string)</pre><p>Returns a port for accumulating output in a string.</p><a name='Feature identifiers'><h2>Feature identifiers</h2></a><p>CHICKEN maintains a global list of <em>features</em> naming functionality available int the current system. Additionally the <tt>cond-expand</tt> form accesses this feature list to infer what features are provided. Predefined features are <tt>chicken</tt>, and the SRFIs (Scheme Request For Implementation) provided by the base system: <tt>srfi-23, srfi-30, srfi-39</tt>. If the <tt>eval</tt> unit is used (the default), the features <tt>srfi-0, srfi-2, srfi-6, srfi-8, srfi-9</tt> and <tt>srfi-10</tt> are defined. When compiling code (during compile-time) the feature <tt>compiling</tt> is registered. When evaluating code in the interpreter (csi), the feature <tt>csi</tt> is registered.</p><a name='features'><h3>features</h3></a><pre>[procedure] (features)</pre><p>Returns a list of all registered features that will be accepted as valid feature-identifiers by <tt>cond-expand</tt>.</p><a name='feature?'><h3>feature?</h3></a><pre>[procedure] (feature? ID ...)</pre><p>Returns <tt>#t</tt> if all features with the given feature-identifiers <tt>ID ...</tt> are registered.</p><a name='register-feature!'><h3>register-feature!</h3></a><pre>[procedure] (register-feature! FEATURE ...)</pre><p>Register one or more features that will be accepted as valid feature-identifiers by <tt>cond-expand</tt>. <tt>FEATURE ...</tt> may be a keyword, string or symbol.</p><a name='unregister-feature!'><h3>unregister-feature!</h3></a><pre>[procedure] (unregister-feature! FEATURE ...)</pre><p>Unregisters the specified feature-identifiers. <tt>FEATURE ...</tt> may be a keyword, string or symbol.</p><a name='Keywords'><h2>Keywords</h2></a><p>Keywords are special symbols prefixed with <tt>#:</tt> that evaluate to themselves.  Procedures can use keywords to accept optional named parameters in addition to normal required parameters.  Assignment to and bindings of keyword symbols is not allowed. The parameter <tt>keyword-style</tt> and the compiler/interpreter option <tt>-keyword-style</tt> can be used to allow an additional keyword syntax, either compatible to Common LISP, or to DSSSL.</p><a name='get-keyword'><h3>get-keyword</h3></a><pre>[procedure] (get-keyword KEYWORD ARGLIST [THUNK])</pre><p>Returns the argument from <tt>ARGLIST</tt> specified under the keyword <tt>KEYWORD</tt>.  If the keyword is not found, then the zero-argument procedure <tt>THUNK</tt> is invoked and the result value is returned. If <tt>THUNK</tt> is not given, <tt>#f</tt> is returned.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">increase</FONT></B> x . args)
  (+ x (get-keyword #:amount args (<B><FONT COLOR="#A020F0">lambda</FONT></B> () 1))) )
(increase 123)                                      =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 124
(increase 123 #:amount 10)                          =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 133
</PRE>
<p>Note: the <tt>KEYWORD</tt> may actually be any kind of object.</p><a name='keyword?'><h3>keyword?</h3></a><pre>[procedure] (keyword? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a keyword symbol, or <tt>#f</tt> otherwise.</p><a name='keyword->string'><h3>keyword->string</h3></a><pre>[procedure] (keyword-&gt;string KEYWORD)</pre><p>Transforms <tt>KEYWORD</tt> into a string.</p><a name='string->keyword'><h3>string->keyword</h3></a><pre>[procedure] (string-&gt;keyword STRING)</pre><p>Returns a keyword with the name <tt>STRING</tt>.</p><a name='Exceptions'><h2>Exceptions</h2></a><p>CHICKEN implements the (currently withdrawn) <a href='http://srfi.schemers.org/srfi-12/srfi-12.html' class='external'>SRFI-12</a> exception system. For more information, see the <a href='http://srfi.schemers.org/srfi-12/srfi-12.html' class='external'>SRFI-12</a> document.</p><a name='condition-case'><h3>condition-case</h3></a><pre>[syntax] (condition-case EXPRESSION CLAUSE ...)</pre><p>Evaluates <tt>EXPRESSION</tt> and handles any exceptions that are covered by <tt>CLAUSE ...</tt>, where <tt>CLAUSE</tt> should be of the following form:</p><PRE>
CLAUSE = ([VARIABLE] (KIND ...) BODY ...)
</PRE>
<p>If provided, <tt>VARIABLE</tt> will be bound to the signalled exception object. <tt>BODY ...</tt> is executed when the exception is a property- or composite condition with the kinds given <tt>KIND ...</tt> (unevaluated). If no clause applies, the exception is re-signalled in the same dynamic context as the <tt>condition-case</tt> form.</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">check</FONT></B> thunk)
  (condition-case (thunk)
    [(exn file) (print <B><FONT COLOR="#BC8F8F">&quot;file error&quot;</FONT></B>)]
    [(exn) (print <B><FONT COLOR="#BC8F8F">&quot;other error&quot;</FONT></B>)]
    [var () (print <B><FONT COLOR="#BC8F8F">&quot;something else&quot;</FONT></B>)] ) )

(check (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (open-input-file <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)))   <I><FONT COLOR="#B22222">; -&gt; &quot;file error&quot;
</FONT></I>(check (<B><FONT COLOR="#A020F0">lambda</FONT></B> () some-unbound-variable))  <I><FONT COLOR="#B22222">; -&gt; &quot;othererror&quot;
</FONT></I>(check (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (signal 99)))            <I><FONT COLOR="#B22222">; -&gt; &quot;something else&quot;
</FONT></I>
(condition-case some-unbound-variable
  [(exn file) (print <B><FONT COLOR="#BC8F8F">&quot;ignored)] )      ; -&gt; signals error

</FONT></B></PRE>
<a name='breakpoint'><h3>breakpoint</h3></a><pre>[procedure] (breakpoint [NAME])</pre><p>Programmatically triggers a breakpoint (similar to the <tt>,br</tt> top-level csi command).</p><p>All error-conditions signalled by the system are of kind <tt>exn</tt>. The following composite conditions are additionally defined:</p><table><tr><td><pre>(exn arity)</pre><p>Signalled when a procedure is called with the wrong number of arguments.</p></td></tr><tr><td><pre>(exn type)</pre><p>Signalled on type-mismatch errors, for example when an argument of the wrong type is passed to a builtin procedure.</p></td></tr><tr><td><pre>(exn arithmetic)</pre><p>Signalled on arithmetic errors, like division by zero.</p></td></tr><tr><td><pre>(exn i/o)</pre><p>Signalled on input/output errors.</p></td></tr><tr><td><pre>(exn i/o file)</pre><p>Signalled on file-related errors.</p></td></tr><tr><td><pre>(exn i/o net)</pre><p>Signalled on network errors.</p></td></tr><tr><td><pre>(exn bounds)</pre><p>Signalled on errors caused by accessing non-existent elements of a collection.</p></td></tr><tr><td><pre>(exn runtime)</pre><p>Signalled on low-level runtime-system error-situations.</p></td></tr><tr><td><pre>(exn runtime limit)</pre><p>Signalled when an internal limit is exceeded (like running out of memory).</p></td></tr><tr><td><pre>(exn match)</pre><p>Signalled on errors raised by failed matches (see the section on <tt>match</tt>).</p></td></tr><tr><td><pre>(exn syntax)</pre><p>Signalled on syntax errors.</p></td></tr><tr><td><pre>(exn breakpoint)</pre><p>Signalled when a breakpoint is reached.</p></td></tr></table><p>Notes:</p><ul><li>All error-exceptions (of the kind <tt>exn</tt>) are non-continuable.</li><li>Error-exceptions of the <tt>exn</tt> kind have additional <tt>arguments</tt> and <tt>location</tt> properties that contain the arguments passed to the exception-handler and the name of the procedure where the error occurred (if available).</li><li>When the <tt>posix</tt> unit is available and used, then a user-interrupt (<tt>signal/int</tt>) signals an exception of the kind <tt>user-interrupt</tt>. </li><li>the procedure <tt>condition-property-accessor</tt> accepts an optional third argument. If the condition does not have a value for the desired property and if the optional argument is given, no error is signalled and the accessor returns the third argument.</li><li>In composite conditionss all properties are currently collected in a single property-list, so in the case that to conditions have the same named property, only one will be visible.</li></ul><a name='Environment information and system interface'><h2>Environment information and system interface</h2></a><a name='argv'><h3>argv</h3></a><pre>[procedure] (argv)</pre><p>Return a list of all supplied command-line arguments. The first item in the list is a string containing the name of the executing program. The other items are the arguments passed to the application. This list is freshly created on every invocation of <tt>(argv)</tt>.  It depends on the host-shell whether arguments are expanded ('globbed') or not.</p><a name='exit'><h3>exit</h3></a><pre>[procedure] (exit [CODE])</pre><p>Exit the running process and return exit-code, which defaults to 0 (Invokes <tt>exit-handler</tt>).</p><a name='build-platform'><h3>build-platform</h3></a><pre>[procedure] (build-platform)</pre><p>Returns a symbol specifying the toolset which has been used for building the executing system, which is one of the following:</p><pre>cygwin
msvc
mingw32
gnu
metrowerks
intel
watcom
unknown</pre><a name='chicken-version'><h3>chicken-version</h3></a><pre>[procedure] (chicken-version [FULL])</pre><p>Returns a string containing the version number of the CHICKEN runtime system. If the optional argument <tt>FULL</tt> is given and true, then a full version string is returned.</p><a name='errno'><h3>errno</h3></a><pre>[procedure] (errno)</pre><p>Returns the error code of the last system call.</p><a name='getenv'><h3>getenv</h3></a><pre>[procedure] (getenv STRING)</pre><p>Returns the value of the environment variable <tt>STRING</tt> or <tt>#f</tt> if that variable is not defined.</p><a name='machine-byte-order'><h3>machine-byte-order</h3></a><pre>[procedure] (machine-byte-order)</pre><p>Returns the symbol <tt>little-endian</tt> or <tt>big-endian</tt>, depending on the machine's byte-order.</p><a name='machine-type'><h3>machine-type</h3></a><pre>[procedure] (machine-type)</pre><p>Returns a symbol specifying the processor on which this process is currently running, which is one of the following:</p><pre>alpha
mips
hppa
ultrasparc
sparc
ppc
ia64
x86
x86-64
unknown</pre><a name='on-exit'><h3>on-exit</h3></a><pre>[procedure] (on-exit THUNK)</pre><p>Schedules the zero-argument procexdures <tt>THUNK</tt> to be executed before the process exits, either explicitly via <tt>exit</tt> or implicitly after exection of the last toplevel form. Note that finalizers for unreferenced finalized data are run before exit procedures.</p><a name='software-type'><h3>software-type</h3></a><pre>[procedure] (software-type)</pre><p>Returns a symbol specifying the operating system on which this process is currently running, which is one of the following:</p><pre>windows
unix
macos
ecos
unknown</pre><a name='software-version'><h3>software-version</h3></a><pre>[procedure] (software-version)</pre><p>Returns a symbol specifying the operating system version on which this process is currently running, which is one of the following:</p><pre>linux
freebsd
netbsd
openbsd
macosx
hpux
solaris
sunos
unknown</pre><a name='c-runtime'><h3>c-runtime</h3></a><pre>[procedure] (c-runtime)</pre><p>Returns a symbol that designates what kind of C runtime library has been linked with this version of the Chicken libraries. Possible return values are <tt>static</tt>, <tt>dynamic</tt> or <tt>unknown</tt>. On systems not compiled with the Microsoft C compiler, <tt>c-runtime</tt> always returns <tt>unknown</tt>.</p><a name='system'><h3>system</h3></a><pre>[procedure] (system STRING)</pre><p>Execute shell command. The functionality offered by this procedure depends on the capabilities of the host shell.</p><a name='Execution time'><h2>Execution time</h2></a><a name='cpu-time'><h3>cpu-time</h3></a><pre>[procedure] (cpu-time)</pre><p>Returns the used CPU time of the current process in milliseconds as two values: the time spent in user code, and the time spent in system code. On platforms where user and system time can not be differentiated, system time will be always be 0.</p><a name='current-milliseconds'><h3>current-milliseconds</h3></a><pre>[procedure] (current-milliseconds)</pre><p>Returns the number of milliseconds since process- or machine startup.</p><a name='current-seconds'><h3>current-seconds</h3></a><pre>[procedure] (current-seconds)</pre><p>Returns the number of seconds since midnight, Jan. 1, 1970.</p><a name='current-gc-milliseconds'><h3>current-gc-milliseconds</h3></a><pre>[procedure] (current-gc-milliseconds)</pre><p>Returns the number of milliseconds spent in major garbage collections since the last call of <tt>current-gc-milliseconds</tt> and returns an exact integer.</p><a name='Interrupts and error-handling'><h2>Interrupts and error-handling</h2></a><a name='enable-warnings'><h3>enable-warnings</h3></a><pre>[procedure] (enable-warnings [BOOL])</pre><p>Enables or disables warnings, depending on wether <tt>BOOL</tt> is true or false. If called with no arguments, this procedure returns <tt>#t</tt> if warnings are currently enabled, or <tt>#f</tt> otherwise. Note that this is not a parameter. The current state (wether warnings are enabled or disabled) is global and not thread-local.</p><a name='error'><h3>error</h3></a><pre>[procedure] (error [LOCATION] [STRING] EXP ...)</pre><p>Prints error message, writes all extra arguments to the value of <tt>(current-error-port)</tt> and invokes the current exception-handler.  This conforms to <a href='http://srfi.schemers.org/srfi-23/srfi-23.html' class='external'>SRFI-23</a>. If <tt>LOCATION</tt> is given and a symbol, it specifies the <em>location</em> (the name of the procedure) where the error occurred.</p><a name='get-call-chain'><h3>get-call-chain</h3></a><pre>[procedure] (get-call-chain [START [THREAD]])</pre><p>Returns a list with the call history. Backtrace information is only generated in code compiled without <tt>-no-trace</tt> and evaluated code. If the optional argument <tt>START</tt> is given, the backtrace starts at this offset, i.e. when <tt>START</tt> is 1, the next to last trace-entry  is printed, and so on. If the optional argument <tt>THREAD</tt> is given, then the call-chain will only be constructed for calls performed by this thread.</p><a name='print-call-chain'><h3>print-call-chain</h3></a><pre>[procedure] (print-call-chain [PORT [START [THREAD]]])</pre><p>Prints a backtrace of the procedure call history to <tt>PORT</tt>, which defaults to <tt>(current-output-port)</tt>.</p><a name='print-error-message'><h3>print-error-message</h3></a><pre>[procedure] (print-error-message EXN [PORT [STRING]])</pre><p>Prints an appropriate error message to <tt>PORT</tt> (which defaults to the value of <tt>(current-output-port)</tt> for the object <tt>EXN</tt>. <tt>EXN</tt> may be a condition, a string or any other object. If the optional argument <tt>STRING</tt> is given, it is printed before the error-message. <tt>STRING</tt> defaults to <tt>"Error:"</tt>.</p><a name='procedure-information'><h3>procedure-information</h3></a><pre>[procedure] (procedure-information PROC)</pre><p>Returns an s-expression with debug information for the procedure <tt>PROC</tt>, or <tt>#f</tt>, if <tt>PROC</tt> has no associated debug information.</p><a name='reset'><h3>reset</h3></a><pre>[procedure] (reset)</pre><p>Reset program (Invokes <tt>reset-handler</tt>).</p><a name='warning'><h3>warning</h3></a><pre>[procedure] (warning STRING EXP ...)</pre><p>Displays a warning message (if warnings are enabled with <tt>enable-warnings</tt>) and continues execution.</p><a name='singlestep'><h3>singlestep</h3></a><pre>[procedure] (singlestep THUNK)</pre><p>Executes the code in the zero-procedure <tt>THUNK</tt> in single-stepping mode.</p><a name='Garbage collection'><h2>Garbage collection</h2></a><a name='gc'><h3>gc</h3></a><pre>[procedure] (gc [FLAG])</pre><p>Invokes a garbage-collection and returns the number of free bytes in the heap. The flag specifies whether a minor (<tt>#f</tt>) or major (<tt>#t</tt>) GC is to be triggered. If no argument is given, <tt>#t</tt> is assumed. When the argument is <tt>#t</tt>, all pending finalizers are executed. </p><a name='memory-statistics'><h3>memory-statistics</h3></a><pre>[procedure] (memory-statistics)</pre><p>Performs a major garbage collection and returns a three element vector  containing the total heap size in bytes, the number of bytes currently used and the size of the nursery (the first heap generation). Note that the actual heap is actually twice the size given in the heap size, because CHICKEN uses a copying semi-space collector.</p><a name='set-finalizer!'><h3>set-finalizer!</h3></a><pre>[procedure] (set-finalizer! X PROC)</pre><p>Registers a procedure of one argument <tt>PROC</tt>, that will be called as soon as the non-immediate data object <tt>X</tt> is about to be garbage-collected (with that object as its argument).  Note that the finalizer will <strong>not</strong> be called when interrupts are disabled. This procedure returns <tt>X</tt>.</p><a name='set-gc-report!'><h3>set-gc-report!</h3></a><pre>[procedure] (set-gc-report! FLAG)</pre><p>Print statistics after every GC, depending on <tt>FLAG</tt>. A value of <tt>#t</tt> shows statistics after every major GC. A true value different from <tt>#t</tt> shows statistics after every minor GC. <tt>#f</tt> switches statistics off.</p><a name='Other control structures'><h2>Other control structures</h2></a><a name='andmap'><h3>andmap</h3></a><pre>[procedure] (andmap PROC LIST1 ...)</pre><p>Repeatedly calls <tt>PROC</tt> with arguments taken from <tt>LIST1 ...</tt>.   If any invocation should return <tt>#f</tt>, the result of <tt>andmap</tt> is <tt>#f</tt>. If all invocations return a true result, then the result of <tt>andmap</tt> is <tt>#t</tt>.</p><a name='ormap'><h3>ormap</h3></a><pre>[procedure] (ormap PROC LIST1 ...)</pre><p>Repeatedly calls <tt>PROC</tt> with arguments taken from <tt>LIST1 ...</tt>.   If any invocation should return a value different from <tt>#f</tt>, then this value is returned as the  result of <tt>ormap</tt>. If all invocations return <strong>#f</strong>, then the result of <tt>ormap</tt> is <tt>#f</tt>.</p><a name='promise?'><h3>promise?</h3></a><pre>[procedure] (promise? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a promise returned by <tt>delay</tt>, or <tt>#f</tt> otherwise.</p><a name='String utilities'><h2>String utilities</h2></a><a name='reverse-list->string'><h3>reverse-list->string</h3></a><pre>[procedure] (reverse-list-&gt;string LIST)</pre><p>Returns a string with the characters in <tt>LIST</tt> in reverse order. This is equivalent to <tt>(list-&gt;string (reverse LIST))</tt>, but much more efficient.</p><a name='Generating uninterned symbols'><h2>Generating uninterned symbols</h2></a><a name='gensym'><h3>gensym</h3></a><pre>[procedure] (gensym [STRING-OR-SYMBOL])</pre><p>Returns a newly created uninterned symbol. If an argument is provided, the new symbol is prefixed with that argument.</p><a name='string->uninterned-symbol'><h3>string->uninterned-symbol</h3></a><pre>[procedure] (string-&gt;uninterned-symbol STRING)</pre><p>Returns a newly created, unique symbol with the name <tt>STRING</tt>.</p><a name='Standard Input/Output'><h2>Standard Input/Output</h2></a><a name='port?'><h3>port?</h3></a><pre>[procedure] (port? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a port object or <tt>#f</tt> otherwise.</p><a name='print'><h3>print</h3></a><pre>[procedure] (print EXP1 EXP2 ...)</pre><p>Outputs the arguments <tt>EXP1 EXP2 ...</tt> using <tt>display</tt> and writes a newline character to the port that is the value of <tt>(current-output-port)</tt>. Returns its first argument.</p><a name='print*'><h3>print*</h3></a><pre>[procedure] (print* EXP1 ...)</pre><p>Similar to <tt>print</tt>, but does not output a terminating newline character and performs a <tt>flush-outout</tt> after writing its arguments.</p><a name='User-defined named characters'><h2>User-defined named characters</h2></a><a name='char-name'><h3>char-name</h3></a><pre>[procedure] (char-name SYMBOL-OR-CHAR [CHAR])</pre><p>This procedure can be used to inquire about character names or to define new ones. With a single argument the behavior is as follows: If <tt>SYMBOL-OR-CHAR</tt> is a symbol, then <tt>char-name</tt> returns the character with this name, or <tt>#f</tt> if no character is defined under this name.  If <tt>SYMBOL-OR-CHAR</tt> is a character, then the name of the character is returned as a symbol, or <tt>#f</tt> if the character has no associated name.</p><p>If the optional argument <tt>CHAR</tt> is provided, then <tt>SYMBOL-OR-CHAR</tt> should be a symbol that will be the new name of the given character.  If multiple names designate the same character, then the <tt>write</tt> will use the character name that was defined last.</p><PRE>
(char-name 'space)                  =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #\space
(char-name #\space)                 =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> space
(char-name 'bell)                   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #f
(char-name (integer-&gt;char 7))       =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #f
(char-name 'bell (integer-&gt;char 7))
(char-name 'bell)                   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> #\bell
(char-&gt;integer (char-name 'bell))   =<B><FONT COLOR="#A020F0">=&gt;</FONT></B> 7
</PRE>
<a name='Vectors'><h2>Vectors</h2></a><a name='vector-copy!'><h3>vector-copy!</h3></a><pre>[procedure] (vector-copy! VECTOR1 VECTOR2 [COUNT])</pre><p>Copies contents of <tt>VECTOR1</tt> into <tt>VECTOR2</tt>. If the argument <tt>COUNT</tt> is given, it specifies the maximal number of elements to be copied. If not given, the minimum of the lengths of the argument vectors is copied.</p><p>Exceptions: <tt>(exn bounds)</tt></p><a name='vector-resize'><h3>vector-resize</h3></a><pre>[procedure] (vector-resize VECTOR N [INIT])</pre><p>Creates and returns a new vector with the contents of <tt>VECTOR</tt> and length <tt>N</tt>. If <tt>N</tt> is greater than the original length of <tt>VECTOR</tt>, then all additional items are initialized to <tt>INIT</tt>. If <tt>INIT</tt> is not specified, the contents are initialized to some unspecified value.</p><a name='The unspecified value'><h2>The unspecified value</h2></a><a name='void'><h3>void</h3></a><pre>[procedure] (void)</pre><p>Returns an unspecified value.</p><a name='Continuations'><h2>Continuations</h2></a><a name='call/cc'><h3>call/cc</h3></a><pre>[procedure] (call/cc PROCEDURE)</pre><p>An alias for <tt>call-with-current-continuation</tt>.</p><a name='continuation-capture'><h3>continuation-capture</h3></a><pre>[procedure] (continuation-capture PROCEDURE)</pre><p>Creates a continuation object representing the current continuation and tail-calls  <tt>PROCEDURE</tt> with this continuation as the single argument.</p><p>More information about this continuation API can be found in the paper <a href='http://repository.readscheme.org/ftp/papers/sw2001/feeley.pdf' class='external'>http://repository.readscheme.org/ftp/papers/sw2001/feeley.pdf</a> <em>A Better API for first class Continuations</em> by Marc Feeley.</p><a name='continuation?'><h3>continuation?</h3></a><pre>[procedure] (continuation? X)</pre><p>Returns <tt>#t</tt> if <tt>X</tt> is a continuation object, or <tt>#f</tt> otherwise.</p><a name='continuation-graft'><h3>continuation-graft</h3></a><pre>[procedure] (continuation-graft CONT THUNK)</pre><p>Calls the procedure <tt>THUNK</tt> with no arguments and the implicit continuation <tt>CONT</tt>.</p><a name='continuation-return'><h3>continuation-return</h3></a><pre>[procedure] (continuation-return CONT VALUE ...)</pre><p>Returns the value(s) to the continuation <tt>CONT</tt>. <tt>continuation-return</tt> could be implemented like this:</p><PRE>
(<B><FONT COLOR="#A020F0">define</FONT></B> (<B><FONT COLOR="#0000FF">continuation-return</FONT></B> k . vals)
  (continuation-graft
    k
    (<B><FONT COLOR="#A020F0">lambda</FONT></B> () (apply values vals)) ) )
</PRE>
<a name='Setters'><h2>Setters</h2></a><p>SRFI-17 is fully implemented. For more information see: <a href='http://srfi.schemers.org/srfi-17/srfi-17.html' class='external'>SRFI-17</a>.</p><a name='setter'><h3>setter</h3></a><pre>[procedure] (setter PROCEDURE)</pre><p>Returns the setter-procedure of <tt>PROCEDURE</tt>, or signals an error if <tt>PROCEDURE</tt> has no associated setter-procedure.</p><p>Note that <tt>(set! (setter PROC) ...)</tt> for a procedure that has no associated setter procedure yet is a very slow operation (the old procedure is replaced by a modified copy, which involves a garbage collection).</p><a name='getter-with-setter'><h3>getter-with-setter</h3></a><pre>[procedure] (getter-with-setter GETTER SETTER)</pre><p>Returns a copy of the procedure <tt>GETTER</tt> with the associated setter procedure <tt>SETTER</tt>. Contrary to the SRFI specification, the setter of the returned procedure may be changed.</p><a name='Reader extensions'><h2>Reader extensions</h2></a><a name='define-reader-ctor'><h3>define-reader-ctor</h3></a><pre>[procedure] (define-reader-ctor SYMBOL PROC)</pre><p>Define new read-time constructor for <tt>#,</tt> read syntax. For further information, see the documentation for <a href='http://srfi.schemers.org/srfi-10/srfi-10.html' class='external'>SRFI-10</a>.</p><a name='set-read-syntax!'><h3>set-read-syntax!</h3></a><pre>[procedure] (set-read-syntax! CHAR-OR-SYMBOL PROC)</pre><p>When the reader is encounting the non-whitespace character <tt>CHAR</tt> while reading an expression from a given port, then the procedure <tt>PROC</tt> will be called with that port as its argument. The procedure should return a value that will be returned to the reader:</p><pre>; A simple RGB color syntax:</pre><pre>(set-read-syntax! #\%
  (lambda (port)
    (apply vector
      (map (cut string-&gt;number &lt;&gt; 16)</pre><p>	    (string-chop (read-string 6 port) 2) ) ) ) )</p><pre>(with-input-from-string "(1 2 %f0f0f0 3)" read)
; ==&gt; (1 2 #(240 240 240) 3)</pre><p>If <tt>CHAR-OR-SYMBOL</tt> is a symbol, then a so-called <em>read-mark</em> handler is defined. In that case the handler procedure will be called when a character-sequence of the form</p><pre>#!SYMBOL</pre><p>is encountered.</p><p>You can undo special handling of read-syntax by passing <tt>#f</tt> as the second argument (if the syntax was previously defined via <tt>set-read-syntax!</tt>).</p><p>Note that all of CHICKEN's special non-standard read-syntax is handled directly by the reader to disable built-in read-syntax, define a handler that triggers an error (for example).</p><a name='set-sharp-read-syntax!'><h3>set-sharp-read-syntax!</h3></a><pre>[procedure] (set-sharp-read-syntax! CHAR-OR-SYMBOL PROC)</pre><p>Similar to <tt>set-read-syntax!</tt>, but allows defining new <tt>#&lt;CHAR&gt; ...</tt> reader syntax. If the first argument is a symbol, then this procedure is equivalent to <tt>set-read-syntax!</tt>.</p><a name='set-parameterized-read-syntax!'><h3>set-parameterized-read-syntax!</h3></a><pre>[procedure] (set-parameterized-read-syntax! CHAR-OR-SYMBOL PROC)</pre><p>Similar to <tt>set-sharp-read-syntax!</tt>, but intended for defining reader syntax of the form <tt>#&lt;NUMBER&gt;&lt;CHAR&gt; ...</tt>. The handler procedure <tt>PROC</tt> will be called with two arguments: the input port and the number preceding the dispatching character. If the first argument is a symbol, then this procedure is equivalent to <tt>set-read-syntax!</tt>.</p><a name='copy-read-table'><h3>copy-read-table</h3></a><pre>[procedure] (copy-read-table READ-TABLE)</pre><p>Returns a copy of the given read-table. You can access the currently active read-table with <tt>(current-read-table)</tt>.</p><p>Previous: <a href='parameters.html' class='internal'>Parameters</a></p><p>Next: <a href='unit-eval.html' class='internal'>Unit eval</a></p>
</body></html>