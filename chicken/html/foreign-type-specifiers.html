<html><head><title>CHICKEN User's Manual - Foreign type specifiers</title></head><body>
<p></p><a name='Foreign type specifiers'><h1>Foreign type specifiers</h1></a><p>Here is a list of valid foreign type specifiers:</p><a name='scheme-object'><h2>scheme-object</h2></a><p>An arbitrary Scheme data object (immediate or non-immediate). </p><a name='bool'><h2>bool</h2></a><p>As argument: any value (<tt>#f</tt> is false, anything else is true). As result: anything different from 0 and the <tt>NULL</tt>-pointer is <tt>#t</tt>.</p><a name='byte unsigned-byte'><h2>byte unsigned-byte</h2></a><p>A byte.</p><a name='char unsigned-char'><h2>char unsigned-char</h2></a><p>A character.</p><a name='short unsigned-short'><h2>short unsigned-short</h2></a><p>A short integer number.</p><a name='int unsigned-int int32 unsigned-int32'><h2>int unsigned-int int32 unsigned-int32</h2></a><p>An small integer number in fixnum range (at least 30 bit).</p><a name='integer unsigned-integer integer32 unsigned-integer32 integer64'><h2>integer unsigned-integer integer32 unsigned-integer32 integer64</h2></a><p>Either a fixnum or a flonum in the range of a (unsigned) machine <em>int</em> or with 32/64 bit width.</p><a name='long unsigned-long'><h2>long unsigned-long</h2></a><p>Either a fixnum or a flonum in the range of a (unsigned) machine <em>long</em> or with 32 bit width.</p><a name='float double'><h2>float double</h2></a><p>A floating-point number. If an exact integer is passed as an argument, then it is automatically converted to a float.</p><a name='number'><h2>number</h2></a><p>A floating-point number. Similar to <tt>double</tt>, but when used as a result type, then either an exact integer or a floating-point number is returned, depending on whether the result fits into an exact integer or not.</p><a name='symbol'><h2>symbol</h2></a><p>A symbol, which will be passed to foreign code as a zero-terminated string. When declared as the result of foreign code, the result should be a string and a symbol with the same name will be interned in the symbol table (and returned to the caller).</p><a name='scheme-pointer'><h2>scheme-pointer</h2></a><p>An untyped pointer to the contents of a non-immediate Scheme object (not allowed as return type).  The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.  Don't confuse this type with <tt>(pointer ...)</tt> which means something different (a machine-pointer object).</p><a name='nonnull-scheme-pointer'><h2>nonnull-scheme-pointer</h2></a><p>As <tt>pointer</tt>, but guaranteed not to be <tt>#f</tt>. Don't confuse this type with <tt>(nonnull-pointer ...)</tt> which means something different (a machine-pointer object).</p><a name='c-pointer'><h2>c-pointer</h2></a><p>An untyped operating-system pointer or a locative.  The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.  If uses as the type of a return value, a <tt>NULL</tt> pointer will be returned as <tt>#f</tt>.</p><a name='nonnull-c-pointer'><h2>nonnull-c-pointer</h2></a><p>As <tt>c-pointer</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name='scheme-or-c-pointer'><h2>scheme-or-c-pointer</h2></a><p>An untyped pointer. If the argument is a machine-pointer object, the wrapped C pointer will be passed. If it is any other object, then this type is treated as <tt>scheme-pointer</tt>.</p><p>Not allowed as a result type.</p><a name='[nonnull-] byte-vector'><h2>[nonnull-] byte-vector</h2></a><p>A byte-vector object, passed as a pointer to its contents. Arguments of type <tt>byte-vector</tt> may optionally be <tt>#f</tt>, which is passed as a NULL pointer.  This is not allowed as a return type.</p><a name='[nonnull-] u8vector [nonnull-] u16vector [nonnull-] u32vector [nonnull-] s8vector [nonnull-] s16vector [nonnull-] s32vector [nonnull-] f32vector [nonnull-] f64vector'><h2>[nonnull-] u8vector [nonnull-] u16vector [nonnull-] u32vector [nonnull-] s8vector [nonnull-] s16vector [nonnull-] s32vector [nonnull-] f32vector [nonnull-] f64vector</h2></a><p>A SRFI-4 number-vector object, passed as a pointer to its contents. Arguments of type <tt>byte-vector</tt> may optionally be <tt>#f</tt>, which is passed as a NULL pointer.  These are not allowed as return types.</p><a name='c-string'><h2>c-string</h2></a><p>A C string (zero-terminated). The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer. If uses as the type of a return value, a <tt>NULL</tt> pointer will be returned as <tt>#f</tt>. Note that the string is copied (with a zero-byte appended) when passed as an argument to a foreign function. Also a return value of this type is copied into garbage collected memory.</p><a name='nonnull-c-string'><h2>nonnull-c-string</h2></a><p>As <tt>c-string</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name='[nonnull-] c-string*'><h2>[nonnull-] c-string*</h2></a><p>Similar to <tt>[nonnull-]c-string</tt>, but if used as a result-type, the pointer returned by the foreign code will be freed (using the C-libraries <tt>free()</tt>) after copying. This type specifier is not valid as a result type for callbacks defined with <tt>define-external</tt>.</p><a name='void'><h2>void</h2></a><p>Specifies an undefined return value. Not allowed as argument type.</p><a name='(const TYPE)'><h2>(const TYPE)</h2></a><p>The foreign type <tt>TYPE</tt> with an additional <tt>const</tt> specifier.</p><a name='(enum NAME)'><h2>(enum NAME)</h2></a><p>An enumeration type. Handled internally as an <tt>integer</tt>.</p><a name='(pointer TYPE) (c-pointer TYPE)'><h2>(pointer TYPE) (c-pointer TYPE)</h2></a><p>An operating-system pointer or a locative to an object of <tt>TYPE</tt>.</p><a name='(nonnull-pointer TYPE) (nonnull-c-pointer TYPE)'><h2>(nonnull-pointer TYPE) (nonnull-c-pointer TYPE)</h2></a><p>As <tt>(pointer TYPE)</tt>, but guaranteed not to be <tt>#f/NULL</tt>.</p><a name='(ref TYPE)'><h2>(ref TYPE)</h2></a><p>A C++ reference type. Reference types are handled the same way as pointers inside Scheme code.</p><a name='(struct NAME)'><h2>(struct NAME)</h2></a><p>A struct of the name <tt>NAME</tt>, which should be a string. Structs can not be directly passed as arguments to foreign function, neither can they be result values. Pointers to structs are allowed, though.</p><a name='(template TYPE ARGTYPE ...)'><h2>(template TYPE ARGTYPE ...)</h2></a><p>A C++ template type. For example <tt>vector&lt;int&gt;</tt> would be specified as <tt>(template "vector" int)</tt>. Template types can not be directly passed as arguments or returned as results.</p><a name='(union NAME)'><h2>(union NAME)</h2></a><p>A union of the name <tt>NAME</tt>, which should be a string. Unions can not be directly passed as arguments to foreign function, neither can they be result values. Pointers to unions are allowed, though.</p><a name='(instance CNAME SCHEMECLASS)'><h2>(instance CNAME SCHEMECLASS)</h2></a><p>A pointer to a C++ class instance. <tt>CNAME</tt> should designate the name of the C++ class, and <tt>SCHEMECLASS</tt> should be the class that wraps the instance pointer. Normally <tt>SCHEMECLASS</tt> should be a subclass of <tt>&lt;c++-object&gt;</tt>.</p><a name='(instance-ref CNAME SCHEMECLASS)'><h2>(instance-ref CNAME SCHEMECLASS)</h2></a><p>A reference to a C++ class instance. </p><a name='(function RESULTTYPE (ARGUMENTTYPE1 ... [...]) [CALLCONV])'><h2>(function RESULTTYPE (ARGUMENTTYPE1 ... [...]) [CALLCONV])</h2></a><p>A function pointer. <tt>CALLCONV</tt> specifies an optional calling convention and should be a string. The meaning of this string is entirely platform dependent.  The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.</p><a name='Mappings'><h1>Mappings</h1></a><p>Foreign types are mapped to C types in the following manner:</p><table><tr><td><p>bool</p></td><td><p>int</p></td></tr><tr><td><p>[unsigned-]char</p></td><td><p>[unsigned] char</p></td></tr><tr><td><p>[unsigned-]short</p></td><td><p>[unsigned] short</p></td></tr><tr><td><p>[unsigned-]int</p></td><td><p>[unsigned] int</p></td></tr><tr><td><p>[unsigned-]integer</p></td><td><p>[unsigned] int</p></td></tr><tr><td><p>[unsigned-]long</p></td><td><p>[unsigned] long</p></td></tr><tr><td><p>float</p></td><td><p>float</p></td></tr><tr><td><p>double</p></td><td><p>double</p></td></tr><tr><td><p>number</p></td><td><p>double</p></td></tr><tr><td><p>[nonnull-]pointer</p></td><td><p>void *</p></td></tr><tr><td><p>[nonnull-]c-pointer</p></td><td><p>void *</p></td></tr><tr><td><p>[nonnull-]byte-vector</p></td><td><p>unsigned char *</p></td></tr><tr><td><p>[nonnull-]u8vector</p></td><td><p>unsigned char *</p></td></tr><tr><td><p>[nonnull-]s8vector</p></td><td><p>char *</p></td></tr><tr><td><p>[nonnull-]u16vector</p></td><td><p>unsigned short *</p></td></tr><tr><td><p>[nonnull-]s16vector</p></td><td><p>short *</p></td></tr><tr><td><p>[nonnull-]u32vector</p></td><td><p>uint32_t *</p></td></tr><tr><td><p>[nonnull-]s32vector</p></td><td><p>int32_t *</p></td></tr><tr><td><p>[nonnull-]f32vector</p></td><td><p>float *</p></td></tr><tr><td><p>[nonnull-]f64vector</p></td><td><p>double *</p></td></tr><tr><td><p>[nonnull-]c-string</p></td><td><p>char *</p></td></tr><tr><td><p>symbol</p></td><td><p>char *</p></td></tr><tr><td><p>void</p></td><td><p>void</p></td></tr><tr><td><p>([nonnull-]pointer TYPE)</p></td><td><p>TYPE *</p></td></tr><tr><td><p>(enum NAME)</p></td><td><p>enum NAME</p></td></tr><tr><td><p>(struct NAME)</p></td><td><p>struct NAME</p></td></tr><tr><td><p>(ref TYPE)</p></td><td><p>TYPE &amp;</p></td></tr><tr><td><p>(template T1 T2 ...)</p></td><td><p>T1&lt;T2, ...&gt;</p></td></tr><tr><td><p>(union NAME)</p></td><td><p>union NAME</p></td></tr><tr><td><p>(function RTYPE (ATYPE ...) [CALLCONV])</p></td><td><p>[CALLCONV] RTYPE (*)(ATYPE, ...)</p></td></tr><tr><td><p>(instance CNAME SNAME)</p></td><td><p>CNAME *</p></td></tr><tr><td><p>(instance-ref CNAME SNAME)</p></td><td><p>CNAME &amp;</p></td></tr></table><p>Previous: <a href='accessing-external-objects.html' class='internal'>Accessing external objects</a></p><p>Next: <a href='embedding.html' class='internal'>Embedding</a></p>
</body></html>