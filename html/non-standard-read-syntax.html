<html><head><title>CHICKEN User's Manual - Non standard read syntax</title></head><body>
<p></p><p></p><a name='Non standard read syntax'><h1>Non standard read syntax</h1></a><a name='Multiline Block Comment'><h2>Multiline Block Comment</h2></a><pre>#| ... |# </pre><p>A multiline <em>block</em> comment. May be nested. Implements <a href='http://srfi.schemers.org/srfi-30/srfi-30.html' class='external'>SRFI-30</a></p><a name='Expression Comment'><h2>Expression Comment</h2></a><pre>#;EXPRESSION</pre><p>Treats <tt>EXPRESSION</tt> as a comment.</p><a name='External Representation'><h2>External Representation</h2></a><pre>#,(CONSTRUCTORNAME DATUM ...)</pre><p>Allows user-defined extension of external representations. (For more information see the documentation for <a href='http://srfi.schemers.org/srfi-10/srfi-10.html' class='external'>SRFI-10</a>)</p><a name='Syntax Expression'><h2>Syntax Expression</h2></a><pre>#'EXPRESSION</pre><p>An abbreviation for <tt>(syntax EXPRESSION)</tt>.</p><a name='Location Expression'><h2>Location Expression</h2></a><pre>#$EXPRESSION</pre><p>An abbreviation for <tt>(location EXPRESSION)</tt>.</p><a name='Keyword'><h2>Keyword</h2></a><pre>#:SYMBOL</pre><p>Syntax for keywords. Keywords are symbols that evaluate to themselves, and as such don't have to be quoted.</p><a name='Multiline String Constant'><h2>Multiline String Constant</h2></a><pre>#&lt;&lt;TAG</pre><p>Specifies a multiline string constant. Anything up to a line equal to <tt>TAG</tt> (or end of file) will be returned as a single string:</p><pre>(define msg #&lt;&lt;END
 "Hello, world!", she said.
END
)</pre><p>is equivalent to</p><pre>(define msg "\"Hello, world!\", she said.")</pre><a name='Multiline String Constant with Embedded Expressions'><h2>Multiline String Constant with Embedded Expressions</h2></a><pre>#&lt;#TAG</pre><p>Similar to <tt>#&lt;&lt;</tt>, but allows substitution of embedded Scheme expressions prefixed with <tt>#</tt> and optionally enclosed in curly brackets. Two consecutive <tt>#</tt>s are translated to a single <tt>#</tt>:</p><pre>(define three 3)
(display #&lt;#EOF
This is a simple string with an embedded `##' character
and substituted expressions: (+ three 99) ==&gt; #(+ three 99)
(three is "#{three}")
EOF
)</pre><p>prints</p><pre>This is a simple string with an embedded `#' character
and substituted expressions: (+ three 99) ==&gt; 102
(three is "3")</pre><a name='Foreign Declare'><h2>Foreign Declare</h2></a><pre>#&gt; ... &lt;#</pre><p>Abbreviation for <tt>foreign-declare " ... ")</tt>.</p><a name='Sharp Prefixed Symbol'><h2>Sharp Prefixed Symbol</h2></a><pre>#%... </pre><p>Reads like a normal symbol.</p><a name='Bang'><h2>Bang</h2></a><pre>#!... </pre><p>Interpretation depends on the directly following characters. Only the following are recognized. Any other case results in a read error.</p><a name='Line Comment'><h3>Line Comment</h3></a><ul><li>If followed by whitespace or a slash, then everything up the end of the current line is ignored</li></ul><a name='Eof Object'><h3>Eof Object</h3></a><ul><li>If followed by the character sequence <tt>eof</tt>, then the (self-evaluating) end-of-file object is returned</li></ul><a name='DSSSL Formal Parameter List Annotation'><h3>DSSSL Formal Parameter List Annotation</h3></a><ul><li>If followed by any of the character sequences <tt>optional</tt>, <tt>rest</tt> or <tt>key</tt>, then a symbol with the same name (and prefixed with <tt>#!</tt>) is returned</li></ul><a name='Read Mark Invocation'><h3>Read Mark Invocation</h3></a><ul><li>If a <em>read mark</em> with the same name as the token is registered, then its procedure is called and the result of the read-mark procedure will be returned</li></ul><a name='Case Sensitive Expression'><h2>Case Sensitive Expression</h2></a><pre>#cs...</pre><p>Read the next expression in case-sensitive mode (regardless of the current global setting).</p><a name='Case Insensitive Expression'><h2>Case Insensitive Expression</h2></a><pre>#ci...</pre><p>Read the next expression in case-insensitive mode (regardless of the current global setting).</p><a name='Conditional Expansion'><h2>Conditional Expansion</h2></a><pre>#+FEATURE EXPR</pre><p>Equivalent to </p><pre>(cond-expand (FEATURE EXPR) (else))</pre><p>Previous: <a href='extensions-to-the-standard.html' class='internal'>Extensions to the standard</a></p><p>Next: <a href='non-standard-macros-and-special-forms.html' class='internal'>Non standard macros and special forms</a></p>
</body></html>